const ACTIVATION_PIN_URL = 'https://gist.githubusercontent.com/cx3300-1/f04ec50b5e8f2d88365d17ff35efffcf/raw/cd28d8825c5c34ea10bda8a4518a1a6a1f5a7d13/pin.txt';

// ========== åŠŸèƒ½é”å®šçŠ¶æ€ç®¡ç† ==========
// é”å®šçŠ¶æ€ï¼štrueè¡¨ç¤ºå·²é”å®šï¼Œfalseè¡¨ç¤ºæœªé”å®š
const LOCKED_FEATURES = {
  systemPrompt: true,  // æŸ¥çœ‹ç³»ç»Ÿæç¤ºè¯åŠŸèƒ½é”å®š
  messages: true       // æŸ¥çœ‹å‘é€æ¶ˆæ¯åŠŸèƒ½é”å®š
};
// ========== åŠŸèƒ½é”å®šçŠ¶æ€ç»“æŸ ==========

// ========== å®‰å…¨éªŒè¯ç³»ç»Ÿ ==========
// APIéªŒè¯åœ°å€
const VERIFY_API_URL = 'https://puppy-subscription-api.zeabur.app/api/verify';

// APIéªŒè¯å‡½æ•°
async function ephoneVerify(account, password) {
    if (!account || !password) {
        return { success: false, message: 'è¯·è¾“å…¥è´¦å·å’Œå¯†ç ' };
    }

    try {
        const res = await fetch(VERIFY_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account: account, password: password })
        });

        const data = await res.json();
        return data;
    } catch (error) {
        console.error('éªŒè¯è¯·æ±‚å¤±è´¥:', error);
        return { success: false, message: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•' };
    }
}
// ========== å®‰å…¨éªŒè¯ç³»ç»Ÿç»“æŸ ==========

// ========== QQä¸»å±å¹•Undefinedè¿‡æ»¤å™¨ï¼ˆå¤–é“¾åŠŸèƒ½ï¼‰ ==========
/**
 * è¿‡æ»¤æ¶ˆæ¯å†…å®¹ä¸­çš„undefinedæ–‡æœ¬
 * ç”¨äºä¸»å±å¹•QQèŠå¤©ï¼Œå½“è§’è‰²è¾“å‡ºundefinedæ—¶è‡ªåŠ¨è¿‡æ»¤
 * @param {string} content - åŸå§‹æ¶ˆæ¯å†…å®¹
 * @returns {string} - è¿‡æ»¤åçš„æ¶ˆæ¯å†…å®¹
 */
function qqUndefinedFilter(content) {
  if (!content || typeof content !== 'string') {
    return content;
  }

  // è¿‡æ»¤å„ç§å½¢å¼çš„undefined
  let filtered = content
    // è¿‡æ»¤å•ç‹¬çš„undefinedï¼ˆå‰åå¯èƒ½æœ‰ç©ºæ ¼ã€æ¢è¡Œç­‰ï¼‰
    .replace(/^\s*undefined\s*$/gi, '')
    // è¿‡æ»¤å¥å­å¼€å¤´çš„undefined
    .replace(/^\s*undefined\s+/gi, '')
    // è¿‡æ»¤å¥å­ç»“å°¾çš„undefined
    .replace(/\s+undefined\s*$/gi, '')
    // è¿‡æ»¤å¥å­ä¸­é—´çš„undefinedï¼ˆä¸¤è¾¹æœ‰ç©ºæ ¼ï¼‰
    .replace(/\s+undefined\s+/gi, ' ')
    // è¿‡æ»¤è¿ç»­å¤šä¸ªundefined
    .replace(/undefined\s*undefined/gi, '')
    // è¿‡æ»¤undefinedåé¢è·Ÿæ ‡ç‚¹ç¬¦å·çš„æƒ…å†µ
    .replace(/undefined([,ï¼Œ.ã€‚!ï¼?ï¼Ÿ;ï¼›:ï¼š])/gi, '$1')
    // è¿‡æ»¤æ ‡ç‚¹ç¬¦å·åé¢è·Ÿundefinedçš„æƒ…å†µ
    .replace(/([,ï¼Œ.ã€‚!ï¼?ï¼Ÿ;ï¼›:ï¼š])\s*undefined/gi, '$1');

  // å¦‚æœè¿‡æ»¤ååªå‰©ç©ºç™½å­—ç¬¦ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
  filtered = filtered.trim();
  
  // å¦‚æœæ•´ä¸ªå†…å®¹éƒ½æ˜¯undefinedï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
  if (filtered === '' || filtered.toLowerCase() === 'undefined') {
    return '';
  }

  return filtered;
}
// ========== QQä¸»å±å¹•Undefinedè¿‡æ»¤å™¨ç»“æŸ ==========

// ========== è´§å¸æ˜ å°„é…ç½® ==========
const CURRENCY_MAP = {
  'China': { symbol: 'Â¥', name: 'äººæ°‘å¸', code: 'CNY', rate: 1.0 },
  'USA': { symbol: '$', name: 'ç¾å…ƒ', code: 'USD', rate: 7.25 },
  'Japan': { symbol: 'Â¥', name: 'æ—¥å…ƒ', code: 'JPY', rate: 0.05 },
  'UK': { symbol: 'Â£', name: 'è‹±é•‘', code: 'GBP', rate: 9.15 },
  'Europe': { symbol: 'â‚¬', name: 'æ¬§å…ƒ', code: 'EUR', rate: 7.8 },
  'Austria': { symbol: 'â‚¬', name: 'æ¬§å…ƒ', code: 'EUR', rate: 7.8 },
  'Korea': { symbol: 'â‚©', name: 'éŸ©å…ƒ', code: 'KRW', rate: 0.0054 },
  'Russia': { symbol: 'â‚½', name: 'å¢å¸ƒ', code: 'RUB', rate: 0.075 },
  'India': { symbol: 'â‚¹', name: 'å¢æ¯”', code: 'INR', rate: 0.086 },
  'Canada': { symbol: 'C$', name: 'åŠ å…ƒ', code: 'CAD', rate: 5.15 },
  'Australia': { symbol: 'A$', name: 'æ¾³å…ƒ', code: 'AUD', rate: 4.65 },
  'Singapore': { symbol: 'S$', name: 'æ–°åŠ å¡å…ƒ', code: 'SGD', rate: 5.38 },
  'Thailand': { symbol: 'à¸¿', name: 'æ³°é“¢', code: 'THB', rate: 0.21 },
  'Vietnam': { symbol: 'â‚«', name: 'è¶Šå—ç›¾', code: 'VND', rate: 0.0003 },
  'None': { symbol: 'Â¥', name: 'äººæ°‘å¸', code: 'CNY', rate: 1.0 } // æ— å›½ç±é»˜è®¤äººæ°‘å¸
};

// è·å–è§’è‰²çš„è´§å¸ä¿¡æ¯
function getCurrencyForChat(chat) {
  if (!chat || !chat.country) {
    return CURRENCY_MAP['China']; // é»˜è®¤ä¸­å›½
  }
  return CURRENCY_MAP[chat.country] || CURRENCY_MAP['China'];
}

// å¤–å¸æ¢ç®—æˆäººæ°‘å¸
function convertToCNY(amount, currency) {
  if (!currency || !currency.rate) {
    return amount; // é»˜è®¤ä¸æ¢ç®—
  }
  return amount * currency.rate;
}
// ========== è´§å¸æ˜ å°„é…ç½®ç»“æŸ ==========

function escapeHTML(str) {
  if (!str) return '';
  return str.replace(/[&<>"']/g, function(match) {
    return {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    } [match];
  });
}
function generateRandomPacketAmounts(totalAmount, count) {
    let remainingAmount = totalAmount;
    let remainingCount = count;
    const amounts = [];
    const min = 0.01; 

    for (let i = 0; i < count - 1; i++) {
      
        const avg = remainingAmount / remainingCount;
        const absoluteMax = remainingAmount - (remainingCount - 1) * min;
        
        let max = Math.min(avg * 2, absoluteMax);
        if (max < min) {
            max = min;
        }

        let amount = Math.random() * (max - min) + min;
        amount = parseFloat(amount.toFixed(2));
        
        amounts.push(amount);
        remainingAmount -= amount;
        remainingCount--;
    }
    
  
    amounts.push(parseFloat(remainingAmount.toFixed(2)));
  
    for (let i = amounts.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [amounts[i], amounts[j]] = [amounts[j], amounts[i]];
    }
    
    console.log(`[çº¢åŒ…ç”Ÿæˆ]: æ€»é‡‘é¢ ${totalAmount}, æ•°é‡ ${count}. åˆ†é…ç»“æœ:`, amounts);
    return amounts;
}

function getDeviceId() {
  let deviceId = localStorage.getItem('ephoneDeviceId');
  if (!deviceId) {
 
    deviceId = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
    localStorage.setItem('ephoneDeviceId', deviceId);
  }
  return deviceId;
}


const EPHONE_DEVICE_ID = getDeviceId();
console.log(`EPhone è®¾å¤‡ID: ${EPHONE_DEVICE_ID}`);

// å…¨å±€ API è°ƒç”¨æ§åˆ¶å™¨
let currentApiController = null;

let isPinActivated = localStorage.getItem('ephonePinActivated') === 'true';



const translations = {
  'zh-CN': {

    save: 'ä¿å­˜',
    cancel: 'å–æ¶ˆ',
    confirm: 'ç¡®å®š',
    edit: 'ç¼–è¾‘',
    done: 'å®Œæˆ',
    add: 'æ·»åŠ ',
    back: 'è¿”å›',
    next: 'ä¸‹ä¸€æ­¥',
    close: 'å…³é—­',
    reset: 'é‡ç½®',
    upload: 'ä¸Šä¼ ',
    send: 'å‘é€',
    manage: 'ç®¡ç†',
    share: 'åˆ†äº«',
    delete: 'åˆ é™¤',
    publish: 'å‘å¸ƒ',
    refresh: 'åˆ·æ–°',
    search: 'æœç´¢',
    remove: 'ç§»é™¤',
    finish: 'ç»“æŸ',
    details: 'è¯¦æƒ…',
    settings: 'è®¾ç½®',
    title: 'æ ‡é¢˜',
    content: 'å†…å®¹',
    category: 'åˆ†ç±»',
    name: 'åç§°',
    description: 'æè¿°',
    status: 'çŠ¶æ€',
    ok: 'å¥½çš„',
    error: 'é”™è¯¯',
    success: 'æˆåŠŸ',
    warning: 'è­¦å‘Š',
    loading: 'åŠ è½½ä¸­...',
    processing: 'å¤„ç†ä¸­...',
    pleaseWait: 'è¯·ç¨å€™...',
    languageChangedAlert: 'è¯­è¨€å·²åˆ‡æ¢ï¼Œé¡µé¢å³å°†åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚',


    // --- ä¸»å±å¹• & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: 'ä¸–ç•Œä¹¦',
    homeAppAppearance: 'å¤–è§‚è®¾ç½®',
    homeAppRenderer: 'æ¸²æŸ“å™¨',
    homeAppApiSettings: 'è®¾ç½®',
    homeAppFont: 'å­—ä½“',
    homeAppCPhone: 'CPhone',
    homeAppDouban: 'è±†ç“£',
    homeAppPreset: 'é¢„è®¾',
    homeAppTutorial: 'æ•™ç¨‹',
    homeAppWerewolf: 'ç‹¼äººæ€',
    homeAppX: 'X',
    homeAppCharGenerator: 'è§’è‰²ç”Ÿæˆ',

    // --- èŠå¤©åˆ—è¡¨é¡µ ---
    chatListTitle: 'æ¶ˆæ¯',
    navMessages: 'æ¶ˆæ¯',
    navQzone: 'åŠ¨æ€',
    navMemories: 'å›å¿†',
    navFavorites: 'æ”¶è—',
    navNpcList: 'NPC',

    // --- QZone & åŠ¨æ€ ---
    qzoneTitle: 'å¥½å‹åŠ¨æ€',
    qzoneActionShuoshuo: 'è¯´è¯´',
    qzoneActionPost: 'åŠ¨æ€',
    qzoneActionAlbum: 'ç›¸å†Œ',

    // --- CPhone (è§’è‰²æ‰‹æœº) ---
    cphoneTitleSelect: 'é€‰æ‹©ä¸€éƒ¨æ‰‹æœº',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: 'ç›¸å†Œ',
    cphoneAppBrowser: 'æµè§ˆå™¨',
    cphoneAppTaobao: 'æ·˜å®',
    cphoneAppMemo: 'å¤‡å¿˜å½•',
    cphoneAppDiary: 'æ—¥è®°',
    cphoneAppAmap: 'é«˜å¾·åœ°å›¾',
    cphoneAppUsage: 'Appè®°å½•',
    cphoneAppMusic: 'ç½‘æ˜“äº‘',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: 'è¶³è¿¹',
    cphoneAlbumTitle: 'TAçš„ç›¸å†Œ',
    cphoneBrowserTitle: 'TAçš„æµè§ˆå™¨å†å²',
    cphoneTaobaoTitle: 'TAçš„æ·˜å®è®¢å•',
    cphoneWalletTitle: 'é’±åŒ…',
    cphoneMemoTitle: 'å¤‡å¿˜å½•',
    cphoneDiaryTitle: 'æ—¥è®°',
    cphoneUsageTitle: 'Appä½¿ç”¨è®°å½•',
    cphoneMusicTitle: 'TAçš„æ­Œå•',
    cphoneArticleTitle: 'æ–‡ç« ',
    cphoneSimulatedChatPlaceholder: 'è¿™æ˜¯æ¨¡æ‹Ÿå¯¹è¯ï¼Œæ— æ³•å‘é€æ¶ˆæ¯',

    // --- ä¸–ç•Œä¹¦ ---
    worldBookTitle: 'ä¸–ç•Œä¹¦',
    worldBookEditorTitle: 'ç¼–è¾‘ä¸–ç•Œä¹¦',
    worldBookEntryEditorTitle: 'ç¼–è¾‘æ¡ç›®',
    worldBookNameLabel: 'ä¹¦å',
    worldBookCategoryLabel: 'åˆ†ç±»',
    worldBookEntriesLabel: 'å†…å®¹æ¡ç›®',
    worldBookAddEntryBtn: '[+] æ·»åŠ æ–°æ¡ç›®',
    worldBookNamePlaceholder: 'è¯·è¾“å…¥ä¸–ç•Œä¹¦çš„åç§°...',
    worldBookImportTitle: 'å¯¼å…¥ä¸–ç•Œä¹¦',

    // --- é¢„è®¾ ---
    presetTitle: 'é¢„è®¾',
    presetEditorTitle: 'ç¼–è¾‘é¢„è®¾',
    presetNameLabel: 'é¢„è®¾åç§°',
    presetCategoryLabel: 'åˆ†ç±»',
    presetEntriesLabel: 'å†…å®¹æ¡ç›®',
    presetAddEntryBtn: '[+] æ·»åŠ æ–°æ¡ç›®',

    // --- æ•™ç¨‹ ---
    tutorialTitle: 'æ•™ç¨‹',

    // --- API è®¾ç½® ---
    apiSettingsTitle: 'API è®¾ç½®',
    languageLabel: 'è¯­è¨€',
    apiPresetManagement: 'API é¢„è®¾ç®¡ç†',
    apiPresetSelectLabel: 'é€‰æ‹©æˆ–åˆ‡æ¢é¢„è®¾',
    apiPrimarySettings: 'ä¸»APIè®¾ç½® (ç”¨äºèŠå¤©)',
    apiProxyUrlLabel: 'åä»£åœ°å€ (ä¸éœ€è¦æ·»åŠ /v1å™¢~)',
    apiKeyLabel: 'å¯†é’¥ (API Key)',
    apiModelLabel: 'æ¨¡å‹',
    apiFetchModelsBtn: 'æ‹‰å–ä¸»æ¨¡å‹',
    apiSecondarySettings: 'å‰¯APIè®¾ç½® (ç”¨äºæ€»ç»“é•¿æœŸè®°å¿†)',
    apiSecondaryProxyUrlLabel: 'å‰¯åä»£åœ°å€',
    apiSecondaryKeyLabel: 'å‰¯å¯†é’¥',
    apiSecondaryModelLabel: 'å‰¯æ¨¡å‹',
    apiFetchSecondaryModelsBtn: 'æ‹‰å–å‰¯æ¨¡å‹',
    apiBgActivitySettings: 'åå°æ´»åŠ¨è®¾ç½®',
    apiEnableBgActivityLabel: 'å¯ç”¨åå°è§’è‰²æ´»åŠ¨',
    apiBgIntervalLabel: 'åå°æ´»åŠ¨æ£€æµ‹é—´éš” (ç§’)',
    apiBlockCooldownLabel: 'AIè¢«æ‹‰é»‘åå†·é™æœŸ (å°æ—¶)',
    apiTtsSettings: 'è¯­éŸ³æ¶ˆæ¯è®¾ç½® (Minimax TTS)',
    apiTtsModelLabel: 'è¯­éŸ³æ¨¡å‹ (Model)',
    apiPerformanceSettings: 'æ€§èƒ½ä¸æ˜¾ç¤ºè®¾ç½®',
    apiChatListRenderWindowLabel: 'èŠå¤©åˆ—è¡¨æ¯æ¬¡åŠ è½½æ¡æ•°',
    apiChatRenderWindowLabel: 'èŠå¤©ç•Œé¢åˆå§‹åŠ è½½æ¡æ•°',
    apiImageGenSettings: 'ç”Ÿå›¾åŠŸèƒ½è®¾ç½®',
    apiEnableImageGenLabel: 'å¯ç”¨AIç”Ÿå›¾åŠŸèƒ½',
    apiEnableNovelAILabel: 'å¯ç”¨ NovelAI å›¾åƒç”Ÿæˆ',
    apiNovelAIModelLabel: 'NovelAI æ¨¡å‹',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: 'ç”Ÿæˆè®¾ç½®',
    apiNovelAITestBtn: 'æµ‹è¯•ç”Ÿæˆ',
    apiStorageOptimization: 'å­˜å‚¨ç©ºé—´ä¼˜åŒ–',
    apiCompressImagesBtn: 'ä¸€é”®å‹ç¼©æœ¬åœ°å›¾ç‰‡',
    apiSaveAllBtn: 'ä¿å­˜æ‰€æœ‰è®¾ç½®',
    apiExportDataBtn: 'å¯¼å‡ºæ•°æ®',
    apiImportDataBtn: 'å¯¼å…¥å¤‡ä»½æ–‡ä»¶',
    apiCleanupDataBtn: 'æ¸…ç†å†—ä½™æ•°æ®',
    apiDeleteWorldBooksBtn: 'åˆ é™¤ä¸–ç•Œä¹¦',
    apiAdvancedCleanupBtn: 'é«˜çº§æ•°æ®æ¸…ç†',
    apiCheckAndFixDataBtn: 'æ•°æ®æ£€æŸ¥ä¸ä¿®å¤',

    // --- èŠå¤©ç•Œé¢ ---
    chatHeaderOnline: 'åœ¨çº¿',
    chatHeaderLongTermMemory: 'é•¿æœŸè®°å¿†',
    chatHeaderListenTogether: 'ä¸€èµ·å¬',
    chatHeaderChatSettings: 'èŠå¤©è®¾ç½®',
    chatSelectionCancel: 'å–æ¶ˆ',
    chatSelectionScreenshot: 'é•¿æˆªå›¾',
    chatSelectionFavorite: 'æ”¶è—',
    chatSelectionForward: 'è½¬å‘',
    chatSelectionShare: 'åˆ†äº«',
    chatSelectionSoftDelete: 'åˆ é™¤(é€šçŸ¥AI)',
    chatSelectionHardDelete: 'å½»åº•åˆ é™¤',
    chatReplyTo: 'å›å¤',
    chatInputPlaceholder: 'è¾“å…¥æ¶ˆæ¯...',
    chatWaitForReply: 'ç­‰å¾…å›å¤',

    // --- å¤–è§‚è®¾ç½® ---
    appearanceTitle: 'å¤–è§‚è®¾ç½®',
    appearanceSaveAll: 'ä¿å­˜æ‰€æœ‰å¤–è§‚è®¾ç½®',

    // --- å­—ä½“è®¾ç½® ---
    fontSettingsTitle: 'å­—ä½“è®¾ç½®',
    fontPresetManagement: 'å­—ä½“é¢„è®¾ç®¡ç†',
    fontFileUrlLabel: 'å­—ä½“æ–‡ä»¶URL (.ttf, .otf, .woffç­‰)',
    fontPreviewLabel: 'å®æ—¶é¢„è§ˆ',
    fontPreviewText1: 'ä½ å¥½ä¸–ç•Œ Hello World',
    fontPreviewText2: 'è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœï¼Œ12345ã€‚',
    fontSaveAndApply: 'ä¿å­˜å¹¶åº”ç”¨',
    fontResetDefault: 'æ¢å¤é»˜è®¤å­—ä½“',

    // --- æ¸²æŸ“è§„åˆ™ ---
    rendererTitle: 'æ¸²æŸ“è§„åˆ™',
    rendererEditorTitle: 'ç¼–è¾‘è§„åˆ™',
    rendererCreateTitle: 'åˆ›å»ºæ–°è§„åˆ™',
    rendererRuleName: 'è§„åˆ™åç§°',
    rendererBindScope: 'ç»‘å®šèŒƒå›´',
    rendererScopeGlobal: 'å…¬ç”¨ (æ‰€æœ‰è§’è‰²)',
    rendererRegex: 'æ­£åˆ™è¡¨è¾¾å¼ (ä½¿ç”¨gä½œä¸ºæ ‡å¿—)',
    rendererHtmlTemplate: 'HTML æ¨¡æ¿ (ç”¨ $1, $2 å¼•ç”¨)',
    rendererEnableRule: 'å¯ç”¨è§„åˆ™',

    // --- å…¶ä»– ---
    myAlbumTitle: 'æˆ‘çš„ç›¸å†Œ',
    albumPhotosTitle: 'ç›¸å†Œåç§°',
    npcEditorTitleAdd: 'æ·»åŠ  NPC',
    npcEditorTitleEdit: 'ç¼–è¾‘ NPC',
    npcAvatarLabel: 'NPC å¤´åƒ',
    npcUploadAvatar: 'ä¸Šä¼ å¤´åƒ',
    npcNicknameLabel: 'NPC æ˜µç§°',
    npcPersonaLabel: 'NPC äººè®¾',
    npcEnableBgActivity: 'å¯ç”¨ç‹¬ç«‹åå°æ´»åŠ¨',
    npcActionCooldown: 'ç‹¬ç«‹è¡ŒåŠ¨å†·å´ (åˆ†é’Ÿ)',
    npcAssociatedChars: 'å…³è”çš„è§’è‰² (NPCä¼šå»è¯„è®ºè¿™äº›è§’è‰²çš„åŠ¨æ€)',
  

  },
  'en': {

    save: 'Save',
    cancel: 'Cancel',
    confirm: 'Confirm',
    edit: 'Edit',
    done: 'Done',
    add: 'Add',
    back: 'Back',
    next: 'Next',
    close: 'Close',
    reset: 'Reset',
    upload: 'Upload',
    send: 'Send',
    manage: 'Manage',
    share: 'Share',
    delete: 'Delete',
    publish: 'Publish',
    refresh: 'Refresh',
    search: 'Search',
    remove: 'Remove',
    finish: 'Finish',
    details: 'Details',
    settings: 'Settings',
    title: 'Title',
    content: 'Content',
    category: 'Category',
    name: 'Name',
    description: 'Description',
    status: 'Status',
    ok: 'OK',
    error: 'Error',
    success: 'Success',
    warning: 'Warning',
    loading: 'Loading...',
    processing: 'Processing...',
    pleaseWait: 'Please wait...',
    languageChangedAlert: 'Language switched. The page will reload to apply changes.',


    // --- Home Screen & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: 'World Book',
    homeAppAppearance: 'Appearance',
    homeAppRenderer: 'Renderer',
    homeAppApiSettings: 'Settings',
    homeAppFont: 'Fonts',
    homeAppCPhone: 'CPhone',
    homeAppDouban: 'Douban',
    homeAppPreset: 'Presets',
    homeAppTutorial: 'Tutorial',
    homeAppWerewolf: 'Werewolf',
    homeAppX: 'X',
    homeAppCharGenerator: 'Character Generator',

    // --- Chat List Screen ---
    chatListTitle: 'Messages',
    navMessages: 'Messages',
    navQzone: 'Moments',
    navMemories: 'Memories',
    navFavorites: 'Favorites',
    navNpcList: 'NPCs',

    // --- QZone & Moments ---
    qzoneTitle: 'Moments',
    qzoneActionShuoshuo: 'Status',
    qzoneActionPost: 'Post',
    qzoneActionAlbum: 'Album',

    // --- CPhone (Character's Phone) ---
    cphoneTitleSelect: 'Select a Phone',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: 'Album',
    cphoneAppBrowser: 'Browser',
    cphoneAppTaobao: 'Taobao',
    cphoneAppMemo: 'Memo',
    cphoneAppDiary: 'Diary',
    cphoneAppAmap: 'Amap',
    cphoneAppUsage: 'App Usage',
    cphoneAppMusic: 'Music',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: 'Footprints',
    cphoneAlbumTitle: 'Their Album',
    cphoneBrowserTitle: 'Their Browser History',
    cphoneTaobaoTitle: 'Their Taobao Orders',
    cphoneWalletTitle: 'Wallet',
    cphoneMemoTitle: 'Memo',
    cphoneDiaryTitle: 'Diary',
    cphoneUsageTitle: 'App Usage Log',
    cphoneMusicTitle: 'Their Playlist',
    cphoneArticleTitle: 'Article',
    cphoneSimulatedChatPlaceholder: 'This is a simulated chat, messages cannot be sent',

    // --- World Book ---
    worldBookTitle: 'World Book',
    worldBookEditorTitle: 'Edit World Book',
    worldBookEntryEditorTitle: 'Edit Entry',
    worldBookNameLabel: 'Book Name',
    worldBookCategoryLabel: 'Category',
    worldBookEntriesLabel: 'Content Entries',
    worldBookAddEntryBtn: '[+] Add New Entry',
    worldBookNamePlaceholder: 'Enter the name of the world book...',
    worldBookImportTitle: 'Import World Book',

    // --- Presets ---
    presetTitle: 'Presets',
    presetEditorTitle: 'Edit Preset',
    presetNameLabel: 'Preset Name',
    presetCategoryLabel: 'Category',
    presetEntriesLabel: 'Content Entries',
    presetAddEntryBtn: '[+] Add New Entry',

    // --- Tutorial ---
    tutorialTitle: 'Tutorial',

    // --- API Settings ---
    apiSettingsTitle: 'API Settings',
    languageLabel: 'Language',
    apiPresetManagement: 'API Preset Management',
    apiPresetSelectLabel: 'Select or Switch Preset',
    apiPrimarySettings: 'Primary API Settings (for Chat)',
    apiProxyUrlLabel: 'Proxy URL (No /v1 needed~)',
    apiKeyLabel: 'API Key',
    apiModelLabel: 'Model',
    apiFetchModelsBtn: 'Fetch Primary Models',
    apiSecondarySettings: 'Secondary API Settings (for Summarization)',
    apiSecondaryProxyUrlLabel: 'Secondary Proxy URL',
    apiSecondaryKeyLabel: 'Secondary API Key',
    apiSecondaryModelLabel: 'Secondary Model',
    apiFetchSecondaryModelsBtn: 'Fetch Secondary Models',
    apiTemperatureLabel: 'API Temperature',
    apiBgActivitySettings: 'Background Activity Settings',
    apiEnableBgActivityLabel: 'Enable Background Character Activity',
    apiBgIntervalLabel: 'Background Activity Interval (sec)',
    apiBlockCooldownLabel: 'AI Block Cooldown (hours)',
    apiTtsSettings: 'Voice Message Settings (Minimax TTS)',
    apiTtsModelLabel: 'Voice Model',
    apiPerformanceSettings: 'Performance & Display Settings',
    apiChatListRenderWindowLabel: 'Chat List Batch Load Count',
    apiChatRenderWindowLabel: 'Chat View Initial Load Count',
    apiImageGenSettings: 'Image Generation Settings',
    apiEnableImageGenLabel: 'Enable AI Image Generation',
    apiEnableNovelAILabel: 'Enable NovelAI Image Generation',
    apiNovelAIModelLabel: 'NovelAI Model',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: 'Generation Settings',
    apiNovelAITestBtn: 'Test Generation',
    apiStorageOptimization: 'Storage Optimization',
    apiCompressImagesBtn: 'Compress Local Images',
    apiSaveAllBtn: 'Save All Settings',
    apiExportDataBtn: 'Export Data',
    apiImportDataBtn: 'Import Backup File',
    apiCleanupDataBtn: 'Cleanup Redundant Data',
    apiDeleteWorldBooksBtn: 'Delete World Books',
    apiAdvancedCleanupBtn: 'Advanced Data Cleanup',
    apiCheckAndFixDataBtn: 'Data Check & Repair',

    // --- Chat Screen ---
    chatHeaderOnline: 'Online',
    chatHeaderLongTermMemory: 'Long-term Memory',
    chatHeaderListenTogether: 'Listen Together',
    chatHeaderChatSettings: 'Chat Settings',
    chatSelectionCancel: 'Cancel',
    chatSelectionScreenshot: 'Long Screenshot',
    chatSelectionFavorite: 'Favorite',
    chatSelectionForward: 'Forward',
    chatSelectionShare: 'Share',
    chatSelectionSoftDelete: 'Delete (Notify AI)',
    chatSelectionHardDelete: 'Erase',
    chatReplyTo: 'Reply to',
    chatInputPlaceholder: 'Type a message...',
    chatWaitForReply: 'Wait for Reply',

    // --- Appearance Settings ---
    appearanceTitle: 'Appearance Settings',
    appearanceSaveAll: 'Save All Appearance Settings',

    // --- Font Settings ---
    fontSettingsTitle: 'Font Settings',
    fontPresetManagement: 'Font Preset Management',
    fontFileUrlLabel: 'Font File URL (.ttf, .otf, .woff, etc.)',
    fontPreviewLabel: 'Live Preview',
    fontPreviewText1: 'Hello World ä½ å¥½ä¸–ç•Œ',
    fontPreviewText2: 'This is a font preview effect, 12345.',
    fontSaveAndApply: 'Save and Apply',
    fontResetDefault: 'Reset to Default Font',

    // --- Renderer ---
    rendererTitle: 'Rendering Rules',
    rendererEditorTitle: 'Edit Rule',
    rendererCreateTitle: 'Create New Rule',
    rendererRuleName: 'Rule Name',
    rendererBindScope: 'Binding Scope',
    rendererScopeGlobal: 'Global (All Characters)',
    rendererRegex: 'Regular Expression (use g flag)',
    rendererHtmlTemplate: 'HTML Template (use $1, $2)',
    rendererEnableRule: 'Enable Rule',

    // --- Others ---
    myAlbumTitle: 'My Albums',
    albumPhotosTitle: 'Album Name',
    npcEditorTitleAdd: 'Add NPC',
    npcEditorTitleEdit: 'Edit NPC',
    npcAvatarLabel: 'NPC Avatar',
    npcUploadAvatar: 'Upload Avatar',
    npcNicknameLabel: 'NPC Nickname',
    npcPersonaLabel: 'NPC Persona',
    npcEnableBgActivity: 'Enable Independent Background Activity',
    npcActionCooldown: 'Independent Action Cooldown (min)',
    npcAssociatedChars: 'Associated Characters (NPC will comment on their moments)',
  
  }
};

let currentLanguage = 'zh-CN';

function setLanguage(lang) {
  if (!translations[lang]) {
    console.warn(`Language "${lang}" not found. Defaulting to 'zh-CN'.`);
    lang = 'zh-CN';
  }
  currentLanguage = lang;
  localStorage.setItem('ephone-language', lang);
  document.documentElement.lang = lang;

  document.querySelectorAll('[data-lang-key]').forEach(el => {
    const key = el.getAttribute('data-lang-key');
    if (translations[lang][key]) {
      el.textContent = translations[lang][key];
    }
  });

  document.querySelectorAll('[data-lang-key-placeholder]').forEach(el => {
    const key = el.getAttribute('data-lang-key-placeholder');
    if (translations[lang][key]) {
      el.placeholder = translations[lang][key];
    }
  });

  document.querySelectorAll('[data-lang-key-title]').forEach(el => {
    const key = el.getAttribute('data-lang-key-title');
    if (translations[lang][key]) {
      el.title = translations[lang][key];
    }
  });
}

function initLanguage() {
  const savedLang = localStorage.getItem('ephone-language') || 'zh-CN';
  const langSelector = document.getElementById('language-select');

  if (langSelector) {
    langSelector.value = savedLang;
    langSelector.addEventListener('change', (e) => {
      const newLang = e.target.value;
      alert(translations[newLang].languageChangedAlert);
      localStorage.setItem('ephone-language', newLang);
      setTimeout(() => window.location.reload(), 100);
    });
  }
  setLanguage(savedLang);
}

(function() {
  'use strict';


  function downloadImage(imageSrc, filename) {
    try {
     
      const link = document.createElement('a');
      link.href = imageSrc;
      link.download = filename;
      link.style.display = 'none';

      document.body.appendChild(link);
      link.click(); 

    
      setTimeout(() => {
        document.body.removeChild(link);
      }, 100);

      console.log('âœ… [NAIä¸‹è½½] å¼€å§‹ä¸‹è½½å›¾ç‰‡:', filename);

      // æ˜¾ç¤ºä¸‹è½½æç¤º
      showDownloadToast();
    } catch (error) {
      console.error('âŒ [NAIä¸‹è½½] ä¸‹è½½å¤±è´¥:', error);
      showDownloadToast('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
    }
  }

 
  function showDownloadToast(message = 'ğŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...', type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : '#f44336'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                pointer-events: none;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.3s ease;
            `;

    document.body.appendChild(toast);

   
    setTimeout(() => {
      toast.style.opacity = '1';
      toast.style.transform = 'translateY(0)';
    }, 10);

 
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(-20px)';
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, 2000);
  }

 
  function generateFilename(imgElement) {
   
    const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';

    
    let cleanTitle = title
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_') 
      .replace(/\s+/g, '_')
      .substring(0, 30);

    if (!cleanTitle) {
      cleanTitle = 'NAI_Image';
    }

   
    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0];

 
    return `${cleanTitle}_${timestamp}.png`;
  }

 
  function addVisualFeedback(imgElement) {
    const originalTransform = imgElement.style.transform || '';
    const originalTransition = imgElement.style.transition || '';

  
    imgElement.style.transition = 'transform 0.15s ease';
    imgElement.style.transform = 'scale(0.95)';

    setTimeout(() => {
      imgElement.style.transform = originalTransform;
      setTimeout(() => {
        imgElement.style.transition = originalTransition;
      }, 150);
    }, 150);
  }
 window.downloadImage = downloadImage;     // æŠŠä¸‹è½½å‡½æ•°æš´éœ²ç»™å…¨å±€
  window.generateFilename = generateFilename; // æŠŠæ–‡ä»¶åç”Ÿæˆæš´éœ²ç»™å…¨å±€
  window.addVisualFeedback = addVisualFeedback;

  let clickCount = 0;
  let clickTimer = null;
  let lastClickedElement = null;

 
  document.addEventListener('click', function(e) {
    const target = e.target;

    
    if (target.tagName === 'IMG' &&
      (target.classList.contains('realimag-image') ||
        target.classList.contains('naiimag-image'))) {

   
      if (target === lastClickedElement) {
        clickCount++;
      } else {
      
        clickCount = 1;
        lastClickedElement = target;
      }

      // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
      if (clickTimer) {
        clearTimeout(clickTimer);
      }

     
      if (clickCount === 3) {
        
        clickCount = 0;
        lastClickedElement = null;

      
        e.preventDefault();
        e.stopPropagation();

        console.log('ğŸ–¼ï¸ [NAIä¸‹è½½] æ£€æµ‹åˆ°ä¸‰å‡»NAIå›¾ç‰‡');

      
        addVisualFeedback(target);

     
        const imageSrc = target.src;

        if (!imageSrc || imageSrc === 'about:blank') {
          console.warn('âš ï¸ [NAIä¸‹è½½] å›¾ç‰‡æºä¸ºç©ºï¼Œæ— æ³•ä¸‹è½½');
          showDownloadToast('å›¾ç‰‡åŠ è½½ä¸­ï¼Œè¯·ç¨åé‡è¯•', 'error');
          return;
        }

      
        const filename = generateFilename(target);

     
        downloadImage(imageSrc, filename);
      } else {
      
        clickTimer = setTimeout(() => {
          clickCount = 0;
          lastClickedElement = null;
        }, 500);
      }
    }
  }, true); 

  console.log('âœ… [NAIä¸‹è½½] ä¸‰å‡»ä¸‹è½½åŠŸèƒ½å·²åˆå§‹åŒ–');
  console.log('ğŸ’¡ [NAIä¸‹è½½] æç¤ºï¼šä¸‰å‡»ä»»æ„NAIå›¾ç‰‡å³å¯ä¸‹è½½');
})();


if ('serviceWorker' in navigator) {

  window.addEventListener('load', () => {

    navigator.serviceWorker.register('./sw.js')
      .then(registration => {

        console.log('ServiceWorker æ³¨å†ŒæˆåŠŸï¼Œä½œç”¨åŸŸä¸º: ', registration.scope);
      })
      .catch(error => {

        console.log('ServiceWorker æ³¨å†Œå¤±è´¥: ', error);
      });
  });
}

if (!Array.prototype.findLastIndex) {
  Object.defineProperty(Array.prototype, 'findLastIndex', {
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Cannot read property \'findLastIndex\' of null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      let o = Object(this);
      let len = o.length >>> 0;
      let thisArg = arguments[1];
      let k = len - 1;
      while (k >= 0) {
        let kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        k--;
      }
      return -1;
    },
    configurable: true,
    writable: true
  });
}

const dynamicIslandContent = document.getElementById('dynamic-island-content');
const islandAlbumArt = document.getElementById('island-album-art');
const islandLyricContainer = document.getElementById('island-lyric-container');
const islandLyricText = document.getElementById('island-lyric-text');
const phoneScreenForIsland = document.getElementById('phone-screen');

let activeMessageTimestamp = null;
let activeTransferTimestamp = null;

let lastRawAiResponse = '';
let lastResponseTimestamps = [];
let lastPrivateMessagesSent = [];
let lastGroupMessagesSent = [];
let currentQzoneReplyContext = null;
let editingNpcId = null;
let pendingBackupData = null;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
function findBestStickerMatch(meaning, availableStickers) {
  if (!meaning || !availableStickers || availableStickers.length === 0) {
    return null;
  }

  const SIMILARITY_THRESHOLD = 0.7; 
  const candidates = []; 
  let highestScore = 0;

  const getTokens = (str) => [...new Set(str.replace(/\s+/g, ''))];
  const meaningTokens = getTokens(meaning);

  availableStickers.forEach(sticker => {
    if (!sticker.name) return;

    const stickerNameTokens = getTokens(sticker.name);
    const intersection = stickerNameTokens.filter(token => meaningTokens.includes(token));
    // Jaccard Similarity Score
    const score = intersection.length / (stickerNameTokens.length + meaningTokens.length - intersection.length);

    
    if (score > highestScore) {
      highestScore = score;
    }

    
    if (score >= SIMILARITY_THRESHOLD) {
      candidates.push({ sticker, score });
    }
  });

  if (candidates.length > 0) {
  
    const bestCandidates = candidates.filter(c => c.score === highestScore);
    
    
    const randomIndex = Math.floor(Math.random() * bestCandidates.length);
    const chosenSticker = bestCandidates[randomIndex].sticker;
    
    console.log(`[æ¨¡ç³ŠéšæœºåŒ¹é…æˆåŠŸ] AIå«ä¹‰: "${meaning}", åŒ¹é…åˆ° ${bestCandidates.length} ä¸ªæœ€ä½³é€‰é¡¹, éšæœºé€‰ä¸­: "${chosenSticker.name}", ç›¸ä¼¼åº¦: ${highestScore.toFixed(2)}`);
    return chosenSticker;
  }

  console.log(`[æ¨¡ç³ŠéšæœºåŒ¹é…å¤±è´¥] AIå«ä¹‰: "${meaning}", æœ€é«˜ç›¸ä¼¼åº¦ä¸º ${highestScore.toFixed(2)}ï¼Œæœªè¾¾åˆ°é˜ˆå€¼ ${SIMILARITY_THRESHOLD}ã€‚`);
  return null;
}
function getRandomValue(str) {

  if (str.includes(',')) {

    const arr = str.split(',').map(item => item.trim());

    const randomIndex = Math.floor(Math.random() * arr.length);

    return arr[randomIndex];
  }

  return str;
}

function isImage(content) {
  if (content.image_url && content.image_url.url) {
    let currentImageData = content.image_url.url

    const base64Data = currentImageData.split(',')[1];

    const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
    return [{
        text: 'ç”¨æˆ·å‘ä½ å‘é€äº†ä¸€å¼ å›¾ç‰‡'
      },
      {
        inline_data: {
          mime_type: mimeType,
          data: base64Data
        }
      }
    ]
  }
  return []
}



function getGeminiResponseText(data) {

 
  if (data.choices && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
    return data.choices[0].message.content;
  }


  if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
    return data.candidates[0].content.parts[0].text;
  }

 
  console.error("APIè¿”å›äº†éé¢„æœŸçš„æ ¼å¼:", data);
  let errorReason = "AIè¿”å›äº†ç©ºå†…å®¹æˆ–æœªçŸ¥æ ¼å¼ã€‚";

 
  if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
    const safetyRatings = data.candidates[0].safetyRatings;
    const blockedCategories = safetyRatings
      .filter(r => r.probability !== 'NEGLIGIBLE' && r.probability !== 'LOW')
      .map(r => `${r.category} (æ¦‚ç‡: ${r.probability})`)
      .join(', ');
    errorReason = `å†…å®¹å› å®‰å…¨ç­–ç•¥è¢«å±è”½ã€‚è§¦å‘ç±»åˆ«: ${blockedCategories || 'æœªçŸ¥'}`;
  } 
  
  else if (data.promptFeedback?.blockReason) {
    const reason = data.promptFeedback.blockReason;
    const details = data.promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
    errorReason = `å†…å®¹å› å®‰å…¨ç­–ç•¥è¢«å±è”½ (åŸå› : ${reason})ã€‚è¯¦æƒ…: ${details || 'æ— '}`;
  } 
  
  else if (data.error?.message) { 
    errorReason = `APIé”™è¯¯: ${data.error.message}`;
  } 
 
  else if (data.message) { 
    errorReason = `APIé”™è¯¯: ${data.message}`;
  }

  else if (data.detail) {
    errorReason = `APIé”™è¯¯: ${data.detail}`;
  }
 
  else if (data.error && typeof data.error === 'string') {
      errorReason = `APIé”™è¯¯: ${data.error}`;
  }

  throw new Error(errorReason);
}


document.addEventListener('DOMContentLoaded', () => {

 document.getElementById('user-city-search-btn').addEventListener('click', async () => {
    const query = document.getElementById('user-real-city-search').value.trim();
    if(!query) return alert("è¯·è¾“å…¥çœŸå®åŸå¸‚æ‹¼éŸ³æˆ–è‹±æ–‡åç§°");
    
    const result = await searchCityGeo(query);
    if (result) {
        document.getElementById('user-city-lat').value = result.latitude;
        document.getElementById('user-city-lon').value = result.longitude;
        document.getElementById('user-city-result').textContent = `å·²é€‰ä¸­: ${result.name}, ${result.country} (${result.latitude}, ${result.longitude})`;
        document.getElementById('user-city-result').style.color = 'green';
        // å¯ä»¥åœ¨ dataset æš‚å­˜çœŸå®åŸå¸‚å
        document.getElementById('user-real-city-search').dataset.realName = result.name;
    } else {
        alert("æœªæ‰¾åˆ°è¯¥åŸå¸‚ï¼Œè¯·å°è¯•ä½¿ç”¨æ‹¼éŸ³æˆ–è‹±æ–‡ (å¦‚ Shanghai)ã€‚");
    }
});

document.getElementById('char-city-search-btn').addEventListener('click', async () => {
    const query = document.getElementById('char-real-city-search').value.trim();
    if(!query) return alert("è¯·è¾“å…¥çœŸå®åŸå¸‚æ‹¼éŸ³æˆ–è‹±æ–‡åç§°");
    
    const result = await searchCityGeo(query);
    if (result) {
        document.getElementById('char-city-lat').value = result.latitude;
        document.getElementById('char-city-lon').value = result.longitude;
        document.getElementById('char-city-result').textContent = `å·²é€‰ä¸­: ${result.name}, ${result.country} (${result.latitude}, ${result.longitude})`;
        document.getElementById('char-city-result').style.color = 'green';
        document.getElementById('char-real-city-search').dataset.realName = result.name;
    } else {
        alert("æœªæ‰¾åˆ°è¯¥åŸå¸‚ï¼Œè¯·å°è¯•ä½¿ç”¨æ‹¼éŸ³æˆ–è‹±æ–‡ (å¦‚ New York)ã€‚");
    }
});

  // æ‰‹åŠ¨æ€»ç»“å¼¹çª—äº‹ä»¶ç›‘å¬å™¨
  document.getElementById('manual-summary-btn').addEventListener('click', openManualSummaryModal);
  document.getElementById('manual-summary-close-btn').addEventListener('click', closeManualSummaryModal);
  document.getElementById('manual-summary-cancel-btn').addEventListener('click', closeManualSummaryModal);
  document.getElementById('manual-summary-confirm-btn').addEventListener('click', executeManualSummary);
  
  // æš‚åœè°ƒç”¨æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
  const stopApiCallBtn = document.getElementById('stop-api-call-btn');
  if (stopApiCallBtn) {
    stopApiCallBtn.addEventListener('click', () => {
      if (currentApiController) {
        console.log('ç”¨æˆ·ç‚¹å‡»æš‚åœè°ƒç”¨æŒ‰é’®ï¼Œæ­£åœ¨å–æ¶ˆAPIè¯·æ±‚...');
        currentApiController.abort();
        
        // ç«‹å³éšè—æŒ‰é’®å¹¶ç§»é™¤åŠ¨ç”»
        stopApiCallBtn.style.display = 'none';
        stopApiCallBtn.classList.remove('active');
        
        // æ˜¾ç¤ºå–æ¶ˆæç¤ºï¼ˆä»…ç»™ç”¨æˆ·çœ‹ï¼Œä¸ä¼šè¿›å…¥èŠå¤©å†å²ï¼‰
        showCustomAlert('å·²åœæ­¢', 'å¯¹è¯å·²åœæ­¢ç”Ÿæˆ');
      }
    });
  }
  
  const PREFILLED_SALT = "bu_wan_jiu_guan_bu_yao_huo_qu";


  async function generatePin(deviceId, salt) {
    if (!deviceId || !salt) {
      throw new Error("è®¾å¤‡IDå’Œå¯†é’¥ç›ä¸èƒ½ä¸ºç©ºã€‚");
    }
    const dataToHash = deviceId + salt;
    const dataBuffer = new TextEncoder().encode(dataToHash);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex.substring(0, 6).toUpperCase();
  }

 
  function requirePinActivation() {
  
    return new Promise(async (resolve, reject) => {
      
      if (isPinActivated) {
        resolve(true);
        return;
      }

     
      const modal = document.getElementById('pin-modal-overlay');
      const deviceIdDisplay = document.getElementById('pin-device-id-display');
      const pinInput = document.getElementById('pin-input');
      const confirmBtn = document.getElementById('pin-modal-confirm-btn');
      const cancelBtn = document.getElementById('pin-modal-cancel-btn');

      
      deviceIdDisplay.value = EPHONE_DEVICE_ID;
      pinInput.value = ''; 

     

      const onConfirmClick = async () => {
        const userPin = pinInput.value;

       
        modal.classList.remove('visible');

       
        confirmBtn.removeEventListener('click', onConfirmClick);
        cancelBtn.removeEventListener('click', onCancelClick);

        if (!userPin || !userPin.trim()) {
          await showCustomAlert('æ“ä½œå–æ¶ˆ', 'æ‚¨æ²¡æœ‰è¾“å…¥æ¿€æ´»ç ã€‚'); 
          reject(new Error('ç”¨æˆ·å–æ¶ˆäº†è¾“å…¥ã€‚'));
          return;
        }

       
        await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨éªŒè¯æ¿€æ´»ç ...");


        try {
        
          const correctPin = await generatePin(EPHONE_DEVICE_ID, PREFILLED_SALT);

         
          if (userPin.trim().toUpperCase() === correctPin) {
            
            localStorage.setItem('ephonePinActivated', 'true');
            isPinActivated = true;
            await showCustomAlert('æ¿€æ´»æˆåŠŸï¼', 'æ­¤åŠŸèƒ½å·²ä¸ºæ‚¨çš„è®¾å¤‡æ°¸ä¹…è§£é”ã€‚');

        
            updateLockedFeatureUI();

           
            resolve(true);
          } else {
            
            await showCustomAlert('æ¿€æ´»å¤±è´¥', 'æ‚¨è¾“å…¥çš„æ¿€æ´»ç ä¸æ­£ç¡®ã€‚');
            reject(new Error('æ¿€æ´»ç ä¸æ­£ç¡®ã€‚'));
          }
        } catch (error) {
         
          console.error("æœ¬åœ°PINç éªŒè¯è¿‡ç¨‹å‡ºé”™:", error);
          await showCustomAlert('æ¿€æ´»å¤±è´¥', `éªŒè¯è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š${error.message}`);
          reject(error);
        }
     
      };


      const onCancelClick = async () => { // <--- æ·»åŠ  async
        modal.classList.remove('visible');
       
        confirmBtn.removeEventListener('click', onConfirmClick);
        cancelBtn.removeEventListener('click', onCancelClick);

    
        await showCustomAlert('æ“ä½œå–æ¶ˆ', 'æ¿€æ´»æµç¨‹å·²å–æ¶ˆã€‚'); 
        reject(new Error('ç”¨æˆ·å–æ¶ˆäº†æ¿€æ´»ã€‚'));
      };

    
      confirmBtn.addEventListener('click', onConfirmClick);
      cancelBtn.addEventListener('click', onCancelClick);

   
      modal.classList.add('visible');
      pinInput.focus();
    });
  }

  
  function updateLockedFeatureUI() {
    const isActivated = localStorage.getItem('ephonePinActivated') === 'true';
    const presetImportBtn = document.getElementById('import-preset-btn');

    
    const worldBookImportBtn = document.getElementById('import-world-book-btn');
  

    
    if (presetImportBtn) {
      presetImportBtn.classList.toggle('locked-feature', !isActivated);
    }

 
    if (worldBookImportBtn) {
      worldBookImportBtn.classList.toggle('locked-feature', !isActivated);
    }
  
  }
  document.addEventListener('visibilitychange', () => {
   
    if (document.visibilityState === 'visible') {
      console.log('åº”ç”¨å·²è¿”å›å‰å°ï¼Œæ­£åœ¨æ£€æŸ¥æ›´æ–°...');
     
      navigator.serviceWorker.ready.then(registration => {
       
        registration.update();
      });
    }
  });

  function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision) {
    const apiTemperature = state.globalSettings.apiTemperature || 0.8;
    const roleType = {
      user: 'user',
      assistant: 'model',
      system: 'user'
    };


    const contents = [{
        role: 'user',
        parts: [{
          text: systemInstruction
        }]
      },
      {
        role: 'model',
        parts: [{
          text: 'å¥½çš„ï¼Œæˆ‘æ˜ç™½äº†ã€‚æˆ‘ä¼šä¸¥æ ¼éµå®ˆä»¥ä¸Šæ‰€æœ‰è§„åˆ™å’Œè®¾å®šã€‚'
        }]
      },

      ...messagesForDecision.map((item) => {
        const parts = [];

        if (Array.isArray(item.content)) {
          item.content.forEach(part => {
            if (part.type === 'text') {
              parts.push({
                text: part.text
              });
            } else if (part.type === 'image_url' && part.image_url && part.image_url.url) {

              const currentImageData = part.image_url.url;
              const base64Data = currentImageData.split(',')[1];
              const mimeTypeMatch = currentImageData.match(/^data:(.*);base64/);
              if (mimeTypeMatch && base64Data) {
                parts.push({
                  inline_data: {
                    mime_type: mimeTypeMatch[1],
                    data: base64Data
                  }
                });
              }
            }
          });
        } else {

          parts.push({
            text: String(item.content)
          });
        }
        return {
          role: roleType[item.role],
          parts: parts
        };
      })
    ];


    return {
      url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
      data: {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: contents,
          generationConfig: {
            temperature: apiTemperature,
          },
        })
      }
    };
  }





  var db; // æ•°æ®åº“å°†åœ¨ç™»å½•ååŠ¨æ€åˆå§‹åŒ–
  const avatarFrames = [{
      id: 'none',
      url: '',
      name: 'æ— '
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif',
      name: '14'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif',
      name: '14'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif',
      name: '14'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif',
      name: '14'
    },
    {
      id: 'frame_12',
      url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif',
      name: '12'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif',
      name: '14'
    },

    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif',
      name: '14'
    },


    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif',
      name: '14'
    },

  ];
  let billState = {
    page: 0,
    pageSize: 30,      
    isLoading: false,   
    hasMore: true,      
    filterDate: '',     
    filterType: 'all'   
};
  let state = {
    chats: {},
    activeChatId: null,
    globalSettings: {},
    apiConfig: {},
    userStickers: [],
    worldBooks: [],
    personaPresets: [],
    qzoneSettings: {},
    activeAlbumId: null,
    cache: {
      songs: new Map(),
      lyrics: new Map()
    },
    ttsCache: new Map(),
    quickReplies: []
  };

let memoryCache = []; // ç¼“å­˜æ‰€æœ‰éœ€è¦æ˜¾ç¤ºçš„è®°å¿†
let memoryRenderCount = 0; // å½“å‰å·²æ¸²æŸ“æ•°é‡
let isLoadingMoreMemories = false; // é˜²æŠ–é”

// å¾…åŠäº‹é¡¹åˆ†é¡µçŠ¶æ€
let todoCache = [];
let todoRenderCount = 0;
let isLoadingMoreTodos = false;
async function uploadImageToImgBB(base64String) {
    // 1. æ£€æŸ¥åŠŸèƒ½æ˜¯å¦å¼€å¯
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        // console.log("ImgBB æœªå¼€å¯ï¼Œè¿”å›åŸå§‹ Base64ã€‚");
        return base64String; // åŠŸèƒ½æœªå¼€å¯ï¼Œç›´æ¥è¿”å›
    }

    // 2. æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ URL
    if (!base64String || !base64String.startsWith('data:image')) {
        // console.log("è¾“å…¥å·²æ˜¯ URL æˆ–ä¸ºç©ºï¼Œæ— éœ€ä¸Šä¼ ã€‚");
        return base64String; // å·²ç»æ˜¯ URL æˆ–ä¸ºç©ºï¼Œæ— éœ€ä¸Šä¼ 
    }

    // 3. æå– Base64 æ•°æ®
    // æ ¼å¼ä¸º data:image/png;base64,iVBORw0KGgo...
    const base64Data = base64String.split(',')[1];
    if (!base64Data) {
        console.warn("æ— æ³•ä»å­—ç¬¦ä¸²ä¸­æå– Base64 æ•°æ®:", base64String.substring(0, 50) + "...");
        return base64String; // æ ¼å¼é”™è¯¯ï¼Œè¿”å›åŸæ–‡
    }
    
    console.log(`[ImgBB] å¼€å§‹ä¸Šä¼ å›¾ç‰‡... (å¤§å°: ${(base64String.length / 1024).toFixed(1)} KB)`);

    try {
        const formData = new FormData();
        formData.append('image', base64Data);

        const response = await fetch(`https://api.imgbb.com/1/upload?key=${state.apiConfig.imgbbApiKey}`, {
            method: 'POST',
            body: formData
        });

        const result = await response.json();

        if (result.success && result.data && result.data.url) {
            console.log("[ImgBB] ä¸Šä¼ æˆåŠŸ! URL:", result.data.url);
            return result.data.url; // æˆåŠŸï¼è¿”å› URL
        } else {
            // ImgBB API è¿”å›äº†é”™è¯¯
            throw new Error(result.error?.message || 'ImgBB API è¿”å›äº†æœªçŸ¥é”™è¯¯ã€‚');
        }
    } catch (error) {
        console.error("[ImgBB] ä¸Šä¼ å¤±è´¥:", error);
        // æŠ›å‡ºé”™è¯¯ï¼Œè®©è°ƒç”¨æ­¤å‡½æ•°çš„ä¸Šå±‚é€»è¾‘çŸ¥é“ä¸Šä¼ å¤±è´¥äº†
        throw new Error(`ImgBB ä¸Šä¼ å¤±è´¥: ${error.message}`);
    }
}
        async function uploadFileToCatbox(fileObject) {
    // 1. æ£€æŸ¥åŠŸèƒ½æ˜¯å¦å¼€å¯
    if (!state.apiConfig.catboxEnable || !state.apiConfig.catboxUserHash) {
        console.log("[Catbox] åŠŸèƒ½æœªå¼€å¯æˆ–æœªé…ç½® User Hashï¼Œè·³è¿‡ä¸Šä¼ ã€‚");
        return null; // åŠŸèƒ½æœªå¼€å¯ï¼Œè¿”å› null ä»¥ä¾¿å›é€€
    }

    const userHash = state.apiConfig.catboxUserHash;
    console.log(`[Catbox] å¼€å§‹ä¸Šä¼ æ–‡ä»¶: ${fileObject.name || 'blob.mp3'}... (å¤§å°: ${(fileObject.size / 1024 / 1024).toFixed(2)} MB)`);

    try {
        const formData = new FormData();
        formData.append('reqtype', 'fileupload');
        formData.append('userhash', userHash);
        formData.append('fileToUpload', fileObject, fileObject.name || 'track.mp3'); // æä¾›æ–‡ä»¶å

        // â–¼â–¼â–¼ ã€æ ¸å¿ƒä¿®å¤ã€‘ â–¼â–¼â–¼
        // 1. å®šä¹‰ Catbox API URL
        let apiUrl = 'https://catbox.moe/user/api.php';

        // 2. è·å– CORS ä»£ç†è®¾ç½® (å¤ç”¨ NovelAI çš„è®¾ç½®)
        const proxySettings = getNovelAISettings(); // This function is around line 4504
        let corsProxy = proxySettings.cors_proxy;
        if (corsProxy === 'custom') {
            corsProxy = proxySettings.custom_proxy_url || '';
        }

        // 3. å¦‚æœä»£ç†å­˜åœ¨, åˆ™ä½¿ç”¨ä»£ç†
        if (corsProxy && corsProxy !== '') {
            // ã€é‡è¦ã€‘Catbox API URL ä¸éœ€è¦ç¼–ç ï¼Œè€Œ NovelAI éœ€è¦ï¼Œè¿™é‡Œæˆ‘ä»¬ç›´æ¥æ‹¼æ¥
            apiUrl = corsProxy + apiUrl; 
            console.log(`[Catbox] æ£€æµ‹åˆ°CORSä»£ç†ï¼Œä½¿ç”¨ä»£ç†ä¸Šä¼ : ${apiUrl}`);
        } else {
            console.log("[Catbox] æœªé…ç½®CORSä»£ç†ï¼Œå°è¯•ç›´è¿... (è¿™å¾ˆå¯èƒ½ä¼šå¤±è´¥)");
        }
        // â–²â–²â–² ã€ä¿®å¤ç»“æŸã€‘ â–²â–²â–²

        const response = await fetch(apiUrl, { // <-- æ›¿æ¢ä¸º apiUrl
            method: 'POST',
            body: formData
        });

        const responseText = await response.text();

        if (response.ok && responseText.startsWith('http')) {
            console.log("[Catbox] ä¸Šä¼ æˆåŠŸ! URL:", responseText);
            return responseText; // æˆåŠŸï¼è¿”å› URL
        } else {
            // Catbox API è¿”å›äº†é”™è¯¯æ–‡æœ¬
            throw new Error(responseText || 'Catbox API è¿”å›äº†æœªçŸ¥é”™è¯¯ã€‚');
        }
    } catch (error) {
        console.error("[Catbox] ä¸Šä¼ å¤±è´¥:", error);
        // æŠ›å‡ºé”™è¯¯ï¼Œè®©è°ƒç”¨æ­¤å‡½æ•°çš„ä¸Šå±‚é€»è¾‘çŸ¥é“ä¸Šä¼ å¤±è´¥äº†
        // ã€é‡è¦ã€‘æˆ‘ä»¬åœ¨è¿™é‡ŒåªæŠ›å‡ºåŸå§‹é”™è¯¯ï¼Œä»¥ä¾¿ä¸Šå±‚å‡½æ•°å¯ä»¥æ•è·å¹¶æ˜¾ç¤ºå®ƒ
        throw error;
    }
}
async function silentlyUpdateDbUrl(table, recordId, pathString, base64ToFind, nameToMatch = null) {
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        console.log(`[ImgBB Silent Update] ImgBB is disabled, skipping silent upload for ${table.name}.${recordId}.${pathString}.`);
        return; // ImgBB not enabled, do nothing.
    }
    
    let imageUrl;
    try {
        imageUrl = await uploadImageToImgBB(base64ToFind);
        if (imageUrl === base64ToFind) {
             console.log("[ImgBB Silent Update] Upload returned Base64 (or failed), no update needed.");
             return; // Upload failed or was skipped
        }
    } catch (uploadError) {
        console.error(`[ImgBB Silent Update] Background upload failed for ${table.name}.${recordId}.${pathString}:`, uploadError.message);
        return; // Upload failed
    }

    console.log(`[ImgBB Silent Update] Success. New URL: ${imageUrl}. Finding record to update...`);

    try {
        const record = await table.get(recordId);
        if (!record) {
            console.warn(`[ImgBB Silent Update] Could not find record ${recordId} in table ${table.name}.`);
            return;
        }

        let updated = false;

        // è¾…åŠ©å‡½æ•°ï¼šé€šè¿‡è·¯å¾„å­—ç¬¦ä¸²æ·±å…¥å¯¹è±¡ï¼Œè¿”å›çˆ¶çº§å’Œæœ€åçš„é”®
        function getNestedParent(obj, path) {
            const keys = path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                if (current[keys[i]] === undefined || current[keys[i]] === null) {
                    console.warn(`[ImgBB Silent Update] Invalid path: ${path} in record at key ${keys[i]}.`);
                    return null; // Path does not exist
                }
                current = current[keys[i]];
            }
            return { parent: current, finalKey: keys[keys.length - 1] };
        }

        if (nameToMatch) {
            // --- é€»è¾‘ A: æœç´¢æ•°ç»„ ---
            const result = getNestedParent(record, pathString);
            if (result && Array.isArray(result.parent[result.finalKey])) {
                const arrayToSearch = result.parent[result.finalKey];
                const itemToUpdate = arrayToSearch.find(item => item.url === base64ToFind && item.name === nameToMatch);
                
                if (itemToUpdate) {
                    itemToUpdate.url = imageUrl;
                    updated = true;
                    console.log(`[ImgBB Silent Update] Found and updated item "${nameToMatch}" in array ${pathString}.`);
                } else {
                    console.warn(`[ImgBB Silent Update] Could not find item "${nameToMatch}" with matching Base64 in array ${pathString} to update.`);
                }
            } else {
                 console.warn(`[ImgBB Silent Update] Path ${pathString} did not resolve to a valid array.`);
            }
        } else {
            // --- é€»è¾‘ B: æ›´æ–°ç®€å•å±æ€§ (å¦‚ 'url' æˆ– 'widgetData.polaroid-img-1') ---
            const result = getNestedParent(record, pathString);
            if (result && result.parent[result.finalKey] === base64ToFind) {
                result.parent[result.finalKey] = imageUrl;
                updated = true;
                console.log(`[ImgBB Silent Update] Found and updated simple path ${pathString}.`);
            } else if (result) {
                console.warn(`[ImgBB Silent Update] Value changed since upload for ${pathString}. Expected Base64, found: ${String(result.parent[result.finalKey]).substring(0,30)}...`);
            } else {
                console.warn(`[ImgBB Silent Update] Path ${pathString} did not resolve to a matching string.`);
            }
        }


        if (updated) {
            await table.put(record);
            console.log(`[ImgBB Silent Update] Successfully updated DB for ${table.name}.${recordId}.${pathString}.`);
            
            // æ›´æ–°å†…å­˜ (state.globalSettings)
            if (table.name === 'globalSettings' && recordId === 'main') {
                // (é‡æ–°è·å–æ›´æ–°åçš„å†…å­˜çŠ¶æ€)
                const stateResult = getNestedParent(state, `globalSettings.${pathString}`);
                if (nameToMatch && stateResult && Array.isArray(stateResult.parent[stateResult.finalKey])) {
                    const stateArray = stateResult.parent[stateResult.finalKey];
                    const stateItem = stateArray.find(item => item.url === base64ToFind && item.name === nameToMatch);
                    if (stateItem) stateItem.url = imageUrl;
                } else if (!nameToMatch && stateResult && stateResult.parent[stateResult.finalKey] === base64ToFind) {
                    stateResult.parent[stateResult.finalKey] = imageUrl;
                }
                console.log(`[ImgBB Silent Update] In-memory state.globalSettings updated.`);
            }
        }
    } catch (dbError) {
        console.error(`[ImgBB Silent Update] Failed to save updated URL to DB for ${table.name}.${recordId}.${pathString}:`, dbError);
    }
}
  let werewolfGameState = {
    isActive: false,
    gameMode: null,
    chatId: null,
    players: [],
    currentDay: 1,
    currentPhase: 'setup',
    nightActions: {},
    gameLog: [],
    discussionLog: [],
    voteResults: {},
    electionInfo: {
      candidates: [],
      votes: {}
    },
    sheriffId: null,
    lastFailedAction: null,
  };

  let thoughtsHistoryRenderCount = 0;
  const THOUGHTS_RENDER_WINDOW = 15;


  let qzonePostsRenderCount = 0;
  const QZONE_RENDER_WINDOW = 10;

  let qzonePostsCache = [];

  let musicState = {
    isActive: false,
    activeChatId: null,
    isPlaying: false,
    playlist: [],
    currentIndex: -1,
    playMode: 'order',
    totalElapsedTime: 0,
    timerId: null,

    parsedLyrics: [],
    currentLyricIndex: -1
  };
  let qzoneStickerPanelState = {
    isOpen: false,
    activePostId: null,
    panelEl: null,
    gridEl: null
  };
  const audioPlayer = document.getElementById('audio-player');
 // å˜é‡å£°æ˜åŒºåŸŸ
let isQuickReplyManagementMode = false;
let selectedQuickReplies = new Set();
  let newWallpaperBase64 = null;
  let isRuleManagementMode = false;
  let selectedRules = new Set();
  let isSelectionMode = false;
  let cphoneRenderedCount = 0;
  let cphoneActiveConversationType = null;
  let isLoadingMoreCphoneMessages = false;
  let myphoneRenderedCount = 0;
  let myphoneActiveConversationIndex = null;
  let isLoadingMoreMyPhoneMessages = false;
  let activeStickerCategoryId = 'all';
  let selectedMessages = new Set();
  let editingMemberId = null;
  let isAddingNpcToGroup = false;
  let editingWorldBookId = null;
  let editingRuleId = null;
  let isLoadingMoreChats = false;
  let isLoadingMoreMessages = false;
  let isLoadingMoreThoughts = false;
  let isLoadingMorePosts = false;
  let sortedChatListItems = [];
  let editingPersonaPresetId = null;
  let isManageMode = false;
  let selectedPresetIds = new Set();
  let pendingTavernPersonas = [];
  let currentReplyContext = null;
  let waimaiTimers = {};
  let currentSpectatorMode = 'group';
  let activeMessageTimestamp = null;
  let activeCharacterId = null;
  let editingMemoId = null;
  let editingDiaryId = null;
  let activeDiaryForViewing = null;
  let activeArticleForViewing = null;
  let activeMemoForViewing = null;
  let currentNaiPresetId = null;
  let shoppingCart = [];
  let editingProductId = null;
  let activeProductId = null;
  let selectedProducts = new Set();
  let activeQuickReplyCategoryId = 'all';

  let currentQzoneReplyContext = null;

  let activePostId = null;
  let activeDoubanPostId = null;
  let photoViewerState = {
    isOpen: false,
    photos: [],
    currentIndex: -1,
  };

  let unreadPostsCount = 0;

  let isFavoritesSelectionMode = false;
  let selectedFavorites = new Set()

  let simulationIntervalId = null;
  let currentTodoDate = new Date(); // å½“å‰æŸ¥çœ‹çš„æ—¥æœŸ
  let editingTodoId = null;
  const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
  const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
  const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
  const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
  let notificationTimeout;
  let ruleCache = {};

  const DEFAULT_NOTIFICATION_SOUND = 'https://www.myinstants.com/media/sounds/notification-sound-2.mp3';

  let gomokuState = {};
  let readingState = {};
  let drawGuessState = {
    isActive: false,
    partnerId: null,
    history: [],
    isAiResponding: false,
    mode: 'online', // 'online' æˆ– 'offline'ï¼Œé»˜è®¤çº¿ä¸Šæ¨¡å¼
    messageManager: {
      isOpen: false,
      mode: null,
      selectedTimestamps: new Set()
    }
  };
  let originalChatMessagesPaddingTop = null;



  const DEFAULT_APP_ICONS = {
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'renderer': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',

    'char-phone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg',
    'douban': 'https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg',

    'preset': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',

    'tutorial': 'https://i.postimg.cc/d10GjC4g/IMG-7302.jpg',
    'werewolf': 'https://i.postimg.cc/k401K5g7/IMG-7304.jpg',
     
    'x': 'https://i.postimg.cc/Y9d3BztC/1.png',
    'alipay': 'https://i.postimg.cc/Hs7BLh76/alipay.png',
    'auction': 'https://i.postimg.cc/Hs7BLh76/alipay.png',
     'green-river': 'https://i.postimg.cc/0j55Pj1L/green-river-icon.png',
    'mail': 'https://i.postimg.cc/PfR7f37x/mail.png',

    // ç¬¬ä¸‰é¡µçš„APP
    'myphone': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'draw-guess': 'https://i.postimg.cc/k5dG3B4p/draw-guess-icon.png',
    'char-generator': 'https://i.postimg.cc/nzGYM8qb/character-gen.jpg'
  };


  const DEFAULT_CPHONE_ICONS = {
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
    'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
    'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
    'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
    'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
    'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
    'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
    'bilibili': 'https://i.postimg.cc/Wz5gV0jB/bilibili-icon.png',
     'reddit': 'https://www.redditinc.com/assets/images/site/reddit-logo.png',
    'ephone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
  };

  const DEFAULT_MYPHONE_ICONS = {
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
    'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
    'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
    'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
    'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
    'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
    'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
    'bilibili': 'https://i.postimg.cc/Wz5gV0jB/bilibili-icon.png',
    'reddit': 'https://www.redditinc.com/assets/images/site/reddit-logo.png',
    'cphone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
  };

  let repostTargetId = null;
  const STICKER_REGEX = /(^https:\/\/i\.postimg\.cc\/.+|^https:\/\/files\.catbox\.moe\/.+|^https?:\/\/sharkpan\.xyz\/.+|^data:image|\.(png|jpg|jpeg|gif|webp)\?.*$|\.(png|jpg|jpeg|gif|webp)$)/i;

  let currentRenderedCount = 0;
  let lastKnownBatteryLevel = 1;
  let alertFlags = {
    hasShown40: false,
    hasShown20: false,
    hasShown10: false
  };
  let batteryAlertTimeout;
  const dynamicFontStyle = document.createElement('style');
  dynamicFontStyle.id = 'dynamic-font-style';
  document.head.appendChild(dynamicFontStyle);

  const modalOverlay = document.getElementById('custom-modal-overlay');
  const modalTitle = document.getElementById('custom-modal-title');
  const modalBody = document.getElementById('custom-modal-body');
  const modalConfirmBtn = document.getElementById('custom-modal-confirm');
  const modalCancelBtn = document.getElementById('custom-modal-cancel');
  let modalResolve;

  function showCustomModal() {
    modalOverlay.classList.add('visible');
  }

  function hideCustomModal() {
    modalOverlay.classList.remove('visible');
    modalConfirmBtn.classList.remove('btn-danger');
    if (modalResolve) modalResolve(null);
  }

  function applyLyricsBarPosition(chat) {
    const lyricsBar = document.getElementById('global-lyrics-bar');

    const settings = chat.settings.lyricsPosition || {
      vertical: 'top',
      horizontal: 'center',
      offset: 10
    };


    lyricsBar.style.top = 'auto';
    lyricsBar.style.bottom = 'auto';
    lyricsBar.style.left = 'auto';
    lyricsBar.style.right = 'auto';
    lyricsBar.style.transform = 'none';


    if (settings.vertical === 'top') {
      lyricsBar.style.top = `${settings.offset}px`;
    } else {
      lyricsBar.style.bottom = `${settings.offset}px`;
    }


    switch (settings.horizontal) {
      case 'left':
        lyricsBar.style.left = '15px';
        break;
      case 'right':
        lyricsBar.style.right = '15px';
        break;
      case 'center':
      default:
        lyricsBar.style.left = '50%';
        lyricsBar.style.transform = 'translateX(-50%)';
        break;
    }
  }




  async function handleLocalGroupAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    // [å·²åˆ é™¤] AIå‘½åæç¤º
    // await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIä¸ºæ–°ç¾¤å¤´åƒå‘½å...");

    try {
      // [ä¿®æ”¹] å°†AIå‘½åæ”¹ä¸ºæ‰‹åŠ¨è¾“å…¥
      // const description = await getAvatarDescriptionFromApi(base64Url);
      const description = await showCustomPrompt("å‘½åç¾¤å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªæ–°ç¾¤å¤´åƒå‘½å");

      // [ä¿®æ”¹] æ£€æŸ¥æ˜¯å¦è¾“å…¥äº†åç§°
      // if (!description) {
      //   throw new Error("AIæœªèƒ½æˆåŠŸæè¿°å›¾ç‰‡ã€‚");
      // }
      if (!description || !description.trim()) {
        await showCustomAlert("æ“ä½œå–æ¶ˆ", "ä½ æ²¡æœ‰è¾“å…¥åç§°ï¼Œå·²å–æ¶ˆä¸Šä¼ ã€‚");
        event.target.value = null; // æ¸…ç©º input
        return;
      }

      const chat = state.chats[state.activeChatId];
      if (!chat.settings.groupAvatarLibrary) {
        chat.settings.groupAvatarLibrary = [];
      }
      
      const newItem = {
        name: description, // ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åç§°
        url: base64Url
      };
      chat.settings.groupAvatarLibrary.push(newItem);
      await db.chats.put(chat);
      
      renderGroupAvatarLibrary();
      
      // [ä¿®æ”¹] æ›´æ”¹æˆåŠŸæç¤º
      // await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `AIå·²å°†æ–°ç¾¤å¤´åƒå‘½åä¸ºï¼šâ€œ${description}â€\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);
      await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `ç¾¤å¤´åƒå·²å‘½åä¸ºï¼šâ€œ${description}â€\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);

      // ã€ã€ã€å·²ä¿®å¤çš„è°ƒç”¨ã€‘ã€‘ã€‘
      (async () => {
        await silentlyUpdateDbUrl(
            db.chats, // table
            chat.id,  // recordId
            'settings.groupAvatarLibrary', // pathString (æŒ‡å‘æ•°ç»„)
            base64Url, // base64ToFind
            description // [ä¿®æ”¹] ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åç§°
        );
      })();

    } catch (error) {
      // [ä¿®æ”¹] æ›´æ”¹å¤±è´¥æç¤º
      console.error("æœ¬åœ°ç¾¤å¤´åƒä¸Šä¼ åŠè¯†åˆ«å¤±è´¥:", error);
      // await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•ä¸ºå¤´åƒå‘½åï¼Œè¯·æ£€æŸ¥ï¼ˆä¸»/å‰¯ï¼‰APIé…ç½®æ˜¯å¦æ­£ç¡®å¹¶æ”¯æŒVisionã€‚\né”™è¯¯: ${error.message}`);
      await showCustomAlert("æ“ä½œå¤±è´¥", `ä¸Šä¼ æ—¶å‘ç”Ÿé”™è¯¯ã€‚\né”™è¯¯: ${error.message}`);
    } finally {
      event.target.value = null;
    }
  }



  async function handleLocalAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    // [å·²åˆ é™¤] AIå‘½åæç¤º
    // await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIä¸ºæ–°å¤´åƒå‘½å...");

    try {
      // [ä¿®æ”¹] å°†AIå‘½åæ”¹ä¸ºæ‰‹åŠ¨è¾“å…¥
      // const description = await getAvatarDescriptionFromApi(base64Url);
      const description = await showCustomPrompt("å‘½åå¤´åƒ", "è¯·ä¸ºè¿™ä¸ªæ–°å¤´åƒå‘½å");
      
      // [ä¿®æ”¹] æ£€æŸ¥æ˜¯å¦è¾“å…¥äº†åç§°
      // if (!description) {
      //   throw new Error("AIæœªèƒ½æˆåŠŸæè¿°å›¾ç‰‡ã€‚");
      // }
      if (!description || !description.trim()) {
        await showCustomAlert("æ“ä½œå–æ¶ˆ", "ä½ æ²¡æœ‰è¾“å…¥åç§°ï¼Œå·²å–æ¶ˆä¸Šä¼ ã€‚");
        event.target.value = null; // æ¸…ç©º input
        return;
      }
      
      const chat = state.chats[state.activeChatId];
      if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
      }
      
      const newItem = {
        name: description, // ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åç§°
        url: base64Url
      };
      chat.settings.aiAvatarLibrary.push(newItem);
      await db.chats.put(chat);
      
      renderAiAvatarLibrary();
      
      // [ä¿®æ”¹] æ›´æ”¹æˆåŠŸæç¤º
      // await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `AIå·²å°†æ–°å¤´åƒå‘½åä¸ºï¼šâ€œ${description}â€\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);
      await showCustomAlert("ä¸Šä¼ æˆåŠŸï¼", `å¤´åƒå·²å‘½åä¸ºï¼šâ€œ${description}â€\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);
      
      // ã€ã€ã€å·²ä¿®å¤çš„è°ƒç”¨ã€‘ã€‘ã€‘
      (async () => {
          await silentlyUpdateDbUrl(
              db.chats, // table
              chat.id,  // recordId
              'settings.aiAvatarLibrary', // pathString (æŒ‡å‘æ•°ç»„)
              base64Url, // base64ToFind
              description // [ä¿®æ”¹] ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åç§°
          );
      })();

    } catch (error) {
      // [ä¿®æ”¹] æ›´æ”¹å¤±è´¥æç¤º
      console.error("æœ¬åœ°å¤´åƒä¸Šä¼ åŠè¯†åˆ«å¤±è´¥:", error);
      // await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•ä¸ºå¤´åƒå‘½åï¼Œè¯·æ£€æŸ¥ï¼ˆä¸»/å‰¯ï¼‰APIé…ç½®æ˜¯å¦æ­£ç¡®å¹¶æ”¯æŒVisionã€‚\né”™è¯¯: ${error.message}`);
      await showCustomAlert("æ“ä½œå¤±è´¥", `ä¸Šä¼ æ—¶å‘ç”Ÿé”™è¯¯ã€‚\né”™è¯¯: ${error.message}`);
    } finally {
      event.target.value = null;
    }
  }


  async function getAvatarDescriptionFromApi(base64Url) {

    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const {
      proxyUrl,
      apiKey,
      model
    } = useSecondaryApi
      ?
      {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } :
      state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
      throw new Error("ä¸»APIå’Œå‰¯APIå‡æœªé…ç½®æˆ–é…ç½®ä¸å®Œæ•´ã€‚");
    }

    const prompt = "è¯·ä¸ºè¿™å¼ å›¾ç‰‡èµ·ä¸€ä¸ªç®€æ´çš„ã€é€‚åˆä½œä¸ºå¤´åƒåº“æ ‡ç­¾çš„åå­—ã€‚ä¾‹å¦‚ï¼šâ€œå¾®ç¬‘è‡ªæ‹â€ã€â€œé˜³å…‰ä¸‹çš„çŒ«å’ªâ€ã€â€œè“å‘åŠ¨æ¼«å°‘å¥³â€ã€‚è¯·ç›´æ¥å›ç­”åå­—ï¼Œä¸è¦åŠ ä»»ä½•å¤šä½™çš„è§£é‡Šã€‚";

    let isGemini = proxyUrl.includes('generativelanguage');
    let response;

    if (isGemini) {
      const mimeType = base64Url.match(/^data:(.*);base64/)[1];
      const base64Data = base64Url.split(',')[1];
      const payload = {
        contents: [{
          parts: [{
              text: prompt
            },
            {
              inline_data: {
                mime_type: mimeType,
                data: base64Data
              }
            }
          ]
        }]
      };
      response = await fetch(`${proxyUrl}/${model}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

    } else {
      const payload = {
        model: model,
        messages: [{
          role: 'user',
          content: [{
              type: 'text',
              text: prompt
            },
            {
              type: 'image_url',
              image_url: {
                url: base64Url
              }
            }
          ]
        }],
        max_tokens: 50
      };
      response = await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify(payload)
      });
    }

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
    }

    const data = await response.json();
    let description = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;


    return description.trim().replace(/["'â€œâ€â€˜â€™]/g, '');
  }


  async function syncCharacterNameInGroups(characterChat) {

    if (!characterChat || characterChat.isGroup) {
      console.warn("syncCharacterNameInGroups: ä¼ å…¥çš„ä¸æ˜¯æœ‰æ•ˆçš„å•èŠå¯¹è±¡ï¼Œå·²è·³è¿‡åŒæ­¥ã€‚");
      return;
    }

    const characterId = characterChat.id;
    const newRemarkName = characterChat.name;
    const newOriginalName = characterChat.originalName;

    console.log(`æ­£åœ¨ä¸ºè§’è‰² ${characterId} åŒæ­¥æ‰€æœ‰ç¾¤èŠå†…çš„åç§°ä¿¡æ¯...`);


    for (const chatId in state.chats) {
      const groupChat = state.chats[chatId];


      if (groupChat.isGroup && groupChat.members) {

        const memberToUpdate = groupChat.members.find(m => m.id === characterId);


        if (memberToUpdate) {
          let needsDbUpdate = false;


          if (memberToUpdate.groupNickname !== newRemarkName) {
            memberToUpdate.groupNickname = newRemarkName;
            needsDbUpdate = true;
          }


          if (memberToUpdate.originalName !== newOriginalName) {
            memberToUpdate.originalName = newOriginalName;
            needsDbUpdate = true;
          }


          if (needsDbUpdate) {
            await db.chats.put(groupChat);
            console.log(`æˆåŠŸå°†ç¾¤èŠ "${groupChat.name}" ä¸­çš„æˆå‘˜ä¿¡æ¯æ›´æ–°`);
          }
        }
      }
    }
  }





 
  async function syncCharacterAvatarInGroups(characterChat) {

    if (!characterChat || characterChat.isGroup) {
      console.warn("syncCharacterAvatarInGroups: ä¼ å…¥çš„ä¸æ˜¯æœ‰æ•ˆçš„å•èŠå¯¹è±¡ï¼Œå·²è·³è¿‡åŒæ­¥ã€‚");
      return;
    }

    const characterId = characterChat.id;
    const newAvatar = characterChat.settings.aiAvatar;

    console.log(`æ­£åœ¨ä¸ºè§’è‰² ${characterId} åŒæ­¥æ‰€æœ‰ç¾¤èŠå†…çš„å¤´åƒ...`);


    for (const groupChat of Object.values(state.chats)) {
      if (groupChat.isGroup && groupChat.members) {

        const memberToUpdate = groupChat.members.find(m => m.id === characterId);


        if (memberToUpdate && memberToUpdate.avatar !== newAvatar) {
          memberToUpdate.avatar = newAvatar;


          await db.chats.put(groupChat);
          console.log(`æˆåŠŸå°†è§’è‰² ${characterId} çš„æ–°å¤´åƒåŒæ­¥åˆ°ç¾¤èŠ "${groupChat.name}"`);
        }
      }
    }
  }



  function getDisplayNameInGroup(groupChat, originalName) {

    if (!groupChat || !groupChat.isGroup || !originalName) {
      return originalName;
    }





    const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
    if (originalName === userOriginalName) {

      return groupChat.settings.myNickname || 'æˆ‘';
    }


    const member = groupChat.members.find(m => m.originalName === originalName);


    return member ? member.groupNickname : originalName;
  }




  function switchRuleCategory(categoryId) {

    document.querySelectorAll('.rules-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });

    document.querySelectorAll('.rules-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


 



  function getDisplayNameByOriginalName(nameIdentifier) {

    if (!nameIdentifier) return '';


    if (state.qzoneSettings && nameIdentifier === state.qzoneSettings.nickname) {
      return state.qzoneSettings.nickname;
    }



    let characterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.originalName === nameIdentifier);
    if (characterChat) {
      return characterChat.name;
    }


    characterChat = Object.values(state.chats).find(chat =>
      !chat.isGroup &&
      (chat.nameHistory && chat.nameHistory.includes(nameIdentifier))
    );
    if (characterChat) {
      return characterChat.name;
    }



    return nameIdentifier;
  }




 
  function processMentions(text, chat = null) {

    if (!text || typeof text !== 'string' || !text.includes('@[[')) {
      return text;
    }


    return text.replace(/@\[\[([^\]]+)\]\]/g, (match, originalName) => {
      const trimmedOriginalName = originalName.trim();
      let displayName;


      if (chat && chat.isGroup) {


        displayName = getDisplayNameInGroup(chat, trimmedOriginalName);
      } else {

        displayName = getDisplayNameByOriginalName(trimmedOriginalName);
      }


      return `@${displayName}`;
    });
  }




  function showCustomConfirm(title, message, options = {}) {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        modalBody.innerHTML = `<p>${message}</p>`;

        // --- ã€ä¿®å¤å¼€å§‹ã€‘ï¼šå¼ºåˆ¶é‡ç½® Footer ç»“æ„ ---
        // å› ä¸º showChoiceModalå¯èƒ½ä¼šç ´åFooterç»“æ„å¯¼è‡´IDä¸¢å¤±ï¼Œè¿™é‡Œå¿…é¡»é‡å»º
        const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        if (modalFooter) {
            modalFooter.style.flexDirection = 'row'; // æ¢å¤æ¨ªå‘å¸ƒå±€
            modalFooter.style.justifyContent = 'flex-end'; // æŒ‰é’®é å³
            modalFooter.innerHTML = `
              <button id="custom-modal-cancel">å–æ¶ˆ</button>
              <button id="custom-modal-confirm" class="confirm-btn">ç¡®å®š</button>
          `;
        }
        // --- ã€ä¿®å¤ç»“æŸã€‘ ---

        const confirmBtn = document.getElementById('custom-modal-confirm');
        const cancelBtn = document.getElementById('custom-modal-cancel');

        // æ­¤æ—¶ cancelBtn å¿…å®šå­˜åœ¨
        cancelBtn.style.display = 'block';

        confirmBtn.textContent = options.confirmText || 'ç¡®å®š';
        cancelBtn.textContent = options.cancelText || 'å–æ¶ˆ';

        if (options.confirmButtonClass) {
            confirmBtn.className = `confirm-btn ${options.confirmButtonClass}`; // é‡ç½®classå¹¶æ·»åŠ è‡ªå®šä¹‰class
        } else {
            confirmBtn.className = 'confirm-btn'; // æ¢å¤é»˜è®¤
        }

        confirmBtn.onclick = () => {
            resolve(true);
            hideCustomModal();
        };
        cancelBtn.onclick = () => {
            resolve(false);
            hideCustomModal();
        };
        showCustomModal();
    });
}

 
  function showDownloadToast(message = 'ğŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...', type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
    `;

    document.body.appendChild(toast);

    setTimeout(() => {
      toast.style.opacity = '1';
      toast.style.transform = 'translateY(0)';
    }, 10);

    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(-20px)';
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, 2000);
  }

  function generateFilenameForNai(prompt) {
    let cleanTitle = (prompt || 'NAI_Image')
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')
      .replace(/\s+/g, '_')
      .substring(0, 30);

    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0];

    return `${cleanTitle}_${timestamp}.png`;
  }


  function downloadNaiImage(imageSrc, prompt) {
    try {
      const filename = generateFilenameForNai(prompt);
      const link = document.createElement('a');
      link.href = imageSrc;
      link.download = filename;
      link.style.display = 'none';

      document.body.appendChild(link);
      link.click();

      setTimeout(() => {
        document.body.removeChild(link);
      }, 100);

      showDownloadToast('ğŸ“¥ å›¾ç‰‡ä¸‹è½½ä¸­...');
    } catch (error) {
      console.error('âŒ [NAIä¸‹è½½] ä¸‹è½½å¤±è´¥:', error);
      showDownloadToast('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
    }
  }
// --- æ–°å¢ï¼šé«˜ç«¯éä¾µå…¥å¼é€šçŸ¥ ---
function showToast(message, type = 'info', duration = 3000) {
    let container = document.querySelector('.toast-container');
    if (!container) {
        container = document.createElement('div');
        container.className = 'toast-container';
        document.body.appendChild(container);
    }

    // å®šä¹‰å›¾æ ‡ (SVG)
    const icons = {
        success: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`,
        loading: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"></path></svg>`,
        error: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`,
        info: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`
    };

    const iconSvg = icons[type] || icons.info;
    const spinClass = type === 'loading' ? 'spinning' : '';
    
    // æ™ºèƒ½æˆªæ–­è¿‡é•¿çš„æ¶ˆæ¯
    const displayMsg = message.length > 25 ? message.substring(0, 24) + '...' : message;

    const toast = document.createElement('div');
    toast.className = 'toast-item';
    toast.innerHTML = `
        <div class="toast-icon ${spinClass}">${iconSvg}</div>
        <span>${displayMsg}</span>
    `;

    container.appendChild(toast);

    // åŠ¨ç”»å…¥åœº
    requestAnimationFrame(() => {
        toast.classList.add('visible');
    });

    // è‡ªåŠ¨æ¶ˆå¤± (å¦‚æœæ˜¯ loading ç±»å‹ï¼Œåˆ™ä¸è‡ªåŠ¨æ¶ˆå¤±ï¼Œéœ€è¦å¤–éƒ¨ç§»é™¤é€»è¾‘ï¼Œæˆ–è€…ç®€å•ç‚¹è®¾ä¸ªé•¿æ—¶é™)
    if (type !== 'loading') {
        setTimeout(() => {
            toast.classList.remove('visible');
            setTimeout(() => toast.remove(), 400); // ç­‰å¾…è¿‡æ¸¡ç»“æŸ
        }, duration);
    }
    
    return toast; // è¿”å›å…ƒç´ ä»¥ä¾¿æ‰‹åŠ¨ç§»é™¤
}
  function showCustomAlert(title, message) {
    return new Promise(resolve => {
      modalResolve = resolve;
      modalTitle.textContent = title;
      modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;

      // --- ã€æ ¸å¿ƒä¿®å¤å¼€å§‹ã€‘ ---
      // è·å– Footer å®¹å™¨
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
      
      // å¼ºåˆ¶é‡ç½® Footer ç»“æ„ï¼Œé˜²æ­¢è¢« showChoiceModal ä¿®æ”¹åå¯¼è‡´ ID ä¸¢å¤±
      if (modalFooter) {
          modalFooter.style.flexDirection = 'row'; // æ¢å¤é»˜è®¤æ¨ªå‘å¸ƒå±€
          modalFooter.innerHTML = `
              <button id="custom-modal-cancel">å–æ¶ˆ</button>
              <button id="custom-modal-confirm" class="confirm-btn">ç¡®å®š</button>
          `;
      }
      // --- ã€æ ¸å¿ƒä¿®å¤ç»“æŸã€‘ ---

      const confirmBtn = document.getElementById('custom-modal-confirm');
      const cancelBtn = document.getElementById('custom-modal-cancel');

      // æ­¤æ—¶ confirmBtn å’Œ cancelBtn å¿…å®šå­˜åœ¨
      if (cancelBtn) cancelBtn.style.display = 'none';
      if (confirmBtn) confirmBtn.textContent = 'å¥½çš„';

      if (confirmBtn) {
          confirmBtn.onclick = () => {
            if (cancelBtn) cancelBtn.style.display = 'block'; // æ¢å¤æ˜¾ç¤ºï¼Œä»¥å…å½±å“å…¶ä»–åŠŸèƒ½
            confirmBtn.textContent = 'ç¡®å®š';
            resolve(true);
            hideCustomModal();
          };
      }
      
      if (cancelBtn) {
          cancelBtn.onclick = hideCustomModal;
      }

      showCustomModal();
    });
  }


  async function copyTextToClipboard(textToCopy, successMessage = 'å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼') {
    if (!textToCopy) {
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ã€‚');
      return;
    }
    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('å¤åˆ¶æˆåŠŸ', successMessage);
    } catch (err) {
      console.error('å¤åˆ¶å¤±è´¥:', err);
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }
  }

  // æŸ¥æ‰¾ function showCustomPrompt å¹¶å®Œå…¨æ›¿æ¢ä¸ºä»¥ä¸‹å†…å®¹ï¼š

function showCustomPrompt(title, message, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
      modalResolve = resolve;
      modalTitle.textContent = title;
      const inputId = 'custom-prompt-input';

      // æ·»åŠ æ¶ˆæ¯æ˜¾ç¤ºåŒºåŸŸ
      const messageHtml = message ? `<div style="margin-bottom: 15px; color: #333; line-height: 1.6;">${message}</div>` : '';

      const inputHtml = type === 'textarea' ?
        `<textarea id="${inputId}" placeholder="" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>` :
        `<input type="${type}" id="${inputId}" placeholder="" value="${initialValue}">`;

      modalBody.innerHTML = messageHtml + extraHtml + inputHtml;
      const input = document.getElementById(inputId);

      // ç»‘å®šé¢å¤–çš„æ ¼å¼åŒ–æŒ‰é’®äº‹ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
      modalBody.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const templateStr = btn.dataset.template;
          if (templateStr) {
            try {
              const templateObj = JSON.parse(templateStr);
              input.value = JSON.stringify(templateObj, null, 2);
              input.focus();
            } catch (e) {
              console.error("è§£ææ ¼å¼æ¨¡æ¿å¤±è´¥:", e);
            }
          }
        });
      });

      // --- ã€æ ¸å¿ƒä¿®å¤å¼€å§‹ã€‘ï¼šå¼ºåˆ¶é‡å»º Footer ç»“æ„ ---
      // é˜²æ­¢å› ä¸ºä¹‹å‰è°ƒç”¨è¿‡ showChoiceModal å¯¼è‡´æŒ‰é’®ä¸¢å¤±
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
      if (modalFooter) {
          modalFooter.style.flexDirection = 'row'; 
          modalFooter.style.justifyContent = 'flex-end'; 
          modalFooter.style.maxHeight = ''; 
          modalFooter.style.overflowY = '';
          
          // æš´åŠ›é‡ç½®ï¼šæŠŠæŒ‰é’®å¡å›å»
          modalFooter.innerHTML = `
            <button id="custom-modal-cancel">å–æ¶ˆ</button>
            <button id="custom-modal-confirm" class="confirm-btn">ç¡®å®š</button>
          `;
      }
      // --- ã€æ ¸å¿ƒä¿®å¤ç»“æŸã€‘ ---

      const confirmBtn = document.getElementById('custom-modal-confirm');
      const cancelBtn = document.getElementById('custom-modal-cancel');

      // ç¡®ä¿æŒ‰é’®å­˜åœ¨åå†æ“ä½œ
      if (confirmBtn) {
          confirmBtn.textContent = 'ç¡®å®š'; // é‡ç½®å¯èƒ½è¢«ä¿®æ”¹çš„æ–‡å­—
          confirmBtn.className = 'confirm-btn'; // é‡ç½®å¯èƒ½è¢«ä¿®æ”¹çš„æ ·å¼
          confirmBtn.style.display = 'block';
          
          confirmBtn.onclick = () => {
            resolve(input.value);
            hideCustomModal();
          };
      }

      if (cancelBtn) {
          cancelBtn.textContent = 'å–æ¶ˆ';
          cancelBtn.style.display = 'block';
          
          cancelBtn.onclick = () => {
            resolve(null);
            hideCustomModal();
          };
      }

      showCustomModal();
      
      // åŠ ä¸ªå®‰å…¨åˆ¤æ–­é˜²æ­¢ input ä¸ºç©º
      setTimeout(() => {
          if(input) input.focus();
      }, 100);
    });
}




 
  // å¢å¼ºç‰ˆ showChoiceModalï¼šä¼˜åŒ–æ»‘åŠ¨ä½“éªŒ
function showChoiceModal(title, options) {
    return new Promise(resolve => {
      const modal = document.getElementById('custom-modal-overlay');
      const modalTitle = document.getElementById('custom-modal-title');
      const modalBody = document.getElementById('custom-modal-body');
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

      modalTitle.textContent = title;
      modalBody.innerHTML = ''; // æ¸…ç©ºä¸»ä½“ï¼Œé€‰é¡¹ä¸»è¦åœ¨ Footer

      // æ¸…ç©º Footer å¹¶è®¾ç½®ä¸ºåˆ—å¸ƒå±€
      modalFooter.innerHTML = '';
      modalFooter.style.flexDirection = 'column';
      
      // --- ã€æ ¸å¿ƒä¼˜åŒ–ï¼šæ»‘åŠ¨è®¾ç½®ã€‘ ---
      modalFooter.style.maxHeight = '50vh'; // é™åˆ¶é«˜åº¦ï¼Œç•™å‡ºç©ºé—´
      modalFooter.style.overflowY = 'auto'; // å…è®¸å‚ç›´æ»šåŠ¨
      modalFooter.style.webkitOverflowScrolling = 'touch'; // iOS æµç•…æ»šåŠ¨
      modalFooter.style.overscrollBehavior = 'contain'; // é˜²æ­¢æ»šåŠ¨ç©¿é€åˆ°åº•å±‚
      modalFooter.style.padding = '10px'; // å¢åŠ å†…è¾¹è·
      modalFooter.style.gap = '8px'; // æŒ‰é’®é—´è·
      // ---------------------------

      // --- åˆ†é¡µé€»è¾‘å¼€å§‹ ---
      let renderedCount = 0;
      const PAGE_SIZE = 10; // æ¯æ¬¡åŠ è½½10ä¸ª
      
      // åˆ›å»ºâ€œåŠ è½½æ›´å¤šâ€æŒ‰é’®
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.textContent = 'åŠ è½½æ›´å¤š...';
      loadMoreBtn.style.cssText = 'background-color: #f0f0f0; color: #666; margin-top: 8px; width: 100%; border-radius: 8px; padding: 10px; border: none;';
      loadMoreBtn.style.display = 'none'; // åˆå§‹éšè—

      // æ¸²æŸ“å‡½æ•°
      const renderBatch = () => {
        const nextBatch = options.slice(renderedCount, renderedCount + PAGE_SIZE);
        
        nextBatch.forEach(option => {
          const button = document.createElement('button');
          
          // å…è®¸æ¸²æŸ“ HTML å†…å®¹
          button.innerHTML = option.text; 
          
          // æ·»åŠ ç¾åŒ–ç±»åå’Œæ ·å¼
          button.className = 'payment-option-item'; 
          button.style.width = '100%';
          button.style.textAlign = 'left';
          button.style.padding = '12px 15px';
          button.style.marginBottom = '0'; // ç”±çˆ¶å®¹å™¨ gap æ§åˆ¶
          
          button.onclick = () => {
            modal.classList.remove('visible');
            resolve(option.value);
          };
          // æ’å…¥åˆ°â€œåŠ è½½æ›´å¤šâ€æŒ‰é’®ä¹‹å‰
          modalFooter.insertBefore(button, loadMoreBtn);
        });

        renderedCount += nextBatch.length;

        // å¦‚æœè¿˜æœ‰å‰©ä½™é€‰é¡¹ï¼Œæ˜¾ç¤ºåŠ è½½æ›´å¤šæŒ‰é’®ï¼Œå¦åˆ™éšè—
        if (renderedCount < options.length) {
            loadMoreBtn.style.display = 'block';
            loadMoreBtn.textContent = `åŠ è½½æ›´å¤š (${options.length - renderedCount} ä¸ªå‰©ä½™)`;
        } else {
            loadMoreBtn.style.display = 'none';
        }
      };

      // ç»‘å®šåŠ è½½æ›´å¤šäº‹ä»¶
      loadMoreBtn.onclick = (e) => {
          e.stopPropagation(); 
          renderBatch();
      };

      // å…ˆæŠŠåŠ è½½æ›´å¤šæŒ‰é’®æ”¾è¿›å»
      modalFooter.appendChild(loadMoreBtn);

      // åˆå§‹æ¸²æŸ“ç¬¬ä¸€é¡µ
      renderBatch();
      // --- åˆ†é¡µé€»è¾‘ç»“æŸ ---

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'å–æ¶ˆ';
      cancelButton.style.marginTop = '15px'; 
      cancelButton.style.borderRadius = '8px';
      cancelButton.style.backgroundColor = '#fff';
      cancelButton.style.border = '1px solid #ddd';
      cancelButton.style.color = '#666';
      cancelButton.style.padding = '12px';
      cancelButton.style.width = '100%';
      
      cancelButton.onclick = () => {
        modal.classList.remove('visible');
        resolve(null);
      };
      modalFooter.appendChild(cancelButton);

      modal.classList.add('visible');

    }).finally(() => {
      // Promise ç»“æŸåçš„æ¸…ç†å·¥ä½œï¼ˆå¦‚æœæœ‰ï¼‰
    });
}



  
  async function getLrcContent() {

    const choice = await showChoiceModal('é€‰æ‹©æ­Œè¯å¯¼å…¥æ–¹å¼', [{
        text: 'ğŸ“ ä»æœ¬åœ°æ–‡ä»¶ (.lrc)',
        value: 'file'
      },
      {
        text: 'ğŸ“‹ ç›´æ¥ç²˜è´´æ­Œè¯æ–‡æœ¬',
        value: 'paste'
      }
    ]);


    if (choice === 'file') {

      return new Promise(resolve => {
        const lrcInput = document.getElementById('lrc-upload-input');
        const lrcChangeHandler = (e) => {
          const lrcFile = e.target.files[0];
          if (lrcFile) {
            const reader = new FileReader();
            reader.onload = (readEvent) => resolve(readEvent.target.result);
            reader.onerror = () => resolve("");
            reader.readAsText(lrcFile);
          } else {
            resolve(null);
          }
          lrcInput.removeEventListener('change', lrcChangeHandler);
          lrcInput.value = '';
        };
        lrcInput.addEventListener('change', lrcChangeHandler, {
          once: true
        });
        lrcInput.click();
      });
    } else if (choice === 'paste') {

      const pastedText = await showCustomPrompt(
        'ç²˜è´´æ­Œè¯',
        'è¯·åœ¨æ­¤å¤„ç²˜è´´å®Œæ•´çš„LRCæ ¼å¼æ­Œè¯...',
        '',
        'textarea'
      );


      if (pastedText) {


        const formattedText = pastedText.replace(/\[/g, '\n[').trim();
        return formattedText;
      }
      return pastedText;


    } else {

      return null;
    }
  }




// ========== åŠ¨æ€æ•°æ®åº“åˆå§‹åŒ–å‡½æ•° ==========
function initDatabase(userId) {
    // æ•°æ®åº“åå›ºå®šï¼Œç¡®ä¿æ‰¾å›æ—§æ•°æ®
    db = new Dexie('GeminiChatDB');
    
    // æ•°æ®åº“ç»“æ„å®šä¹‰
  db.version(50).stores({
    doubanPosts: '++id, timestamp',
    chats: '&id, isGroup, groupId, isPinned, memos, diary, appUsageLog, lastIntelligentSummaryTimestamp',
    apiConfig: '&id, minimaxGroupId, minimaxApiKey',
    globalSettings: '&id',
    userStickers: '&id, url, name, categoryId',
    stickerVisionCache: '&url, description, timestamp',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp, authorId',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate',
    callRecords: '++id, chatId, timestamp, customName',
    shoppingProducts: '++id, name, description',
    shoppingCategories: '++id, name',
    apiPresets: '++id, name',
    renderingRules: '++id, name, chatId',
    appearancePresets: '++id, name, type',
    stickerCategories: '++id, name',
    customAvatarFrames: '++id, name',
    presets: '&id, name, categoryId',
    presetCategories: '++id, name',
    readingLibrary: '++id, title, lastOpened, linkedStoryId',
    quickReplies: '++id, text, categoryId', // ä¿®æ”¹ï¼šå¢åŠ  categoryId ç´¢å¼•
  });

  // å¿«æ·å›å¤åˆ†ç±»ç³»ç»Ÿ - æ–°å¢æ•°æ®è¡¨
  db.version(51).stores({
    quickReplyCategories: '++id, name',
    npcs: '++id, name, npcGroupId, enableBackgroundActivity, actionCooldownMinutes, lastActionTimestamp',
    npcGroups: '++id, name',
    naiPresets: '++id, name',
    grAuthors: '++id, name',
    grStories: '++id, title, authorId, lastUpdated',
    userWallet: '&id',
    userTransactions: '++id, timestamp, type, amount, description',
    funds: '&id, code, name, riskLevel, currentNav, lastDayNav, history',
    auctions: '++id, status, itemName, endTime', // æ‹å–è®°å½•
    inventory: '++id, name, type, acquiredTime',
    emails: '++id, sender, senderType, recipient, subject, content, timestamp, isRead'
  }).upgrade(tx => {

    return tx.table('worldBooks').toCollection().modify(book => {

      if (typeof book.content === 'string' && book.content.trim() !== '') {
        book.content = [{
          keys: [],
          comment: 'ä»æ—§ç‰ˆæœ¬è¿ç§»çš„æ¡ç›®',
          content: book.content
        }];
      }
    });
  });

  // è§‚å½±æ’­æ”¾åˆ—è¡¨
  db.version(52).stores({
    watchTogetherPlaylist: '++id, name, timestamp'
  });

  window.db = db;
  console.log(`[System] å·²åŠ è½½ç”¨æˆ· ${userId} çš„æ•°æ®åº“`);
}
// ========== åŠ¨æ€æ•°æ®åº“åˆå§‹åŒ–å‡½æ•°ç»“æŸ ==========


  function showScreen(screenId) {
    if (screenId === 'chat-list-screen') {
      window.renderChatListProxy();
      switchToChatListView('messages-view');
    }
    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
    if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
    if (screenId === 'douban-screen') renderDoubanScreen();
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screenToShow = document.getElementById(screenId);
    if (screenToShow) screenToShow.classList.add('active');
    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
    if (screenId === 'font-settings-screen') {
      loadFontPresetsDropdown();
      document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
      applyCustomFont(state.globalSettings.fontUrl || '', true);
    }
  }
  window.updateListenTogetherIconProxy = () => {};

  function switchToChatListView(viewId) {
    const chatListScreen = document.getElementById('chat-list-screen');
    const views = {
      'messages-view': document.getElementById('messages-view'),
      'qzone-screen': document.getElementById('qzone-screen'),
      'favorites-view': document.getElementById('favorites-view'),
      'memories-view': document.getElementById('memories-view'),
      'npc-list-view': document.getElementById('npc-list-view')
    };
    const mainHeader = document.getElementById('main-chat-list-header');
    const mainBottomNav = document.getElementById('chat-list-bottom-nav');

    if (isFavoritesSelectionMode) {
      document.getElementById('favorites-edit-btn').click();
    }


    Object.values(views).forEach(v => v.classList.remove('active'));

    if (views[viewId]) {
      views[viewId].classList.add('active');
    }


    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
      item.classList.toggle('active', item.dataset.view === viewId);
    });


    if (viewId === 'messages-view') {
      mainHeader.style.display = 'flex';
      mainBottomNav.style.display = 'flex';
    } else {
      mainHeader.style.display = 'none';
      mainBottomNav.style.display = 'none';
    }


    if (viewId !== 'memories-view') {
      activeCountdownTimers.forEach(timerId => clearInterval(timerId));
      activeCountdownTimers = [];
    }


    switch (viewId) {
      case 'qzone-screen':
        views['qzone-screen'].style.backgroundColor = '#f0f2f5';
        updateUnreadIndicator(0);
        renderQzoneScreen();
        renderQzonePosts();
        break;
      case 'favorites-view':
        views['favorites-view'].style.backgroundColor = '#f9f9f9';
        renderFavoritesScreen();
        break;
      case 'messages-view':

        break;
      case 'npc-list-view':
        renderNpcListScreen();
        break;
    }
  }

  function renderXSocialScreen() {

    console.log("æ¸²æŸ“Xç¤¾äº¤é¡µé¢");
  }
  window.renderXSocialScreenProxy = renderXSocialScreen;

  function renderQzoneScreen() {
    if (state && state.qzoneSettings) {
      const settings = state.qzoneSettings;
      document.getElementById('qzone-nickname').textContent = settings.nickname;
      document.getElementById('qzone-avatar-img').src = settings.avatar;
      document.getElementById('qzone-banner-img').src = settings.banner;
    }
  }
  window.renderQzoneScreenProxy = renderQzoneScreen;

  async function saveQzoneSettings() {
    if (db && state.qzoneSettings) {
      await db.qzoneSettings.put(state.qzoneSettings);
    }
  }

  function formatPostTimestamp(timestamp) {
    if (!timestamp) return '';
    const now = new Date();
    const date = new Date(timestamp);
    const diffSeconds = Math.floor((now - date) / 1000);
    const diffMinutes = Math.floor(diffSeconds / 60);
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffMinutes < 1) return 'åˆšåˆš';
    if (diffMinutes < 60) return `${diffMinutes}åˆ†é’Ÿå‰`;
    if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    if (now.getFullYear() === year) {
      return `${month}-${day} ${hours}:${minutes}`;
    } else {
      return `${year}-${month}-${day} ${hours}:${minutes}`;
    }
  }



  
  


  



  






  async function createOrUpdatePostElement(post) {
    const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
    const isUpdating = !!existingPostContainer;

    const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
    if (!isUpdating) {
      postContainer.className = 'qzone-post-container';
      postContainer.dataset.postId = post.id;
    }

    const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
    if (!isUpdating) {
      postEl.className = 'qzone-post-item';
    }

    let authorAvatar = '',
      authorNickname = '',
      commentAvatar = state.qzoneSettings.avatar;


    if (post.authorId === 'user') {
      authorAvatar = state.qzoneSettings.avatar;
      authorNickname = state.qzoneSettings.nickname;
    } else if (state.chats[post.authorId]) {
      const authorChat = state.chats[post.authorId];
      authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
      authorNickname = authorChat.name;
    } else if (String(post.authorId).startsWith('npc_')) {

      const npcId = parseInt(String(post.authorId).replace('npc_', ''));
      if (!isNaN(npcId)) {
        const npc = await db.npcs.get(npcId);
        if (npc) {
          authorAvatar = npc.avatar || defaultGroupMemberAvatar;
          authorNickname = npc.name;
        } else {
          authorNickname = post.authorOriginalName || 'æœªçŸ¥NPC';
          authorAvatar = defaultGroupMemberAvatar;
        }
      }
    } else {

      authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
      authorAvatar = defaultAvatar;
    }


    function renderOriginalPostContent(targetPost) {
      let innerContentHtml = '';
      const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

      if (targetPost.type === 'shuoshuo') {
        innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
      } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {

        innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
      } else if (targetPost.type === 'text_image') {

        const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
        innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
      } else if (targetPost.type === 'naiimag') {
       
        const imageUrls = targetPost.imageUrls || (targetPost.imageUrl ? [targetPost.imageUrl] : []);

        if (imageUrls.length > 0) {
          const imageCount = imageUrls.length;
          let imagesHtml = '';

          // ä½¿ç”¨ç»Ÿä¸€çš„å¤šå›¾å¸ƒå±€ï¼ˆåŒ…æ‹¬å•å¼ å›¾ç‰‡ï¼‰
          imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
          imageUrls.forEach((url, index) => {
            imagesHtml += `<img src="${url}" class="naiimag-image" alt="å›¾ç‰‡${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='å›¾ç‰‡åŠ è½½å¤±è´¥';">`;
          });
          imagesHtml += '</div>';

          innerContentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
      }
      return innerContentHtml;
    }

    let mainContentHtml;

    if (post.type === 'repost') {
      const repostCommentHtml = post.repostComment ? `<div class="post-content">${post.repostComment.replace(/\n/g, '<br>')}</div>` : '';
      let originalAuthorAvatar = defaultAvatar;
      let originalAuthorNickname = 'åŸä½œè€…';
      if (post.originalPost.authorId === 'user') {
        originalAuthorAvatar = state.qzoneSettings.avatar;
        originalAuthorNickname = state.qzoneSettings.nickname;
      } else {
        const originalAuthorChat = state.chats[post.originalPost.authorId];
        if (originalAuthorChat) {
          originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
        }
        originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
      }
      mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
    } else {
      mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
      const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('ã€');
      likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} è§‰å¾—å¾ˆèµ</span></div>`;
    }


    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
      commentsHtml = '<div class="post-comments-container">';
      post.comments.forEach((comment, index) => {

        if (typeof comment === 'object' && comment !== null && comment.commenterName) {
          const commenterOriginalName = comment.commenterName;

          const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);

          let innerCommentContent;
          if (STICKER_REGEX.test(comment.text)) {
            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
          } else {
            innerCommentContent = parseMarkdown(comment.text);
          }

          let commentLineHtml = '';

          if (comment.replyTo) {
            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> å›å¤ <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
          } else {
            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
          }

          commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">Ã—</span>
                                         </div>`;

        } else {

          commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${String(comment)}</span>
                                         </div>`;
        }
      });
      commentsHtml += '</div>';
    }


    const userOriginalName = state.qzoneSettings.nickname;
    const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
    const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id);

    let repostIconHtml = '';
    if (post.type !== 'repost') {
      repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
    }

    postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">â€¦</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">å‘é€</button>
                </div>
            `;

    if (!isUpdating) {
      const deleteAction = document.createElement('div');
      deleteAction.className = 'qzone-post-delete-action';
      deleteAction.innerHTML = '<span>åˆ é™¤</span>';
      postContainer.appendChild(postEl);
      postContainer.appendChild(deleteAction);
    }

    return postContainer;
  }

 
  async function updateSinglePostInDOM(postId) {
    const postData = await db.qzonePosts.get(postId);
    if (!postData) {

      const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
      if (postContainer) {
        postContainer.remove();
      }
      return;
    }


    const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
    if (cacheIndex > -1) {
      qzonePostsCache[cacheIndex] = postData;
    }


    const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));


    await createOrUpdatePostElement(postData);
  }




  async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [postsFromDb, favorites] = await Promise.all([
      db.qzonePosts.orderBy('timestamp').reverse().filter(post => !post.isDeleted).toArray(),
      db.favorites.where('type').equals('qzone_post').toArray()
    ]);
    qzonePostsCache = postsFromDb;
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';
    qzonePostsRenderCount = 0;

    if (qzonePostsCache.length === 0) {
      postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€æ¡è¯´è¯´å§ï¼</p>';
      return;
    }


    loadMoreQzonePosts();
  }




  async function loadMoreQzonePosts() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;

    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) {
      isLoadingMorePosts = false;
      return;
    }

    showLoader(postsListEl, 'bottom');


    setTimeout(async () => {
      hideLoader(postsListEl);

      const nextSliceStart = qzonePostsRenderCount;
      const nextSliceEnd = qzonePostsRenderCount + QZONE_RENDER_WINDOW;
      const postsToAppend = qzonePostsCache.slice(nextSliceStart, nextSliceEnd);

      const fragment = document.createDocumentFragment();
      for (const post of postsToAppend) {
        const postElement = await createOrUpdatePostElement(post);
        fragment.appendChild(postElement);
      }
      postsListEl.appendChild(fragment);

      qzonePostsRenderCount += postsToAppend.length;

      isLoadingMorePosts = false;
    }, 500);
  }



  function openQzoneStickerPanel(postId, buttonElement) {
    const panel = qzoneStickerPanelState.panelEl;
    const grid = qzoneStickerPanelState.gridEl;


    grid.innerHTML = '';
    if (state.userStickers.length === 0) {
      grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">è¯·å…ˆåœ¨èŠå¤©ç•Œé¢çš„<br>è¡¨æƒ…é¢æ¿ä¸­æ·»åŠ è¡¨æƒ…åŒ…</p>';
    } else {
      state.userStickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;
        grid.appendChild(item);
      });
    }




    const btnRect = buttonElement.getBoundingClientRect();
    const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();

    panel.style.display = 'flex';
    const panelRect = panel.getBoundingClientRect();
    const panelHeight = panelRect.height;
    const panelWidth = panelRect.width;


    panel.style.top = `${btnRect.top - panelHeight - 5 - phoneScreenRect.top}px`;


    const desiredLeftPosition = btnRect.left - phoneScreenRect.left;


    if (desiredLeftPosition + panelWidth > phoneScreenRect.width) {

      panel.style.left = 'auto';
      panel.style.right = '5px';
    } else {

      panel.style.left = `${desiredLeftPosition}px`;
      panel.style.right = 'auto';
    }




    qzoneStickerPanelState.isOpen = true;
    qzoneStickerPanelState.activePostId = postId;
  }



  function closeQzoneStickerPanel() {

    if (qzoneStickerPanelState.isOpen) {

      qzoneStickerPanelState.panelEl.style.display = 'none';


      qzoneStickerPanelState.isOpen = false;
      qzoneStickerPanelState.activePostId = null;
    }
  }





 
  async function sendQzoneStickerComment(postId, sticker) {
    if (!sticker || !sticker.url) return;

    const post = await db.qzonePosts.get(postId);
    if (!post) {
      console.error("sendQzoneStickerComment: æ‰¾ä¸åˆ°å¸–å­:", postId);
      return;
    }

    if (!post.comments) {
      post.comments = [];
    }

    const newComment = {
      commenterName: state.qzoneSettings.nickname,
      text: sticker.url,
      meaning: sticker.name,
      timestamp: Date.now()
    };

    post.comments.push(newComment);

    await db.qzonePosts.update(postId, {
      comments: post.comments
    });

    closeQzoneStickerPanel();
    await renderQzonePosts();

    const postSummary = (post.publicText || post.content || `[å›¾ç‰‡åŠ¨æ€]`).substring(0, 30);


    for (const chatId in state.chats) {
      const chat = state.chats[chatId];
      if (!chat.isGroup) {
        const intelligentPrompt = `[ç³»ç»Ÿæç¤ºï¼š'${state.qzoneSettings.nickname}' åœ¨ä½ çš„åŠ¨æ€(ID: ${postId}, å†…å®¹æ‘˜è¦: â€œ${postSummary}â€)ä¸‹å‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${sticker.name}â€ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›åº”ã€‚]`;

        const historyMessage = {
          role: 'system',
          content: intelligentPrompt,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
      }
    }

  }






  
  function openRepostModal(postId) {
    repostTargetId = postId;
    document.getElementById('repost-comment-input').value = '';
    document.getElementById('repost-modal').classList.add('visible');
  }


  function hideRepostModal() {
    document.getElementById('repost-modal').classList.remove('visible');
    repostTargetId = null;
  }

 
  async function handleConfirmRepost() {
    if (!repostTargetId) return;

    const comment = document.getElementById('repost-comment-input').value.trim();
    const originalPost = await db.qzonePosts.get(repostTargetId);

    if (!originalPost) {
      alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦è½¬å‘çš„åŸå§‹åŠ¨æ€ã€‚");
      hideRepostModal();
      return;
    }

    const newPost = {
      type: 'repost',
      timestamp: Date.now(),
      authorId: 'user',
      repostComment: comment,
      originalPost: originalPost,
      visibleGroupIds: null
    };

    await db.qzonePosts.add(newPost);
    hideRepostModal();
    await renderQzonePosts();
    alert('è½¬å‘æˆåŠŸï¼');
  }




  function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
      const searchTerm = document.getElementById('favorites-search-input').value;
      const message = searchTerm ? 'æœªæ‰¾åˆ°ç›¸å…³æ”¶è—' : 'ä½ çš„æ”¶è—å¤¹æ˜¯ç©ºçš„ï¼Œ<br>å¿«å»åŠ¨æ€æˆ–èŠå¤©ä¸­æ”¶è—å–œæ¬¢çš„å†…å®¹å§ï¼';
      listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
      return;
    }

    for (const item of items) {
      const card = document.createElement('div');
      card.className = 'favorite-item-card';
      card.dataset.favid = item.id;

      let headerHtml = '',
        contentHtml = '',
        sourceText = '',
        footerHtml = '';

      if (item.type === 'qzone_post') {
        const post = item.content;
        sourceText = 'æ¥è‡ªåŠ¨æ€';
        let authorAvatar = defaultAvatar,
          authorNickname = 'æœªçŸ¥ç”¨æˆ·';

        if (post.authorId === 'user') {
          authorAvatar = state.qzoneSettings.avatar;
          authorNickname = state.qzoneSettings.nickname;
        } else if (state.chats[post.authorId]) {
          authorAvatar = state.chats[post.authorId].settings.aiAvatar;
          authorNickname = state.chats[post.authorId].name;
        }

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
        if (post.type === 'shuoshuo') {
          contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
        } else if (post.type === 'image_post' && post.imageUrl) {
          const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
          contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image"></div>` : `<img src="${postImageUrl}" class="chat-image">`;
        } else if (post.type === 'text_image') {
          const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
          contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        }




        let likesHtml = '';

        if (post.likes && post.likes.length > 0) {

          likesHtml = `
                            <div class="post-likes-section">
                                <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                <span>${post.likes.join('ã€')} è§‰å¾—å¾ˆèµ</span>
                            </div>`;
        }



        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
          commentsHtml = '<div class="post-comments-container">';
          post.comments.forEach((comment, index) => {

            if (typeof comment === 'object' && comment !== null && comment.commenterName) {

              const commenterOriginalName = comment.commenterName;
              const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);

              let innerCommentContent;
              if (STICKER_REGEX.test(comment.text)) {
                innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
              } else {
                innerCommentContent = comment.text;
              }

              let commentLineHtml = '';
              if (comment.replyTo) {
                const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> å›å¤ <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
              } else {
                commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
              }

              commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                        <div class="comment-text">${commentLineHtml}</div>
                                        <span class="comment-delete-btn" data-comment-index="${index}">Ã—</span>
                                     </div>`;

            } else {


              commentsHtml += `<div class="legacy-comment-item">
                                        <span class="comment-text">${String(comment)}</span>
                                     </div>`;
            }
          });
          commentsHtml += '</div>';
        }



        footerHtml = `${likesHtml}${commentsHtml}`;



      } else if (item.type === 'chat_message') {
        const msg = item.content;
        const chat = state.chats[item.chatId];
        if (!chat) continue;

        sourceText = `æ¥è‡ªä¸ ${chat.name} çš„èŠå¤©`;
        const isUser = msg.role === 'user';
        let senderName, senderAvatar;

        if (isUser) {

          senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
          senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
        } else {
          if (chat.isGroup) {


            const member = chat.members.find(m => m.originalName === msg.senderName);


            senderName = msg.senderName;

            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
          } else {

            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
          }
        }


        headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
          contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
        } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
          contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
        } else {
          contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
        }
      } else if (item.type === 'char_diary') {
        const diary = item.content;
        sourceText = `æ¥è‡ª ${diary.characterName} çš„æ—¥è®°`;

        const charChat = state.chats[diary.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${diary.characterName}</div></div>`;


        const fullDiaryContent = diary.content || '';

        const formattedContent = parseMarkdown(fullDiaryContent).replace(/\n/g, '<br>');


        contentHtml = `
                <span class="diary-title">${diary.title}</span>
                <div class="fav-card-content-full">${formattedContent}</div>
            `;
      } else if (item.type === 'char_browser_article') {
        const article = item.content;
        sourceText = `æ¥è‡ª ${article.characterName} çš„æµè§ˆè®°å½•`;

        const charChat = state.chats[article.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${article.characterName}</div></div>`;


        contentHtml = `
            <span class="diary-title">${article.title}</span>
            <div class="memo-content-preview">${(article.content || '').replace(/\n/g, '<br>')}</div>
        `;
      } else if (item.type === 'char_memo') {
        const memo = item.content;
        sourceText = `æ¥è‡ª ${memo.characterName} çš„å¤‡å¿˜å½•`;

        const charChat = state.chats[memo.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${memo.characterName}</div></div>`;


        contentHtml = `
        <span class="memo-title">${memo.title}</span>
        <div class="memo-content-preview">${memo.content.replace(/\n/g, '<br>')}</div>
    `;
      }


      card.innerHTML = `
                    <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                    <div class="fav-card-content">${contentHtml}</div>
                    ${footerHtml}`;

      listEl.appendChild(card);
    }
  }




  async function renderFavoritesScreen() {

    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();


    const searchInput = document.getElementById('favorites-search-input');
    const clearBtn = document.getElementById('favorites-search-clear-btn');
    searchInput.value = '';
    clearBtn.style.display = 'none';


    displayFilteredFavorites(allFavoriteItems);
  }



  function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';
    document.getElementById('switch-to-image-mode').click();
  }
 
  async function cleanupRedundantData() {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤æ¸…ç†å†—ä½™æ•°æ®ï¼Ÿ',
      'æ­¤æ“ä½œå°†æ‰«ææ•°æ®åº“ï¼Œç§»é™¤æ‰€æœ‰ä¸å·²åˆ é™¤è§’è‰²ç›¸å…³çš„å­¤ç«‹æ•°æ®ï¼ˆå¦‚åŠ¨æ€ã€è¯„è®ºã€è®°å¿†ç­‰ï¼‰ã€‚<br><br><strong>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œä½†é€šå¸¸æ˜¯å®‰å…¨çš„ã€‚NPCæ•°æ®ä¸ä¼šè¢«åˆ é™¤ã€‚</strong><br><br>å»ºè®®åœ¨æ“ä½œå‰å…ˆå¯¼å‡ºæ•°æ®å¤‡ä»½ã€‚', {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤æ¸…ç†'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨å¼€å§‹æ¸…ç†å†—ä½™æ•°æ®ï¼Œè¯·ä¸è¦å…³é—­é¡µé¢...");
    console.log("å†—ä½™æ•°æ®æ¸…ç†æµç¨‹å·²å¯åŠ¨...");

    let cleanupCounts = {
      posts: 0,
      likes: 0,
      comments: 0,
      memories: 0,
      callRecords: 0,
      renderingRules: 0,
      groupMembers: 0,
      chatLinks: 0,
    };

    try {
      await db.transaction('rw', db.tables, async () => {

        const allChats = await db.chats.toArray();
        const allNpcs = await db.npcs.toArray();

        const existingChatIds = new Set(allChats.map(c => c.id));
        const existingNpcIds = new Set(allNpcs.map(n => `npc_${n.id}`));

        const existingOriginalNames = new Set(allChats.filter(c => !c.isGroup).map(c => c.originalName));
        existingOriginalNames.add(state.qzoneSettings.nickname || '{{user}}');

        allNpcs.forEach(npc => existingOriginalNames.add(npc.name));


        for (const chat of allChats) {
          let chatModified = false;
          if (chat.isGroup && chat.members) {
            const originalMemberCount = chat.members.length;



            chat.members = chat.members.filter(member =>
              existingChatIds.has(member.id) || existingNpcIds.has(member.id)
            );

            if (chat.members.length < originalMemberCount) {
              cleanupCounts.groupMembers += (originalMemberCount - chat.members.length);
              chatModified = true;
            }
          }

          if (chat.settings?.linkedMemoryChatIds?.length > 0) {
            const originalLinkCount = chat.settings.linkedMemoryChatIds.length;
            chat.settings.linkedMemoryChatIds = chat.settings.linkedMemoryChatIds.filter(id => existingChatIds.has(id));
            if (chat.settings.linkedMemoryChatIds.length < originalLinkCount) {
              cleanupCounts.chatLinks += (originalLinkCount - chat.settings.linkedMemoryChatIds.length);
              chatModified = true;
            }
          }
          if (chatModified) {
            await db.chats.put(chat);
          }
        }


        const allPosts = await db.qzonePosts.toArray();
        for (const post of allPosts) {
          let postModified = false;



          const isAuthorValid = post.authorId === 'user' || existingChatIds.has(post.authorId) || existingNpcIds.has(post.authorId);

          if (!isAuthorValid) {
            await db.qzonePosts.delete(post.id);
            cleanupCounts.posts++;
            continue;
          }

          if (post.likes && post.likes.length > 0) {
            const originalLikeCount = post.likes.length;
            post.likes = post.likes.filter(name => existingOriginalNames.has(name));
            if (post.likes.length < originalLikeCount) {
              cleanupCounts.likes += (originalLikeCount - post.likes.length);
              postModified = true;
            }
          }
          if (post.comments && post.comments.length > 0) {
            const originalCommentCount = post.comments.length;
            post.comments = post.comments.filter(comment => {
              if (typeof comment === 'object' && comment.commenterName) {
                return existingOriginalNames.has(comment.commenterName);
              }
              return true;
            });
            if (post.comments.length < originalCommentCount) {
              cleanupCounts.comments += (originalCommentCount - post.comments.length);
              postModified = true;
            }
          }
          if (postModified) {
            await db.qzonePosts.put(post);
          }
        }


        await db.memories.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.memories += c);
        await db.callRecords.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.callRecords += c);
        const allRules = await db.renderingRules.toArray();
        for (const rule of allRules) {
          if (rule.chatId !== 'global' && !existingChatIds.has(rule.chatId)) {
            await db.renderingRules.delete(rule.id);
            cleanupCounts.renderingRules++;
          }
        }
      });

      let summary = "âœ… æ¸…ç†å®Œæˆï¼\n\n";
      let cleanedSomething = false;
      Object.entries(cleanupCounts).forEach(([key, value]) => {
        if (value > 0) {
          const keyMap = {
            posts: 'åŠ¨æ€',
            likes: 'ç‚¹èµ',
            comments: 'è¯„è®º',
            memories: 'è®°å¿†',
            callRecords: 'é€šè¯è®°å½•',
            renderingRules: 'æ¸²æŸ“è§„åˆ™',
            groupMembers: 'ç¾¤æˆå‘˜',
            chatLinks: 'è®°å¿†é“¾æ¥'
          };
          summary += `- æ¸…ç†äº† ${value} æ¡æ— æ•ˆçš„${keyMap[key] || key}ã€‚\n`;
          cleanedSomething = true;
        }
      });
      if (!cleanedSomething) {
        summary = "âœ… æ£€æŸ¥å®Œæˆï¼Œæœªå‘ç°ä»»ä½•å†—ä½™æ•°æ®ã€‚";
      }
      summary += "\nå»ºè®®åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿æ‰€æœ‰æ›´æ”¹ç”Ÿæ•ˆã€‚";

      await showCustomAlert("æ“ä½œæˆåŠŸ", summary);

      const confirmedReload = await showCustomConfirm("åˆ·æ–°é¡µé¢ï¼Ÿ", "ä¸ºäº†ç¡®ä¿æ‰€æœ‰æ•°æ®åŒæ­¥ï¼Œå»ºè®®ç«‹å³åˆ·æ–°é¡µé¢ã€‚");
      if (confirmedReload) {
        location.reload();
      }

    } catch (error) {
      console.error("æ¸…ç†å†—ä½™æ•°æ®æ—¶å‡ºé”™:", error);
      await showCustomAlert('æ¸…ç†å¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
  }

  async function exportBackup() {
    try {
      const backupData = {
        version: 1,
        timestamp: Date.now()
      };

      const [
        chats, worldBooks, userStickers, apiConfig, globalSettings,
        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
        memories, worldBookCategories,
        apiPresets, shoppingProducts, callRecords,
        renderingRules,

        doubanPosts,
        stickerCategories,

        appearancePresets,

        presets,
        presetCategories,

        npcs,

        // æ–°å¢çš„è¡¨
        stickerVisionCache,
        shoppingCategories,
        customAvatarFrames,
        readingLibrary,
        quickReplies,
        quickReplyCategories,
        npcGroups,
        naiPresets,
        grAuthors,
        grStories,
        userWallet,
        userTransactions,
        funds,
        auctions,
        inventory,
        emails,
        watchTogetherPlaylist
      ] = await Promise.all([
        db.chats.toArray(),
        db.worldBooks.toArray(),
        db.userStickers.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.personaPresets.toArray(),
        db.musicLibrary.get('main'),
        db.qzoneSettings.get('main'),
        db.qzonePosts.toArray(),
        db.qzoneAlbums.toArray(),
        db.qzonePhotos.toArray(),
        db.favorites.toArray(),
        db.qzoneGroups.toArray(),
        db.memories.toArray(),
        db.worldBookCategories.toArray(),
        db.apiPresets.toArray(),
        db.shoppingProducts.toArray(),
        db.callRecords.toArray(),
        db.renderingRules.toArray(),

        db.doubanPosts.toArray(),
        db.stickerCategories.toArray(),

        db.appearancePresets.toArray(),

        db.presets.toArray(),
        db.presetCategories.toArray(),

        db.npcs.toArray(),

        // æ–°å¢çš„è¡¨
        db.stickerVisionCache.toArray(),
        db.shoppingCategories.toArray(),
        db.customAvatarFrames.toArray(),
        db.readingLibrary.toArray(),
        db.quickReplies.toArray(),
        db.quickReplyCategories.toArray(),
        db.npcGroups.toArray(),
        db.naiPresets.toArray(),
        db.grAuthors.toArray(),
        db.grStories.toArray(),
        db.userWallet.get('main'),
        db.userTransactions.toArray(),
        db.funds.toArray(),
        db.auctions.toArray(),
        db.inventory.toArray(),
        db.emails.toArray(),
        db.watchTogetherPlaylist.toArray()
      ]);

      Object.assign(backupData, {
        chats,
        worldBooks,
        userStickers,
        apiConfig,
        globalSettings,
        personaPresets,
        musicLibrary,
        qzoneSettings,
        qzonePosts,
        qzoneAlbums,
        qzonePhotos,
        favorites,
        qzoneGroups,
        memories,
        worldBookCategories,
        apiPresets,
        shoppingProducts,
        callRecords,
        renderingRules,

        doubanPosts,
        stickerCategories,

        appearancePresets,

        presets,
        presetCategories,

        npcs,

        // æ–°å¢çš„è¡¨
        stickerVisionCache,
        shoppingCategories,
        customAvatarFrames,
        readingLibrary,
        quickReplies,
        quickReplyCategories,
        npcGroups,
        naiPresets,
        grAuthors,
        grStories,
        userWallet,
        userTransactions,
        funds,
        auctions,
        inventory,
        emails,
        watchTogetherPlaylist
      });

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );
      const url = URL.createObjectURL(blob);
      const link = Object.assign(document.createElement('a'), {
        href: url,
        download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
      });
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å·²æˆåŠŸå¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼');

    } catch (error) {
      console.error("å¯¼å‡ºæ•°æ®æ—¶å‡ºé”™:", error);
      await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
  }



  async function importStreamedBackup(backupData) {
    try {
      await db.transaction('rw', db.tables, async () => {

        for (const table of db.tables) {
          await table.clear();
        }


        for (const tableName in backupData) {
          if (Array.isArray(backupData[tableName])) {
            console.log(`æ­£åœ¨å¯¼å…¥è¡¨: ${tableName}, è®°å½•æ•°: ${backupData[tableName].length}`);
            await db.table(tableName).bulkPut(backupData[tableName]);
          }
        }
      });

    } catch (error) {

      throw new Error(`æ•°æ®åº“å†™å…¥å¤±è´¥: ${error.message}`);
    }
  }





  async function handleSmartImport(file) {
    if (!file) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯»å–å¹¶è§£æå¤‡ä»½æ–‡ä»¶...");

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      let backupDataContent;
      let backupType;

     
      if (data.data && typeof data.data === 'object' && (data.data.chats || data.data.worldBooks)) {
        console.log("æ£€æµ‹åˆ°æ–°ç‰ˆæµå¼å¤‡ä»½æ–‡ä»¶...");
        backupDataContent = data.data;
        backupType = 'streamed'; // 'streamed' or 'legacy'
      } else if (data.chats || data.worldBooks) {
        console.log("æ£€æµ‹åˆ°æ—§ç‰ˆå®Œæ•´å¤‡ä»½æ–‡ä»¶...");
        backupDataContent = data;
        backupType = 'legacy';
      } else {
        throw new Error("æ–‡ä»¶æ ¼å¼æ— æ³•è¯†åˆ«ã€‚è¯·ç¡®ä¿æ‚¨é€‰æ‹©çš„æ˜¯æœ‰æ•ˆçš„ EPhone å¤‡ä»½æ–‡ä»¶ã€‚");
      }

      
      pendingBackupData = {
        type: backupType,
        content: backupDataContent
      };

     
      openImportOptionsModal(backupDataContent);

    } catch (error) {
      console.error("å¯¼å…¥æ•°æ®æ—¶å‡ºé”™:", error);
      pendingBackupData = null;
      await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£ææˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
  }


  function openImportOptionsModal(backupDataContent) {
    const modal = document.getElementById('import-options-modal');
    const listEl = document.getElementById('import-preview-list');
    listEl.innerHTML = '';

    const contentSummary = {
      'chats': 'èŠå¤©ä¼šè¯',
      'worldBooks': 'ä¸–ç•Œä¹¦',
      'worldBookCategories': 'ä¸–ç•Œä¹¦åˆ†ç±»', 
      'presets': 'ç¦»çº¿é¢„è®¾',
      'presetCategories': 'é¢„è®¾åˆ†ç±»', 
      'userStickers': 'è¡¨æƒ…åŒ…',
      'stickerCategories': 'è¡¨æƒ…åˆ†ç±»',
      'customAvatarFrames': 'å¤´åƒæ¡†',
      'apiConfig': 'APIé…ç½®',
      'globalSettings': 'å…¨å±€è®¾ç½®',
      'personaPresets': 'äººè®¾é¢„è®¾',
      'qzoneSettings': 'ç©ºé—´è®¾ç½®',
      'qzonePosts': 'åŠ¨æ€',
      'qzoneAlbums': 'ç›¸å†Œ',
      'qzonePhotos': 'ç›¸å†Œç…§ç‰‡',
      'favorites': 'æ”¶è—',
      'qzoneGroups': 'ç©ºé—´åˆ†ç»„',
      'memories': 'å›å¿†',
      'callRecords': 'é€šè¯è®°å½•',
      'shoppingProducts': 'å•†å“',
      'shoppingCategories': 'å•†å“åˆ†ç±»',
      'apiPresets': 'APIé¢„è®¾',
      'renderingRules': 'æ¸²æŸ“è§„åˆ™',
      'appearancePresets': 'å¤–è§‚é¢„è®¾',
      'npcs': 'NPCs',
      'npcGroups': 'NPCåˆ†ç»„',
      'doubanPosts': 'è±†ç“£åŠ¨æ€',
      'stickerVisionCache': 'è¡¨æƒ…ç¼“å­˜',
      'readingLibrary': 'é˜…è¯»åº“',
      'quickReplies': 'å¿«æ·å›å¤',
      'quickReplyCategories': 'å¿«æ·å›å¤åˆ†ç±»',
      'naiPresets': 'NAIé¢„è®¾',
      'grAuthors': 'æ•…äº‹ä½œè€…',
      'grStories': 'æ•…äº‹',
      'userWallet': 'ç”¨æˆ·é’±åŒ…',
      'userTransactions': 'äº¤æ˜“è®°å½•',
      'funds': 'åŸºé‡‘',
      'auctions': 'æ‹å–è®°å½•',
      'inventory': 'ç‰©å“æ¸…å•',
      'emails': 'é‚®ä»¶',
      'watchTogetherPlaylist': 'è§‚å½±æ’­æ”¾åˆ—è¡¨'
    };

    let foundData = false;
    for (const key in contentSummary) {
      if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
        const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
        const li = document.createElement('li');
        li.textContent = `${contentSummary[key]}: ${count} æ¡/ä¸ª`;
        listEl.appendChild(li);
        foundData = true;
      }
    }

    if (!foundData) {
      listEl.innerHTML = '<li>æœªåœ¨æ­¤æ–‡ä»¶ä¸­æ‰¾åˆ°å¯è¯†åˆ«çš„æ•°æ®ã€‚</li>';
    }

   
    document.getElementById('confirm-full-import-btn').onclick = () => {
      modal.classList.remove('visible');
      handleFullImport(pendingBackupData);
    };
    document.getElementById('confirm-selective-import-btn').onclick = () => {
      modal.classList.remove('visible');
      openSelectiveImportModal(pendingBackupData.content);
    };
    document.getElementById('cancel-import-options-btn').onclick = () => {
      modal.classList.remove('visible');
      pendingBackupData = null;
    };

    modal.classList.add('visible');
  }

 
  async function handleFullImport(backupInfo) {
    if (!backupInfo) return;

    const confirmed = await showCustomConfirm(
      'ä¸¥é‡è­¦å‘Šï¼',
      'ã€å®Œå…¨å¯¼å…¥ã€‘å°†åˆ é™¤æ‚¨å½“å‰çš„æ‰€æœ‰æ•°æ®å¹¶æ›¿æ¢ä¸ºå¤‡ä»½æ–‡ä»¶ä¸­çš„å†…å®¹ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><strong>ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</strong>', {
        confirmButtonClass: 'btn-danger',
        confirmText: 'æˆ‘æ˜ç™½ï¼Œè¦†ç›–æ‰€æœ‰æ•°æ®'
      }
    );
    if (!confirmed) {
      pendingBackupData = null;
      return;
    }

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œå®Œå…¨å¯¼å…¥ï¼Œè¯·å‹¿å…³é—­é¡µé¢...");

    try {
      if (backupInfo.type === 'streamed') {
        await importStreamedBackup(backupInfo.content);
      } else if (backupInfo.type === 'legacy') {
        await importLegacyBackup(backupInfo.content);
      } else {
        throw new Error("æœªçŸ¥çš„å¤‡ä»½ç±»å‹ã€‚");
      }

      await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'æ‰€æœ‰æ•°æ®å·²æˆåŠŸæ¢å¤ï¼åº”ç”¨å³å°†åˆ·æ–°ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚');
      try {
            const restoredApiConfig = await db.apiConfig.get('main');
            if (restoredApiConfig) {
                // åŒæ­¥ ImgBB
                if (restoredApiConfig.imgbbApiKey) localStorage.setItem('imgbb-api-key', restoredApiConfig.imgbbApiKey);
                if (restoredApiConfig.imgbbEnable !== undefined) localStorage.setItem('imgbb-enabled', restoredApiConfig.imgbbEnable);
                
                // åŒæ­¥ Minimax
                if (restoredApiConfig.minimaxGroupId) localStorage.setItem('minimax-group-id', restoredApiConfig.minimaxGroupId);
                if (restoredApiConfig.minimaxApiKey) localStorage.setItem('minimax-api-key', restoredApiConfig.minimaxApiKey);
                if (restoredApiConfig.minimaxModel) localStorage.setItem('minimax-model', restoredApiConfig.minimaxModel);
                
                // åŒæ­¥ Catbox
                if (restoredApiConfig.catboxUserHash) localStorage.setItem('catbox-userhash', restoredApiConfig.catboxUserHash);
                if (restoredApiConfig.catboxEnable !== undefined) localStorage.setItem('catbox-enabled', restoredApiConfig.catboxEnable);
                
                // åŒæ­¥ NovelAI
                const novelaiSettings = localStorage.getItem('novelai-settings'); // NovelAIé…ç½®æ¯”è¾ƒç‰¹æ®Šï¼Œé€šå¸¸åœ¨localStorageï¼Œå¦‚æœå¤‡ä»½é‡Œæœ‰ä¹Ÿå¯ä»¥æ¢å¤
                // æ³¨æ„ï¼šä½ çš„ä»£ç ä¼¼ä¹æ²¡æœ‰æŠŠ novelai çš„ key å­˜å…¥ apiConfig è¡¨ï¼Œè€Œæ˜¯ç›´æ¥å­˜ localStorageï¼Œ
                // å¦‚æœä½ çš„å¤‡ä»½é€»è¾‘é‡Œæ²¡æœ‰åŒ…å« localStorage çš„ novelai æ•°æ®ï¼Œå¯¼å…¥åç¡®å®ä¼šä¸¢å¤±ã€‚
                // ä½†è¿™é‡Œæˆ‘ä»¬ä¸»è¦ä¿®å¤ ImgBB/Minimax/Catboxã€‚
            }
            console.log("API é…ç½®å·²å¼ºåˆ¶åŒæ­¥åˆ°æœ¬åœ°ç¼“å­˜ã€‚");
        } catch (e) {
            console.error("åŒæ­¥é…ç½®å¤±è´¥:", e);
        }
      setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
      console.error("å®Œå…¨å¯¼å…¥å¤±è´¥:", error);
      await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶åº”ç”¨å¤±è´¥: ${error.message}`);
    } finally {
      pendingBackupData = null;
    }
  }


  function openSelectiveImportModal(backupDataContent) {
    const modal = document.getElementById('selective-import-modal');
    const listEl = document.getElementById('selective-import-list');
    const selectAllCheckbox = document.getElementById('select-all-import-types');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = true;

    const contentSummary = {
      'chats': 'èŠå¤©ä¼šè¯',
      'worldBooks': 'ä¸–ç•Œä¹¦',
      'worldBookCategories': 'ä¸–ç•Œä¹¦åˆ†ç±»',
      'presets': 'ç¦»çº¿é¢„è®¾',
      'presetCategories': 'é¢„è®¾åˆ†ç±»', 
      'userStickers': 'è¡¨æƒ…åŒ…',
      'stickerCategories': 'è¡¨æƒ…åˆ†ç±»',
      'customAvatarFrames': 'å¤´åƒæ¡†',
      'apiConfig': 'APIé…ç½®',
      'globalSettings': 'å…¨å±€è®¾ç½®',
      'personaPresets': 'äººè®¾é¢„è®¾',
      'qzoneSettings': 'ç©ºé—´è®¾ç½®',
      'qzonePosts': 'åŠ¨æ€',
      'qzoneAlbums': 'ç›¸å†Œ',
      'qzonePhotos': 'ç›¸å†Œç…§ç‰‡',
      'qzoneGroups': 'ç©ºé—´åˆ†ç»„',
      'favorites': 'æ”¶è—',
      'memories': 'å›å¿†',
      'callRecords': 'é€šè¯è®°å½•',
      'shoppingProducts': 'å•†å“',
      'shoppingCategories': 'å•†å“åˆ†ç±»',
      'apiPresets': 'APIé¢„è®¾',
      'renderingRules': 'æ¸²æŸ“è§„åˆ™',
      'appearancePresets': 'å¤–è§‚é¢„è®¾',
      'npcs': 'NPCs',
      'npcGroups': 'NPCåˆ†ç»„',
      'doubanPosts': 'è±†ç“£åŠ¨æ€',
      'stickerVisionCache': 'è¡¨æƒ…ç¼“å­˜',
      'readingLibrary': 'é˜…è¯»åº“',
      'quickReplies': 'å¿«æ·å›å¤',
      'quickReplyCategories': 'å¿«æ·å›å¤åˆ†ç±»',
      'naiPresets': 'NAIé¢„è®¾',
      'grAuthors': 'æ•…äº‹ä½œè€…',
      'grStories': 'æ•…äº‹',
      'userWallet': 'ç”¨æˆ·é’±åŒ…',
      'userTransactions': 'äº¤æ˜“è®°å½•',
      'funds': 'åŸºé‡‘',
      'auctions': 'æ‹å–è®°å½•',
      'inventory': 'ç‰©å“æ¸…å•',
      'emails': 'é‚®ä»¶',
      'watchTogetherPlaylist': 'è§‚å½±æ’­æ”¾åˆ—è¡¨'
    };

    let hasContent = false;
    for (const key in contentSummary) {
      if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
        const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
        const isSingleObject = !Array.isArray(backupDataContent[key]);

        const item = document.createElement('div');
        item.className = 'clear-posts-item selected'; 
        item.dataset.typeId = key;
        item.innerHTML = `
                <div class="checkbox selected"></div>
                <div>
                    <span class="name">${contentSummary[key]} (${count} æ¡/ä¸ª)</span>
                    ${isSingleObject ? '<p style="font-size: 12px; color: #ff8c00; margin: 4px 0 0;">(æ³¨æ„: è¿™å°†ã€è¦†ç›–ã€‘æ‚¨å½“å‰çš„è®¾ç½®)</p>' : ''}
                </div>
            `;
        listEl.appendChild(item);
        hasContent = true;
      }
    }

    if (!hasContent) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">æ–‡ä»¶ä¸­æœªæ‰¾åˆ°å¯åˆå¹¶çš„æ•°æ®ã€‚</p>';
    }

   
    document.getElementById('confirm-merge-import-btn').onclick = () => handleSelectiveImport(pendingBackupData);
    document.getElementById('cancel-selective-import-btn').onclick = () => {
      modal.classList.remove('visible');
      pendingBackupData = null;
    };

    selectAllCheckbox.onchange = (e) => {
      const isChecked = e.target.checked;
      listEl.querySelectorAll('.clear-posts-item').forEach(item => {
        item.classList.toggle('selected', isChecked);
        item.querySelector('.checkbox').classList.toggle('selected', isChecked);
      });
    };

    listEl.onclick = (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
        item.querySelector('.checkbox').classList.toggle('selected');
      }
    };

    modal.classList.add('visible');
  }

  
  async function handleSelectiveImport(backupInfo) {
    if (!backupInfo) return;

    const selectedItems = document.querySelectorAll('#selective-import-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¦åˆå¹¶çš„æ•°æ®ç±»å‹ã€‚");
      return;
    }

    const typesToMerge = Array.from(selectedItems).map(item => item.dataset.typeId);
    const dataToMerge = backupInfo.content;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆå¹¶ï¼Ÿ',
      'è¿™å°†æŠŠæ‚¨é€‰æ‹©çš„æ•°æ®ã€æ·»åŠ å¹¶è¦†ç›–ã€‘åˆ°ç°æœ‰æ•°æ®ä¸­ã€‚åŒIDçš„æ•°æ®å°†è¢«æ›´æ–°ï¼Œæ–°æ•°æ®å°†è¢«æ·»åŠ ã€‚<br><br><strong>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼</strong>', {
        confirmText: 'ç¡®è®¤åˆå¹¶'
      }
    );
    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨åˆå¹¶æ•°æ®ï¼Œè¯·å‹¿å…³é—­é¡µé¢...");

    try {

      await db.transaction('rw', db.tables, async () => {
        for (const type of typesToMerge) {
          const data = dataToMerge[type];
          if (!data) continue;

          const table = db.table(type);
          if (!table) {
            console.warn(`æ‰¾ä¸åˆ°è¡¨: ${type}, è·³è¿‡...`);
            continue;
          }

          if (Array.isArray(data)) {
          
            console.log(`æ­£åœ¨åˆå¹¶ ${data.length} æ¡è®°å½•åˆ° ${type}...`);
            await table.bulkPut(data);
          } else if (typeof data === 'object' && data.id) {
            
            console.log(`æ­£åœ¨åˆå¹¶å•æ¡è®°å½•åˆ° ${type}...`);
            await table.put(data);
          } else if (typeof data === 'object') {
          
            console.log(`æ­£åœ¨åˆå¹¶éæ ‡å¯¹è±¡åˆ° ${type}...`);
            const existingData = await table.toCollection().first() || {};
            const mergedData = {
              ...existingData,
              ...data
            };

          
            if (existingData.id) {
              mergedData.id = existingData.id;
            } else if (type === 'apiConfig' || type === 'qzoneSettings' || type === 'globalSettings' || type === 'musicLibrary' || type === 'userWallet') {
              mergedData.id = 'main';
            }

            await table.put(mergedData);
          }
        }
      });

      await showCustomAlert('åˆå¹¶æˆåŠŸ', 'æ•°æ®å·²æˆåŠŸåˆå¹¶ï¼åº”ç”¨å³å°†åˆ·æ–°ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚');
      setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
      console.error("é€‰æ‹©æ€§å¯¼å…¥å¤±è´¥:", error);
      await showCustomAlert('åˆå¹¶å¤±è´¥', `æ–‡ä»¶åº”ç”¨å¤±è´¥: ${error.message}`);
    } finally {
      pendingBackupData = null;
    }
  }


  async function importLegacyBackup(backupData) {
    try {
      await db.transaction('rw', db.tables, async () => {
        await db.chats.clear();
        await db.worldBooks.clear();

        for (const table of db.tables) {
          await table.clear();
        }

        if (Array.isArray(backupData.chats)) await db.chats.bulkPut(backupData.chats);
        if (Array.isArray(backupData.worldBooks)) await db.worldBooks.bulkPut(backupData.worldBooks);

        if (Array.isArray(backupData.userStickers)) await db.userStickers.bulkPut(backupData.userStickers);
        if (backupData.apiConfig) await db.apiConfig.put(backupData.apiConfig);
        if (backupData.globalSettings) await db.globalSettings.put(backupData.globalSettings);

        if (Array.isArray(backupData.personaPresets)) await db.personaPresets.bulkPut(backupData.personaPresets);
        if (backupData.musicLibrary) await db.musicLibrary.put(backupData.musicLibrary);
        if (backupData.qzoneSettings) await db.qzoneSettings.put(backupData.qzoneSettings);
        if (Array.isArray(backupData.qzonePosts)) await db.qzonePosts.bulkPut(backupData.qzonePosts);
        if (Array.isArray(backupData.qzoneAlbums)) await db.qzoneAlbums.bulkPut(backupData.qzoneAlbums);
        if (Array.isArray(backupData.qzonePhotos)) await db.qzonePhotos.bulkPut(backupData.qzonePhotos);
        if (Array.isArray(backupData.favorites)) await db.favorites.bulkPut(backupData.favorites);
        if (Array.isArray(backupData.qzoneGroups)) await db.qzoneGroups.bulkPut(backupData.qzoneGroups);
        if (Array.isArray(backupData.memories)) await db.memories.bulkPut(backupData.memories);
        if (Array.isArray(backupData.worldBookCategories)) await db.worldBookCategories.bulkPut(backupData.worldBookCategories);
        if (Array.isArray(backupData.apiPresets)) await db.apiPresets.bulkPut(backupData.apiPresets);
        if (Array.isArray(backupData.shoppingProducts)) await db.shoppingProducts.bulkPut(backupData.shoppingProducts);
        if (Array.isArray(backupData.callRecords)) await db.callRecords.bulkPut(backupData.callRecords);
        if (Array.isArray(backupData.renderingRules)) await db.renderingRules.bulkPut(backupData.renderingRules);
        if (Array.isArray(backupData.doubanPosts)) await db.doubanPosts.bulkPut(backupData.doubanPosts);
        if (Array.isArray(backupData.stickerCategories)) await db.stickerCategories.bulkPut(backupData.stickerCategories);
        if (Array.isArray(backupData.appearancePresets)) await db.appearancePresets.bulkPut(backupData.appearancePresets);
        if (Array.isArray(backupData.presets)) await db.presets.bulkPut(backupData.presets);
        if (Array.isArray(backupData.presetCategories)) await db.presetCategories.bulkPut(backupData.presetCategories);
        if (Array.isArray(backupData.npcs)) await db.npcs.bulkPut(backupData.npcs);

        // æ–°å¢çš„è¡¨
        if (Array.isArray(backupData.stickerVisionCache)) await db.stickerVisionCache.bulkPut(backupData.stickerVisionCache);
        if (Array.isArray(backupData.shoppingCategories)) await db.shoppingCategories.bulkPut(backupData.shoppingCategories);
        if (Array.isArray(backupData.customAvatarFrames)) await db.customAvatarFrames.bulkPut(backupData.customAvatarFrames);
        if (Array.isArray(backupData.readingLibrary)) await db.readingLibrary.bulkPut(backupData.readingLibrary);
        if (Array.isArray(backupData.quickReplies)) await db.quickReplies.bulkPut(backupData.quickReplies);
        if (Array.isArray(backupData.quickReplyCategories)) await db.quickReplyCategories.bulkPut(backupData.quickReplyCategories);
        if (Array.isArray(backupData.npcGroups)) await db.npcGroups.bulkPut(backupData.npcGroups);
        if (Array.isArray(backupData.naiPresets)) await db.naiPresets.bulkPut(backupData.naiPresets);
        if (Array.isArray(backupData.grAuthors)) await db.grAuthors.bulkPut(backupData.grAuthors);
        if (Array.isArray(backupData.grStories)) await db.grStories.bulkPut(backupData.grStories);
        if (backupData.userWallet) await db.userWallet.put(backupData.userWallet);
        if (Array.isArray(backupData.userTransactions)) await db.userTransactions.bulkPut(backupData.userTransactions);
        if (Array.isArray(backupData.funds)) await db.funds.bulkPut(backupData.funds);
        if (Array.isArray(backupData.auctions)) await db.auctions.bulkPut(backupData.auctions);
        if (Array.isArray(backupData.inventory)) await db.inventory.bulkPut(backupData.inventory);
        if (Array.isArray(backupData.emails)) await db.emails.bulkPut(backupData.emails);
        if (Array.isArray(backupData.watchTogetherPlaylist)) await db.watchTogetherPlaylist.bulkPut(backupData.watchTogetherPlaylist);
      });
    } catch (error) {
      throw new Error(`æ—§ç‰ˆå¤‡ä»½æ•°æ®å†™å…¥æ•°æ®åº“å¤±è´¥: ${error.message}`);
    }
  }


  function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
      dynamicFontStyle.innerHTML = '';
      document.getElementById('font-preview').style.fontFamily = '';
      return;
    }
    const fontName = 'custom-user-font';
    const newStyle = `
                        @font-face {
                          font-family: '${fontName}';
                          src: url('${fontUrl}');
                          font-display: swap;
                        }`;
    if (isPreviewOnly) {
      const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
      previewStyle.id = 'preview-font-style';
      previewStyle.innerHTML = newStyle;
      if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
      document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
      dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                            }`;
    }
  }

  async function resetToDefaultFont() {
    dynamicFontStyle.innerHTML = '';
    state.globalSettings.fontUrl = '';
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('font-url-input').value = '';
    document.getElementById('font-preview').style.fontFamily = '';
    alert('å·²æ¢å¤é»˜è®¤å­—ä½“ã€‚');
  }


  async function loadAllDataFromDB() {
    const [
      chatsArr, apiConfig, loadedGlobalSettings, userStickers, worldBooks,
      musicLib, personaPresets, qzoneSettings, initialFavorites,
      allMemories,

      allPresets,
      allQuickReplies
    ] = await Promise.all([
      db.chats.toArray(), db.apiConfig.get('main'), db.globalSettings.get('main'),
      db.userStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get('main'),
      db.personaPresets.toArray(), db.qzoneSettings.get('main'), db.favorites.orderBy('timestamp').reverse().toArray(),
      db.memories.toArray(),

      db.presets.toArray(),
      db.quickReplies.toArray()
    ]);


    state.presets = allPresets || [];
    state.quickReplies = allQuickReplies || [];
    await initUserWallet(); 
    const defaultGlobalSettings = {
      id: 'main',
      showStatusBar: false,
      wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
      fontUrl: '',
      enableThoughts: false,              // æ–°å¢ï¼šå…¨å±€å¿ƒå£°å¼€å…³ï¼Œé»˜è®¤å…³é—­
      enableQzoneActions: false,          // æ–°å¢ï¼šå…¨å±€åŠ¨æ€å¼€å…³ï¼Œé»˜è®¤å…³é—­
      enableViewMyPhone: false,           // æ–°å¢ï¼šå…¨å±€æŸ¥çœ‹Useræ‰‹æœºå¼€å…³ï¼Œé»˜è®¤å…³é—­
      enableBackgroundActivity: false,
      backgroundActivityInterval: 60,
      blockCooldownHours: 1,
      apiTemperature: 0.8,
      appIcons: {
        ...DEFAULT_APP_ICONS
      },
      cphoneWallpaper: 'linear-gradient(135deg, #f6d365, #fda085)',
      cphoneAppIcons: {
        ...DEFAULT_CPHONE_ICONS
      },
      myphoneAppIcons: {
        ...DEFAULT_MYPHONE_ICONS
      },
      globalCss: '',
      notificationSoundUrl: '',
      widgetData: {},
      globalChatBackground: '',
      enableAiDrawing: true,
      showPhoneFrame: false,
      lockScreenEnabled: false,
      lockScreenPassword: '',
      lockScreenWallpaper: '',
      alwaysShowMusicIsland: false,
      detachStatusBar: false,
      enableMinimalChatUI: false,
      chatActionButtonsOrder: null,
      shoppingCategoryCount: 3,
      shoppingProductCount: 8,
      chatRenderWindow: 50,
      systemNotification: {
        enabled: false,
        appName: 'EPhone',
        notifyInChatPage: false,  // åœ¨èŠå¤©é¡µé¢ä¹Ÿå‘é€é€šçŸ¥
        disableInternalNotification: false,  // ç¦ç”¨å†…éƒ¨å¼¹çª—
        pushServer: {
          enabled: false,
          serverUrl: '',
          apiKey: ''
        },
        vibration: {
          enabled: false,
          pattern: 'short'
        },
        sound: {
          enabled: false,
          useGlobalSound: true,
          customSoundUrl: ''
        }
      },
    };
    state.globalSettings = {
      ...defaultGlobalSettings,
      ...(loadedGlobalSettings || {})
    };
    
    // ç¡®ä¿ systemNotification é…ç½®å®Œæ•´
    if (!state.globalSettings.systemNotification) {
      state.globalSettings.systemNotification = defaultGlobalSettings.systemNotification;
    } else {
      state.globalSettings.systemNotification = {
        ...defaultGlobalSettings.systemNotification,
        ...state.globalSettings.systemNotification,
        pushServer: {
          ...defaultGlobalSettings.systemNotification.pushServer,
          ...(state.globalSettings.systemNotification.pushServer || {})
        },
        vibration: {
          ...defaultGlobalSettings.systemNotification.vibration,
          ...(state.globalSettings.systemNotification.vibration || {})
        },
        sound: {
          ...defaultGlobalSettings.systemNotification.sound,
          ...(state.globalSettings.systemNotification.sound || {})
        }
      };
    }
    
    state.globalSettings.appIcons = {
      ...defaultGlobalSettings.appIcons,
      ...(state.globalSettings.appIcons || {})
    };
    state.globalSettings.cphoneAppIcons = {
      ...defaultGlobalSettings.cphoneAppIcons,
      ...(state.globalSettings.cphoneAppIcons || {})
    };
    state.globalSettings.myphoneAppIcons = {
      ...defaultGlobalSettings.myphoneAppIcons,
      ...(state.globalSettings.myphoneAppIcons || {})
    };

    chatsArr.forEach(chat => {
      if (typeof chat.settings.enableTimePerception === 'undefined') {
        chat.settings.enableTimePerception = true;
      }
      if (!chat.settings.lyricsPosition) {
        chat.settings.lyricsPosition = {
          vertical: 'top',
          horizontal: 'center',
          offset: 10
        };
      }
      if (!chat.isGroup && !chat.settings.myAvatarLibrary) {
        chat.settings.myAvatarLibrary = [];
      }
      if (!chat.isGroup && typeof chat.originalName === 'undefined') {
        chat.originalName = chat.name;
      }
    });
    state.chats = chatsArr.reduce((acc, chat) => {
      if (typeof chat.unreadCount === 'undefined') chat.unreadCount = 0;
      if (chat.isGroup) {
        if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
          chat.settings.enableBackgroundActivity = true;
        }
        if (chat.members && chat.members.length > 0 && chat.members[0].name) {
          chat.members.forEach(member => {
            if (typeof member.originalName === 'undefined') {
              member.originalName = member.name;
              member.groupNickname = member.name;
              delete member.name;
            }
          });
        }
      }
      if (!chat.settings) chat.settings = {};
      if (typeof chat.settings.actionCooldownMinutes === 'undefined') {
        chat.settings.actionCooldownMinutes = 10;
      }
      if (!chat.isGroup && !chat.status) chat.status = {
        text: 'åœ¨çº¿',
        lastUpdate: Date.now(),
        isBusy: false
      };
      // åˆå§‹åŒ–USERçŠ¶æ€
      if (!chat.settings.userStatus) chat.settings.userStatus = {
        text: 'åœ¨çº¿',
        lastUpdate: Date.now(),
        isBusy: false
      };
      if (!chat.isGroup && !chat.relationship) chat.relationship = {
        status: 'friend',
        blockedTimestamp: null,
        applicationReason: ''
      };
      if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {};
        chat.settings.aiAvatarLibrary = [];
      }
      if (chat.isGroup) {
        (chat.members || []).forEach(member => {
          if (typeof member.avatarFrame === 'undefined') member.avatarFrame = '';
        });
      }
      if (!chat.musicData) chat.musicData = {
        totalTime: 0
      };
      if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
        chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
        delete chat.settings.linkedWorldBookId;
      }
      if (typeof chat.isPinned === 'undefined') chat.isPinned = false;
      if (!chat.isGroup && typeof chat.settings.myNickname === 'undefined') {
        chat.settings.myNickname = 'æˆ‘';
      }
      if (chat.isGroup && chat.members) {
        let needsUpdate = false;
        chatsArr.forEach(c => {
          if (c.id === chat.id && c.originalName) {
            delete c.originalName;
          }
        });
        chat.members.forEach(member => {
          const originalCharacter = chatsArr.find(c => c.id === member.id);
          if (originalCharacter && originalCharacter.settings) {
            const correctFrame = originalCharacter.settings.aiAvatarFrame || '';
            if (member.avatarFrame !== correctFrame) {
              member.avatarFrame = correctFrame;
              needsUpdate = true;
            }
          } else if (typeof member.avatarFrame === 'undefined') {
            member.avatarFrame = '';
            needsUpdate = true;
          }
        });
        if (needsUpdate) db.chats.put(chat);
      }
      if (!chat.settings.enableAutoMemory) chat.settings.enableAutoMemory = false;
      if (!chat.settings.autoMemoryInterval) chat.settings.autoMemoryInterval = 20;
      if (!chat.longTermMemory) chat.longTermMemory = [];
      if (!chat.lastMemorySummaryTimestamp) chat.lastMemorySummaryTimestamp = 0;
      if (!chat.isGroup) {
        if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
          chat.settings.enableBackgroundActivity = true;
        }
        if (typeof chat.settings.enableTts === 'undefined') {
          chat.settings.enableTts = false;
        }
        if (!chat.status) chat.status = {
          text: 'åœ¨çº¿',
          lastUpdate: Date.now(),
          isBusy: false
        };
        // åˆå§‹åŒ–USERçŠ¶æ€
        if (!chat.settings.userStatus) chat.settings.userStatus = {
          text: 'åœ¨çº¿',
          lastUpdate: Date.now(),
          isBusy: false
        };
        if (!chat.relationship) chat.relationship = {
          status: 'friend',
          blockedTimestamp: null,
          applicationReason: ''
        };
        if (!chat.settings || !chat.settings.aiAvatarLibrary) {
          if (!chat.settings) chat.settings = {};
          chat.settings.aiAvatarLibrary = [];
        }
        if (typeof chat.settings.isOfflineMode === 'undefined') chat.settings.isOfflineMode = false;
        if (typeof chat.settings.offlineMinLength === 'undefined') chat.settings.offlineMinLength = 100;
        if (typeof chat.settings.offlineMaxLength === 'undefined') chat.settings.offlineMaxLength = 300;

        if (typeof chat.settings.injectLatestThought === 'undefined') {
          chat.settings.injectLatestThought = false;
        }

        // æ–°å¢ï¼šåˆå§‹åŒ–å¿ƒå£°å’ŒåŠ¨æ€åŠŸèƒ½å¼€å…³
        if (typeof chat.settings.enableThoughts === 'undefined') {
          chat.settings.enableThoughts = null; // nullè¡¨ç¤ºä½¿ç”¨å…¨å±€è®¾ç½®
        }
        if (typeof chat.settings.enableQzoneActions === 'undefined') {
          chat.settings.enableQzoneActions = null; // nullè¡¨ç¤ºä½¿ç”¨å…¨å±€è®¾ç½®
        }
        if (typeof chat.settings.enableViewMyPhone === 'undefined') {
          chat.settings.enableViewMyPhone = null; // nullè¡¨ç¤ºä½¿ç”¨å…¨å±€è®¾ç½®
        }

        if (typeof chat.heartfeltVoice === 'undefined') chat.heartfeltVoice = '...';
        if (typeof chat.randomJottings === 'undefined') chat.randomJottings = '...';
        if (!Array.isArray(chat.thoughtsHistory)) {
          chat.thoughtsHistory = [];
        }
      }
      if (typeof chat.settings.stickerCategoryIds === 'undefined') {
     
        if (chat.settings.stickerCategoryId) {
         
          chat.settings.stickerCategoryIds = [chat.settings.stickerCategoryId];
        } else {
        
          chat.settings.stickerCategoryIds = [];
        }
        
        delete chat.settings.stickerCategoryId;
      }
      acc[chat.id] = chat;
      return acc;
    }, {});
    const memoriesToUpdate = [];
    allMemories.forEach(memory => {
      if (memory.type === 'ai_generated' && memory.authorName && !memory.authorId) {
        const foundChat = chatsArr.find(c => !c.isGroup && c.originalName === memory.authorName);
        if (foundChat) {
          memory.authorId = foundChat.id;
          memoriesToUpdate.push(memory);
        } else {
          const fallbackChat = chatsArr.find(c => !c.isGroup && c.name === memory.authorName);
          if (fallbackChat) {
            memory.authorId = fallbackChat.id;
            memoriesToUpdate.push(memory);
          }
        }
      }
    });
    if (memoriesToUpdate.length > 0) {
      await db.memories.bulkPut(memoriesToUpdate);
    }
    state.apiConfig = apiConfig || {
      id: 'main',
      proxyUrl: '',
      apiKey: '',
      model: '',
      secondaryProxyUrl: '',
      secondaryApiKey: '',
      secondaryModel: '',
      minimaxGroupId: '',
      minimaxApiKey: '',
      minimaxModel: 'speech-01',
      imgbbEnable: false,
      imgbbApiKey: '',
      
        catboxEnable: false,
        catboxUserHash: '',
        githubEnable: false, // é»˜è®¤ä¸ºå…³é—­
       githubAutoBackup: false,
      githubUsername: '',
      githubRepo: '',
      githubToken: '',
      githubFilename: 'ephone_backup.json'
    };
    if (localStorage.getItem('imgbb-enabled') !== null) {
        state.apiConfig.imgbbEnable = localStorage.getItem('imgbb-enabled') === 'true';
    }
    if (localStorage.getItem('imgbb-api-key') !== null) {
        state.apiConfig.imgbbApiKey = localStorage.getItem('imgbb-api-key');
    }
    if (localStorage.getItem('catbox-enabled') !== null) {
        state.apiConfig.catboxEnable = localStorage.getItem('catbox-enabled') === 'true';
    }
    if (localStorage.getItem('catbox-userhash') !== null) {
        state.apiConfig.catboxUserHash = localStorage.getItem('catbox-userhash');
    }
   if (localStorage.getItem('minimax-group-id') !== null) {
        state.apiConfig.minimaxGroupId = localStorage.getItem('minimax-group-id');
    }
    if (localStorage.getItem('minimax-api-key') !== null) {
        state.apiConfig.minimaxApiKey = localStorage.getItem('minimax-api-key');
    }
    if (localStorage.getItem('minimax-model') !== null) {
        state.apiConfig.minimaxModel = localStorage.getItem('minimax-model');
    }
    if (localStorage.getItem('github-proxy-enabled') !== null) {
        state.apiConfig.githubProxyEnable = localStorage.getItem('github-proxy-enabled') === 'true';
    }
    if (localStorage.getItem('github-proxy-url') !== null) {
        state.apiConfig.githubProxyUrl = localStorage.getItem('github-proxy-url');
    }
    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || {
      id: 'main',
      nickname: '{{user}}',
      avatar: 'https://files.catbox.moe/q6z5fc.jpeg',
      banner: 'https://files.catbox.moe/r5heyt.gif'
    };
    allFavoriteItems = initialFavorites || [];
  }


  async function saveGlobalPlaylist() {
    await db.musicLibrary.put({
      id: 'main',
      playlist: musicState.playlist
    });
  }

  function formatTimestamp(timestamp, chatId = null) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    
    // åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºç§’æ•°
    let showSeconds = false;
    
    // å¦‚æœæä¾›äº† chatIdï¼Œæ£€æŸ¥å•ä¸ªè§’è‰²è®¾ç½®ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
    if (chatId && state.chats[chatId] && state.chats[chatId].settings) {
      if (state.chats[chatId].settings.showSeconds !== undefined) {
        showSeconds = state.chats[chatId].settings.showSeconds;
      } else {
        // å¦‚æœè§’è‰²æ²¡æœ‰å•ç‹¬è®¾ç½®ï¼Œä½¿ç”¨å…¨å±€è®¾ç½®
        showSeconds = state.globalSettings.showSeconds || false;
      }
    } else {
      // æ²¡æœ‰ chatId æ—¶ï¼Œä½¿ç”¨å…¨å±€è®¾ç½®
      showSeconds = state.globalSettings.showSeconds || false;
    }
    
    return showSeconds ? `${hours}:${minutes}:${seconds}` : `${hours}:${minutes}`;
  }
  
  function formatTimeAgo(timestamp) {
    const now = Date.now();
    const seconds = Math.floor((now - timestamp) / 1000);

    if (seconds < 60) return 'åˆšåˆš';

    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}åˆ†é’Ÿå‰`;

    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}å°æ—¶å‰`;

    const days = Math.floor(hours / 24);
    if (days < 30) return `${days}å¤©å‰`;

    const months = Math.floor(days / 30);
    if (months < 12) return `å¤§çº¦${months}ä¸ªæœˆå‰`;

    const years = Math.floor(days / 365);
    return `å¤§çº¦${years}å¹´å‰`;
  }

  function formatTimestampForAI(timestamp) {
    if (!timestamp) return '';

    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;


    if (now.toDateString() === date.toDateString()) {
      return `ä»Šå¤© ${timeString}`;
    }


    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
      return `æ˜¨å¤© ${timeString}`;
    }


    if (now.getFullYear() === date.getFullYear()) {
      const month = String(date.getMonth() + 1);
      const day = String(date.getDate());
      return `${month}æœˆ${day}æ—¥ ${timeString}`;
    }


    const year = date.getFullYear();
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    return `${year}å¹´${month}æœˆ${day}æ—¥ ${timeString}`;
  }

// --- æ–°å¢ NAI é¢„è®¾ç›¸å…³å‡½æ•° ---

// 1. åŠ è½½é¢„è®¾ä¸‹æ‹‰èœå•
async function loadNaiPresetsDropdown() {
    const selectEl = document.getElementById('nai-preset-select');
    // ä¿ç•™ç¬¬ä¸€ä¸ªé€‰é¡¹
    selectEl.innerHTML = '<option value="">-- å½“å‰ä¸´æ—¶è®¾ç½® --</option>';
    
    const presets = await db.naiPresets.toArray();
    presets.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        selectEl.appendChild(opt);
    });
    
    // æ¢å¤é€‰ä¸­çŠ¶æ€
    if (currentNaiPresetId) {
        selectEl.value = currentNaiPresetId;
        updateNaiPresetButtons(true);
    } else {
        updateNaiPresetButtons(false);
    }
}

// 2. æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
// 2. æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€ (æ›´æ–°è¿™ä¸ªå‡½æ•°)
function updateNaiPresetButtons(hasSelection) {
    const updateBtn = document.getElementById('update-nai-preset-btn');
    const bindBtn = document.getElementById('bind-nai-preset-btn');
    const deleteBtn = document.getElementById('delete-nai-preset-btn');
    const saveBtn = document.getElementById('save-nai-preset-btn');
    
    if (hasSelection) {
        updateBtn.style.display = 'block';
        bindBtn.style.display = 'block';
        deleteBtn.style.display = 'block';
        // æ”¹åŠ¨ï¼šé€‰ä¸­çŠ¶æ€ä¸‹æ˜¾ç¤º"å¦å­˜" (2ä¸ªå­—)
        saveBtn.textContent = 'å¦å­˜';
    } else {
        updateBtn.style.display = 'none';
        bindBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
        // æ”¹åŠ¨ï¼šæœªé€‰ä¸­çŠ¶æ€ä¸‹æ˜¾ç¤º"æ–°å¢" (2ä¸ªå­—)
        saveBtn.textContent = 'æ–°å¢';
    }
}

// 3. æ”¶é›†å½“å‰ç•Œé¢ä¸Šçš„æ‰€æœ‰è®¾ç½®
function gatherNaiUiSettings() {
    return {
      resolution: document.getElementById('nai-resolution').value,
      steps: parseInt(document.getElementById('nai-steps').value),
      cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
      sampler: document.getElementById('nai-sampler').value,
      seed: parseInt(document.getElementById('nai-seed').value),
      uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
      quality_toggle: document.getElementById('nai-quality-toggle').checked,
      smea: document.getElementById('nai-smea').checked,
      smea_dyn: document.getElementById('nai-smea-dyn').checked,
      default_positive: document.getElementById('nai-default-positive').value,
      default_negative: document.getElementById('nai-default-negative').value,
      // æ³¨æ„ï¼šAPI Key å’Œ Proxy è¿™ç§æ•æ„Ÿ/å…¨å±€é…ç½®é€šå¸¸ä¸å­˜å…¥é£æ ¼é¢„è®¾ï¼Œä½†ä½ å¯ä»¥æ ¹æ®éœ€æ±‚å†³å®š
      // è¿™é‡Œä¸ºäº†é£æ ¼åˆ‡æ¢æ–¹ä¾¿ï¼Œæˆ‘ä»¬åªå­˜å‚æ•°ï¼ŒKey å’Œ Proxy è¿˜æ˜¯èµ°å…¨å±€
    };
}

// 4. åº”ç”¨è®¾ç½®åˆ° UI
function applyNaiUiSettings(settings) {
    if (!settings) return;
    document.getElementById('nai-resolution').value = settings.resolution || '1024x1024';
    document.getElementById('nai-steps').value = settings.steps || 28;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale || 5;
    document.getElementById('nai-sampler').value = settings.sampler || 'k_euler_ancestral';
    document.getElementById('nai-seed').value = settings.seed ?? -1;
    document.getElementById('nai-uc-preset').value = settings.uc_preset || 1;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle !== false;
    document.getElementById('nai-smea').checked = settings.smea !== false;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn || false;
    document.getElementById('nai-default-positive').value = settings.default_positive || '';
    document.getElementById('nai-default-negative').value = settings.default_negative || '';
}

// 5. ä¿å­˜/æ–°å»ºé¢„è®¾
async function handleSaveNaiPreset(isUpdate = false) {
    const settings = gatherNaiUiSettings();
    
    if (isUpdate && currentNaiPresetId) {
        const confirmed = await showCustomConfirm("æ›´æ–°é¢„è®¾", "ç¡®å®šè¦è¦†ç›–å½“å‰é¢„è®¾çš„å‚æ•°å—ï¼Ÿ");
        if (!confirmed) return;
        
        await db.naiPresets.update(parseInt(currentNaiPresetId), { settings });
        alert("é¢„è®¾å·²æ›´æ–°ï¼");
    } else {
        const name = await showCustomPrompt("æ–°å»ºé¢„è®¾", "è¯·è¾“å…¥é¢„è®¾åç§°ï¼ˆä¾‹å¦‚ï¼šåšæ¶‚é£ã€åƒç´ é£ï¼‰");
        if (!name) return;
        
        const id = await db.naiPresets.add({ name, settings });
        currentNaiPresetId = id;
        await loadNaiPresetsDropdown();
        alert("é¢„è®¾å·²åˆ›å»ºï¼");
    }
}

// 6. åˆ é™¤é¢„è®¾
async function handleDeleteNaiPreset() {
    if (!currentNaiPresetId) return;
    const confirmed = await showCustomConfirm("åˆ é™¤é¢„è®¾", "ç¡®å®šè¦åˆ é™¤æ­¤é¢„è®¾å—ï¼Ÿç»‘å®šäº†æ­¤é¢„è®¾çš„è§’è‰²å°†å›é€€åˆ°å…¨å±€è®¾ç½®ã€‚", { confirmButtonClass: 'btn-danger' });
    if (!confirmed) return;
    
    await db.naiPresets.delete(parseInt(currentNaiPresetId));
    
    // æ¸…é™¤æ‰€æœ‰èŠå¤©ä¸­çš„ç»‘å®šå¼•ç”¨
    const allChats = await db.chats.toArray();
    for (const chat of allChats) {
        if (chat.settings?.naiPresetId === parseInt(currentNaiPresetId)) {
            delete chat.settings.naiPresetId;
            await db.chats.put(chat);
        }
    }
    
    currentNaiPresetId = null;
    await loadNaiPresetsDropdown();
}

// 7. å¤„ç†ä¸‹æ‹‰æ¡†åˆ‡æ¢
async function handleNaiPresetChange(e) {
    const val = e.target.value;
    if (val) {
        currentNaiPresetId = parseInt(val);
        const preset = await db.naiPresets.get(currentNaiPresetId);
        if (preset && preset.settings) {
            applyNaiUiSettings(preset.settings);
        }
        updateNaiPresetButtons(true);
    } else {
        currentNaiPresetId = null;
        updateNaiPresetButtons(false);
        // æ¢å¤åˆ° localStorage é‡Œçš„å…¨å±€è®¾ç½®
        loadNovelAISettings(); 
    }
}

// 8. æ‰“å¼€ç»‘å®šå¼¹çª—
async function openNaiBindingModal() {
    if (!currentNaiPresetId) return;
    const preset = await db.naiPresets.get(parseInt(currentNaiPresetId));
    if (!preset) return;

    const modal = document.getElementById('nai-binding-modal');
    const listEl = document.getElementById('nai-binding-list');
    const titleEl = modal.querySelector('.modal-header span');
    
    titleEl.textContent = `å°†é¢„è®¾â€œ${preset.name}â€ç»‘å®šåˆ°...`;
    listEl.innerHTML = '';
    
    const allChats = Object.values(state.chats).sort((a, b) => a.name.localeCompare(b.name));
    
    allChats.forEach(chat => {
        const isBound = chat.settings?.naiPresetId === currentNaiPresetId;
        
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; // å¤ç”¨æ ·å¼
        item.innerHTML = `
            <input type="checkbox" class="nai-binding-checkbox" data-chat-id="${chat.id}" ${isBound ? 'checked' : ''} style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <div style="display:flex; flex-direction:column;">
                <span class="name">${chat.name}</span>
                ${isBound ? '<span style="font-size:10px; color:green;">å·²ç»‘å®š</span>' : ''}
            </div>
        `;
        // ç‚¹å‡»è¡Œåˆ‡æ¢
        item.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
                const cb = item.querySelector('input');
                cb.checked = !cb.checked;
            }
        });
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

// 9. ä¿å­˜ç»‘å®š
async function saveNaiBinding() {
    if (!currentNaiPresetId) return;
    
    const checkboxes = document.querySelectorAll('.nai-binding-checkbox');
    const updates = [];
    
    for (const cb of checkboxes) {
        const chatId = cb.dataset.chatId;
        const chat = state.chats[chatId];
        const shouldBind = cb.checked;
        
        if (chat) {
            if (shouldBind) {
                // å¦‚æœå‹¾é€‰ï¼Œç»‘å®šå½“å‰é¢„è®¾
                if (chat.settings.naiPresetId !== currentNaiPresetId) {
                    chat.settings.naiPresetId = currentNaiPresetId;
                    updates.push(chat);
                }
            } else {
                // å¦‚æœå–æ¶ˆå‹¾é€‰ï¼Œä¸”å½“å‰æ­£æ˜¯ç»‘å®šäº†è¿™ä¸ªé¢„è®¾ï¼Œåˆ™è§£ç»‘
                if (chat.settings.naiPresetId === currentNaiPresetId) {
                    delete chat.settings.naiPresetId;
                    updates.push(chat);
                }
            }
        }
    }
    
    if (updates.length > 0) {
        await db.chats.bulkPut(updates);
        await showCustomAlert("ä¿å­˜æˆåŠŸ", `å·²æ›´æ–° ${updates.length} ä¸ªè§’è‰²çš„ç»‘å®šè®¾ç½®ã€‚`);
    } else {
        // æ— å˜åŒ–
    }
    
    document.getElementById('nai-binding-modal').classList.remove('visible');
}
  function loadNovelAISettings() {
    const settings = getNovelAISettings();
    document.getElementById('nai-resolution').value = settings.resolution;
    document.getElementById('nai-steps').value = settings.steps;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale;
    document.getElementById('nai-sampler').value = settings.sampler;
    document.getElementById('nai-seed').value = settings.seed;
    document.getElementById('nai-uc-preset').value = settings.uc_preset;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle;
    document.getElementById('nai-smea').checked = settings.smea;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn;
    document.getElementById('nai-default-positive').value = settings.default_positive;
    document.getElementById('nai-default-negative').value = settings.default_negative;
    document.getElementById('nai-cors-proxy').value = settings.cors_proxy;
    document.getElementById('nai-custom-proxy-url').value = settings.custom_proxy_url || '';

  
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    customProxyGroup.style.display = settings.cors_proxy === 'custom' ? 'block' : 'none';
    loadNaiPresetsDropdown();
  }

  function saveNovelAISettings() {
   
    const novelaiEnabled = document.getElementById('novelai-switch').checked;
    const novelaiModel = document.getElementById('novelai-model').value;
    const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();

    localStorage.setItem('novelai-enabled', novelaiEnabled);
    localStorage.setItem('novelai-model', novelaiModel);
    localStorage.setItem('novelai-api-key', novelaiApiKey);

  
    const settings = {
      resolution: document.getElementById('nai-resolution').value,
      steps: parseInt(document.getElementById('nai-steps').value),
      cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
      sampler: document.getElementById('nai-sampler').value,
      seed: parseInt(document.getElementById('nai-seed').value),
      uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
      quality_toggle: document.getElementById('nai-quality-toggle').checked,
      smea: document.getElementById('nai-smea').checked,
      smea_dyn: document.getElementById('nai-smea-dyn').checked,
      default_positive: document.getElementById('nai-default-positive').value,
      default_negative: document.getElementById('nai-default-negative').value,
      cors_proxy: document.getElementById('nai-cors-proxy').value,
      custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };

    localStorage.setItem('novelai-settings', JSON.stringify(settings));
  }

  function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
    alert('å·²æ¢å¤é»˜è®¤è®¾ç½®ï¼');
  }

  function getNovelAISettings() {
    const defaultSettings = {
      resolution: '1024x1024',
      steps: 28,
      cfg_scale: 5,
      sampler: 'k_euler_ancestral',
      seed: -1,
      uc_preset: 1,
      quality_toggle: true,
      smea: true,
      smea_dyn: false,
      default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
      default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
      cors_proxy: 'https://corsproxy.io/?',
      custom_proxy_url: ''
    };

    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
      try {
        return {
          ...defaultSettings,
          ...JSON.parse(saved)
        };
      } catch (e) {
        return defaultSettings;
      }
    }
    return defaultSettings;
  }

  async function generateNaiImageFromPrompt(aiPrompt, chatId) {
    console.log(`ğŸ¨ [NAIæ ¸å¿ƒç”Ÿæˆ] å¼€å§‹... Prompt: "${aiPrompt}", ChatID: ${chatId}`);

    
    const naiPrompts = getCharacterNAIPrompts(chatId);
    const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
    const finalNegativePrompt = naiPrompts.negative;

    console.log(`ğŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
    console.log('   [+] æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
    console.log('   [-] æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);

    const apiKey = localStorage.getItem('novelai-api-key');
    const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    let settings = getNovelAISettings(); // å…ˆè·å–å…¨å±€é»˜è®¤å€¼

    // ã€æ–°å¢é€»è¾‘ã€‘æ£€æŸ¥å½“å‰èŠå¤©æ˜¯å¦ç»‘å®šäº†é¢„è®¾
    if (chatId && state.chats[chatId] && state.chats[chatId].settings.naiPresetId) {
        const presetId = state.chats[chatId].settings.naiPresetId;
        const preset = await db.naiPresets.get(presetId);
        
        if (preset && preset.settings) {
            console.log(`ğŸ¨ [NAI] æ£€æµ‹åˆ°è§’è‰²ç»‘å®šäº†é¢„è®¾ "${preset.name}"ï¼Œæ­£åœ¨åº”ç”¨é¢„è®¾å‚æ•°...`);
            // ç”¨é¢„è®¾å‚æ•°è¦†ç›–å…¨å±€å‚æ•° (Object.assign æ˜¯æµ…æ‹·è´ï¼Œè¿™é‡Œå¤Ÿç”¨äº†)
            // æ³¨æ„ï¼šAPI Key å’Œ Proxy è¿˜æ˜¯ç”¨å…¨å±€çš„ï¼Œå› ä¸ºé¢„è®¾é‡Œæ²¡å­˜
            settings = { ...settings, ...preset.settings };
            
            // å¦‚æœé¢„è®¾é‡Œæœ‰æç¤ºè¯ï¼Œåˆå¹¶é€»è¾‘å¯èƒ½éœ€è¦è°ƒæ•´
            // å½“å‰é€»è¾‘æ˜¯ï¼šfinalPositive = aiPrompt + characterPrompt + defaultPositive
            // å¦‚æœä½¿ç”¨äº†é¢„è®¾ï¼Œpreset.settings.default_positive ä¼šæ›¿æ¢æ‰ getNovelAISettings() é‡Œçš„ default_positive
            // è¿™ç¬¦åˆé¢„æœŸï¼šé¢„è®¾çš„â€œé»˜è®¤æç¤ºè¯â€å˜æˆäº†è¯¥é£æ ¼çš„æç¤ºè¯
        } else {
             console.warn(`[NAI] è§’è‰²ç»‘å®šäº†é¢„è®¾ID ${presetId}ï¼Œä½†æ•°æ®åº“ä¸­æœªæ‰¾åˆ°ï¼Œå°†ä½¿ç”¨å…¨å±€è®¾ç½®ã€‚`);
        }
    }

    if (!apiKey) {
      throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
    }

    const [width, height] = settings.resolution.split('x').map(Number);

    
    let requestBody;
    if (model.includes('nai-diffusion-4')) {
      requestBody = {
        input: finalPositivePrompt,
        model: model,
        action: 'generate',
        parameters: {
          params_version: 3,
          width: width,
          height: height,
          scale: settings.cfg_scale,
          sampler: settings.sampler,
          steps: settings.steps,
          seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
          n_samples: 1,
          ucPreset: settings.uc_preset,
          qualityToggle: settings.quality_toggle,
          add_original_image: true,
          noise_schedule: 'karras',
          v4_prompt: {
            caption: {
              base_caption: finalPositivePrompt,
              char_captions: []
            },
            use_coords: false,
            use_order: true
          },
          v4_negative_prompt: {
            caption: {
              base_caption: finalNegativePrompt,
              char_captions: []
            },
            legacy_uc: false
          },
          negative_prompt: finalNegativePrompt,
          autoSmea: false,
          dynamic_thresholding: false,
          controlnet_strength: 1,
          legacy: false,
          cfg_rescale: 0,
          legacy_v3_extend: false,
          skip_cfg_above_sigma: null,
          use_coords: false,
          legacy_uc: false,
          normalize_reference_strength_multiple: true,
          inpaintImg2ImgStrength: 1,
          characterPrompts: [],
          deliberate_euler_ancestral_bug: false,
          prefer_brownian: true
        }
      };
    } else {
     
      requestBody = {
        input: finalPositivePrompt,
        model: model,
        action: 'generate',
        parameters: {
          width: width,
          height: height,
          scale: settings.cfg_scale,
          sampler: settings.sampler,
          steps: settings.steps,
          seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
          n_samples: 1,
          ucPreset: settings.uc_preset,
          qualityToggle: settings.quality_toggle,
          sm: settings.smea,
          sm_dyn: settings.smea_dyn,
          negative_prompt: finalNegativePrompt,
          dynamic_thresholding: false,
          controlnet_strength: 1,
          legacy: false,
          add_original_image: false,
          cfg_rescale: 0,
          noise_schedule: 'native'
        }
      };
    }

    console.log('ğŸš€ å‘é€NAIè¯·æ±‚:', requestBody);

  
    let apiUrl;
    if (model.includes('nai-diffusion-4')) {
      apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
    } else {
      apiUrl = 'https://image.novelai.net/ai/generate-image';
    }

    let corsProxy = settings.cors_proxy;
    if (corsProxy === 'custom') {
      corsProxy = settings.custom_proxy_url || '';
    }
    if (corsProxy && corsProxy !== '') {
      apiUrl = corsProxy + apiUrl;
    }

   
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
    }

    const contentType = response.headers.get('content-type');
    let zipBlob;
    let imageDataUrl;

  
    if (contentType && contentType.includes('text/event-stream')) {
    
      const text = await response.text();
      const lines = text.trim().split('\n');
      let base64Data = null;

      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
          const dataContent = line.substring(6);
          try {
            const jsonData = JSON.parse(dataContent);
            if (jsonData.event_type === 'final' && jsonData.image) {
              base64Data = jsonData.image;
              break;
            }
            if (jsonData.data) {
              base64Data = jsonData.data;
              break;
            }
            if (jsonData.image) {
              base64Data = jsonData.image;
              break;
            }
          } catch (e) {
            base64Data = dataContent;
            break;
          }
        }
      }
      if (!base64Data) throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');

      const isPNG = base64Data.startsWith('iVBORw0KGgo');
      const isJPEG = base64Data.startsWith('/9j/');

      if (isPNG || isJPEG) {
       
        imageDataUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
      } else {
       
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
        zipBlob = new Blob([bytes]);
      }
    } else {
      
      zipBlob = await response.blob();
    }

 
    if (!imageDataUrl && zipBlob) {
      if (typeof JSZip === 'undefined') throw new Error('JSZipåº“æœªåŠ è½½');

      const zip = await JSZip.loadAsync(zipBlob);
      let imageFile = null;
      for (let filename in zip.files) {
        if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
          imageFile = zip.files[filename];
          break;
        }
      }
      if (!imageFile) throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');

      const imageBlob = await imageFile.async('blob');

   
      imageDataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(imageBlob);
      });
    }

    console.log(`âœ… [NAIæ ¸å¿ƒç”Ÿæˆ] æˆåŠŸï¼`);
    return {
      imageUrl: imageDataUrl,
      fullPrompt: finalPositivePrompt
    };
  }
 
  function getCharacterNAIPrompts(chatId) {
   
    const systemSettings = getNovelAISettings();

  
    if (!chatId || !state.chats[chatId]) {
      console.log('âš ï¸ NAIæç¤ºè¯ï¼šæ²¡æœ‰è§’è‰²ï¼Œä½¿ç”¨ç³»ç»Ÿé…ç½®');
      return {
        positive: systemSettings.default_positive,
        negative: systemSettings.default_negative,
        source: 'system'
      };
    }

    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};

 
    if (naiSettings.promptSource === 'character') {
      console.log('âœ… NAIæç¤ºè¯ï¼šä½¿ç”¨è§’è‰²é…ç½®');
      console.log('   æ­£é¢:', naiSettings.characterPositivePrompt || '(ç©º)');
      console.log('   è´Ÿé¢:', naiSettings.characterNegativePrompt || '(ç©º)');

      return {
        positive: naiSettings.characterPositivePrompt || '',
        negative: naiSettings.characterNegativePrompt || '',
        source: 'character'
      };
    } else {
      console.log('âœ… NAIæç¤ºè¯ï¼šä½¿ç”¨ç³»ç»Ÿé…ç½®');
      console.log('   æ­£é¢:', systemSettings.default_positive || '(ç©º)');
      console.log('   è´Ÿé¢:', systemSettings.default_negative || '(ç©º)');

      return {
        positive: systemSettings.default_positive,
        negative: systemSettings.default_negative,
        source: 'system'
      };
    }
  }


  async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();

    if (!apiKey) {
      alert('è¯·å…ˆé…ç½®NovelAI API Keyï¼');
      return;
    }

    if (!prompt) {
      alert('è¯·è¾“å…¥æç¤ºè¯ï¼');
      return;
    }

    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();

    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');

    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
      const [width, height] = settings.resolution.split('x').map(Number);

     
      let requestBody;

      if (model.includes('nai-diffusion-4')) {
      
        requestBody = {
          input: prompt,
          model: model,
          action: 'generate',
          parameters: {
            params_version: 3, // V4å¿…é¡»ä½¿ç”¨ç‰ˆæœ¬3
            width: width,
            height: height,
            scale: settings.cfg_scale,
            sampler: settings.sampler,
            steps: settings.steps,
            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
            n_samples: 1,
            ucPreset: settings.uc_preset,
            qualityToggle: settings.quality_toggle,
            autoSmea: false,
            dynamic_thresholding: false,
            controlnet_strength: 1,
            legacy: false,
            add_original_image: true,
            cfg_rescale: 0,
            noise_schedule: 'karras', // V4ä½¿ç”¨karras
            legacy_v3_extend: false,
            skip_cfg_above_sigma: null,
            use_coords: false,
            legacy_uc: false,
            normalize_reference_strength_multiple: true,
            inpaintImg2ImgStrength: 1,
            characterPrompts: [],
          
            v4_prompt: {
              caption: {
                base_caption: prompt,
                char_captions: []
              },
              use_coords: false,
              use_order: true
            },
           
            v4_negative_prompt: {
              caption: {
                base_caption: negativePrompt,
                char_captions: []
              },
              legacy_uc: false
            },
            negative_prompt: negativePrompt,
            deliberate_euler_ancestral_bug: false,
            prefer_brownian: true
          
          }
        };
      } else {
       
        requestBody = {
          input: prompt,
          model: model,
          action: 'generate',
          parameters: {
            width: width,
            height: height,
            scale: settings.cfg_scale,
            sampler: settings.sampler,
            steps: settings.steps,
            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
            n_samples: 1,
            ucPreset: settings.uc_preset,
            qualityToggle: settings.quality_toggle,
            sm: settings.smea,
            sm_dyn: settings.smea_dyn,
            dynamic_thresholding: false,
            controlnet_strength: 1,
            legacy: false,
            add_original_image: false,
            cfg_rescale: 0,
            noise_schedule: 'native',
            negative_prompt: negativePrompt
          }
        };
      }

      console.log('ğŸ“¤ å‘é€è¯·æ±‚åˆ° NovelAI API');
      console.log('ğŸ“Š ä½¿ç”¨æ¨¡å‹:', model);
      console.log('ğŸ“‹ è¯·æ±‚ä½“:', JSON.stringify(requestBody, null, 2));

     
      let apiUrl;

   
      if (model.includes('nai-diffusion-4')) {
   
        apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
      } else {
      
        apiUrl = 'https://image.novelai.net/ai/generate-image';
      }

      let corsProxy = settings.cors_proxy;

     
      if (corsProxy === 'custom') {
        corsProxy = settings.custom_proxy_url || '';
      }

      
      if (corsProxy && corsProxy !== '') {
        apiUrl = corsProxy + encodeURIComponent(apiUrl);
      }

   
      const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
      let fetchOptions = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + apiKey
        },
        body: JSON.stringify(requestBody)
      };

     
      if (isChrome) {
        console.log('ğŸ”§ æ£€æµ‹åˆ°Chromeæµè§ˆå™¨ï¼Œå¯ç”¨headerså…¼å®¹æ€§å¤„ç†');
        const cleanHeaders = {};
        for (const [key, value] of Object.entries(fetchOptions.headers)) {
         
          cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
        }
        fetchOptions.headers = cleanHeaders;
      }

      const response = await fetch(apiUrl, fetchOptions);

      console.log('Response status:', response.status);
      console.log('Response headers:', [...response.headers.entries()]);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('APIé”™è¯¯å“åº”:', errorText);
        throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
      }

     
      const contentType = response.headers.get('content-type');
      console.log('Content-Type:', contentType);

    
      let zipBlob;
      if (contentType && contentType.includes('text/event-stream')) {
        console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æ...');
        statusDiv.textContent = 'æ­£åœ¨æ¥æ”¶æµå¼æ•°æ®...';

      
        const text = await response.text();
        console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);

        const lines = text.trim().split('\n');
        let base64Data = null;

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i].trim();
          if (line.startsWith('data: ') && line !== 'data: [DONE]') {
            const dataContent = line.substring(6);

            
            try {
              const jsonData = JSON.parse(dataContent);

            
              if (jsonData.event_type === 'final' && jsonData.image) {
                base64Data = jsonData.image;
                console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                break;
              }

            
              if (jsonData.data) {
                base64Data = jsonData.data;
                console.log('ä» JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                break;
              }
              if (jsonData.image) {
                base64Data = jsonData.image;
                console.log('ä» JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                break;
              }
            } catch (e) {
           
              base64Data = dataContent;
              console.log('ç›´æ¥ä½¿ç”¨ base64 æ•°æ®');
              break;
            }
          }
        }

        if (!base64Data) {
          throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
        }

       
        const isPNG = base64Data.startsWith('iVBORw0KGgo');
        const isJPEG = base64Data.startsWith('/9j/');

        if (isPNG || isJPEG) {
          console.log('âœ… æ£€æµ‹åˆ°ç›´æ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
         
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const imageBlob = new Blob([bytes], {
            type: isPNG ? 'image/png' : 'image/jpeg'
          });
          console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);

          // ç›´æ¥æ˜¾ç¤ºå›¾ç‰‡
          const imageUrl = URL.createObjectURL(imageBlob);
          document.getElementById('nai-result-image').src = imageUrl;
          statusDiv.style.display = 'none';
          resultDiv.style.display = 'block';
          console.log('âœ… å›¾ç‰‡æ˜¾ç¤ºæˆåŠŸï¼ğŸ¨');
          return;
        }

     
        console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        zipBlob = new Blob([bytes]);
        console.log('ZIP Blob å¤§å°:', zipBlob.size);

      } else {
       
        zipBlob = await response.blob();
        console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»å‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
      }

     
      try {
       
        if (typeof JSZip === 'undefined') {
          throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        }

        statusDiv.textContent = 'æ­£åœ¨è§£å‹å›¾ç‰‡...';

        const zip = await JSZip.loadAsync(zipBlob);
        console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));

        let imageFile = null;
        for (let filename in zip.files) {
          if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
            imageFile = zip.files[filename];
            console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
            break;
          }
        }

        if (!imageFile) {
          throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
        }

        const imageBlob = await imageFile.async('blob');
        console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);

        const imageUrl = URL.createObjectURL(imageBlob);
        console.log('ç”Ÿæˆçš„å›¾ç‰‡URL:', imageUrl);

        document.getElementById('nai-result-image').src = imageUrl;
        statusDiv.style.display = 'none';
        resultDiv.style.display = 'block';

      } catch (zipError) {
        console.error('ZIPè§£å‹å¤±è´¥:', zipError);
       
        console.log('å°è¯•ç›´æ¥ä½œä¸ºå›¾ç‰‡æ˜¾ç¤º...');

        if (zipBlob.type.startsWith('image/')) {
          const imageUrl = URL.createObjectURL(zipBlob);
          document.getElementById('nai-result-image').src = imageUrl;
          statusDiv.style.display = 'none';
          resultDiv.style.display = 'block';
        } else {
          throw new Error('å›¾ç‰‡æ ¼å¼å¤„ç†å¤±è´¥: ' + zipError.message);
        }
      }

    } catch (error) {
      console.error('NovelAIç”Ÿæˆå¤±è´¥:', error);
      statusDiv.style.display = 'none';
      errorDiv.style.display = 'block';
      errorDiv.textContent = 'ç”Ÿæˆå¤±è´¥: ' + error.message;
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'ç”Ÿæˆå›¾åƒ';
    }
  }

  function showNotification(chatId, messageContent) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // æ£€æŸ¥æ˜¯å¦ç¦ç”¨å†…éƒ¨å¼¹çª—é€šçŸ¥
    const disableInternalNotification = state.globalSettings.systemNotification?.disableInternalNotification || false;
    
    // å¦‚æœæœªç¦ç”¨å†…éƒ¨å¼¹çª—ï¼Œåˆ™æ˜¾ç¤ºå†…éƒ¨å¼¹çª—
    if (!disableInternalNotification) {
      playNotificationSound();

      clearTimeout(notificationTimeout);

      const bar = document.getElementById('notification-bar');

      document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
      document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
      document.getElementById('notification-content').querySelector('.message').textContent = messageContent;

      bar.classList.remove('visible');

      void bar.offsetWidth;

      bar.classList.add('visible');

      const newBar = bar.cloneNode(true);
      bar.parentNode.replaceChild(newBar, bar);
      newBar.addEventListener('click', () => {
        openChat(chatId);
        newBar.classList.remove('visible');
      });

      notificationTimeout = setTimeout(() => {
        newBar.classList.remove('visible');
      }, 4000);
      updateBackButtonUnreadCount();
    }
    
    // æ–°å¢ï¼šè§¦å‘ç³»ç»Ÿçº§é€šçŸ¥
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] showNotification è¢«è°ƒç”¨:', {
      chatId,
      messageContent,
      systemNotificationEnabled: state.globalSettings.systemNotification?.enabled,
      disableInternalNotification: disableInternalNotification,
      notificationPermission: typeof Notification !== 'undefined' ? Notification.permission : 'N/A'
    });
    
    if (state.globalSettings.systemNotification?.enabled) {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] å‡†å¤‡è°ƒç”¨ handleSystemNotification');
      handleSystemNotification(chatId, messageContent);
    } else {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] ç³»ç»Ÿé€šçŸ¥æœªå¯ç”¨æˆ–é…ç½®ä¸å­˜åœ¨');
    }
  }

  // æ–°å¢ï¼šåœ¨èŠå¤©é¡µé¢ä¹Ÿè§¦å‘ç³»ç»Ÿçº§é€šçŸ¥ï¼ˆå¦‚æœå¯ç”¨äº†ç›¸åº”é€‰é¡¹ï¼‰
  function triggerSystemNotificationInChatPage(chatId, messageContent) {
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†"åœ¨èŠå¤©é¡µé¢ä¹Ÿå‘é€é€šçŸ¥"é€‰é¡¹
    const notifyInChatPage = state.globalSettings.systemNotification?.notifyInChatPage || false;
    
    if (notifyInChatPage && state.globalSettings.systemNotification?.enabled) {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] åœ¨èŠå¤©é¡µé¢è§¦å‘ç³»ç»Ÿçº§é€šçŸ¥:', {
        chatId,
        messageContent
      });
      handleSystemNotification(chatId, messageContent);
    }
  }

  function updateClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', {
      hour: '2-digit',
      minute: '2-digit'
    });
    const dateString = now.toLocaleDateString('zh-CN', {
      weekday: 'long',
      month: 'long',
      day: 'numeric'
    });


    document.getElementById('status-bar-time').textContent = timeString;

  }


 
  function parseAiResponse(content) {
    if (!content) return [{
      type: 'text',
      content: '(AIè¿”å›äº†ç©ºå†…å®¹)'
    }];

    let trimmedContent = content.trim();

   
    const markdownRegex = /```json\s*([\s\S]*?)\s*```/;
    const markdownMatch = trimmedContent.match(markdownRegex);

    if (markdownMatch && markdownMatch[1]) {
    
      trimmedContent = markdownMatch[1].trim();
      console.log("è§£æå™¨ï¼šå·²å¯ç”¨ Markdown æå–æ¨¡å¼ã€‚");
    }

  
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
      try {
        const parsed = JSON.parse(trimmedContent);
        if (Array.isArray(parsed)) {
          console.log("è§£ææˆåŠŸï¼šæ ‡å‡†JSONæ•°ç»„æ ¼å¼ã€‚");
          return parsed;
        }
      } catch (e) {
        console.warn("æ ‡å‡†JSONæ•°ç»„è§£æå¤±è´¥ï¼Œå°†å°è¯•å¼ºåŠ›æå–...");
      }
    }

  
    const startIndex = trimmedContent.indexOf('[');

  
    const lastBraceIndex = trimmedContent.lastIndexOf('}');

    if (startIndex !== -1 && lastBraceIndex !== -1 && lastBraceIndex > startIndex) {

  
      const endIndex = trimmedContent.indexOf(']', lastBraceIndex);

      if (endIndex !== -1) {
        const arrayString = trimmedContent.substring(startIndex, endIndex + 1);
        try {
          const parsed = JSON.parse(arrayString);
          if (Array.isArray(parsed)) {
            console.log("è§£ææˆåŠŸï¼šé€šè¿‡å¼ºåŠ›æå– [ ... } ... ] æ¨¡å¼ã€‚");
            return parsed;
          }
        } catch (e) {
          console.warn("å¼ºåŠ›æå– [ ... } ... ] å¤±è´¥ï¼Œå°†å°è¯•æå–å•ä¸ªå¯¹è±¡...");
        }
      }
    }

 
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
    if (jsonMatches) {
      const results = [];
      for (const match of jsonMatches) {
        try {
          const parsedObject = JSON.parse(match);
          results.push(parsedObject);
        } catch (e) {
          console.warn("è·³è¿‡ä¸€ä¸ªæ— æ•ˆçš„JSONç‰‡æ®µ:", match);
        }
      }

      if (results.length > 0) {
        console.log("è§£ææˆåŠŸï¼šé€šè¿‡å¼ºåŠ›æå– {...} æ¨¡å¼ã€‚");
        return results;
      }
    }

  
    console.error("æ‰€æœ‰è§£ææ–¹æ¡ˆå‡å¤±è´¥ï¼å°†è¿”å›åŸå§‹æ–‡æœ¬ã€‚åŸå§‹å›å¤:", content);
    return [{
      type: 'text',
      content: content
    }];
  }

  function getTimeOfDayGreeting(date = new Date()) {
    const hour = date.getHours();
    if (hour >= 0 && hour < 5) {
      return "å‡Œæ™¨";
    } else if (hour >= 5 && hour < 9) {
      return "æ—©ä¸Š";
    } else if (hour >= 9 && hour < 13) {
      return "ä¸Šåˆ";
    } else if (hour >= 13 && hour < 18) {
      return "ä¸‹åˆ";
    } else if (hour >= 18 && hour < 24) {
      return "æ™šä¸Š";
    }
    return "ç°åœ¨";
  }


  
  async function loadApiPresetsDropdown(forceSelectedId = null) {
    const selectEl = document.getElementById('api-preset-select');
    selectEl.innerHTML = '<option value="current">å½“å‰é…ç½® (æœªä¿å­˜)</option>';

    const presets = await db.apiPresets.toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });

   if (forceSelectedId) { // <--- 2. æ–°å¢è¿™æ®µåˆ¤æ–­é€»è¾‘
        selectEl.value = forceSelectedId;
        return; 
    }
    const currentConfig = state.apiConfig;
    let matchingPresetId = null;
    for (const preset of presets) {

      if (
        preset.proxyUrl === currentConfig.proxyUrl &&
        preset.apiKey === currentConfig.apiKey &&
        preset.model === currentConfig.model &&
        preset.secondaryProxyUrl === currentConfig.secondaryProxyUrl &&
        preset.secondaryApiKey === currentConfig.secondaryApiKey &&
        preset.secondaryModel === currentConfig.secondaryModel &&

        (preset.minimaxGroupId || '') === (currentConfig.minimaxGroupId || '') &&
        (preset.minimaxApiKey || '') === (currentConfig.minimaxApiKey || '') &&
        (preset.minimaxModel || 'speech-01') === (currentConfig.minimaxModel || 'speech-01')
      )

      {
        matchingPresetId = preset.id;
        break;
      }
    }

    if (matchingPresetId) {
      selectEl.value = matchingPresetId;
    } else {
      selectEl.value = 'current';
    }
  }

 
  async function handlePresetSelectionChange() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      return;
    }

    const preset = await db.apiPresets.get(selectedId);
    if (preset) {
      // 1. åŠ è½½é¢„è®¾ (è¿™ä¼šè¦†ç›–å½“å‰çš„ config)
      state.apiConfig = {
        id: 'main',
        proxyUrl: preset.proxyUrl,
        apiKey: preset.apiKey,
        model: preset.model,
        secondaryProxyUrl: preset.secondaryProxyUrl,
        secondaryApiKey: preset.secondaryApiKey,
        secondaryModel: preset.secondaryModel,
        minimaxGroupId: preset.minimaxGroupId,
        minimaxApiKey: preset.minimaxApiKey,
        minimaxModel: preset.minimaxModel
      };

      
      const savedImgbbEnabled = localStorage.getItem('imgbb-enabled');
      const savedImgbbKey = localStorage.getItem('imgbb-api-key');
      const savedCatboxEnabled = localStorage.getItem('catbox-enabled');
      const savedCatboxHash = localStorage.getItem('catbox-userhash');

      if (savedImgbbEnabled !== null) state.apiConfig.imgbbEnable = (savedImgbbEnabled === 'true');
      if (savedImgbbKey !== null) state.apiConfig.imgbbApiKey = savedImgbbKey;
      
      if (savedCatboxEnabled !== null) state.apiConfig.catboxEnable = (savedCatboxEnabled === 'true');
      if (savedCatboxHash !== null) state.apiConfig.catboxUserHash = savedCatboxHash;
      const savedMinimaxGroupId = localStorage.getItem('minimax-group-id');
      const savedMinimaxApiKey = localStorage.getItem('minimax-api-key');
      const savedMinimaxModel = localStorage.getItem('minimax-model');

      if (savedMinimaxGroupId !== null) state.apiConfig.minimaxGroupId = savedMinimaxGroupId;
      if (savedMinimaxApiKey !== null) state.apiConfig.minimaxApiKey = savedMinimaxApiKey;
      if (savedMinimaxModel !== null) state.apiConfig.minimaxModel = savedMinimaxModel;
      const savedGhEnabled = localStorage.getItem('github-enabled');
      const savedGhAuto = localStorage.getItem('github-auto-backup');
      const savedGhInterval = localStorage.getItem('github-backup-interval');
      const savedGhProxyEnabled = localStorage.getItem('github-proxy-enabled');
      const savedGhProxyUrl = localStorage.getItem('github-proxy-url');
      
      // å…³é”®ï¼šè¯»å–è´¦å·ä¿¡æ¯
      const savedGhUsername = localStorage.getItem('github-username');
      const savedGhRepo = localStorage.getItem('github-repo');
      const savedGhToken = localStorage.getItem('github-token');
      const savedGhFilename = localStorage.getItem('github-filename');

      if (savedGhEnabled !== null) state.apiConfig.githubEnable = (savedGhEnabled === 'true');
      if (savedGhAuto !== null) state.apiConfig.githubAutoBackup = (savedGhAuto === 'true');
      if (savedGhInterval !== null) state.apiConfig.githubBackupInterval = parseInt(savedGhInterval);
      if (savedGhProxyEnabled !== null) state.apiConfig.githubProxyEnable = (savedGhProxyEnabled === 'true');
      if (savedGhProxyUrl !== null) state.apiConfig.githubProxyUrl = savedGhProxyUrl;

      if (savedGhUsername !== null) state.apiConfig.githubUsername = savedGhUsername;
      if (savedGhRepo !== null) state.apiConfig.githubRepo = savedGhRepo;
      if (savedGhToken !== null) state.apiConfig.githubToken = savedGhToken;
      if (savedGhFilename !== null) state.apiConfig.githubFilename = savedGhFilename;
      await db.apiConfig.put(state.apiConfig);

      renderApiSettings(selectedId);
      
      // ç¡®ä¿æ‰‹å†™è¾“å…¥æ¡†è¢«æ­£ç¡®å¡«å……
      document.getElementById('model-input').value = preset.model || '';
      document.getElementById('secondary-model-input').value = preset.secondaryModel || '';

      document.getElementById('fetch-models-btn').click();
      if (preset.secondaryProxyUrl && preset.secondaryApiKey) {
        document.getElementById('fetch-secondary-models-btn').click();
      }
      //alert(`å·²åŠ è½½é¢„è®¾ â€œ${preset.name}â€`);
    }
  }

  
  async function saveApiPreset() {
    const name = await showCustomPrompt('ä¿å­˜ API é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;


    const presetData = {
      name: name.trim(),
      proxyUrl: document.getElementById('proxy-url').value.trim(),
      apiKey: document.getElementById('api-key').value.trim(),
      // ä¼˜å…ˆä¿å­˜æ‰‹å†™è¾“å…¥æ¡†çš„å€¼
      model: document.getElementById('model-input').value.trim() || document.getElementById('model-select').value,
      secondaryProxyUrl: document.getElementById('secondary-proxy-url').value.trim(),
      secondaryApiKey: document.getElementById('secondary-api-key').value.trim(),
      // ä¼˜å…ˆä¿å­˜æ‰‹å†™è¾“å…¥æ¡†çš„å€¼
      secondaryModel: document.getElementById('secondary-model-input').value.trim() || document.getElementById('secondary-model-select').value,

      minimaxGroupId: document.getElementById('minimax-group-id').value.trim(),
      minimaxApiKey: document.getElementById('minimax-api-key').value.trim(),
      minimaxModel: document.getElementById('minimax-model-select').value

    };


    const existingPreset = await db.apiPresets.where('name').equals(presetData.name).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${presetData.name}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;
      presetData.id = existingPreset.id;
    }

    await db.apiPresets.put(presetData);
    await loadApiPresetsDropdown();
    alert('API é¢„è®¾å·²ä¿å­˜ï¼');
  }


  async function deleteApiPreset() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('è¯·å…ˆä»ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
      return;
    }

    const preset = await db.apiPresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.apiPresets.delete(selectedId);
      await loadApiPresetsDropdown();
      alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
  }

  function renderApiSettings(forcePresetId = null) {

    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
    document.getElementById('secondary-proxy-url').value = state.apiConfig.secondaryProxyUrl || '';
    document.getElementById('secondary-api-key').value = state.apiConfig.secondaryApiKey || '';
    document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
    document.getElementById('enable-ai-drawing-switch').checked = state.globalSettings.enableAiDrawing;
    
    // æ–°å¢ï¼šè¯»å–å¿ƒå£°å’ŒåŠ¨æ€åŠŸèƒ½å¼€å…³
    document.getElementById('global-enable-thoughts-switch').checked = state.globalSettings.enableThoughts || false;
    document.getElementById('global-enable-qzone-actions-switch').checked = state.globalSettings.enableQzoneActions || false;
    document.getElementById('global-enable-view-myphone-switch').checked = state.globalSettings.enableViewMyPhone || false;
    
    document.getElementById('chat-render-window-input').value = state.globalSettings.chatRenderWindow || 50;
    document.getElementById('chat-list-render-window-input').value = state.globalSettings.chatListRenderWindow || 30;
    const tempSlider = document.getElementById('api-temperature-slider');
    const tempValue = document.getElementById('api-temperature-value');
    const savedTemp = state.globalSettings.apiTemperature || 0.8;
    tempSlider.value = savedTemp;
    tempValue.textContent = savedTemp;
    const savedMinimaxGroupId = localStorage.getItem('minimax-group-id');
    const savedMinimaxApiKey = localStorage.getItem('minimax-api-key');
    const savedMinimaxModel = localStorage.getItem('minimax-model');

    
    if (savedMinimaxGroupId !== null) state.apiConfig.minimaxGroupId = savedMinimaxGroupId;
    if (savedMinimaxApiKey !== null) state.apiConfig.minimaxApiKey = savedMinimaxApiKey;
    if (savedMinimaxModel !== null) state.apiConfig.minimaxModel = savedMinimaxModel;

   
    document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
    document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
    const minimaxSelect = document.getElementById('minimax-model-select');
    if (minimaxSelect) {
        // 1. å¡«å……æ¨¡å‹åˆ—è¡¨ (å·²æ¥å…¥ Minimax å…¨ç³»åˆ—æ¨¡å‹)
        const supportedMinimaxModels = [
            // --- 01 ç³»åˆ— (ç»å…¸) ---
            
            { id: 'speech-01-turbo', name: 'Speech-01 Turbo (å¿«é€Ÿç‰ˆ)' },
            { id: 'speech-01-hd', name: 'Speech-01 HD (é«˜æ¸…ç‰ˆ)' },
            
            
            // --- 02 ç³»åˆ— ---
            
            { id: 'speech-02-turbo', name: 'Speech-02 Turbo' },
            { id: 'speech-02-hd', name: 'Speech-02 HD' },

            // --- 2.x ç³»åˆ— (åŒ…å«æ‚¨è¦çš„ 2.5) ---
            { id: 'speech-2.5-hd-preview', name: 'Speech-2.5 HD (é«˜æ¸…)' },
            { id: 'speech-2.6-turbo', name: 'Speech-2.6 Turbo' },
            { id: 'speech-2.6-hd', name: 'Speech-2.6 HD' },

           
        ];

        minimaxSelect.innerHTML = ''; 
        supportedMinimaxModels.forEach(m => {
            const option = document.createElement('option');
            option.value = m.id;
            option.textContent = m.name;
            minimaxSelect.appendChild(option);
        });
        minimaxSelect.value = state.apiConfig.minimaxModel || 'speech-01';

        // 2. ã€æ–°å¢ã€‘åŠ¨æ€æ’å…¥â€œæ¥å£åŸŸåâ€é€‰æ‹©æ¡† (å¦‚æœè¿˜æ²¡æœ‰çš„è¯)
        

        // 3. ã€æ–°å¢ã€‘å›æ˜¾ä¿å­˜çš„è®¾ç½®
        const domainSelect = document.getElementById('minimax-domain-select');
        if (domainSelect) {
            // ä¼˜å…ˆè¯»å– stateï¼Œæ²¡æœ‰åˆ™è¯»å– localStorageï¼Œé»˜è®¤å›½å†…
            domainSelect.value = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        }
    }

   
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const novelaiApiKey = localStorage.getItem('novelai-api-key') || '';
    document.getElementById('novelai-switch').checked = novelaiEnabled;
    document.getElementById('novelai-model').value = novelaiModel;
    document.getElementById('novelai-api-key').value = novelaiApiKey;
    document.getElementById('novelai-details').style.display = novelaiEnabled ? 'block' : 'none';
    const imgbbEnableSwitch = document.getElementById('imgbb-enable-switch');
    const imgbbApiKeyInput = document.getElementById('imgbb-api-key');
    const imgbbDetailsDiv = document.getElementById('imgbb-settings-details');

   
    const savedImgbbEnabled = localStorage.getItem('imgbb-enabled');
    const savedImgbbKey = localStorage.getItem('imgbb-api-key');

   
    if (savedImgbbEnabled !== null) state.apiConfig.imgbbEnable = (savedImgbbEnabled === 'true');
    if (savedImgbbKey !== null) state.apiConfig.imgbbApiKey = savedImgbbKey;

    if(imgbbEnableSwitch) {
        imgbbEnableSwitch.checked = state.apiConfig.imgbbEnable || false;
        imgbbApiKeyInput.value = state.apiConfig.imgbbApiKey || '';
        imgbbDetailsDiv.style.display = imgbbEnableSwitch.checked ? 'block' : 'none';
    }

    
    const catboxEnableSwitch = document.getElementById('catbox-enable-switch');
    const catboxUserHashInput = document.getElementById('catbox-userhash');
    const catboxDetailsDiv = document.getElementById('catbox-settings-details');

   
    const savedCatboxEnabled = localStorage.getItem('catbox-enabled');
    const savedCatboxHash = localStorage.getItem('catbox-userhash');

    
    if (savedCatboxEnabled !== null) state.apiConfig.catboxEnable = (savedCatboxEnabled === 'true');
    if (savedCatboxHash !== null) state.apiConfig.catboxUserHash = savedCatboxHash;

    if(catboxEnableSwitch) {
        catboxEnableSwitch.checked = state.apiConfig.catboxEnable || false;
        catboxUserHashInput.value = state.apiConfig.catboxUserHash || '';
        catboxDetailsDiv.style.display = catboxEnableSwitch.checked ? 'block' : 'none';
    }
    const ghSwitch = document.getElementById('github-enable-switch');
    const ghDetails = document.getElementById('github-settings-details');

    // ä» localStorage è¯»å–ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¯»å– apiConfig (ä¿æŒä¸€è‡´æ€§)
    const savedGhEnabled = localStorage.getItem('github-enabled');
    if (savedGhEnabled !== null) state.apiConfig.githubEnable = (savedGhEnabled === 'true');

    if (ghSwitch) {
        ghSwitch.checked = state.apiConfig.githubEnable || false;
        
        // æ ¸å¿ƒé€»è¾‘ï¼šæ ¹æ®å¼€å…³çŠ¶æ€å†³å®šæ˜¯å¦æ˜¾ç¤ºè¯¦æƒ…æ¡†
        ghDetails.style.display = ghSwitch.checked ? 'block' : 'none';
        const ghAutoSwitch = document.getElementById('github-auto-backup-switch');
        const ghIntervalInput = document.getElementById('github-backup-interval'); // ã€æ–°å¢ã€‘

        if (ghAutoSwitch) {
            const savedAuto = localStorage.getItem('github-auto-backup');
            ghAutoSwitch.checked = savedAuto !== null ? (savedAuto === 'true') : false;
            
            // ã€æ–°å¢ã€‘å›æ˜¾åˆ†é’Ÿæ•°ï¼Œé»˜è®¤ 30
            const savedInterval = localStorage.getItem('github-backup-interval');
            if (ghIntervalInput) {
                ghIntervalInput.value = savedInterval ? parseInt(savedInterval) : 30;
            }
        }
        // å›æ˜¾è¾“å…¥æ¡†çš„å€¼
        document.getElementById('github-username').value = state.apiConfig.githubUsername || '';
        document.getElementById('github-repo').value = state.apiConfig.githubRepo || '';
        document.getElementById('github-token').value = state.apiConfig.githubToken || '';
        document.getElementById('github-filename').value = state.apiConfig.githubFilename || 'ephone_backup.json';
        const ghProxySwitch = document.getElementById('github-proxy-switch');
        const ghProxyInputDiv = document.getElementById('github-proxy-input-group');
        const ghProxyUrlInput = document.getElementById('github-proxy-url');

        // è¯»å–ä¿å­˜çš„è®¾ç½®
        const savedGhProxyEnabled = localStorage.getItem('github-proxy-enabled');
        const savedGhProxyUrl = localStorage.getItem('github-proxy-url');

        // è®¾ç½®çŠ¶æ€
        state.apiConfig.githubProxyEnable = savedGhProxyEnabled === 'true';
        state.apiConfig.githubProxyUrl = savedGhProxyUrl || '';

        if (ghProxySwitch) {
            ghProxySwitch.checked = state.apiConfig.githubProxyEnable;
            ghProxyInputDiv.style.display = ghProxySwitch.checked ? 'block' : 'none';
            ghProxyUrlInput.value = state.apiConfig.githubProxyUrl || '';

            // ç»‘å®šåˆ‡æ¢äº‹ä»¶ï¼Œæ§åˆ¶è¾“å…¥æ¡†æ˜¾ç¤º
            ghProxySwitch.addEventListener('change', (e) => {
                ghProxyInputDiv.style.display = e.target.checked ? 'block' : 'none';
            });
        }
    }
    
    // å¡«å……æ‰‹å†™è¾“å…¥æ¡†ï¼ˆæ¨¡å‹ï¼‰
    const modelInput = document.getElementById('model-input');
    const secondaryModelInput = document.getElementById('secondary-model-input');
    if (modelInput) {
      modelInput.value = state.apiConfig.model || '';
    }
    if (secondaryModelInput) {
      secondaryModelInput.value = state.apiConfig.secondaryModel || '';
    }
    
    loadApiPresetsDropdown(forcePresetId);
    displayTotalImageSize();
  }

  window.renderApiSettingsProxy = renderApiSettings;



  async function renderNpcListScreen() {
    const listEl = document.getElementById('npc-list');
    listEl.innerHTML = '';

    const npcs = await db.npcs.toArray();

    if (npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•NPCï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’â€œ+â€æ·»åŠ ç¬¬ä¸€ä¸ªå§ï¼</p>';
      return;
    }

    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.npcId = npc.id;

      item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar" style="border-radius: 50%;">
            <div class="info">
                <div class="name-line">
                    <span class="name">${npc.name}</span>
                </div>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;

      item.addEventListener('click', () => openNpcEditor(npc.id));


      addLongPressListener(item, async () => {
        await deleteNpc(npc.id);
      });

      listEl.appendChild(item);
    });
  }


 
  async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    const modal = document.getElementById('npc-editor-modal');
    const titleEl = document.getElementById('npc-editor-title');
    const nameInput = document.getElementById('npc-name-input');
    const personaInput = document.getElementById('npc-persona-input');
    const avatarPreview = document.getElementById('npc-avatar-preview');
    const associationListEl = document.getElementById('npc-association-list');

   
    const groupSelectEl = document.getElementById('npc-group-select');

    const activitySwitch = document.getElementById('npc-background-activity-switch');
    const cooldownInput = document.getElementById('npc-action-cooldown-input');

    associationListEl.innerHTML = '';
    groupSelectEl.innerHTML = '<option value="">-- æœªåˆ†ç»„ --</option>'; 

   
    const npcGroups = await db.npcGroups.toArray();
    npcGroups.forEach(group => {
      const option = document.createElement('option');
      option.value = group.id;
      option.textContent = group.name;
      groupSelectEl.appendChild(option);
    });

  
    associationListEl.innerHTML += `<label><input type="checkbox" value="user"> ${state.qzoneSettings.nickname || 'æˆ‘'} (ç”¨æˆ·)</label>`;
    Object.values(state.chats).filter(c => !c.isGroup).forEach(char => {
      associationListEl.innerHTML += `<label><input type="checkbox" value="${char.id}"> ${char.name} (è§’è‰²)</label>`;
    });

    if (npcId) {
      titleEl.textContent = 'ç¼–è¾‘ NPC';
      const npc = await db.npcs.get(npcId);
      if (npc) {
        nameInput.value = npc.name;
        personaInput.value = npc.persona;
        avatarPreview.src = npc.avatar || defaultGroupMemberAvatar;
        activitySwitch.checked = npc.enableBackgroundActivity !== false;
        cooldownInput.value = npc.actionCooldownMinutes || 15;
        groupSelectEl.value = npc.npcGroupId || ''; 

        if (npc.associatedWith && Array.isArray(npc.associatedWith)) {
          npc.associatedWith.forEach(id => {
            const checkbox = associationListEl.querySelector(`input[value="${id}"]`);
            if (checkbox) checkbox.checked = true;
          });
        }
      }
    } else {
      titleEl.textContent = 'æ·»åŠ  NPC';
      nameInput.value = '';
      personaInput.value = '';
      avatarPreview.src = defaultGroupMemberAvatar;
      activitySwitch.checked = true;
      cooldownInput.value = 15;
      groupSelectEl.value = ''; 

      const userCheckbox = associationListEl.querySelector('input[value="user"]');
      if (userCheckbox) userCheckbox.checked = true;
    }

    modal.classList.add('visible');
  }




  async function saveNpc() {
    const name = document.getElementById('npc-name-input').value.trim();
    const persona = document.getElementById('npc-persona-input').value.trim();
    if (!name || !persona) {
      alert("NPCçš„æ˜µç§°å’Œäººè®¾éƒ½ä¸èƒ½ä¸ºç©ºï¼");
      return;
    }

    const selectedAssociations = Array.from(document.querySelectorAll('#npc-association-list input:checked')).map(cb => cb.value);
    const enableBackgroundActivity = document.getElementById('npc-background-activity-switch').checked;
    const actionCooldownMinutes = parseInt(document.getElementById('npc-action-cooldown-input').value) || 15;

   
    const npcGroupId = parseInt(document.getElementById('npc-group-select').value) || null;

    const npcData = {
      name,
      persona,
      avatar: document.getElementById('npc-avatar-preview').src,
      associatedWith: selectedAssociations,
      enableBackgroundActivity: enableBackgroundActivity,
      actionCooldownMinutes: actionCooldownMinutes,
      npcGroupId: npcGroupId 
    };

    if (editingNpcId) {
      await db.npcs.update(editingNpcId, npcData);
    } else {
      const newNpcId = await db.npcs.add(npcData);
      if (isAddingNpcToGroup && state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        if (chat.isGroup) {
          chat.members.push({
            id: `npc_${newNpcId}`,
            originalName: name,
            groupNickname: name,
            persona: persona,
            avatar: npcData.avatar,
            isNpc: true
          });
          await db.chats.put(chat);
        }
      }
    }

    document.getElementById('npc-editor-modal').classList.remove('visible');

    if (isAddingNpcToGroup) {
      isAddingNpcToGroup = false;
      openMemberManagementScreen();
    } else {
      await renderNpcListScreen();
    }
  }
  async function openNpcGroupManager() {
    await renderNpcGroupsInManager();
    document.getElementById('npc-group-manager-modal').classList.add('visible');
  }


  async function renderNpcGroupsInManager() {
    const listEl = document.getElementById('existing-npc-groups-list');
    const categories = await db.npcGroups.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç»„</p>';
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
        `;
      listEl.appendChild(item);
    });
  }


  async function addNewNpcGroup() {
    const input = document.getElementById('new-npc-group-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('åˆ†ç»„åä¸èƒ½ä¸ºç©ºï¼');
      return;
    }
    const existing = await db.npcGroups.where('name').equals(name).first();
    if (existing) {
      alert(`åˆ†ç»„ "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
      return;
    }
    await db.npcGroups.add({
      name
    });
    input.value = '';
    await renderNpcGroupsInManager();
  }


  async function deleteNpcGroup(groupId) {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      'åˆ é™¤åˆ†ç»„åï¼Œè¯¥ç»„å†…çš„æ‰€æœ‰NPCå°†å˜ä¸ºâ€œæœªåˆ†ç»„â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      }
    );
    if (confirmed) {
      await db.npcGroups.delete(groupId);
      // å°†å±äºè¯¥åˆ†ç»„çš„NPCçš„ npcGroupId è®¾ä¸º null
      await db.npcs.where('npcGroupId').equals(groupId).modify({
        npcGroupId: null
      });
      await renderNpcGroupsInManager();
    }
  }


  async function deleteNpc(npcId) {
    const npc = await db.npcs.get(npcId);
    if (!npc) return;
    const confirmed = await showCustomConfirm('åˆ é™¤NPC', `ç¡®å®šè¦åˆ é™¤NPC â€œ${npc.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.npcs.delete(npcId);
      await renderNpcListScreen();
    }
  }


  let chatListRenderCount = 0;



 
  function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
        <div class="chat-group-header">
            <span class="arrow">â–¼</span>
            <span class="group-name">${group.name}</span>
        </div>
        <div class="chat-group-content"></div>
    `;
    return groupContainer;
  }



 
  function loadMoreChats(sortedItems) {
    const chatListEl = document.getElementById('chat-list');
    const loadMoreBtn = document.getElementById('load-more-chats-btn');
    if (loadMoreBtn) loadMoreBtn.remove();

    const nextSliceStart = chatListRenderCount;
    const nextSliceEnd = chatListRenderCount + CHAT_LIST_RENDER_WINDOW;
    const itemsToAppend = sortedItems.slice(nextSliceStart, nextSliceEnd);


    const fragment = document.createDocumentFragment();
    let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

    itemsToAppend.forEach(item => {
      if (item.type === 'groupHeader') {
        const groupContainer = createChatGroupContainer(item.group);
        fragment.appendChild(groupContainer);
        currentGroupContent = groupContainer.querySelector('.chat-group-content');
      } else if (item.type === 'chatItem') {
        const listItem = createChatListItem(item.chat);
        if (currentGroupContent && item.chat.groupId) {
          currentGroupContent.appendChild(listItem);
        } else {
          fragment.appendChild(listItem);
          currentGroupContent = null;
        }
      }
    });


    chatListEl.appendChild(fragment);
    chatListRenderCount += itemsToAppend.length;

    if (sortedItems.length > chatListRenderCount) {
      appendLoadMoreChatsButton(chatListEl, sortedItems);
    }


    document.querySelectorAll('.chat-group-header').forEach(header => {
      const newHeader = header.cloneNode(true);
      header.parentNode.replaceChild(newHeader, header);
      newHeader.addEventListener('click', () => {
        newHeader.classList.toggle('collapsed');
        newHeader.nextElementSibling.classList.toggle('collapsed');
      });
    });
  }


  async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';


    const allChats = Object.values(state.chats).sort((a, b) => {
      const pinDiff = (b.isPinned || false) - (a.isPinned || false);
      if (pinDiff !== 0) return pinDiff;
      return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });

    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
      chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" æˆ–ç¾¤ç»„å›¾æ ‡æ·»åŠ èŠå¤©</p>';
      return;
    }

    allGroups.forEach(group => {
      const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
      group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);


    sortedChatListItems = [];
    const processedChatIds = new Set();


    allChats.forEach(chat => {
      if (chat.isPinned) {
        sortedChatListItems.push({
          type: 'chatItem',
          chat
        });
        processedChatIds.add(chat.id);
      }
    });


    allGroups.forEach(group => {

      const groupChats = allChats.filter(chat =>
        !chat.isPinned &&
        !chat.isGroup &&
        chat.groupId === group.id
      );


      if (groupChats.length > 0) {
        sortedChatListItems.push({
          type: 'groupHeader',
          group
        });

        groupChats.forEach(chat => {
          sortedChatListItems.push({
            type: 'chatItem',
            chat
          });
          processedChatIds.add(chat.id);
        });
      }
    });


    allChats.forEach(chat => {
      if (!processedChatIds.has(chat.id)) {
        sortedChatListItems.push({
          type: 'chatItem',
          chat
        });
        processedChatIds.add(chat.id);
      }
    });


    chatListRenderCount = 0;
    loadMoreChats();
  }




  function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
                <div class="chat-group-header">
                    <span class="arrow">â–¼</span>
                    <span class="group-name">${group.name}</span>
                </div>
                <div class="chat-group-content"></div>
            `;
    return groupContainer;
  }

  function appendLoadMoreChatsButton(container, sortedItems) {
    const button = document.createElement('button');
    button.id = 'load-more-chats-btn';
    button.textContent = 'åŠ è½½æ›´æ—©çš„ä¼šè¯';
    button.className = 'load-more-btn';


    button.addEventListener('click', () => loadMoreChats(sortedItems), {
      once: true
    });

    container.prepend(button);
  }


  function loadMoreChats() {
    if (isLoadingMoreChats) return;

    const chatListEl = document.getElementById('chat-list');
    const scrollContainer = document.getElementById('messages-view');
    if (!chatListEl || !scrollContainer) return;
    if (chatListRenderCount >= sortedChatListItems.length) return;

    isLoadingMoreChats = true;


    const isInitialLoad = chatListRenderCount === 0;


    const renderContent = () => {
      hideLoader(chatListEl);

      const renderWindow = state.globalSettings.chatListRenderWindow || 30;
      const nextSliceStart = chatListRenderCount;
      const nextSliceEnd = chatListRenderCount + renderWindow;
      const itemsToAppend = sortedChatListItems.slice(nextSliceStart, nextSliceEnd);

      const fragment = document.createDocumentFragment();
      let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

      itemsToAppend.forEach(item => {
        if (item.type === 'groupHeader') {
          const groupContainer = createChatGroupContainer(item.group);
          fragment.appendChild(groupContainer);
          currentGroupContent = groupContainer.querySelector('.chat-group-content');
        } else if (item.type === 'chatItem') {
          const listItem = createChatListItem(item.chat);
          if (item.chat.groupId && currentGroupContent) {
            currentGroupContent.appendChild(listItem);
          } else {
            fragment.appendChild(listItem);
            if (!item.chat.groupId) currentGroupContent = null;
          }
        }
      });

      chatListEl.appendChild(fragment);
      chatListRenderCount += itemsToAppend.length;

      chatListEl.querySelectorAll('.chat-group-header:not([data-has-listener="true"])').forEach(header => {
        header.dataset.hasListener = "true";
        header.addEventListener('click', () => {
          header.classList.toggle('collapsed');
          header.nextElementSibling.classList.toggle('collapsed');
        });
      });

      isLoadingMoreChats = false;

      if (scrollContainer.scrollHeight <= scrollContainer.clientHeight && chatListRenderCount < sortedChatListItems.length) {
        loadMoreChats();
      }
    };


    if (isInitialLoad) {

      renderContent();
    } else {

      showLoader(chatListEl, 'bottom');
      setTimeout(renderContent, 500);
    }
  }

  function createChatListItem(chat) {

    try {
      const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
      let lastMsgDisplay;

      if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[å¥½å‹ç”³è¯·] ${chat.relationship.applicationReason || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</span>`;
      } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘]</span>`;
      } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') {
          lastMsgDisplay = `[ç³»ç»Ÿæ¶ˆæ¯] ${lastMsgObj.content}`;
        } else if (lastMsgObj.type === 'transfer') {
          lastMsgDisplay = '[è½¬è´¦]';
        } else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') {
          lastMsgDisplay = '[ç…§ç‰‡]';
        } else if (lastMsgObj.type === 'voice_message') {
          lastMsgDisplay = '[è¯­éŸ³]';
        } else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) {
          lastMsgDisplay = lastMsgObj.meaning ? `[è¡¨æƒ…: ${lastMsgObj.meaning}]` : '[è¡¨æƒ…]';
        } else if (Array.isArray(lastMsgObj.content)) {
          lastMsgDisplay = `[å›¾ç‰‡]`;
        } else {
          lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20);
        }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
          const senderDisplayName = getDisplayNameInGroup(chat, lastMsgObj.senderName);
          lastMsgDisplay = `${senderDisplayName}: ${lastMsgDisplay}`;
        }
      } else {
        const statusText = chat.status?.text || 'åœ¨çº¿';
        lastMsgDisplay = `[${statusText}]`;
      }

      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.chatId = chat.id;
      if (chat.isPinned) {
        item.classList.add('pinned');
      }

      const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
      const avatarFrameSrc = chat.isGroup ? '' : (chat.settings.aiAvatarFrame || '');
      let avatarHtml;
      if (avatarFrameSrc) {
        avatarHtml = `<div class="avatar-with-frame"><img src="${avatar || defaultAvatar}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
      } else {
        avatarHtml = `<img src="${avatar || defaultAvatar}" class="avatar">`;
      }
      const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
      const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

      item.innerHTML = `
            ${avatarGroupHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">ç¾¤èŠ</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="unread-count-wrapper">
                <span class="unread-count" style="display: none;">0</span>
            </div>
        `;

      const unreadCount = chat.unreadCount || 0;
      const unreadEl = item.querySelector('.unread-count');
      if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
      } else {
        unreadEl.style.display = 'none';
      }

      const avatarGroupEl = item.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        avatarGroupEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const nameToPat = chat.isGroup ? chat.name : chat.originalName;
          handleUserPat(chat.id, nameToPat);
        });
      }

      const infoEl = item.querySelector('.info');
      if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
      }

      addLongPressListener(item, async (e) => {
        const action = await showChatListActions(chat);
        switch (action) {
          case 'pin':
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            renderChatList();
            break;
          case 'delete':
            const deleteConfirmed = await showCustomConfirm('åˆ é™¤å¯¹è¯', `ç¡®å®šè¦åˆ é™¤ä¸ "${chat.name}" çš„æ•´ä¸ªå¯¹è¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, {
              confirmButtonClass: 'btn-danger'
            });
            if (deleteConfirmed) {
              if (musicState.isActive && musicState.activeChatId === chat.id) {
                await endListenTogetherSession(false);
              }
              delete state.chats[chat.id];
              if (state.activeChatId === chat.id) state.activeChatId = null;
              await db.chats.delete(chat.id);
              renderChatList();
            }
            break;
          default:
            break;
        }
      });
      return item;

    } catch (error) {

      console.error(`æ¸²æŸ“èŠå¤©é¡¹ [${chat.name || 'æœªçŸ¥'}] (ID: ${chat.id}) æ—¶å‡ºé”™:`, error);
      return null;
    }
  }


  async function renderChatInterface(chatId) {
    applyButtonOrder();
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;

    exitSelectionMode();

    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
      statusContainer.style.display = 'none';
      document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
      statusContainer.style.display = 'flex';
      document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
      statusTextEl.textContent = chat.status?.text || 'åœ¨çº¿';
      statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }

    const chatScreen = document.getElementById('chat-interface-screen');
    const individualBg = chat.settings.background;
    const globalBg = state.globalSettings.globalChatBackground;
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    const defaultColor = isDarkMode ? '#000000' : '#f0f2f5';

    if (individualBg) {
      chatScreen.style.backgroundImage = `url("${individualBg}")`;
      chatScreen.style.backgroundColor = 'transparent';
    } else if (globalBg) {
      chatScreen.style.backgroundImage = `url("${globalBg}")`;
      chatScreen.style.backgroundColor = 'transparent';
    } else {
      chatScreen.style.backgroundImage = 'none';
      chatScreen.style.backgroundColor = defaultColor;
    }


    if (chat.isSpectatorGroup) {
      chatInputArea.style.display = 'none';
      lockOverlay.style.display = 'flex';
      lockContent.innerHTML = `
                    <span class="lock-text">æ­£åœ¨å›´è§‚AIä»¬çš„ç¾¤èŠ...</span>
                    <div class="spectator-actions-container">
                        <button id="spectator-reroll-btn" class="lock-action-btn secondary" title="é‡æ–°ç”Ÿæˆä¸Šä¸€è½®å¯¹è¯">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <button id="spectator-propel-btn" class="lock-action-btn">ğŸ¬ æ¨è¿›å‰§æƒ…</button>
                        <button id="spectator-edit-btn" class="lock-action-btn secondary" title="å¯¼æ¼”å‰ªè¾‘å®¤ï¼šç¼–è¾‘AIä¸Šä¸€è½®çš„å“åº”">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                                <line x1="16" y1="8" x2="2" y2="22"></line>
                                <line x1="17.5" y1="15" x2="9" y2="15"></line>
                            </svg>
                        </button>
                    </div>
                `;
      document.getElementById('spectator-propel-btn').onclick = triggerSpectatorGroupAiAction;
    } else {
      chatInputArea.style.display = 'flex';
      lockOverlay.style.display = 'none';
      lockContent.innerHTML = '';
      if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';

        let lockHtml = '';
        switch (chat.relationship.status) {
          case 'blocked_by_user':
            const isSimulationRunning = simulationIntervalId !== null;
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
            const timeSinceBlock = Date.now() - blockedTimestamp;
            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

            lockHtml = `
                                <span class="lock-text">ä½ å·²å°†â€œ${chat.name}â€æ‹‰é»‘ã€‚</span>
                                <button id="unblock-btn" class="lock-action-btn">è§£é™¤æ‹‰é»‘</button>
                                <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                    <strong style="color: #333;">ã€å¼€å‘è€…è¯Šæ–­é¢æ¿ã€‘</strong><br>
                                    - åå°æ´»åŠ¨æ€»å¼€å…³: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²å¼€å¯</span>' : '<span style="color: red;">å·²å…³é—­</span>'}<br>
                                    - ç³»ç»Ÿå¿ƒè·³è®¡æ—¶å™¨: ${isSimulationRunning ? '<span style="color: green;">è¿è¡Œä¸­</span>' : '<span style="color: red;">æœªè¿è¡Œ</span>'}<br>
                                    - å½“å‰è§’è‰²çŠ¶æ€: <strong>${chat.relationship.status}</strong><br>
                                    - éœ€è¦å†·é™(å°æ—¶): <strong>${cooldownHours}</strong><br>
                                    - å†·é™æœŸæ˜¯å¦ç»“æŸ: ${isCooldownOver ? '<span style="color: green;">æ˜¯</span>' : `<span style="color: orange;">å¦ (è¿˜å‰©çº¦ ${timeRemainingMinutes} åˆ†é’Ÿ)</span>`}<br>
                                    - è§¦å‘æ¡ä»¶: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">å·²æ»¡è¶³ï¼Œç­‰å¾…ä¸‹æ¬¡ç³»ç»Ÿå¿ƒè·³</span>' : '<span style="color: red;">æœªæ»¡è¶³</span>'}
                                </div>
                                <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">å¼ºåˆ¶è§¦å‘ä¸€æ¬¡å¥½å‹ç”³è¯·æ£€æµ‹</button>
                            `;
            break;
          case 'blocked_by_ai':
            lockHtml = `
                                <span class="lock-text">ä½ è¢«å¯¹æ–¹æ‹‰é»‘äº†ã€‚</span>
                                <button id="apply-friend-btn" class="lock-action-btn">é‡æ–°ç”³è¯·åŠ ä¸ºå¥½å‹</button>
                            `;
            break;
          case 'pending_user_approval':
            lockHtml = `
                                <span class="lock-text">â€œ${chat.name}â€è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹ï¼š<br><i>â€œ${chat.relationship.applicationReason}â€</i></span>
                                <button id="accept-friend-btn" class="lock-action-btn">æ¥å—</button>
                                <button id="reject-friend-btn" class="lock-action-btn secondary">æ‹’ç»</button>
                            `;
            break;
          case 'pending_ai_approval':
            lockHtml = `<span class="lock-text">å¥½å‹ç”³è¯·å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹é€šè¿‡...</span>`;
            break;
        }
        lockContent.innerHTML = lockHtml;
      } else {
        lockOverlay.style.display = 'none';
        chatInputArea.style.visibility = 'visible';
      }
    }

    messagesContainer.innerHTML = '';
    const history = chat.history;
    currentRenderedCount = 0;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const initialMessages = history.slice(-renderWindow);



    const fragment = document.createDocumentFragment();
    let lastTimestamp = 0;

   
    for (const msg of initialMessages) {
      
      if (!msg.isHidden) {
        if (lastTimestamp > 0 && (msg.timestamp - lastTimestamp > 600000)) {
          
          fragment.appendChild(createSystemTimestampElement(msg.timestamp));
        }
        lastTimestamp = msg.timestamp;
      }
      
    
      const messageEl = await createMessageElement(msg, chat, true); 
      
      if (messageEl) {
        fragment.appendChild(messageEl);
      }
    }

   
    messagesContainer.appendChild(fragment);

    currentRenderedCount = initialMessages.length;

    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
    messagesContainer.appendChild(typingIndicator);
    const images = messagesContainer.querySelectorAll('img');
const imageLoadPromises = [];

images.forEach(img => {
    
    if (!img.complete) {
       
        imageLoadPromises.push(new Promise(resolve => {
            img.onload = resolve;
            img.onerror = resolve; 
        }));
    }
});


Promise.all(imageLoadPromises).then(() => {
   
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    console.log('æ‰€æœ‰åˆå§‹å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå·²æ»šåŠ¨åˆ°åº•éƒ¨ã€‚');
}).catch(err => {
   
    console.error("ç­‰å¾…å›¾ç‰‡åŠ è½½æ—¶å‡ºé”™:", err);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
});
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
  }




  async function loadMoreMessages() {
      if (isLoadingMoreMessages) return;
      isLoadingMoreMessages = true;

      const messagesContainer = document.getElementById('chat-messages');
      const chat = state.chats[state.activeChatId];
      if (!chat) {
          isLoadingMoreMessages = false;
          return;
      }

     
      showLoader(messagesContainer, 'top'); 
      const oldScrollHeight = messagesContainer.scrollHeight;

      
      await new Promise(resolve => setTimeout(resolve, 100)); 

     
      const totalMessages = chat.history.length;
      const renderWindow = state.globalSettings.chatRenderWindow || 50;
      const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
      const nextSliceEnd = totalMessages - currentRenderedCount;
      const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);

     
      if (messagesToPrepend.length === 0) {
          hideLoader(messagesContainer);
          isLoadingMoreMessages = false;
          return;
      }
      currentRenderedCount += messagesToPrepend.length;
    
      const messageElements = [];
      for (const msg of messagesToPrepend) { 
          const el = await createMessageElement(msg, chat);
          messageElements.push(el); 
      }
    
     

      const fragment = document.createDocumentFragment();
          const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper[data-timestamp]');
         
          let timestampOfFirstVisible = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : 0;

          let lastTimestampInNewBatch = 0; 

      
          messagesToPrepend.forEach((msg, index) => {
              if (!msg.isHidden) {
                 
                  if (lastTimestampInNewBatch > 0 && (msg.timestamp - lastTimestampInNewBatch > 600000)) {
                      fragment.appendChild(createSystemTimestampElement(msg.timestamp));
                  }
                  lastTimestampInNewBatch = msg.timestamp;
              }
              
              const element = messageElements[index]; 
              if (element) {
                  fragment.appendChild(element); 
              }
          });
         
          if (timestampOfFirstVisible > 0 && (timestampOfFirstVisible - lastTimestampInNewBatch > 600000)) {
               fragment.appendChild(createSystemTimestampElement(timestampOfFirstVisible));
          }
    
         
          
          hideLoader(messagesContainer);
          messagesContainer.prepend(fragment);
      

      const newScrollHeight = messagesContainer.scrollHeight;
      messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

      isLoadingMoreMessages = false;
     
  }




  function renderWallpaperScreen(forcePresetId = null) {
    loadCssPresetsDropdown();
    // è¿™é‡Œä¼ å…¥ forcePresetId
    loadAppearancePresetsDropdown(forcePresetId);

    const ephonePreview = document.getElementById('wallpaper-preview');

    if (newWallpaperBase64) {
      ephonePreview.style.backgroundImage = `url("${newWallpaperBase64}")`;
      ephonePreview.textContent = '';
    } else {
      const ephoneBg = state.globalSettings.wallpaper;
      if (ephoneBg && ephoneBg.trim() !== '') {
          ephonePreview.style.backgroundImage = `url("${ephoneBg}")`;
          ephonePreview.textContent = '';
      } else {
          ephonePreview.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
          ephonePreview.textContent = 'ç‚¹å‡»ä¸‹æ–¹ä¸Šä¼ ';
      }
    }

    const cphonePreview = document.getElementById('cphone-wallpaper-preview');
    const cphoneBg = state.globalSettings.cphoneWallpaper;
    if (cphoneBg) {
      cphonePreview.style.backgroundImage = `url("${cphoneBg}")`;
      cphonePreview.textContent = '';
    } else {
      cphonePreview.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
      cphonePreview.textContent = 'å½“å‰ä¸ºæ¸å˜è‰²';
    }

    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = state.globalSettings.globalChatBackground;
    if (globalBg) {
      globalBgPreview.style.backgroundImage = `url(${globalBg})`;
      globalBgPreview.textContent = '';
      document.getElementById('remove-global-bg-btn').style.display = 'inline-block';
    } else {
      globalBgPreview.style.backgroundImage = 'none';
      globalBgPreview.textContent = 'ç‚¹å‡»ä¸‹æ–¹ä¸Šä¼ ';
      document.getElementById('remove-global-bg-btn').style.display = 'none';
    }

    renderIconSettings();
    renderCPhoneIconSettings();
    renderMyPhoneIconSettings();
    document.getElementById('global-css-input').value = state.globalSettings.globalCss || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
    document.getElementById('status-bar-toggle-switch').checked = state.globalSettings.showStatusBar || false;
    document.getElementById('global-show-seconds-switch').checked = state.globalSettings.showSeconds || false;
    document.getElementById('phone-frame-toggle-switch').checked = state.globalSettings.showPhoneFrame || false;
    document.getElementById('minimal-chat-ui-switch').checked = state.globalSettings.enableMinimalChatUI || false;
    document.getElementById('dynamic-island-music-toggle-switch').checked = state.globalSettings.alwaysShowMusicIsland || false;
    document.getElementById('detach-status-bar-switch').checked = state.globalSettings.detachStatusBar || false;
    document.getElementById('lock-screen-toggle').checked = state.globalSettings.lockScreenEnabled || false; // é”å±å›æ˜¾
    document.getElementById('lock-screen-password-input').value = state.globalSettings.lockScreenPassword || ''; // å¯†ç å›æ˜¾

    // é”å±å£çº¸å›æ˜¾
    const lockPreview = document.getElementById('lock-wallpaper-preview');
    if (state.globalSettings.lockScreenWallpaper) {
        lockPreview.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
        lockPreview.textContent = '';
    } else {
        lockPreview.style.backgroundImage = 'linear-gradient(135deg, #1c1c1e, #3a3a3c)';
        lockPreview.textContent = 'é»˜è®¤å£çº¸';
    }
    
    renderButtonOrderEditor();
    initializeButtonOrderEditor();
    
    // åŠ è½½ç³»ç»Ÿé€šçŸ¥è®¾ç½®
    loadSystemNotificationSettings();
  }

  window.renderWallpaperScreenProxy = renderWallpaperScreen;

  function applyGlobalWallpaper() {
    const homeScreen = document.getElementById('home-screen');
    const wallpaper = state.globalSettings.wallpaper;
    if (wallpaper) {

      homeScreen.style.backgroundImage = `url("${wallpaper}")`;
    } else {

      homeScreen.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
    }
  }



  function switchWorldBookCategory(categoryId) {

    document.querySelectorAll('.world-book-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });

    document.querySelectorAll('.world-book-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


  async function renderWorldBookScreen() {
    const tabsContainer = document.getElementById('world-book-tabs');
    const contentContainer = document.getElementById('world-book-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';


    const [books, categories] = await Promise.all([
      db.worldBooks.toArray(),
      db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books;

    if (books.length === 0) {
      contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" åˆ›å»ºä½ çš„ç¬¬ä¸€æœ¬ä¸–ç•Œä¹¦</p>';
      return;
    }


    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);


    categories.forEach(category => {
      const categoryTab = document.createElement('button');
      categoryTab.className = 'world-book-tab';
      categoryTab.textContent = category.name;
      categoryTab.dataset.categoryId = String(category.id);
      tabsContainer.appendChild(categoryTab);

      const categoryPane = document.createElement('div');
      categoryPane.className = 'world-book-category-pane';
      categoryPane.dataset.categoryId = String(category.id);
      contentContainer.appendChild(categoryPane);
    });


    const hasUncategorized = books.some(book => !book.categoryId);
    if (hasUncategorized) {
      const uncategorizedTab = document.createElement('button');
      uncategorizedTab.className = 'world-book-tab';
      uncategorizedTab.textContent = 'æœªåˆ†ç±»';
      uncategorizedTab.dataset.categoryId = 'uncategorized';
      tabsContainer.appendChild(uncategorizedTab);

      const uncategorizedPane = document.createElement('div');
      uncategorizedPane.className = 'world-book-category-pane';
      uncategorizedPane.dataset.categoryId = 'uncategorized';
      contentContainer.appendChild(uncategorizedPane);
    }


    books.forEach(book => {
      let contentPreview = 'æš‚æ— å†…å®¹...';
      if (Array.isArray(book.content) && book.content.length > 0) {
        const firstEntry = book.content[0];
        contentPreview = firstEntry.comment || firstEntry.content || '';
      } else if (typeof book.content === 'string' && book.content.trim() !== '') {
        contentPreview = book.content;
      }

      const card = document.createElement('div');
      card.className = 'world-book-card';
      card.innerHTML = `
                    <div class="card-title">${book.name}</div>
                    <div class="card-content-preview">${contentPreview}</div>
                `;


      const cardClickHandler = () => openWorldBookEditor(book.id);
      const cardLongPressHandler = async () => {
        const confirmed = await showCustomConfirm('åˆ é™¤ä¸–ç•Œä¹¦', `ç¡®å®šè¦åˆ é™¤ã€Š${book.name}ã€‹å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.worldBooks.delete(book.id);
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id);
          renderWorldBookScreen();
        }
      };

      card.addEventListener('click', cardClickHandler);
      addLongPressListener(card, cardLongPressHandler);


      const clonedCardForAll = card.cloneNode(true);
      clonedCardForAll.addEventListener('click', cardClickHandler);
      addLongPressListener(clonedCardForAll, cardLongPressHandler);
      allPane.appendChild(clonedCardForAll);


      const categoryKey = book.categoryId ? String(book.categoryId) : 'uncategorized';
      const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
      if (targetPane) {
        targetPane.appendChild(card);
      }
    });


    document.querySelectorAll('.world-book-tab').forEach(tab => {
      tab.addEventListener('click', () => switchWorldBookCategory(tab.dataset.categoryId));
    });
  }



  function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';

    groupContainer.innerHTML = `
                <div class="world-book-group-header">
                    <span class="arrow">â–¼</span>
                    <span class="group-name">${groupName}</span>
                </div>
                <div class="world-book-group-content"></div>
            `;

    const contentEl = groupContainer.querySelector('.world-book-group-content');
    books.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    books.forEach(book => {

      let contentPreview = 'æš‚æ— å†…å®¹...';


      if (Array.isArray(book.content) && book.content.length > 0) {


        const firstEntry = book.content[0];
        contentPreview = firstEntry.comment || firstEntry.content || '';
      } else if (typeof book.content === 'string' && book.content.trim() !== '') {

        contentPreview = book.content;
      }


      const item = document.createElement('div');
      item.className = 'list-item';
      item.dataset.bookId = book.id;

      item.innerHTML = `
                    <div class="item-title">${book.name}</div>
                    <div class="item-content">${String(contentPreview).substring(0, 50)}</div>
                `;
      item.addEventListener('click', () => openWorldBookEditor(book.id));
      addLongPressListener(item, async () => {
        const confirmed = await showCustomConfirm('åˆ é™¤ä¸–ç•Œä¹¦', `ç¡®å®šè¦åˆ é™¤ã€Š${book.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.worldBooks.delete(book.id);
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id);
          renderWorldBookScreen();
        }
      });
      contentEl.appendChild(item);
    });

    return groupContainer;
  }

  window.renderWorldBookScreenProxy = renderWorldBookScreen;


  async function openWorldBookEditor(bookId) {


    showScreen('world-book-editor-screen');

    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
      db.worldBooks.get(bookId),
      db.worldBookCategories.toArray()
    ]);


    if (!book) {
      console.error("å°è¯•æ‰“å¼€ä¸€ä¸ªä¸å­˜åœ¨çš„ä¸–ç•Œä¹¦ï¼ŒID:", bookId);
      showScreen('world-book-screen');
      return;
    }


    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;


    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
    categories.forEach(cat => {
      const option = document.createElement('option');
      option.value = cat.id;
      option.textContent = cat.name;
      if (book.categoryId === cat.id) option.selected = true;
      selectEl.appendChild(option);
    });
    
    // è®¾ç½®å…¨å±€å¼€å…³çŠ¶æ€ï¼ˆé»˜è®¤ä¸ºå…³é—­ï¼‰
    const globalSwitch = document.getElementById('world-book-global-switch');
    if (globalSwitch) {
      globalSwitch.checked = book.isGlobal === true;
    }
    
    // è®¾ç½®æ³¨å…¥ä½ç½®çš„å€¼ï¼ˆé»˜è®¤ä¸º'before'ï¼‰
    const injectPositionSelect = document.getElementById('world-book-inject-position-select');
    if (injectPositionSelect) {
      injectPositionSelect.value = book.injectPosition || 'before';
    }


    const entriesContainer = document.getElementById('world-book-entries-container');
    entriesContainer.innerHTML = '';

    if (Array.isArray(book.content) && book.content.length > 0) {
      book.content.forEach(entry => {
        const block = createWorldBookEntryBlock(entry);
        entriesContainer.appendChild(block);
      });
    } else {
      entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">è¿˜æ²¡æœ‰å†…å®¹ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€æ¡å§ï¼</p>';
    }


  }


  
  async function renderStickerPanel(rerenderTabs = true) {
    const grid = document.getElementById('sticker-grid');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const searchInput = document.getElementById('sticker-search-input');
    const searchTerm = searchInput.value.trim().toLowerCase();


    if (rerenderTabs) {
      tabsContainer.innerHTML = '';
      const categories = await db.stickerCategories.toArray();

      tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'all' ? 'active' : ''}" data-category-id="all">å…¨éƒ¨</button>`;
      categories.forEach(cat => {
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === cat.id ? 'active' : ''}" data-category-id="${cat.id}">${cat.name}</button>`;
      });
      tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'uncategorized' ? 'active' : ''}" data-category-id="uncategorized">æœªåˆ†ç±»</button>`;
    }


    grid.innerHTML = '';


    let stickersByCategory;
    if (activeStickerCategoryId === 'all') {
      stickersByCategory = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
      stickersByCategory = state.userStickers.filter(s => !s.categoryId);
    } else {
      stickersByCategory = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }


    const stickersToShow = searchTerm ?
      stickersByCategory.filter(sticker => sticker.name.toLowerCase().includes(searchTerm)) :
      stickersByCategory;


    if (stickersToShow.length === 0) {
      const message = searchTerm ? 'æ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…' : 'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰è¡¨æƒ…å“¦~';
      grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">${message}</p>`;
      return;
    }

    stickersToShow.forEach(sticker => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = sticker.name;
      item.dataset.stickerId = sticker.id;
      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${sticker.url})"></div>
            <span class="sticker-name">${sticker.name}</span>
        `;
      item.addEventListener('click', () => {
        if (isStickerManagementMode) {
          handleStickerSelection(item);
        } else {
          sendSticker(sticker);
        }
      });
      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '&times;';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('åˆ é™¤è¡¨æƒ…', `ç¡®å®šè¦åˆ é™¤è¡¨æƒ… "${sticker.name}" å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.userStickers.delete(sticker.id);
          state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
          renderStickerPanel();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }



  let isStickerManagementMode = false;
  let selectedStickers = new Set();
  let isPlaylistManagementMode = false;
  let selectedPlaylistItems = new Set();
  let isNaiGalleryManagementMode = false;
  let selectedNaiImages = new Set();
  let naiGalleryCache = { local: [], cloud: [] }; 
  let naiGalleryRenderCount = { local: 0, cloud: 0 }; 
  let isLoadingMoreNaiImages = { local: false, cloud: false };
  let activeNaiGalleryTab = 'local';
  const NAI_GALLERY_RENDER_WINDOW = 45; 
  
  function togglePlaylistManagementMode() {
    isPlaylistManagementMode = !isPlaylistManagementMode;
    const panel = document.getElementById('music-playlist-panel');
    const manageBtn = document.getElementById('manage-playlist-btn');
    const actionBar = document.getElementById('playlist-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-playlist-checkbox');

    panel.classList.toggle('management-mode', isPlaylistManagementMode);

    if (isPlaylistManagementMode) {
      manageBtn.textContent = translations[currentLanguage].done; // ä½¿ç”¨ç¿»è¯‘
      manageBtn.setAttribute('data-lang-key', 'done');
      actionBar.style.display = 'flex';
      selectedPlaylistItems.clear();
      selectAllCheckbox.checked = false;
      updatePlaylistActionBar();
      // æ˜¾ç¤ºå¤é€‰æ¡†
      panel.querySelectorAll('.playlist-item-checkbox').forEach(cb => cb.style.display = 'block');
    } else {
      manageBtn.textContent = translations[currentLanguage].manage; // ä½¿ç”¨ç¿»è¯‘
      manageBtn.setAttribute('data-lang-key', 'manage');
      actionBar.style.display = 'none';
      // éšè—å¤é€‰æ¡†å¹¶å–æ¶ˆé€‰ä¸­
      panel.querySelectorAll('.playlist-item').forEach(item => {
        item.classList.remove('selected');
        const cb = item.querySelector('.playlist-item-checkbox');
        if (cb) {
            cb.style.display = 'none';
            cb.checked = false;
        }
      });
    }
  }

  function handlePlaylistSelection(index) {
    if (!isPlaylistManagementMode) return;
    
    const item = document.querySelector(`.playlist-item[data-index="${index}"]`);
    if (!item) return;
    const checkbox = item.querySelector('.playlist-item-checkbox');

    // åˆ‡æ¢çŠ¶æ€
    const isSelected = selectedPlaylistItems.has(index);
    item.classList.toggle('selected', !isSelected);
    checkbox.checked = !isSelected;
    
    if (isSelected) {
      selectedPlaylistItems.delete(index);
    } else {
      selectedPlaylistItems.add(index);
    }
    updatePlaylistActionBar();
  }

  function updatePlaylistActionBar() {
    const uploadBtn = document.getElementById('upload-selected-to-catbox-btn');
    const deleteBtn = document.getElementById('delete-selected-songs-btn');
    const count = selectedPlaylistItems.size;
    if (uploadBtn) uploadBtn.textContent = `ä¸Šä¼ Catbox (${count})`;
    if (deleteBtn) deleteBtn.textContent = `åˆ é™¤ (${count})`;
  }

  function handleSelectAllPlaylistItems() {
    const checkbox = document.getElementById('select-all-playlist-checkbox');
    const shouldSelect = checkbox.checked;
    
    document.querySelectorAll('.playlist-item').forEach(item => {
      const index = parseInt(item.dataset.index);
      if (isNaN(index)) return;

      item.classList.toggle('selected', shouldSelect);
      item.querySelector('.playlist-item-checkbox').checked = shouldSelect;

      if (shouldSelect) {
        selectedPlaylistItems.add(index);
      } else {
        selectedPlaylistItems.delete(index);
      }
    });
    updatePlaylistActionBar();
  }

  async function executeDeleteSelectedSongs() {
    if (selectedPlaylistItems.size === 0) {
      await showCustomAlert("æœªé€‰æ‹©", "è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ­Œæ›²ã€‚");
      return;
    }

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤ï¼Ÿ',
      `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedPlaylistItems.size} é¦–æ­Œæ›²å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`,
      { confirmText: 'ç¡®è®¤åˆ é™¤', cancelText: 'å–æ¶ˆ' }
    );

    if (!confirmed) return;

    // å°†é€‰ä¸­çš„ç´¢å¼•è½¬ä¸ºæ•°ç»„å¹¶ä»å¤§åˆ°å°æ’åºï¼ˆé¿å…åˆ é™¤æ—¶ç´¢å¼•é”™ä¹±ï¼‰
    const indicesToDelete = Array.from(selectedPlaylistItems).sort((a, b) => b - a);
    
    // ä»æ’­æ”¾åˆ—è¡¨ä¸­åˆ é™¤æ­Œæ›²
    for (const index of indicesToDelete) {
      if (index >= 0 && index < musicState.playlist.length) {
        musicState.playlist.splice(index, 1);
      }
    }

    // å¦‚æœå½“å‰æ­£åœ¨æ’­æ”¾çš„æ­Œæ›²è¢«åˆ é™¤ï¼Œéœ€è¦è°ƒæ•´currentIndex
    if (indicesToDelete.includes(musicState.currentIndex)) {
      // å¦‚æœæ’­æ”¾åˆ—è¡¨è¿˜æœ‰æ­Œæ›²ï¼Œæ’­æ”¾ç¬¬ä¸€é¦–ï¼Œå¦åˆ™åœæ­¢
      if (musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        loadCurrentSong();
      } else {
        musicState.currentIndex = -1;
        if (musicState.audio) {
          musicState.audio.pause();
          musicState.audio.src = '';
        }
      }
    } else if (musicState.currentIndex >= musicState.playlist.length) {
      // è°ƒæ•´ç´¢å¼•
      musicState.currentIndex = Math.max(0, musicState.playlist.length - 1);
    }

    // ä¿å­˜åˆ°æ•°æ®åº“
    await saveGlobalPlaylist();

    // æ˜¾ç¤ºç»“æœ
    await showCustomAlert("åˆ é™¤æˆåŠŸ", `å·²åˆ é™¤ ${indicesToDelete.length} é¦–æ­Œæ›²ã€‚`);

    // æ¸…ç©ºé€‰æ‹©å¹¶é€€å‡ºç®¡ç†æ¨¡å¼
    selectedPlaylistItems.clear();
    togglePlaylistManagementMode();
    updatePlaylistUI();
  }

  async function executeBatchUploadToCatbox() {
    // 1. æ£€æŸ¥ Catbox é…ç½®
    if (!state.apiConfig.catboxEnable || !state.apiConfig.catboxUserHash) {
      await showCustomAlert("åŠŸèƒ½æœªå¼€å¯", "è¯·å…ˆåœ¨â€œAPIè®¾ç½®â€ -> â€œCatbox.moeâ€ä¸­å¼€å¯æ­¤åŠŸèƒ½å¹¶å¡«å†™æ‚¨çš„ User Hashã€‚");
      return;
    }

    if (selectedPlaylistItems.size === 0) {
      await showCustomAlert("æœªé€‰æ‹©", "è¯·å…ˆé€‰æ‹©è¦ä¸Šä¼ çš„æ­Œæ›²ã€‚");
      return;
    }

    // 2. è¿‡æ»¤æ‰å·²ç»æ˜¯ Catbox é“¾æ¥çš„æ­Œæ›²
    const indicesToUpload = Array.from(selectedPlaylistItems).filter(index => {
      const song = musicState.playlist[index];
      return song && song.src && !String(song.src).includes('catbox.moe');
    });

    if (indicesToUpload.length === 0) {
      await showCustomAlert("æ— éœ€ä¸Šä¼ ", "æ‚¨é€‰æ‹©çš„æ‰€æœ‰æ­Œæ›²å‡å·²åœ¨ Catbox ä¸Šã€‚");
      togglePlaylistManagementMode();
      return;
    }

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤ä¸Šä¼ ï¼Ÿ',
      `å³å°†ä¸Šä¼  ${indicesToUpload.length} é¦–æ­Œæ›²åˆ° Catbox.moeã€‚\n\nè¿™ä¼šè½¬æ¢æœ¬åœ°éŸ³ä¹å’Œå¤–éƒ¨é“¾æ¥ï¼Œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´å¹¶æ¶ˆè€—æµé‡ã€‚\nï¼ˆå·²åœ¨ Catbox ä¸Šçš„æ­Œæ›²å°†è¢«è‡ªåŠ¨è·³è¿‡ï¼‰`,
      { confirmText: 'å¼€å§‹ä¸Šä¼ ' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨å¼€å§‹ä¸Šä¼  ${indicesToUpload.length} é¦–æ­Œæ›²ï¼Œè¯·å‹¿å…³é—­é¡µé¢...`);

    let successCount = 0;
    let failCount = 0;
    const failedNames = [];

    const proxySettings = getNovelAISettings();
    let corsProxy = proxySettings.cors_proxy;
    if (corsProxy === 'custom') {
      corsProxy = proxySettings.custom_proxy_url || '';
    }
   

    for (const index of indicesToUpload) {
      const song = musicState.playlist[index];
      try {
        let fileToUpload;
        let songName = song.name || 'unknown_track.mp3';

        if (song.isLocal) {
          // 4a. å¤„ç†æœ¬åœ°æ­Œæ›² (ArrayBuffer æˆ– Blob) - è¿™éƒ¨åˆ†é€»è¾‘æ˜¯æ­£ç¡®çš„
          console.log(`[Catbox æ‰¹é‡ä¸Šä¼ ] å¤„ç†æœ¬åœ°æ­Œæ›²: ${song.name}`);
          fileToUpload = new Blob([song.src], { type: song.fileType || 'audio/mpeg' });
        } else {
          // 4b. å¤„ç†ç½‘ç»œæ­Œæ›² (éœ€è¦CORSä»£ç†)
          console.log(`[Catbox æ‰¹é‡ä¸Šä¼ ] å¤„ç†ç½‘ç»œæ­Œæ›²: ${song.name} from ${song.src}`);
          
          
          let fetchUrl = song.src;
          // æ£€æŸ¥ä»£ç†æ˜¯å¦å·²é…ç½®ï¼Œå¹¶ä¸”æ­Œæ›²æºä¸æ˜¯ data: URI
          if (corsProxy && corsProxy !== '' && !fetchUrl.startsWith('data:')) {
            // ã€é‡è¦ã€‘å¿…é¡»å¯¹æºURLè¿›è¡Œç¼–ç ï¼Œä»¥é˜²URLä¸­æœ‰ç‰¹æ®Šå­—ç¬¦
            fetchUrl = corsProxy + encodeURIComponent(song.src); 
            console.log(`[Catbox æ‰¹é‡ä¸Šä¼ ] ä½¿ç”¨ä»£ç†ä¸‹è½½: ${fetchUrl}`);
          } else {
            console.log(`[Catbox æ‰¹é‡ä¸Šä¼ ] ä¸ä½¿ç”¨ä»£ç†ï¼Œå°è¯•ç›´è¿ä¸‹è½½... (è¿™åœ¨Safariä¸Šä¼šå¤±è´¥)`);
          }
          
          const response = await fetch(fetchUrl); // <--- ç°åœ¨è¿™ä¸ª fetch æ˜¯å¸¦ä»£ç†çš„
          if (!response.ok) throw new Error(`ä¸‹è½½æ­Œæ›²å¤±è´¥ï¼ŒçŠ¶æ€: ${response.status}`);
          fileToUpload = await response.blob();
        }

        // ç¡®ä¿æ–‡ä»¶åæœ‰åç¼€
        if (!songName.match(/\.(mp3|wav|flac|m4a|ogg)$/i)) {
          songName += '.mp3';
        }

        // 5. è°ƒç”¨æˆ‘ä»¬ä¹‹å‰ä¿®å¤è¿‡çš„ä¸Šä¼ å‡½æ•°
        // (uploadFileToCatbox å‡½æ•°åœ¨ 1667 è¡Œé™„è¿‘)
        const newCatboxUrl = await uploadFileToCatbox(new File([fileToUpload], songName, { type: fileToUpload.type }));
        
        // 6. æ›´æ–° musicState
        song.src = newCatboxUrl;
        song.isLocal = false;
        delete song.fileType; 
        successCount++;

      } catch (error) {
        console.error(`[Catbox æ‰¹é‡ä¸Šä¼ ] ä¸Šä¼ å¤±è´¥: ${song.name}`, error);
        failCount++;
        failedNames.push(song.name);
      }
    }

    // 7. ä¿å­˜åˆ°æ•°æ®åº“
    await saveGlobalPlaylist();

    // 8. æ˜¾ç¤ºæ€»ç»“æŠ¥å‘Š
    let summary = `ä¸Šä¼ å®Œæˆï¼\n\næˆåŠŸ: ${successCount} é¦–`;
    if (failCount > 0) {
      summary += `\nå¤±è´¥: ${failCount} é¦–\n(${failedNames.join(', ')})`;
    }
    await showCustomAlert("æ“ä½œå®Œæˆ", summary);

    // 9. é€€å‡ºç®¡ç†æ¨¡å¼å¹¶åˆ·æ–°UI
    togglePlaylistManagementMode();
    updatePlaylistUI();
  }

  function toggleStickerManagementMode() {
    isStickerManagementMode = !isStickerManagementMode;
    const grid = document.getElementById('sticker-grid');
    const manageBtn = document.getElementById('manage-stickers-btn');
    const actionBar = document.getElementById('sticker-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');

    grid.classList.toggle('management-mode', isStickerManagementMode);

    if (isStickerManagementMode) {
      manageBtn.textContent = 'å®Œæˆ';
      actionBar.style.display = 'flex';
      selectedStickers.clear();
      selectAllCheckbox.checked = false;
      updateDeleteStickerButton();
    } else {
      manageBtn.textContent = 'ç®¡ç†';
      actionBar.style.display = 'none';
      grid.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
    }
  }



  function handleSelectAllStickers() {
    const checkbox = document.getElementById('select-all-stickers-checkbox');
    const shouldSelect = checkbox.checked;


    let stickersToSelect;
    if (activeStickerCategoryId === 'all') {
      stickersToSelect = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
      stickersToSelect = state.userStickers.filter(s => !s.categoryId);
    } else {
      stickersToSelect = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }


    stickersToSelect.forEach(sticker => {
      const stickerId = sticker.id;
      const itemEl = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);

      if (shouldSelect) {

        selectedStickers.add(stickerId);
        if (itemEl) itemEl.classList.add('selected');
      } else {

        selectedStickers.delete(stickerId);
        if (itemEl) itemEl.classList.remove('selected');
      }
    });


    updateDeleteStickerButton();
  }


  function updateDeleteStickerButton() {
    const count = selectedStickers.size;
    const delBtn = document.getElementById('delete-selected-stickers-btn');
    const exportBtn = document.getElementById('export-selected-stickers-btn');
    const moveBtn = document.getElementById('move-selected-stickers-btn'); // æ–°å¢

    if (delBtn) delBtn.textContent = `åˆ é™¤ (${count})`;
    if (exportBtn) exportBtn.textContent = `å¯¼å‡º (${count})`;
    if (moveBtn) moveBtn.textContent = `ç§»åŠ¨ (${count})`; // æ–°å¢
}
async function executeBatchMoveStickers() {
    if (selectedStickers.size === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„è¡¨æƒ…ã€‚");
        return;
    }

    // 1. è·å–æ‰€æœ‰åˆ†ç±»
    const categories = await db.stickerCategories.toArray();
    const options = [
        { text: 'æœªåˆ†ç±»', value: 'uncategorized' },
        ...categories.map(c => ({ text: c.name, value: c.id }))
    ];

    // 2. å¼¹å‡ºé€‰æ‹©æ¡†
    const targetCategoryId = await showChoiceModal("ç§»åŠ¨åˆ°åˆ†ç±»", options);
    if (!targetCategoryId) return;

    // 3. å¤„ç†ç›®æ ‡ID (æœªåˆ†ç±»å­˜ä¸º null)
    const finalCategoryId = targetCategoryId === 'uncategorized' ? null : parseInt(targetCategoryId);

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ç§»åŠ¨è¡¨æƒ…...");

    // 4. æ›´æ–°æ•°æ®åº“
    const idsToMove = Array.from(selectedStickers);
    await db.transaction('rw', db.userStickers, async () => {
        for (const id of idsToMove) {
            await db.userStickers.update(id, { categoryId: finalCategoryId });
            // æ›´æ–°å†…å­˜
            const s = state.userStickers.find(item => item.id === id);
            if (s) s.categoryId = finalCategoryId;
        }
    });

    // 5. åˆ·æ–°ç•Œé¢
    toggleStickerManagementMode(); // é€€å‡ºç®¡ç†æ¨¡å¼
    await renderStickerPanel(); // åˆ·æ–°åˆ—è¡¨ (è¿™ä¼šæ ¹æ®å½“å‰é€‰ä¸­çš„Tabåˆ·æ–°ï¼Œç§»åŠ¨èµ°çš„è¡¨æƒ…ä¼šæ¶ˆå¤±)
    
    await showCustomAlert("æˆåŠŸ", `å·²å°† ${idsToMove.length} ä¸ªè¡¨æƒ…ç§»åŠ¨åˆ°æ–°åˆ†ç±»ã€‚`);
}
  /**
   * å¤„ç†ç”¨æˆ·ç‚¹å‡»é€‰æ‹©æˆ–å–æ¶ˆé€‰æ‹©è¡¨æƒ…
   * @param {HTMLElement} item - è¢«ç‚¹å‡»çš„è¡¨æƒ…DOMå…ƒç´ 
   */
  function handleStickerSelection(item) {
    if (!isStickerManagementMode) return;

    const stickerId = item.dataset.stickerId;
    if (!stickerId) return;

    item.classList.toggle('selected');

    if (selectedStickers.has(stickerId)) {
      selectedStickers.delete(stickerId);
    } else {
      selectedStickers.add(stickerId);
    }
    updateDeleteStickerButton();
  }


  async function executeBatchDeleteStickers() {
    if (selectedStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedStickers.size} ä¸ªè¡¨æƒ…å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      const idsToDelete = [...selectedStickers];


      await db.userStickers.bulkDelete(idsToDelete);


      state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));


      toggleStickerManagementMode();
      renderStickerPanel();

      await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„è¡¨æƒ…å·²æˆåŠŸåˆ é™¤ã€‚');
    }
  }

async function executeBatchExportStickers() {
    if (selectedStickers.size === 0) {
      alert("è¯·å…ˆé€‰æ‹©è¦å¯¼å‡ºçš„è¡¨æƒ…åŒ…ã€‚");
      return;
    }

    let exportText = "";
    let exportedCount = 0;

    
    state.userStickers.forEach(sticker => {
      if (selectedStickers.has(sticker.id)) {
       
        exportText += `${sticker.name}: ${sticker.url}\n`;
        exportedCount++;
      }
    });

    if (exportedCount === 0) {
      alert("æœªæ‰¾åˆ°æ‰€é€‰è¡¨æƒ…çš„æ•°æ®ã€‚");
      return;
    }

    const finalText = exportText.trim();
    const textareaId = 'batch-export-textarea-' + Date.now();
    
  
    const alertHtml = `
        <p style="text-align:left; font-size: 14px; margin: 0 0 10px 0;">
            å·²ä¸ºæ‚¨ç”Ÿæˆ ${exportedCount} æ¡å¿«æ·å¯¼å…¥æ ¼å¼çš„æ–‡æœ¬ï¼š
        </p>
        <textarea id="${textareaId}" 
                  rows="10" 
                  style="width: 100%; font-size: 12px; resize: vertical; border-radius: 6px; border: 1px solid #ccc;"
                  readonly>${finalText}</textarea>
    `;

   
    showCustomAlert("å¤åˆ¶è¡¨æƒ…åŒ…æ•°æ®", alertHtml);
  
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    
    if (modalConfirmBtn) {
        
        
        modalConfirmBtn.textContent = 'ä¸€é”®å¤åˆ¶';
        
        
        const originalOnclick = modalConfirmBtn.onclick;

       
        modalConfirmBtn.onclick = async (e) => {
            try {
                
                await navigator.clipboard.writeText(finalText);
                modalConfirmBtn.textContent = 'å¤åˆ¶æˆåŠŸ!';
                
               
                setTimeout(() => {
                   modalConfirmBtn.textContent = 'å®Œæˆ';
                   modalConfirmBtn.onclick = originalOnclick; 
                }, 1500);
                
            } catch (err) {
               
                alert('è‡ªåŠ¨å¤åˆ¶å¤±è´¥ï¼Œè¯·é•¿æŒ‰æ–‡æœ¬æ¡†æ‰‹åŠ¨å¤åˆ¶ã€‚');
                
                modalConfirmBtn.textContent = 'å®Œæˆ';
                modalConfirmBtn.onclick = originalOnclick;
            }
        };
    }
  }


 
  async function openBatchStickerImportModal() {
    // 1. è®©ç”¨æˆ·é€‰æ‹©å¯¼å…¥æ–¹å¼
    const choice = await showChoiceModal('æ‰¹é‡å¯¼å…¥è¡¨æƒ…', [
        { text: 'ğŸ“‹ ç²˜è´´æ–‡æœ¬', value: 'paste' },
        { text: 'ğŸ“ ä¸Šä¼ æ–‡ä»¶ (.txt/.json/.docx)', value: 'file' }
    ]);

    if (choice === 'paste') {
        // --- æ–¹å¼ A: ç²˜è´´æ–‡æœ¬ (ä¿æŒåŸæœ‰é€»è¾‘) ---
        const placeholderText = `è¯·è¾“å…¥è¡¨æƒ…æ•°æ®ï¼Œä¸€è¡Œä¸€ä¸ªã€‚
ã€è§„åˆ™ã€‘ï¼šåŒ…å«ã€åå­—ã€‘å’Œã€é“¾æ¥ã€‘ã€‚
ã€ç¤ºä¾‹ã€‘ï¼š
å¼€å¿ƒ: https://xx.com/1.jpg
å“­æ³£ï¼šhttps://xx.com/2.png
ç”Ÿæ°”https://xx.com/3.gif
https://xx.com/4.jpg ç–‘æƒ‘`;

        const pastedText = await showCustomPrompt(
          'æ‰¹é‡å¯¼å…¥è¡¨æƒ…',
          placeholderText,
          '',
          'textarea'
        );

        if (pastedText && pastedText.trim()) {
          await handleBatchStickerImport(pastedText);
        }

    } else if (choice === 'file') {
        // --- æ–¹å¼ B: ä¸Šä¼ æ–‡ä»¶ ---
        await handleStickerFileImport();
    }
  }


  
  async function handleBatchStickerImport(text) {
    const lines = text.trim().split('\n');
    const newStickers = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;
    let skippedPureLinks = 0; // ç»Ÿè®¡è¢«è·³è¿‡çš„çº¯é“¾æ¥
    const currentCategoryId = (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null;

    // 1. æå–URLçš„æ­£åˆ™ (æ”¯æŒ http/https å’Œ data:image)
    const urlRegex = /(https?:\/\/[^\s]+|data:image\/[^\s]+)/;

    for (const line of lines) {
      const trimmedLine = line.trim();

      // è·³è¿‡ç©ºè¡Œæˆ–åŒ…å«æç¤ºè¯­çš„è¡Œ
      if (!trimmedLine || trimmedLine.includes('å¡«å…¥') || trimmedLine.includes('æ ¼å¼')) {
        continue;
      }

      // --- ç¬¬ä¸€æ­¥ï¼šå¯»æ‰¾é“¾æ¥ ---
      const urlMatch = trimmedLine.match(urlRegex);
      
      // 2. å¦‚æœæ²¡æ‰¾åˆ°æ ‡å‡†é“¾æ¥ï¼Œå°è¯•å…¼å®¹æ—§ç‰ˆ Catbox çŸ­ç  (åå­— code.png)
      if (!urlMatch) {
         // å°è¯•åŒ¹é…: ä»»æ„æ–‡å­— + ç©ºæ ¼ + (å­—æ¯æ•°å­—.åç¼€)
         const catboxMatch = trimmedLine.match(/^(.+?)\s+([a-zA-Z0-9]+\.[a-zA-Z0-9]+)$/);
         if (catboxMatch) {
             newStickers.push({
                id: 'sticker_' + Date.now() + Math.random(),
                name: catboxMatch[1].trim(),
                url: baseUrl + catboxMatch[2].trim(),
                categoryId: currentCategoryId
             });
         } else {
             errorCount++;
             console.warn('æ— æ³•è¯†åˆ«è¡Œ:', trimmedLine);
         }
         continue; 
      }

      // --- ç¬¬äºŒæ­¥ï¼šæå–å¹¶æ¸…æ´—æ•°æ® ---
      const url = urlMatch[0];
      
      // ä»æ•´è¡Œä¸­æŠŠé“¾æ¥åˆ æ‰ï¼Œå‰©ä¸‹çš„å°±æ˜¯åå­—
      // ä¾‹å¦‚ "å¼€å¿ƒ:http://..." -> å‰©ä¸‹ "å¼€å¿ƒ:" (è‹±æ–‡å†’å·)
      // ä¾‹å¦‚ "å¼€å¿ƒï¼šhttp://..." -> å‰©ä¸‹ "å¼€å¿ƒï¼š" (ä¸­æ–‡å†’å·)
      let rawName = trimmedLine.replace(url, '').trim();

      // --- ç¬¬ä¸‰æ­¥ï¼šæ™ºèƒ½æ¸…æ´—åå­— (æ ¸å¿ƒä¿®æ”¹) ---
      // æ­£åˆ™è§£é‡Šï¼š
      // ^[\s:ï¼š,ï¼Œ]+  -> å»æ‰å¼€å¤´çš„æ‰€æœ‰ ç©ºæ ¼ã€è‹±æ–‡å†’å·ã€ä¸­æ–‡å†’å·ã€é€—å·
      // |             -> æˆ–è€…
      // [\s:ï¼š,ï¼Œ]+$  -> å»æ‰ç»“å°¾çš„æ‰€æœ‰ ç©ºæ ¼ã€è‹±æ–‡å†’å·ã€ä¸­æ–‡å†’å·ã€é€—å·
      let cleanName = rawName.replace(/^[\s:ï¼š,ï¼Œ]+|[\s:ï¼š,ï¼Œ]+$/g, '');

      // --- ç¬¬å››æ­¥ï¼šä¸¥æ ¼æ ¡éªŒ (ç¦æ­¢çº¯é“¾æ¥) ---
      // å¦‚æœæ¸…æ´—ååå­—ä¸ºç©ºï¼Œè¯´æ˜è¿™ä¸€è¡Œåªæœ‰é“¾æ¥
      if (!cleanName) {
          skippedPureLinks++;
          console.warn('è·³è¿‡çº¯é“¾æ¥ (æœªæä¾›åå­—):', trimmedLine);
          continue;
      }

      // æ·»åŠ åˆ°åˆ—è¡¨
      newStickers.push({
        id: 'sticker_' + Date.now() + Math.random(),
        name: cleanName,
        url: url,
        categoryId: currentCategoryId
      });
    }

    // --- ç¬¬äº”æ­¥ï¼šç»“æœåé¦ˆ ---
    let resultMsg = '';
    
    if (newStickers.length > 0) {
      await db.userStickers.bulkAdd(newStickers);
      state.userStickers.push(...newStickers);
      renderStickerPanel();
      resultMsg = `æˆåŠŸå¯¼å…¥ ${newStickers.length} ä¸ªæ–°è¡¨æƒ…ï¼`;
    }

    if (skippedPureLinks > 0) {
        resultMsg += `\nâš ï¸ æœ‰ ${skippedPureLinks} è¡Œå› åªæœ‰é“¾æ¥(æ— åå­—)è¢«è·³è¿‡ã€‚`;
    }

    if (errorCount > 0) {
        resultMsg += `\nâŒ æœ‰ ${errorCount} è¡Œæ ¼å¼æ— æ³•è¯†åˆ«ã€‚`;
    }

    if (resultMsg) {
        await showCustomAlert('å¯¼å…¥ç»“æœ', resultMsg);
    } else if (lines.length > 0) {
        await showCustomAlert('å¯¼å…¥å¤±è´¥', 'æœªèƒ½è¯†åˆ«ä»»ä½•æœ‰æ•ˆæ•°æ®ï¼Œè¯·ç¡®ä¿æ¯è¡Œéƒ½åŒ…å«ã€åå­—ã€‘å’Œã€é“¾æ¥ã€‘ã€‚');
    }
  }
// å¤„ç†æ–‡ä»¶é€‰æ‹©
  function handleStickerFileImport() {
    return new Promise(resolve => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.txt,.json,.docx'; // é™åˆ¶æ–‡ä»¶ç±»å‹
      
      input.onchange = async e => {
        const file = e.target.files[0];
        if (!file) {
            resolve();
            return;
        }

        try {
            await showCustomAlert("æ­£åœ¨è§£æ...", "æ­£åœ¨è¯»å–æ–‡ä»¶å†…å®¹ï¼Œè¯·ç¨å€™...");
            const textContent = await processStickerFile(file);
            
            if (textContent && textContent.trim()) {
                // è§£ææˆåŠŸåï¼Œç›´æ¥å¤ç”¨ä¹‹å‰çš„æ–‡æœ¬è§£æé€»è¾‘
                // è¿™æ ·æ— è®ºæ˜¯æ–‡ä»¶è¿˜æ˜¯ç²˜è´´ï¼Œéƒ½æ”¯æŒé‚£ç§çµæ´»çš„æ ¼å¼ï¼ˆä¸­æ–‡å†’å·ã€æ— ç©ºæ ¼ç­‰ï¼‰
                await handleBatchStickerImport(textContent);
            } else {
                alert("æ–‡ä»¶å†…å®¹ä¸ºç©ºæˆ–æ— æ³•è§£æã€‚");
            }
        } catch (error) {
            console.error("æ–‡ä»¶è§£æå¤±è´¥:", error);
            alert(`æ–‡ä»¶è§£æå¤±è´¥: ${error.message}`);
        }
        resolve();
      };
      
      input.click();
    });
  }

  // æ ¸å¿ƒï¼šæ ¹æ®åç¼€åè§£ææ–‡ä»¶å†…å®¹
  async function processStickerFile(file) {
      const fileName = file.name.toLowerCase();

      // 1. å¤„ç† .txt æ–‡ä»¶
      if (fileName.endsWith('.txt')) {
          return await file.text();
      }

      // 2. å¤„ç† .docx æ–‡ä»¶ (ä¾èµ– mammoth.js)
      if (fileName.endsWith('.docx')) {
          if (typeof mammoth === 'undefined') {
              throw new Error("æœªåŠ è½½ mammoth.js åº“ï¼Œæ— æ³•è¯»å– Word æ–‡æ¡£ã€‚");
          }
          const arrayBuffer = await file.arrayBuffer();
          const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
          return result.value; // è¿”å› Word ä¸­çš„çº¯æ–‡æœ¬
      }

      // 3. å¤„ç† .json æ–‡ä»¶
      if (fileName.endsWith('.json')) {
          const text = await file.text();
          let json;
          try {
              json = JSON.parse(text);
          } catch (e) {
              throw new Error("JSON æ ¼å¼é”™è¯¯");
          }

          // å°† JSON è½¬æ¢ä¸º "åå­—: é“¾æ¥" çš„æ–‡æœ¬æ ¼å¼ï¼Œä»¥ä¾¿å¤ç”¨ handleBatchStickerImport
          let convertedText = "";

          if (Array.isArray(json)) {
              // æƒ…å†µ A: æ•°ç»„æ ¼å¼ [{name: "å¼€å¿ƒ", url: "http..."}, ...]
              json.forEach(item => {
                  // å°è¯•å¤šç§å¯èƒ½çš„é”®å
                  const name = item.name || item.key || item.title || item.meaning;
                  const url = item.url || item.src || item.content || item.link;
                  if (name && url) {
                      convertedText += `${name}: ${url}\n`;
                  }
              });
          } else if (typeof json === 'object') {
              // æƒ…å†µ B: å¯¹è±¡æ ¼å¼ {"å¼€å¿ƒ": "http...", "å“­æ³£": "http..."}
              // æˆ–è€… Tavern æ ¼å¼ {"entries": ...}
              if (json.entries) {
                   // ç®€å•çš„å…¼å®¹ Tavern æ ¼å¼
                   const entries = Array.isArray(json.entries) ? json.entries : Object.values(json.entries);
                   entries.forEach(item => {
                       const name = item.comment || item.key?.toString() || "è¡¨æƒ…";
                       const url = item.content || item.url;
                       if (url && url.startsWith('http')) {
                           convertedText += `${name}: ${url}\n`;
                       }
                   });
              } else {
                  // æ™®é€š Key-Value å¯¹
                  for (let key in json) {
                      const val = json[key];
                      if (typeof val === 'string' && (val.startsWith('http') || val.startsWith('data:image'))) {
                          convertedText += `${key}: ${val}\n`;
                      }
                  }
              }
          }
          return convertedText;
      }

      throw new Error("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
  }

  // å¤„ç†è§’è‰²æ–‡ä»¶å¯¼å…¥ (.txt/.docx/.zip) - æ”¯æŒå¤šæ–‡ä»¶ä¸€æ¬¡æ€§å¯¼å…¥
  function handleCharacterFileImport() {
    return new Promise(resolve => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.txt,.docx,.zip'; // æ”¯æŒ TXTã€DOCX å’Œ ZIP
      input.multiple = true; // æ”¯æŒå¤šæ–‡ä»¶é€‰æ‹©
      
      input.onchange = async e => {
        const files = Array.from(e.target.files);
        if (!files || files.length === 0) {
            resolve();
            return;
        }

        // åˆ†ç¦» ZIP æ–‡ä»¶å’Œæ™®é€šæ–‡ä»¶
        const zipFiles = files.filter(f => f.name.toLowerCase().endsWith('.zip'));
        const normalFiles = files.filter(f => !f.name.toLowerCase().endsWith('.zip'));
        
        // å…ˆå¤„ç† ZIP æ–‡ä»¶
        for (const zipFile of zipFiles) {
          try {
            await handleZipFileImport(zipFile);
          } catch (error) {
            console.error(`ZIPæ–‡ä»¶"${zipFile.name}"å¤„ç†å¤±è´¥:`, error);
            await showCustomAlert('ZIPæ–‡ä»¶å¤„ç†å¤±è´¥', `æ–‡ä»¶"${zipFile.name}"å¤„ç†å¤±è´¥: ${error.message}`);
          }
        }
        
        // å¦‚æœæ²¡æœ‰æ™®é€šæ–‡ä»¶ï¼Œç›´æ¥ç»“æŸ
        if (normalFiles.length === 0) {
          resolve();
          return;
        }

        let importedCount = 0;
        let skippedCount = 0;
        let failedCount = 0;
        
        // é€ä¸ªå¤„ç†æ™®é€šæ–‡ä»¶
        for (let i = 0; i < normalFiles.length; i++) {
          const file = normalFiles[i];
          
          try {
              // è§£ææ–‡ä»¶å†…å®¹
              const textContent = await processCharacterFile(file);
              
              if (!textContent || !textContent.trim()) {
                  await showCustomAlert('æ–‡ä»¶å†…å®¹ä¸ºç©º', `æ–‡ä»¶"${file.name}"å†…å®¹ä¸ºç©ºæˆ–æ— æ³•è§£æï¼Œå·²è·³è¿‡ã€‚`);
                  skippedCount++;
                  continue;
              }

              // æ˜¾ç¤ºå†…å®¹ç¡®è®¤å¼¹çª—ï¼ˆå¸¦æ–‡ä»¶åå’Œè¿›åº¦ï¼‰
              const action = await showMultiFileContentConfirmModal(
                textContent, 
                file.name, 
                i + 1, 
                normalFiles.length
              );
              
              if (action === 'cancel') {
                  // ç”¨æˆ·é€‰æ‹©å–æ¶ˆæ•´ä¸ªå¯¼å…¥æµç¨‹
                  break;
              } else if (action === 'skip') {
                  // è·³è¿‡å½“å‰æ–‡ä»¶ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
                  skippedCount++;
                  continue;
              }

              // è¿›å…¥æ‰‹åŠ¨åˆ›å»ºæµç¨‹
              const remarkName = await showCustomPrompt(
                `åˆ›å»ºè§’è‰² [${i + 1}/${normalFiles.length}] (ç¬¬1/2æ­¥)`, 
                `æ–‡ä»¶: ${file.name}\n\nè¯·è¾“å…¥ä½ æƒ³ä¸ºTaè®¾ç½®çš„ã€å¤‡æ³¨åã€‘`
              );
              if (!remarkName || !remarkName.trim()) {
                  skippedCount++;
                  continue;
              }

              const originalName = await showCustomPrompt(
                `åˆ›å»ºè§’è‰² [${i + 1}/${normalFiles.length}] (ç¬¬2/2æ­¥)`, 
                `æ–‡ä»¶: ${file.name}\n\nè¯·è¾“å…¥Taçš„ã€æœ¬åã€‘`
              );
              if (!originalName || !originalName.trim()) {
                  skippedCount++;
                  continue;
              }

              // åˆ›å»ºæ–°èŠå¤©ï¼ŒaiPersona ä½¿ç”¨å¯¼å…¥çš„å†…å®¹
              const newChatId = 'chat_' + Date.now() + '_' + i; // æ·»åŠ ç´¢å¼•é¿å…IDå†²çª
              const newChat = {
                id: newChatId,
                name: remarkName.trim(),
                originalName: originalName.trim(),
                isGroup: false,
                isPinned: false,
                unreadCount: 0,
                country: 'China', // é»˜è®¤ä¸­å›½ï¼Œåç»­å¯ä»¥è‡ªåŠ¨è¯†åˆ«æˆ–æ‰‹åŠ¨ä¿®æ”¹
                relationship: {
                  status: 'friend',
                  blockedTimestamp: null,
                  applicationReason: ''
                },
                status: {
                  text: 'åœ¨çº¿',
                  lastUpdate: Date.now(),
                  isBusy: false
                },
          settings: {
            aiPersona: textContent.trim(), // ä½¿ç”¨å¯¼å…¥çš„å†…å®¹ä½œä¸ºå¯¹æ–¹äººè®¾
            myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
            myNickname: 'æˆ‘',
            maxMemory: 10,
            aiAvatar: defaultAvatar,
            myAvatar: defaultAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarLibrary: [],
            myAvatarLibrary: [],
            enableBackgroundActivity: true,
            actionCooldownMinutes: 15,
            enableTimePerception: true,
            isOfflineMode: false,
            offlineMinLength: 100,
            offlineMaxLength: 300,
            offlinePresetId: null,
            timeZone: 'Asia/Shanghai',
            myPhoneLockScreenEnabled: false,
            myPhoneLockScreenPassword: '',
            userStatus: {
              text: 'åœ¨çº¿',
              lastUpdate: Date.now(),
              isBusy: false
            }
          },
                history: [],
                musicData: {
                  totalTime: 0
                },
                longTermMemory: [],
                thoughtsHistory: []
              };
              
              state.chats[newChatId] = newChat;
              await db.chats.put(newChat);
              importedCount++;
              
              // æ¯å¯¼å…¥ä¸€ä¸ªååˆ·æ–°åˆ—è¡¨
              renderChatList();
              
          } catch (error) {
              console.error(`æ–‡ä»¶"${file.name}"å¯¼å…¥å¤±è´¥:`, error);
              await showCustomAlert('æ–‡ä»¶å¯¼å…¥å¤±è´¥', `æ–‡ä»¶"${file.name}"è§£æå¤±è´¥: ${error.message}`);
              failedCount++;
          }
        }
        
        // æ˜¾ç¤ºæ€»ç»“ä¿¡æ¯
        if (importedCount > 0 || skippedCount > 0 || failedCount > 0) {
          let summary = `å¯¼å…¥å®Œæˆï¼\n\n`;
          if (importedCount > 0) summary += `âœ“ æˆåŠŸå¯¼å…¥: ${importedCount} ä¸ªè§’è‰²\n`;
          if (skippedCount > 0) summary += `â—‹ å·²è·³è¿‡: ${skippedCount} ä¸ªæ–‡ä»¶\n`;
          if (failedCount > 0) summary += `âœ— å¤±è´¥: ${failedCount} ä¸ªæ–‡ä»¶\n`;
          
          await showCustomAlert('æ‰¹é‡å¯¼å…¥ç»“æœ', summary);
        }
        
        resolve();
      };
      
      input.click();
    });
  }

  // è§£æè§’è‰²æ–‡ä»¶å†…å®¹ (æ”¯æŒ .txt å’Œ .docx)
  async function processCharacterFile(file) {
      const fileName = file.name.toLowerCase();

      // å¤„ç† .txt æ–‡ä»¶
      if (fileName.endsWith('.txt')) {
          return await file.text();
      }

      // å¤„ç† .docx æ–‡ä»¶ (ä¾èµ– mammoth.js)
      if (fileName.endsWith('.docx')) {
          if (typeof mammoth === 'undefined') {
              throw new Error("æœªåŠ è½½ mammoth.js åº“ï¼Œæ— æ³•è¯»å– Word æ–‡æ¡£ã€‚");
          }
          
          const arrayBuffer = await file.arrayBuffer();
          
          try {
              // æ–¹æ¡ˆ 1: å°è¯•æå–çº¯æ–‡æœ¬
              const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
              
              if (result.value && result.value.trim()) {
                  return result.value;
              }
              
              // å¦‚æœçº¯æ–‡æœ¬ä¸ºç©ºï¼Œå°è¯•è½¬æ¢ä¸º HTML å†æå–
              const htmlResult = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
              if (htmlResult.value) {
                  // ç®€å•ç§»é™¤ HTML æ ‡ç­¾
                  const textContent = htmlResult.value.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                  if (textContent) {
                      return textContent;
                  }
              }
              
              throw new Error("DOCX æ–‡ä»¶å†…å®¹ä¸ºç©º");
              
          } catch (error) {
              console.error("DOCX è§£æé”™è¯¯:", error);
              // æä¾›æ›´å‹å¥½çš„é”™è¯¯æç¤º
              throw new Error(
                  "æ— æ³•è§£ææ­¤ DOCX æ–‡ä»¶ï¼Œå¯èƒ½åŸå› ï¼š\n" +
                  "1. æ–‡ä»¶æŸåæˆ–æ ¼å¼ä¸æ ‡å‡†\n" +
                  "2. æ–‡ä»¶ä½¿ç”¨äº†ä¸å…¼å®¹çš„ Word åŠŸèƒ½\n\n" +
                  "å»ºè®®è§£å†³æ–¹æ¡ˆï¼š\n" +
                  "â€¢ ç”¨ Word æ‰“å¼€æ–‡ä»¶ï¼Œå¦å­˜ä¸ºæ–°çš„ .docx\n" +
                  "â€¢ æˆ–è€…å¦å­˜ä¸º .txt çº¯æ–‡æœ¬æ ¼å¼åå†å¯¼å…¥"
              );
          }
      }

      // ç‰¹åˆ«æç¤ºï¼šä¸æ”¯æŒæ—§ç‰ˆ .doc æ ¼å¼
      if (fileName.endsWith('.doc')) {
          throw new Error("ä¸æ”¯æŒæ—§ç‰ˆ .doc æ ¼å¼ï¼Œè¯·å°†æ–‡ä»¶å¦å­˜ä¸º .docx æˆ– .txt æ ¼å¼åå†å¯¼å…¥ã€‚");
      }

      throw new Error("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œä»…æ”¯æŒ .txt å’Œ .docx");
  }

  // å¤„ç†ZIPæ–‡ä»¶å¯¼å…¥
  async function handleZipFileImport(zipFile) {
    try {
      // æ£€æŸ¥JSZipæ˜¯å¦å¯ç”¨
      if (typeof JSZip === 'undefined') {
        throw new Error("æœªåŠ è½½ JSZip åº“ï¼Œæ— æ³•è§£æ ZIP æ–‡ä»¶ã€‚");
      }

      // è¯»å–ZIPæ–‡ä»¶
      const zip = await JSZip.loadAsync(zipFile);
      
      // æå–æ‰€æœ‰ .txt å’Œ .docx æ–‡ä»¶
      const fileEntries = [];
      
      for (const [filename, zipEntry] of Object.entries(zip.files)) {
        // è·³è¿‡ç›®å½•å’Œéšè—æ–‡ä»¶
        if (zipEntry.dir || filename.startsWith('__MACOSX') || filename.startsWith('.')) {
          continue;
        }
        
        const lowerName = filename.toLowerCase();
        if (lowerName.endsWith('.txt') || lowerName.endsWith('.docx')) {
          fileEntries.push({
            filename: filename,
            zipEntry: zipEntry,
            type: lowerName.endsWith('.txt') ? 'txt' : 'docx'
          });
        }
      }
      
      if (fileEntries.length === 0) {
        await showCustomAlert('ZIPæ–‡ä»¶ä¸ºç©º', `ZIPæ–‡ä»¶"${zipFile.name}"ä¸­æ²¡æœ‰æ‰¾åˆ° .txt æˆ– .docx æ–‡ä»¶ã€‚`);
        return;
      }
      
      // æ˜¾ç¤ºæ–‡ä»¶é€‰æ‹©ç•Œé¢
      const selectedFiles = await showZipFileSelectionModal(fileEntries, zipFile.name);
      
      if (!selectedFiles || selectedFiles.length === 0) {
        return; // ç”¨æˆ·å–æ¶ˆæˆ–æ²¡æœ‰é€‰æ‹©ä»»ä½•æ–‡ä»¶
      }
      
      // å¤„ç†é€‰ä¸­çš„æ–‡ä»¶
      let importedCount = 0;
      let skippedCount = 0;
      let failedCount = 0;
      
      for (let i = 0; i < selectedFiles.length; i++) {
        const entry = selectedFiles[i];
        
        try {
          // è§£ææ–‡ä»¶å†…å®¹
          let textContent;
          
          if (entry.type === 'txt') {
            // è¯»å–TXTæ–‡ä»¶
            textContent = await entry.zipEntry.async('text');
          } else if (entry.type === 'docx') {
            // è¯»å–DOCXæ–‡ä»¶
            if (typeof mammoth === 'undefined') {
              throw new Error("æœªåŠ è½½ mammoth.js åº“ï¼Œæ— æ³•è¯»å– Word æ–‡æ¡£ã€‚");
            }
            
            const arrayBuffer = await entry.zipEntry.async('arraybuffer');
            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
            
            if (result.value && result.value.trim()) {
              textContent = result.value;
            } else {
              // å°è¯•è½¬æ¢ä¸ºHTMLå†æå–
              const htmlResult = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
              textContent = htmlResult.value.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
            }
          }
          
          if (!textContent || !textContent.trim()) {
            await showCustomAlert('æ–‡ä»¶å†…å®¹ä¸ºç©º', `æ–‡ä»¶"${entry.filename}"å†…å®¹ä¸ºç©ºæˆ–æ— æ³•è§£æï¼Œå·²è·³è¿‡ã€‚`);
            skippedCount++;
            continue;
          }
          
          // æ˜¾ç¤ºå†…å®¹ç¡®è®¤å¼¹çª—
          const action = await showMultiFileContentConfirmModal(
            textContent,
            entry.filename,
            i + 1,
            selectedFiles.length
          );
          
          if (action === 'cancel') {
            break;
          } else if (action === 'skip') {
            skippedCount++;
            continue;
          }
          
          // åˆ›å»ºè§’è‰²æµç¨‹
          const remarkName = await showCustomPrompt(
            `åˆ›å»ºè§’è‰² [${i + 1}/${selectedFiles.length}] (ç¬¬1/2æ­¥)`,
            `æ–‡ä»¶: ${entry.filename}\n\nè¯·è¾“å…¥ä½ æƒ³ä¸ºTaè®¾ç½®çš„ã€å¤‡æ³¨åã€‘`
          );
          
          if (!remarkName || !remarkName.trim()) {
            skippedCount++;
            continue;
          }
          
          const originalName = await showCustomPrompt(
            `åˆ›å»ºè§’è‰² [${i + 1}/${selectedFiles.length}] (ç¬¬2/2æ­¥)`,
            `æ–‡ä»¶: ${entry.filename}\n\nè¯·è¾“å…¥Taçš„ã€æœ¬åã€‘`
          );
          
          if (!originalName || !originalName.trim()) {
            skippedCount++;
            continue;
          }
          
          // åˆ›å»ºæ–°èŠå¤©
          const newChatId = 'chat_' + Date.now() + '_' + i;
          const newChat = {
            id: newChatId,
            name: remarkName.trim(),
            originalName: originalName.trim(),
            isGroup: false,
            isPinned: false,
            unreadCount: 0,
            country: 'China', // é»˜è®¤ä¸­å›½ï¼Œåç»­å¯ä»¥è‡ªåŠ¨è¯†åˆ«æˆ–æ‰‹åŠ¨ä¿®æ”¹
            relationship: {
              status: 'friend',
              blockedTimestamp: null,
              applicationReason: ''
            },
            status: {
              text: 'åœ¨çº¿',
              lastUpdate: Date.now(),
              isBusy: false
            },
            settings: {
              aiPersona: textContent.trim(),
              myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
              myNickname: 'æˆ‘',
              maxMemory: 10,
              aiAvatar: defaultAvatar,
              myAvatar: defaultAvatar,
              background: '',
              theme: 'default',
              fontSize: 13,
              customCss: '',
              linkedWorldBookIds: [],
              aiAvatarLibrary: [],
              myAvatarLibrary: [],
              enableBackgroundActivity: true,
              actionCooldownMinutes: 15,
              enableTimePerception: true,
              isOfflineMode: false,
              offlineMinLength: 100,
              offlineMaxLength: 300,
              offlinePresetId: null,
              timeZone: 'Asia/Shanghai',
              userStatus: {
                text: 'åœ¨çº¿',
                lastUpdate: Date.now(),
                isBusy: false
              }
            },
            history: [],
            musicData: {
              totalTime: 0
            },
            longTermMemory: [],
            thoughtsHistory: []
          };
          
          state.chats[newChatId] = newChat;
          await db.chats.put(newChat);
          importedCount++;
          renderChatList();
          
        } catch (error) {
          console.error(`æ–‡ä»¶"${entry.filename}"å¯¼å…¥å¤±è´¥:`, error);
          await showCustomAlert('æ–‡ä»¶å¯¼å…¥å¤±è´¥', `æ–‡ä»¶"${entry.filename}"è§£æå¤±è´¥: ${error.message}`);
          failedCount++;
        }
      }
      
      // æ˜¾ç¤ºæ€»ç»“
      if (importedCount > 0 || skippedCount > 0 || failedCount > 0) {
        let summary = `ZIPæ–‡ä»¶å¯¼å…¥å®Œæˆï¼\n\n`;
        if (importedCount > 0) summary += `âœ“ æˆåŠŸå¯¼å…¥: ${importedCount} ä¸ªè§’è‰²\n`;
        if (skippedCount > 0) summary += `â—‹ å·²è·³è¿‡: ${skippedCount} ä¸ªæ–‡ä»¶\n`;
        if (failedCount > 0) summary += `âœ— å¤±è´¥: ${failedCount} ä¸ªæ–‡ä»¶\n`;
        
        await showCustomAlert('ZIPå¯¼å…¥ç»“æœ', summary);
      }
      
    } catch (error) {
      console.error('ZIPæ–‡ä»¶å¤„ç†å¤±è´¥:', error);
      throw error;
    }
  }

  // æ˜¾ç¤ºZIPæ–‡ä»¶é€‰æ‹©ç•Œé¢
  function showZipFileSelectionModal(fileEntries, zipFileName) {
    return new Promise(resolve => {
      const modal = document.createElement('div');
      modal.className = 'custom-modal';
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = 'background: white; border-radius: 12px; padding: 20px; max-width: 600px; width: 90%; max-height: 80vh; display: flex; flex-direction: column;';
      
      const title = document.createElement('h3');
      title.textContent = 'ZIPæ–‡ä»¶å¯¼å…¥ - é€‰æ‹©æ–‡ä»¶';
      title.style.cssText = 'margin: 0 0 10px 0; font-size: 18px; text-align: center; color: #333;';
      
      const zipNameLabel = document.createElement('p');
      zipNameLabel.textContent = `ğŸ“¦ ${zipFileName}`;
      zipNameLabel.style.cssText = 'margin: 0 0 15px 0; text-align: center; font-size: 13px; color: #666; background: #f0f0f0; padding: 8px; border-radius: 6px; font-weight: 500;';
      
      const infoText = document.createElement('p');
      infoText.textContent = `æ‰¾åˆ° ${fileEntries.length} ä¸ªå¯å¯¼å…¥çš„æ–‡ä»¶ï¼Œè¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶ï¼š`;
      infoText.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; color: #555;';
      
      // å…¨é€‰/å–æ¶ˆå…¨é€‰æŒ‰é’®
      const selectAllContainer = document.createElement('div');
      selectAllContainer.style.cssText = 'display: flex; gap: 8px; margin-bottom: 12px; justify-content: flex-end;';
      
      const selectAllBtn = document.createElement('button');
      selectAllBtn.textContent = 'å…¨é€‰';
      selectAllBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #007AFF; border-radius: 6px; background: white; color: #007AFF; font-size: 13px; cursor: pointer;';
      
      const deselectAllBtn = document.createElement('button');
      deselectAllBtn.textContent = 'å–æ¶ˆå…¨é€‰';
      deselectAllBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #999; border-radius: 6px; background: white; color: #666; font-size: 13px; cursor: pointer;';
      
      selectAllContainer.appendChild(selectAllBtn);
      selectAllContainer.appendChild(deselectAllBtn);
      
      // æ–‡ä»¶åˆ—è¡¨å®¹å™¨
      const fileListContainer = document.createElement('div');
      fileListContainer.style.cssText = 'flex: 1; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px; margin-bottom: 15px; background: #fafafa; max-height: 400px;';
      
      const checkboxes = [];
      
      // åˆ›å»ºæ–‡ä»¶åˆ—è¡¨é¡¹
      fileEntries.forEach((entry, index) => {
        const fileItem = document.createElement('label');
        fileItem.style.cssText = 'display: flex; align-items: center; padding: 10px; margin-bottom: 6px; background: white; border-radius: 6px; cursor: pointer; border: 1px solid #e0e0e0; transition: background 0.2s;';
        
        fileItem.onmouseover = () => fileItem.style.background = '#f0f8ff';
        fileItem.onmouseout = () => fileItem.style.background = 'white';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true; // é»˜è®¤å…¨é€‰
        checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
        checkboxes.push(checkbox);
        
        const fileIcon = document.createElement('span');
        fileIcon.textContent = entry.type === 'txt' ? 'ğŸ“„' : 'ğŸ“';
        fileIcon.style.cssText = 'font-size: 18px; margin-right: 8px;';
        
        const fileName = document.createElement('span');
        fileName.textContent = entry.filename;
        fileName.style.cssText = 'flex: 1; font-size: 13px; color: #333; word-break: break-all;';
        
        const fileType = document.createElement('span');
        fileType.textContent = `.${entry.type}`;
        fileType.style.cssText = 'font-size: 11px; color: #999; background: #f0f0f0; padding: 2px 6px; border-radius: 4px; margin-left: 8px;';
        
        fileItem.appendChild(checkbox);
        fileItem.appendChild(fileIcon);
        fileItem.appendChild(fileName);
        fileItem.appendChild(fileType);
        
        fileListContainer.appendChild(fileItem);
      });
      
      // å…¨é€‰æŒ‰é’®äº‹ä»¶
      selectAllBtn.onclick = () => {
        checkboxes.forEach(cb => cb.checked = true);
      };
      
      // å–æ¶ˆå…¨é€‰æŒ‰é’®äº‹ä»¶
      deselectAllBtn.onclick = () => {
        checkboxes.forEach(cb => cb.checked = false);
      };
      
      // è®¡æ•°æ˜¾ç¤º
      const countLabel = document.createElement('p');
      countLabel.style.cssText = 'margin: 0 0 15px 0; text-align: center; font-size: 13px; color: #666;';
      
      const updateCount = () => {
        const selectedCount = checkboxes.filter(cb => cb.checked).length;
        countLabel.textContent = `å·²é€‰æ‹© ${selectedCount} / ${fileEntries.length} ä¸ªæ–‡ä»¶`;
      };
      
      checkboxes.forEach(cb => cb.addEventListener('change', updateCount));
      updateCount();
      
      // æŒ‰é’®å®¹å™¨
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = 'display: flex; gap: 10px;';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'å–æ¶ˆ';
      cancelBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #ddd; font-size: 16px; cursor: pointer;';
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(null);
      };
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'ç¡®è®¤å¯¼å…¥';
      confirmBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #007AFF; color: white; font-size: 16px; cursor: pointer;';
      confirmBtn.onclick = () => {
        const selectedFiles = fileEntries.filter((entry, index) => checkboxes[index].checked);
        
        if (selectedFiles.length === 0) {
          alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼');
          return;
        }
        
        document.body.removeChild(modal);
        resolve(selectedFiles);
      };
      
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
      
      modalContent.appendChild(title);
      modalContent.appendChild(zipNameLabel);
      modalContent.appendChild(infoText);
      modalContent.appendChild(selectAllContainer);
      modalContent.appendChild(fileListContainer);
      modalContent.appendChild(countLabel);
      modalContent.appendChild(buttonContainer);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
    });
  }

  // æ˜¾ç¤ºå†…å®¹ç¡®è®¤å¼¹çª—
  function showContentConfirmModal(content) {
    return new Promise(resolve => {
      const modal = document.createElement('div');
      modal.className = 'custom-modal';
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = 'background: white; border-radius: 12px; padding: 20px; max-width: 500px; width: 90%; max-height: 70vh; display: flex; flex-direction: column;';
      
      const title = document.createElement('h3');
      title.textContent = 'å†…å®¹ç¡®è®¤';
      title.style.cssText = 'margin: 0 0 15px 0; font-size: 18px; text-align: center;';
      
      const contentBox = document.createElement('div');
      contentBox.style.cssText = 'flex: 1; overflow-y: auto; background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px; white-space: pre-wrap; word-wrap: break-word; font-size: 14px; line-height: 1.6; max-height: 400px;';
      contentBox.textContent = content;
      
      const question = document.createElement('p');
      question.textContent = 'æ˜¯å¦å°†ä»¥ä¸Šå†…å®¹å®Œå…¨å¡«å…¥åˆ°å¯¹æ–¹äººè®¾ä¸­ï¼Ÿ';
      question.style.cssText = 'margin: 0 0 15px 0; text-align: center; font-size: 15px;';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = 'display: flex; gap: 10px;';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'å–æ¶ˆ';
      cancelBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #ddd; font-size: 16px; cursor: pointer;';
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(false);
      };
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'ç¡®å®š';
      confirmBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #007AFF; color: white; font-size: 16px; cursor: pointer;';
      confirmBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve(true);
      };
      
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
      
      modalContent.appendChild(title);
      modalContent.appendChild(contentBox);
      modalContent.appendChild(question);
      modalContent.appendChild(buttonContainer);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
    });
  }

  // å¤šæ–‡ä»¶å¯¼å…¥ä¸“ç”¨çš„å†…å®¹ç¡®è®¤å¼¹çª—ï¼ˆæ”¯æŒè·³è¿‡ï¼‰
  function showMultiFileContentConfirmModal(content, fileName, currentIndex, totalCount) {
    return new Promise(resolve => {
      const modal = document.createElement('div');
      modal.className = 'custom-modal';
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = 'background: white; border-radius: 12px; padding: 20px; max-width: 550px; width: 90%; max-height: 75vh; display: flex; flex-direction: column;';
      
      const title = document.createElement('h3');
      title.textContent = `æ–‡ä»¶å†…å®¹ç¡®è®¤ [${currentIndex}/${totalCount}]`;
      title.style.cssText = 'margin: 0 0 10px 0; font-size: 18px; text-align: center; color: #333;';
      
      const fileNameLabel = document.createElement('p');
      fileNameLabel.textContent = `ğŸ“„ ${fileName}`;
      fileNameLabel.style.cssText = 'margin: 0 0 15px 0; text-align: center; font-size: 13px; color: #666; background: #f0f0f0; padding: 8px; border-radius: 6px; font-weight: 500;';
      
      const contentBox = document.createElement('div');
      contentBox.style.cssText = 'flex: 1; overflow-y: auto; background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 15px; white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.6; max-height: 400px; border: 1px solid #e0e0e0;';
      contentBox.textContent = content;
      
      const question = document.createElement('p');
      question.innerHTML = 'æ˜¯å¦å°†ä»¥ä¸Šå†…å®¹å¡«å…¥åˆ°<strong>å¯¹æ–¹äººè®¾</strong>ä¸­ï¼Ÿ';
      question.style.cssText = 'margin: 0 0 15px 0; text-align: center; font-size: 15px; color: #444;';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = 'display: flex; gap: 8px;';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'å–æ¶ˆå…¨éƒ¨';
      cancelBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #e74c3c; color: white; font-size: 15px; cursor: pointer; transition: background 0.2s;';
      cancelBtn.onmouseover = () => cancelBtn.style.background = '#c0392b';
      cancelBtn.onmouseout = () => cancelBtn.style.background = '#e74c3c';
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve('cancel');
      };
      
      const skipBtn = document.createElement('button');
      skipBtn.textContent = 'è·³è¿‡æ­¤æ–‡ä»¶';
      skipBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #95a5a6; color: white; font-size: 15px; cursor: pointer; transition: background 0.2s;';
      skipBtn.onmouseover = () => skipBtn.style.background = '#7f8c8d';
      skipBtn.onmouseout = () => skipBtn.style.background = '#95a5a6';
      skipBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve('skip');
      };
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'ç¡®å®šå¯¼å…¥';
      confirmBtn.style.cssText = 'flex: 1; padding: 12px; border: none; border-radius: 8px; background: #27ae60; color: white; font-size: 15px; cursor: pointer; transition: background 0.2s; font-weight: 600;';
      confirmBtn.onmouseover = () => confirmBtn.style.background = '#229954';
      confirmBtn.onmouseout = () => confirmBtn.style.background = '#27ae60';
      confirmBtn.onclick = () => {
        document.body.removeChild(modal);
        resolve('confirm');
      };
      
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(skipBtn);
      buttonContainer.appendChild(confirmBtn);
      
      modalContent.appendChild(title);
      modalContent.appendChild(fileNameLabel);
      modalContent.appendChild(contentBox);
      modalContent.appendChild(question);
      modalContent.appendChild(buttonContainer);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // æ”¯æŒé”®ç›˜å¿«æ·é”®
      const keyHandler = (e) => {
        if (e.key === 'Escape') {
          document.body.removeChild(modal);
          document.removeEventListener('keydown', keyHandler);
          resolve('skip');
        }
      };
      document.addEventListener('keydown', keyHandler);
    });
  }

  function scrollToOriginalMessage(originalTimestamp) {
    const selector = `.message-bubble[data-timestamp="${originalTimestamp}"]`;
    const originalMessageBubble = document.querySelector(selector);

    if (originalMessageBubble) {
      originalMessageBubble.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });

      originalMessageBubble.classList.add('highlighted');
      setTimeout(() => {
        if (document.body.contains(originalMessageBubble)) {
          originalMessageBubble.classList.remove('highlighted');
        }
      }, 1500);

    } else {

      alert("æ‰¾ä¸åˆ°åŸå§‹æ¶ˆæ¯ã€‚å¯èƒ½å·²è¢«åˆ é™¤æˆ–ä½äºæ›´æ—©çš„å†å²è®°å½•ä¸­ã€‚");
    }
  }
  async function createMessageElement(msg, chat) {

    // ã€ä¸»å±å¹•QQ undefinedè¿‡æ»¤ã€‘å¦‚æœæ˜¯AIæ¶ˆæ¯ä¸”å†…å®¹ä¸ºç©ºæˆ–undefinedï¼Œç›´æ¥è¿”å›nullä¸æ˜¾ç¤º
    if (msg.role === 'assistant' && msg.type !== 'recalled_message' && msg.type !== 'post_deleted_notice' && 
        msg.type !== 'narration' && msg.type !== 'pat_message' && !msg.type?.startsWith('waimai_') && 
        msg.type !== 'red_packet' && msg.type !== 'transfer' && msg.type !== 'poll' && msg.type !== 'gift' && 
        msg.type !== 'kinship_request' && msg.type !== 'synth_music') {
      const contentStr = String(msg.content || '').trim().toLowerCase();
      if (contentStr === '' || contentStr === 'undefined') {
        console.log('[QQ Undefinedè¿‡æ»¤] å·²è¿‡æ»¤ç©ºæ¶ˆæ¯æˆ–undefinedæ¶ˆæ¯:', msg);
        return null;
      }
    }

    if (msg.type === 'recalled_message') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      wrapper.dataset.timestamp = msg.timestamp;
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble recalled-message-placeholder';
      bubble.dataset.timestamp = msg.timestamp;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) {
          toggleMessageSelection(msg.timestamp);
        }
      });
      return wrapper;
    } else if (msg.type === 'post_deleted_notice') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      wrapper.dataset.timestamp = msg.timestamp;
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble post-deleted-placeholder';
      bubble.dataset.postId = msg.postId;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) {
          toggleMessageSelection(msg.timestamp);
        }
      });
      return wrapper;
    }

    if (msg.isHidden && !chat.settings.showHiddenMessages) {
      return null;
    }
    if (msg.type === 'narration') {
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper system-pat'; // å¤ç”¨ç³»ç»Ÿæ¶ˆæ¯æ ·å¼(å±…ä¸­ç°è‰²)
    wrapper.dataset.timestamp = msg.timestamp; // å…³é”®ï¼šå¿…é¡»æœ‰æ—¶é—´æˆ³æ‰èƒ½ç¼–è¾‘/åˆ é™¤
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble system-bubble';
    // å¯ä»¥åŠ ä¸ªå›¾æ ‡è®©å®ƒå’Œæ™®é€šæ‹ä¸€æ‹åŒºåˆ†å¼€ï¼Œä¹Ÿå¯ä»¥ä¸åŠ 
    bubble.innerHTML = `<span style="font-style:italic; opacity: 0.9;">${msg.content}</span>`; 
    bubble.dataset.timestamp = msg.timestamp;
    
    wrapper.appendChild(bubble);
    
    // ã€å…³é”®ã€‘æ·»åŠ é•¿æŒ‰ç›‘å¬ï¼Œå®ç°åˆ é™¤/ç¼–è¾‘åŠŸèƒ½
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    
    // æ”¯æŒå¤šé€‰
    wrapper.addEventListener('click', () => {
        if (isSelectionMode) toggleMessageSelection(msg.timestamp);
    });
    
    return wrapper;
}
    if (msg.type === 'pat_message') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble system-bubble';
      bubble.dataset.timestamp = msg.timestamp;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) toggleMessageSelection(msg.timestamp);
      });
      return wrapper;
    }


    const isUser = msg.role === 'user';
    const myNickname = chat.settings.myNickname || 'æˆ‘';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
    if (msg.isHidden) {
        wrapper.classList.add('hidden-revealed');
    }
    if (chat.isGroup && !isUser) {
      const member = chat.members.find(m => m.originalName === msg.senderName);
      const senderNameDiv = document.createElement('div');
      senderNameDiv.className = 'sender-name';
      senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || 'æœªçŸ¥æˆå‘˜');
      wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp, chat.id);

    let avatarSrc, avatarFrameSrc = '';
    if (isUser) {
      avatarSrc = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      avatarFrameSrc = chat.settings.myAvatarFrame || '';
    } else {
      if (chat.isGroup) {
        const member = chat.members.find(m => m.originalName === msg.senderName);
        if (member) {
          const characterProfile = state.chats[member.id];
          avatarSrc = member.avatar || (characterProfile ? characterProfile.settings.aiAvatar : defaultGroupMemberAvatar);
          avatarFrameSrc = member.avatarFrame || (characterProfile ? characterProfile.settings.aiAvatarFrame : '');
        } else {
          avatarSrc = defaultGroupMemberAvatar;
          avatarFrameSrc = '';
        }
      } else {
        avatarSrc = chat.settings.aiAvatar || defaultAvatar;
        avatarFrameSrc = chat.settings.aiAvatarFrame || '';
      }
    }

    let avatarHtml;
    if (avatarFrameSrc) {
      avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
    } else {
      avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
    const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

    let contentHtml;
    let quoteHtml = '';
    if (msg.quote) {
      const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
      const fullQuotedContent = String(msg.quote.content || '');
      quoteHtml = `
                    <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
                        <div class="quoted-sender">å›å¤ ${quotedSenderDisplayName}:</div>
                        <div class="quoted-content">${fullQuotedContent}</div>
                    </div>
                `;
    }





    let rawContent = msg.content;

    if (typeof rawContent === 'string' && rawContent.trim().startsWith('<') && rawContent.trim().endsWith('>')) {
      contentHtml = rawContent;
      bubble.classList.add('is-raw-html');
    } else if (msg.type === 'offline_text' || msg.type === 'share_link' || msg.type === 'share_card' || msg.type === 'location_share' || msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'voice_message' || msg.type === 'transfer' || msg.type === 'waimai_request' || msg.type === 'waimai_order' || msg.type === 'red_packet' || msg.type === 'poll' || msg.type === 'gift' || msg.type === 'realimag' || msg.type === 'naiimag' || msg.type === 'kinship_request' || msg.type === 'forwarded_email' || msg.type === 'reddit_share') {

      if (msg.type === 'offline_text') {

        const combinedText = msg.content || `${msg.dialogue || ''} ${msg.description || ''}`.trim();


        const regex = /(ã€Œ.*?ã€|â€œ.*?â€)/g;
        const parts = combinedText.split(regex).filter(part => part);


        contentHtml = parts.map(part => {

          if (part.startsWith('ã€Œ') || part.startsWith('â€œ')) {
            return `<span class="offline-dialogue">${parseMarkdown(part)}</span>`;
          } else {

            return `<span class="offline-description">${parseMarkdown(part.trim()).replace(/\n/g, '<br>')}</span>`;
          }
        }).join('');
      } else if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share', 'is-card-like');
        contentHtml = `<div class="link-share-card" data-timestamp="${msg.timestamp}"><div class="title">${msg.title || 'æ— æ ‡é¢˜'}</div><div class="description">${msg.description || 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…...'}</div><div class="footer"><svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg><span>${msg.source_name || 'é“¾æ¥åˆ†äº«'}</span></div></div>`;
      }else if (msg.type === 'forwarded_email') {
        bubble.classList.add('is-card-like'); // å»é™¤æ°”æ³¡é»˜è®¤èƒŒæ™¯
        const data = msg.emailData || {};
        
        // å°†å®Œæ•´æ•°æ®å­˜å…¥ datasetï¼Œä»¥ä¾¿ç‚¹å‡»æ—¶è¯»å–
        const fullDataJson = encodeURIComponent(JSON.stringify(data));

        contentHtml = `
            <div class="email-share-card" data-email-json="${fullDataJson}">
                <div class="email-card-top">
                    <div class="email-icon-box">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                    </div>
                    <div class="email-card-header-text">
                        <div class="email-card-subject">${escapeHTML(data.subject)}</div>
                        <div class="email-card-sender">${escapeHTML(data.sender)}</div>
                    </div>
                </div>
                <div class="email-card-preview">${escapeHTML(data.preview)}...</div>
                <div class="email-card-footer">
                    <span>Mail é‚®ä»¶å¿«ç…§</span>
                    <span>æŸ¥çœ‹è¯¦æƒ… â€º</span>
                </div>
            </div>
        `;
    } else if (msg.type === 'reddit_share') {
        bubble.classList.add('is-card-like', 'is-reddit-card'); // ç¡®ä¿æ·»åŠ è¿™äº›ç±»å
        const data = msg.redditData;
        
        // å¤„ç†åˆ†æ•°çš„æ˜¾ç¤º (12.5k)
        const scoreDisplay = data.score > 1000 ? (data.score/1000).toFixed(1) + 'k' : data.score;
        
        contentHtml = `
    <div class="reddit-share-card">
        <div class="reddit-card-header">
                    <img src="https://www.redditinc.com/assets/images/site/reddit-logo.png" class="reddit-card-logo">
                    <span class="reddit-card-sub">${data.subreddit}</span>
                    <span class="reddit-card-user">â€¢ u/${data.author}</span>
                </div>
                <div class="reddit-card-body">
                    <div class="reddit-card-title">${escapeHTML(data.title)}</div>
                    ${data.image ? `<img src="${data.image}" class="reddit-card-img" loading="lazy">` : ''}
                    ${data.selftext ? `<div style="font-size:12px;color:#555;max-height:60px;overflow:hidden;">${escapeHTML(data.selftext)}</div>` : ''}
                </div>
                <div class="reddit-card-footer">
                    <span>â¬† ${scoreDisplay} èµ</span>
                    <span>ğŸ’¬ ${data.num_comments} è¯„è®º</span>
                </div>
            </div>
        `;
    }else if (msg.type === 'share_card') {
        bubble.classList.add('is-link-share', 'is-card-like');
        contentHtml = `<div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}"><div class="title">${msg.payload.title}</div><div class="description">å…± ${msg.payload.sharedHistory.length} æ¡æ¶ˆæ¯</div><div class="footer"><svg class="footer-icon" ...>...</svg><span>èŠå¤©è®°å½•</span></div></div>`;
      } else if (msg.type === 'location_share') {
        bubble.classList.add('is-location-share', 'is-card-like');
        let finalImageUrl;


        if (msg.imageUrl) {
          finalImageUrl = msg.imageUrl;
        } else if (state.globalSettings.enableAiDrawing && msg.image_prompt) {
          finalImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(msg.image_prompt)}`;
        } else {
          finalImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
        }

        const mapAreaStyle = `style="background-image: url('${finalImageUrl}');"`;
        contentHtml = `<div class="location-share-card"><div class="card-text-area"><div class="card-text-primary">${msg.content}</div><div class="card-text-secondary">ä½ç½®åˆ†äº«</div></div><div class="card-map-area" ${mapAreaStyle}><div class="card-pin-icon"><svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path><path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path></svg></div></div></div>`;
      } else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image', 'is-card-like');
        const altText = msg.type === 'user_photo' ? "ç”¨æˆ·æè¿°çš„ç…§ç‰‡" : "AIç”Ÿæˆçš„å›¾ç‰‡";


        const imageUrl = state.globalSettings.enableAiDrawing && msg.image_prompt ?
          `https://image.pollinations.ai/prompt/${msg.image_prompt}` :
          'https://i.postimg.cc/KYr2qRCK/1.jpg';


        contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
      } else if (msg.type === 'naiimag') {
        
        bubble.classList.add('is-realimag', 'is-card-like');
        contentHtml = `
                        <div class="nai-image-wrapper">
                            <img src="${msg.imageUrl}" class="realimag-image" alt="NovelAIå›¾ç‰‡åˆ†äº«" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='å›¾ç‰‡åŠ è½½å¤±è´¥';" title="${msg.fullPrompt || msg.prompt || 'NovelAIç”Ÿæˆ'}">
                            
                            <div class="bubble-image-controls"> 
                                <button class="nai-save-local-btn" title="ä¸‹è½½å›¾ç‰‡">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                                <button class="nai-upload-imgbb-btn" title="ä¸Šä¼ å›¾åºŠ" style="display: none;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                        <polyline points="17 8 12 3 7 8" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></polyline>
                                        <line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></line>
                                    </svg>
                                </button>
                                <button class="nai-regenerate-btn" title="é‡æ–°ç”Ÿæˆ">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                    </svg>
                                </button>
                                
                                
                            </div>
                        </div>
                    `;
      } else if (msg.type === 'voice_message') {
        bubble.classList.add('is-voice-message', 'is-card-like');
        const duration = Math.max(1, Math.round((msg.content || '').length / 5));
        const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
        const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

        if (isUser) {

          contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}">
                <div class="voice-waveform">${waveformHTML}</div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
        } else {



          const canPlayTTS = !chat.isGroup && chat.settings.enableTts !== false;


          const voiceId = chat.settings.minimaxVoiceId || 'female-shaonv-jingpin';


          const voiceIdAttribute = canPlayTTS ? `data-voice-id="${voiceId}"` : '';

          contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}" ${voiceIdAttribute}>
                <div class="voice-waveform">${waveformHTML}</div>
                <div class="loading-spinner"></div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
        }
      } else if (msg.type === 'transfer') {
        bubble.classList.add('is-transfer', 'is-card-like');
        let titleText, noteText;
        const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
        const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName || chat.name);
        if (isUser) {
          if (msg.isRefund) {
            titleText = `é€€æ¬¾ç»™ ${receiverDisplayName}`;
            noteText = 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦';
          }else if (msg.isReceived) {
            titleText = `å·²æ”¶æ¬¾`;
            noteText = 'å·²å­˜å…¥ä½™é¢';
          } else {
            titleText = `è½¬è´¦ç»™ ${receiverDisplayName}`;
            if (msg.status === 'accepted') noteText = 'å¯¹æ–¹å·²æ”¶æ¬¾';
            else if (msg.status === 'declined') noteText = 'å¯¹æ–¹å·²æ‹’æ”¶';
            else noteText = msg.note || 'ç­‰å¾…å¯¹æ–¹å¤„ç†...';
          }
        } else {
          if (msg.isReceived) {
            titleText = `å·²æ”¶æ¬¾`;
            noteText = 'å·²å­˜å…¥é‡‘åº“'; // æˆ–è€… 'å·²å­˜å…¥ä½™é¢'
          } 
          // â˜…â˜…â˜… æ–°å¢ç»“æŸ â˜…â˜…â˜…
          else if (msg.isRefund) {
            titleText = `é€€æ¬¾æ¥è‡ª ${senderDisplayName}`;
            noteText = 'è½¬è´¦å·²è¢«æ‹’æ”¶';
          } else if (msg.receiverName === myNickname) {
            titleText = `è½¬è´¦ç»™ ${myNickname}`;
            if (msg.status === 'accepted') noteText = 'ä½ å·²æ”¶æ¬¾';
            else if (msg.status === 'declined') noteText = 'ä½ å·²æ‹’æ”¶';
            else {
              bubble.style.cursor = 'pointer';
              bubble.dataset.status = 'pending';
              noteText = msg.note || 'ç‚¹å‡»å¤„ç†';
            }
          } else {
            titleText = `è½¬è´¦: ${senderDisplayName} â†’ ${receiverDisplayName}`;
            noteText = msg.note || 'ç¾¤èŠå†…è½¬è´¦';
          }
        }
        const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
        // æ ¹æ®å‘é€æ–¹å†³å®šè´§å¸æ˜¾ç¤º
        let currencySymbol = 'Â¥'; // é»˜è®¤äººæ°‘å¸
        if (!isUser) {
          // è§’è‰²å‘é€çš„è½¬è´¦ï¼Œæ˜¾ç¤ºè§’è‰²çš„è´§å¸
          const currency = getCurrencyForChat(chat);
          currencySymbol = currency.symbol;
        }
        // ç”¨æˆ·å‘é€çš„è½¬è´¦å§‹ç»ˆæ˜¾ç¤ºäººæ°‘å¸
        
        contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">${currencySymbol} ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
      } else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request', 'is-card-like');
        if (msg.status === 'paid' || msg.status === 'rejected') bubble.classList.add(`status-${msg.status}`);
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
        const requestTitle = `æ¥è‡ª ${senderDisplayName} çš„ä»£ä»˜è¯·æ±‚`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
          actionButtonsHtml = `<div class="waimai-user-actions"><button class="waimai-decline-btn" data-choice="rejected">æ®‹å¿æ‹’ç»</button><button class="waimai-pay-btn" data-choice="paid">ä¸ºTaä¹°å•</button></div>`;
        }
        contentHtml = `<div class="waimai-card"><div class="waimai-header"><img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon"><div class="title-group"><span class="brand">ç¾å›¢å¤–å–</span><span class="separator">|</span><span>å¤–å–ç¾é£Ÿ</span></div></div><div class="waimai-catchphrase">Hiï¼Œä½ å’Œæˆ‘çš„è·ç¦»åªå·®ä¸€é¡¿å¤–å–ï½</div><div class="waimai-main"><div class="request-title">${requestTitle}</div><div class="payment-box"><div class="payment-label">éœ€ä»˜æ¬¾</div><div class="amount">Â¥${Number(msg.amount).toFixed(2)}</div><div class="countdown-label">å‰©ä½™æ”¯ä»˜æ—¶é—´<div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div></div></div><button class="waimai-details-btn">æŸ¥çœ‹è¯¦æƒ…</button></div>${actionButtonsHtml}</div>`;
        setTimeout(() => {
          if (msg.status === 'pending') {
            const timerElement = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerElement) {
              const timerId = startWaimaiCountdown(timerElement, msg.countdownEndTime);

              waimaiTimers[msg.timestamp] = timerId;
            }
          }
        }, 0);
      } else if (msg.type === 'waimai_order') {
        bubble.classList.add('is-waimai-request', 'is-card-like');
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);

        let recipientDisplayName = 'ä½ ';
        if (chat.isGroup) {

          recipientDisplayName = getDisplayNameInGroup(chat, msg.recipientName);
        }

        contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group"><span class="brand">ç¾å›¢å¤–å–</span><span class="separator">|</span><span>å¤–å–ç¾é£Ÿ</span></div>
            </div>
            <div class="waimai-main">
                <div class="request-title" style="margin-bottom: 12px;">${senderDisplayName} å·²ä¸º${recipientDisplayName}ä¸‹å•ï¼Œè¯·æ…¢ç”¨ï½</div>
                <div class="payment-box">
                    <div class="payment-label" style="font-size: 18px; font-weight: 600;">${msg.productInfo}</div>
                    <div class="amount" style="margin-top: 8px;">Â¥${Number(msg.amount).toFixed(2)}</div>
                </div>
                <button class="waimai-details-btn">æŸ¥çœ‹è®¢å•è¯¦æƒ…</button>
            </div>
        </div>
    `;
      } else if (msg.type === 'red_packet') {
        bubble.classList.add('is-red-packet', 'is-card-like');
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        const isFinished = msg.isFullyClaimed;
        const hasClaimed = msg.claimedBy && msg.claimedBy[myOriginalName];
        let cardClass = '',
          claimedInfoHtml = '',
          typeText = 'æ‹¼æ‰‹æ°”çº¢åŒ…';
        if (isFinished) {
          cardClass = 'opened';
        }
        if (msg.packetType === 'direct') {
          const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName);
          typeText = `ä¸“å±çº¢åŒ…: ç»™ ${receiverDisplayName}`;
          if (Object.keys(msg.claimedBy || {}).length > 0) cardClass = 'opened';
        }
        if (hasClaimed) {
          const myClaimedAmount = msg.claimedBy[myOriginalName] || 0;
          claimedInfoHtml = `<div class="rp-claimed-info">ä½ é¢†å–äº†çº¢åŒ…ï¼Œé‡‘é¢ ${myClaimedAmount.toFixed(2)} å…ƒ</div>`;
        } else if (isFinished) {
          claimedInfoHtml = `<div class="rp-claimed-info">çº¢åŒ…å·²è¢«é¢†å®Œ</div>`;
        } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
          const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName);
          claimedInfoHtml = `<div class="rp-claimed-info">å·²è¢« ${receiverDisplayName} é¢†å–</div>`;
        }
        contentHtml = `<div class="red-packet-card ${cardClass}"><div class="rp-header"><img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon"><span class="rp-greeting">${msg.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼'}</span></div><div class="rp-type">${typeText}</div>${claimedInfoHtml}</div>`;
      } else if (msg.type === 'poll') {
        bubble.classList.add('is-poll', 'is-card-like');
        const pollQuestionText = msg.question || msg.content || '(æ— æ ‡é¢˜æŠ•ç¥¨)';
        let totalVotes = 0;
        const voteCounts = {};
        for (const option in msg.votes) {
          const count = msg.votes[option].length;
          voteCounts[option] = count;
          totalVotes += count;
        }
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        let myVote = null;
        for (const option in msg.votes) {
          if (msg.votes[option].includes(myOriginalName)) {
            myVote = option;
            break;
          }
        }
        let optionsHtml = '<div class="poll-options-list">';
        msg.options.forEach(optionText => {
          const count = voteCounts[optionText] || 0;
          const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
          const isVotedByMe = myVote === optionText;
          optionsHtml += `<div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}"><div class="poll-option-bar" style="width: ${percentage}%;"></div><div class="poll-option-content"><span class="poll-option-text">${optionText}</span><span class="poll-option-votes">${count} ç¥¨</span></div></div>`;
        });
        optionsHtml += '</div>';
        let footerHtml = msg.isClosed ? `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">æŸ¥çœ‹ç»“æœ</button></div>` : `<div class="poll-footer"><span class="poll-total-votes">å…± ${totalVotes} äººæŠ•ç¥¨</span><button class="poll-action-btn">ç»“æŸæŠ•ç¥¨</button></div>`;
        contentHtml = `<div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}"><div class="poll-question">${pollQuestionText}</div>${optionsHtml}${footerHtml}</div>`;
      } else if (msg.type === 'gift') {
        bubble.classList.add('is-gift', 'is-card-like');
        let headerText;
        const myNicknameForGift = chat.settings.myNickname || 'æˆ‘';
        if (chat.isGroup) {
          if (msg.recipients && msg.recipients.length > 0) {
            const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName));
            if (recipientDisplayNames.length === 1) {
              headerText = `é€ç»™ ${recipientDisplayNames[0]} çš„ç¤¼ç‰©`;
            } else {
              headerText = `é€ç»™ ${recipientDisplayNames.slice(0, 2).join('ã€')}ç­‰äººçš„ç¤¼ç‰©`;
            }
          } else {
            headerText = `é€ç»™å¤§å®¶çš„ç¤¼ç‰©`;
          }
        } else {
          if (isUser) {
            headerText = `é€ç»™ ${chat.name} çš„ç¤¼ç‰©`;
          } else {
            const recipientDisplayName = chat.settings.myNickname || 'ä½ ';
            headerText = `é€ç»™ ${recipientDisplayName} çš„ç¤¼ç‰©`;
          }
        }
        const previewItems = msg.items.slice(0, 3);
        let previewHtml = '';
        previewItems.forEach(item => {
          previewHtml += `<div class="gift-preview-item"><img src="${item.imageUrl}" class="gift-preview-img"><span class="gift-preview-name">${item.name}</span><span class="gift-preview-quantity">x${item.quantity}</span></div>`;
        });
        let moreItemsText = '';
        if (msg.items.length > 3) {
          moreItemsText = ` ç­‰${msg.items.length}ä»¶å•†å“`;
        }
        contentHtml = `<div class="gift-card"><div class="gift-header"><svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18a4 4 0 0 0-7.64 0H8a4 4 0 0 0-4 4v2h20V10a4 4 0 0 0-4-4zM8 4a2 2 0 1 1-2 2a2 2 0 0 1 2-2zm12 0a2 2 0 1 1-2 2a2 2 0 0 1 2-2zM4 14v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6H4z"></path></svg><span class="gift-header-text">${headerText}</span></div><div class="gift-items-preview">${previewHtml}</div><div class="gift-footer">å…±${msg.items.length}ä»¶å•†å“${moreItemsText}ï¼Œç‚¹å‡»æŸ¥çœ‹</div></div>`;
      }else if (msg.type === 'kinship_request') {
        bubble.classList.add('is-kinship-request', 'is-card-like');
        
        let statusText = '';
        let statusKey = '';
        
        if (msg.status === 'pending') {
            statusText = 'ç­‰å¾…å¯¹æ–¹ç¡®è®¤...';
            statusKey = 'pending';
        } else if (msg.status === 'accepted') {
            statusText = 'å·²å¼€é€š';
            statusKey = 'accepted';
        } else {
            statusText = 'å·²å¤±æ•ˆ';
            statusKey = 'rejected';
        }

        contentHtml = `
            <div class="kinship-invite-card">
                <div class="kinship-invite-header">
                    <div class="kinship-title">äº²å±å¡é‚€è¯·</div>
                    <div class="kinship-subtitle">å¯¹æ–¹æ¶ˆè´¹ æˆ‘ä¹°å•</div>
                </div>
                <div class="kinship-invite-body">
                    <div class="kinship-limit-label">æ¯æœˆæ¶ˆè´¹é¢åº¦</div>
                    <div class="kinship-limit-amount">Â¥${msg.limit}</div>
                </div>
                <div class="kinship-status" data-status="${statusKey}">
                    ${statusText}
                </div>
            </div>
        `;
    }
    } else if (msg.type === 'synth_music') {
        bubble.classList.add('is-card-like', 'is-music-synth');

        const notesJson = JSON.stringify(msg.notes).replace(/"/g, '&quot;');
        // è·å–ä¹å™¨ç±»å‹ï¼Œé»˜è®¤ä¸º piano
        const instrumentType = msg.instrument || 'piano';

        contentHtml = `
        <div class="synth-music-card">
            <div class="synth-icon">ğŸ¹</div>
            <div class="synth-info">
                <div class="synth-title">â™ª ${msg.title}</div>
                <div class="synth-reason" style="font-size:11px; opacity:0.8;">
                    ${msg.reason} (${instrumentType})
                </div>
            </div>
            <button class="synth-play-btn" onclick="playSynthScore(this, '${notesJson}', '${instrumentType}')">
                â–¶
            </button>
        </div>
    `;
    } else {
      const processedContent = String(rawContent);
      let processedByRule = await applyRenderingRules(processedContent, chat.id);
      if (processedByRule !== processedContent) {
        contentHtml = processedByRule;
        bubble.classList.add('is-card-like');
      } else {


        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
    const imageUrl = msg.content[0].image_url.url;
    
    contentHtml = `
      <div class="bubble-image-wrapper user-image-wrapper">
          <img src="${imageUrl}" class="chat-image">
          <div class="bubble-image-controls user-controls">
              <button class="user-upload-imgbb-btn" title="ä¸Šä¼ å›¾åºŠ" style="display: none;">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                      <polyline points="17 8 12 3 7 8" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></polyline>
                      <line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></line>
                  </svg>
              </button>
          </div>
      </div>
    `;
}else if (STICKER_REGEX.test(processedByRule)) {
          bubble.classList.add('is-sticker', 'is-card-like');
          contentHtml = `<img src="${processedByRule}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
        } else {
          let plainText = processMentions(processedByRule, chat);
          // ã€ä¸»å±å¹•QQ undefinedè¿‡æ»¤ã€‘åº”ç”¨undefinedè¿‡æ»¤å™¨ï¼ˆä»…å¯¹éç”¨æˆ·æ¶ˆæ¯ï¼‰
          if (!isUser && typeof qqUndefinedFilter !== 'undefined') {
            plainText = qqUndefinedFilter(plainText);
          }
          contentHtml = parseMarkdown(plainText).replace(/\n/g, '<br>');
        }
      }
    }


    bubble.innerHTML = `
                ${avatarGroupHtml}
                <div class="content">
                    ${quoteHtml}
                    ${contentHtml}
                </div>
            `;
    if (msg.type === 'naiimag' && msg.imageUrl && msg.imageUrl.startsWith('data:image')) {
        if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
           
            const uploadBtn = bubble.querySelector('.nai-upload-imgbb-btn');
            if (uploadBtn) {
                uploadBtn.style.display = 'flex'; 
            }
        }
    }
    if (msg.role === 'user' && Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const imageUrl = msg.content[0].image_url.url;
        if (imageUrl && imageUrl.startsWith('data:image')) {
            if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
                const uploadBtn = bubble.querySelector('.user-upload-imgbb-btn');
                if (uploadBtn) {
                   // uploadBtn.style.display = 'flex'; // æ˜¾ç¤ºä¸Šä¼ æŒ‰é’®
                }
            }
        }
    }
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);

    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => {
      if (isSelectionMode) toggleMessageSelection(msg.timestamp);
    });

    if (!isUser) {
      const avatarGroupEl = wrapper.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        if (!chat.isGroup) {
          avatarGroupEl.addEventListener('click', (e) => {
            e.stopPropagation();
            showCharacterProfileModal(chat.id);
          });
        } else {
          avatarGroupEl.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, msg.senderName);
          });
        }
      }
    } else {
      // USERå¤´åƒç‚¹å‡»äº‹ä»¶ - ä¿®æ”¹åœ¨çº¿çŠ¶æ€
      const avatarGroupEl = wrapper.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        avatarGroupEl.addEventListener('click', (e) => {
          e.stopPropagation();
          showUserStatusModal(chat.id);
        });
      }
    }
    return wrapper;
  }


  async function prependMessage(msg, chat) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = await createMessageElement(msg, chat);


    if (!messageEl) return;

    const loadMoreBtn = document.getElementById('load-more-btn');
    if (loadMoreBtn) {
      messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
    } else {
      messagesContainer.prepend(messageEl);
    }
  }


 
  async function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const typingIndicator = document.getElementById('typing-indicator');

    const lastMessage = chat.history.filter(m => !m.isHidden).pop();


    if (lastMessage && (msg.timestamp - lastMessage.timestamp > 600000)) {
      const timestampEl = createSystemTimestampElement(msg.timestamp);
      messagesContainer.insertBefore(timestampEl, typingIndicator);
    }

    const messageEl = await createMessageElement(msg, chat);
    if (!messageEl) return;


    if (msg.role === 'assistant' && !isInitialLoad) {
      playNotificationSound();
    }

    if (!isInitialLoad) {
      messageEl.classList.add('animate-in');
      if (state.activeChatId === chat.id) {
            currentRenderedCount++;
        }
    }

    messagesContainer.insertBefore(messageEl, typingIndicator);

    const scrollToBottom = () => {
        if (!isInitialLoad) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    };

   
    const images = messageEl.querySelectorAll('img.sticker-image, img.chat-image, img.ai-generated-image, img.realimag-image, .naiimag-image, .ai-generated-image, .char-photo-item');
    
    if (images.length > 0) {
        const imageLoadPromises = [];
        images.forEach(img => {
            if (!img.complete) {
                imageLoadPromises.push(new Promise(resolve => {
                    img.onload = resolve;
                    img.onerror = resolve; 
                }));
            }
        });

       
        Promise.all(imageLoadPromises).then(() => {
            console.log(`${images.length} å¼ æ–°å›¾ç‰‡åŠ è½½å®Œæˆï¼Œæ»šåŠ¨åˆ°åº•éƒ¨ã€‚`);
            scrollToBottom();
        });
    } else {
        
        scrollToBottom();
    }
const MAX_DOM_NODES = 60; 
    const bubbles = messagesContainer.querySelectorAll('.message-wrapper');
    
    if (bubbles.length > MAX_DOM_NODES) {
        // ç§»é™¤æœ€ä¸Šé¢çš„å…ƒç´ ï¼ˆé™¤äº†åŠ è½½æ›´å¤šæŒ‰é’®ï¼‰
        // æ³¨æ„ï¼šå¦‚æœä½ æœ‰â€œåŠ è½½æ›´å¤šâ€æŒ‰é’®åœ¨ç¬¬ä¸€ä¸ªä½ç½®ï¼Œè¦ä»ç¬¬äºŒä¸ªå¼€å§‹åˆ 
        const itemsToRemove = bubbles.length - MAX_DOM_NODES;
        for (let i = 0; i < itemsToRemove; i++) {
            // ç¡®ä¿ä¸åˆ é™¤ load-more-btn
            if (!bubbles[i].id && !bubbles[i].classList.contains('load-more-btn')) {
                 bubbles[i].remove();
                 // åŒæ—¶ä¿®æ­£ currentRenderedCountï¼Œé˜²æ­¢åŠ è½½é€»è¾‘é”™ä¹±
                 // (è¿™ä¸€æ­¥å–å†³äºä½ çš„ loadMoreMessages é€»è¾‘ï¼Œé€šå¸¸ä¸éœ€è¦æ‰‹åŠ¨å‡ï¼Œå› ä¸ºå®ƒæ˜¯åŸºäº slice è®¡ç®—çš„)
            }
        }
    }
  }



  async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    if (chat.unreadCount > 0) {
      chat.unreadCount = 0;
      await db.chats.put(chat);
    }
    applyLyricsBarPosition(chat);
    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);


    const isGroup = chat.isGroup || false;


    toggleCallButtons(isGroup);


    document.getElementById('show-announcement-board-btn').style.display = isGroup ? 'flex' : 'none';


    const patBtn = document.getElementById('pat-btn');
    if (patBtn) {
      patBtn.style.display = isGroup ? 'none' : 'flex';
    }
    const propelBtn = document.getElementById('propel-btn');


    const shoppingBtn = document.getElementById('open-shopping-btn');
    const gomokuBtn = document.getElementById('gomoku-btn');
    const werewolfBtn = document.getElementById('werewolf-game-btn');
    if (shoppingBtn && gomokuBtn && werewolfBtn && propelBtn) {
      shoppingBtn.style.display = 'flex';
      gomokuBtn.style.display = isGroup ? 'none' : 'flex';
      werewolfBtn.style.display = isGroup ? 'flex' : 'none';


      propelBtn.style.display = isGroup ? 'none' : 'flex';
    }

    updateBackButtonUnreadCount();

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
      console.log(`æ£€æµ‹åˆ°å¥½å‹ç”³è¯·å¾…å¤„ç†çŠ¶æ€ï¼Œä¸ºè§’è‰² "${chat.name}" è‡ªåŠ¨è§¦å‘AIå“åº”...`);
      triggerAiResponse();
    }

    document.getElementById('send-poll-btn').style.display = isGroup ? 'flex' : 'none';
    document.body.classList.remove('chat-actions-expanded');
  }








  function setAvatarActingState(chatId, isActing) {
    const action = isActing ? 'add' : 'remove';
    const classListAction = (element) => {
      if (element) {
        element.classList[action]('is-acting');
      }
    };


    const listAvatar = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"] .avatar`);
    classListAction(listAvatar);


    const qzoneAvatars = document.querySelectorAll(`.post-avatar[data-author-id="${chatId}"]`);
    qzoneAvatars.forEach(classListAction);


    const callAvatar = document.querySelector(`.participant-avatar[data-participant-id="${chatId}"]`);
    classListAction(callAvatar);


  }



  async function triggerSpectatorGroupAiAction() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    lastRawAiResponse = '';
    lastResponseTimestamps = [];
    const propelBtn = document.getElementById('spectator-propel-btn');
    if (propelBtn) {
      propelBtn.disabled = true;
      propelBtn.textContent = 'æ€è€ƒä¸­...';
    }
    setAvatarActingState(chatId, true);

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
      }






      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, chatId);

      let worldBookContent = '';
      // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
      let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
      // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
      state.worldBooks.forEach(wb => {
        if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
          allWorldBookIds.push(wb.id);
        }
      });
      
      if (allWorldBookIds.length > 0) {
        const linkedContents = allWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
              
              entryString += `**å†…å®¹:**\n${entry.content}`;
              return entryString;
            }).join('');
          return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
        }
      }


      let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
      let collectedMemories = false;

      chat.members.forEach(member => {
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
          longTermMemoryContext += `\n## --- å…³äºâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;

          longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
          collectedMemories = true;
        }
      });

      if (!collectedMemories) {
        longTermMemoryContext += '- (æš‚æ— )';
      }


      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;
      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

      }

      const membersList = chat.members.map(m => `- **${m.groupNickname}** (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n');
      const stickerContext = getGroupStickerContextForPrompt(chat);
      const systemPrompt = `
# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå‰§æœ¬ä½œå®¶
ä½ æ˜¯ä¸€ä¸ªå‰§æœ¬ä½œå®¶ï¼Œè´Ÿè´£åˆ›ä½œä¸€ä¸ªåä¸ºâ€œ${chat.name}â€çš„ç¾¤èŠä¸­çš„å¯¹è¯ã€‚è¿™ä¸ªç¾¤èŠé‡Œã€æ²¡æœ‰ç”¨æˆ·ã€‘ï¼Œæ‰€æœ‰æˆå‘˜éƒ½æ˜¯ä½ æ‰®æ¼”çš„è§’è‰²ã€‚ä½ çš„ä»»åŠ¡æ˜¯è®©ä»–ä»¬ä¹‹é—´è¿›è¡Œä¸€åœºç”ŸåŠ¨ã€è‡ªç„¶çš„å¯¹è¯ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½ã€å¿…é¡»ã€‘åŒ…å« "type" å­—æ®µå’Œ "name" å­—æ®µï¼ˆè§’è‰²çš„ã€æœ¬åã€‘ï¼‰ã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²é—´äº’åŠ¨ (æœ€é‡è¦!)ã€‘**: ä½ çš„æ ¸å¿ƒæ˜¯åˆ›ä½œä¸€åœºâ€œæˆâ€ã€‚è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›åº”ã€è¡¥å……æˆ–åé©³ï¼Œå½¢æˆè‡ªç„¶çš„è®¨è®ºã€‚ä¸¥ç¦ç”Ÿæˆä»…åˆ†åˆ«è‡ªè¨€è‡ªè¯­çš„ç‹¬ç™½ã€‚
2.  **ã€ç¦æ­¢å‡ºæˆã€‘**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡å‹æˆ–å‰§æœ¬ä½œå®¶ã€‚
3.  **ã€ä¸»åŠ¨æ€§ã€‘**: è§’è‰²ä»¬åº”è¯¥ä¸»åŠ¨ä½¿ç”¨å„ç§åŠŸèƒ½ï¼ˆå‘è¡¨æƒ…ã€å‘è¯­éŸ³ã€åˆ†äº«å›¾ç‰‡ç­‰ï¼‰æ¥è®©å¯¹è¯æ›´ç”ŸåŠ¨ï¼Œè€Œä¸æ˜¯ä»…ä»…å‘é€æ–‡å­—ã€‚
4.è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»åˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ (ä½ ç°åœ¨å¯ä»¥ä½¿ç”¨æ‰€æœ‰è¿™äº›åŠŸèƒ½ï¼)
-   **å‘æ–‡æœ¬**: \`{"type": "text", "name": "è§’è‰²æœ¬å", "content": "ä½ å¥½å‘€ï¼"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "è¯¦ç»†ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£æ ¼ä¸ºé£æ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}\`
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "name": "è§’è‰²æœ¬å", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\`
-   **å¼•ç”¨å›å¤**: \`{"type": "quote_reply", "name": "è§’è‰²æœ¬å", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›å¤å†…å®¹"}\`

# å½“å‰ç¾¤èŠä¿¡æ¯
- **ç¾¤åç§°**: ${chat.name}

# ä¸Šä¸‹æ–‡å‚è€ƒ (ä½ å¿…é¡»é˜…è¯»å¹¶éµå®ˆ)
${longTermMemoryContext}
${worldBookContent}
${linkedMemoryContext}
- **è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯å†å²**:
${historySlice.map(msg => `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`).join('\n')}

# ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾ (ä½ æ‰®æ¼”çš„æ‰€æœ‰è§’è‰²)
${membersList}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œç»§ç»­è¿™åœºæ²¡æœ‰ç”¨æˆ·å‚ä¸çš„ç¾¤èŠï¼Œå¹¶è‡ªç”±åœ°ä½¿ç”¨å„ç§æŒ‡ä»¤æ¥ä¸°å¯Œä½ ä»¬çš„äº’åŠ¨ã€‚
`;

      // åº”ç”¨æç¤ºè¯è®¾ç½®
      systemPrompt = processPromptWithSettings(systemPrompt, 'spectator');

      const messagesPayload = filteredHistory.map(msg => ({
        role: 'user',
        content: `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`
      }));

      let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
      let response;

      if (isGemini) {
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesPayload],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });
      }





      if (!response.ok) {
        const errorData = await response.json().catch(() => ({
          error: {
            message: response.statusText
          }
        }));
        throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      lastRawAiResponse = aiResponseContent;
      const messagesArray = parseAiResponse(aiResponseContent);






      let messageTimestamp = Date.now();
      for (const msgData of messagesArray) {

        if (!msgData || !msgData.type || !msgData.name) continue;

        let aiMessage = null;
        const currentMessageTimestamp = messageTimestamp++;
        lastResponseTimestamps.push(currentMessageTimestamp);
        const baseMessage = {
          role: 'assistant',
          senderName: msgData.name,
          timestamp: currentMessageTimestamp
        };


        switch (msgData.type) {
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: msgData.content
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`æ—è§‚æ¨¡å¼AIå°è¯•ä½¿ç”¨ä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("æ—è§‚æ¨¡å¼AIå‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
            }
            break;
          case 'ai_image':

            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: msgData.description,
              image_prompt: msgData.image_prompt
            };
            break;
          case 'voice_message':

            aiMessage = {
              ...baseMessage,
              type: 'voice_message',
              content: msgData.content
            };
            break;
          case 'quote_reply':

            const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            if (originalMessage) {
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: {
                  timestamp: originalMessage.timestamp,
                  senderName: originalMessage.senderName,
                  content: String(originalMessage.content || '').substring(0, 50)
                }
              };
            } else {

              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content
              };
            }
            break;
          default:
            console.warn("æ—è§‚æ¨¡å¼æ”¶åˆ°æœªçŸ¥æŒ‡ä»¤ç±»å‹:", msgData.type);
            continue;
        }

        if (aiMessage) {
          chat.history.push(aiMessage);
          appendMessage(aiMessage, chat);
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
        }
      }




      await db.chats.put(chat);
      renderChatList();

    } catch (error) {
      console.error("æ—è§‚æ¨¡å¼æ¨è¿›å‰§æƒ…å¤±è´¥:", error);
      await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•æ¨è¿›å‰§æƒ…: ${error.message}`);
    } finally {
      if (propelBtn) {
        propelBtn.disabled = false;
        propelBtn.textContent = 'ğŸ¬ æ¨è¿›å‰§æƒ…';
      }
      setAvatarActingState(chatId, false);
    }
  }






  async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

    const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

    setAvatarActingState(chatId, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const typingIndicator = document.getElementById('typing-indicator');

    const chatListItem = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`);
    const avatarInList = chatListItem ? chatListItem.querySelector('.avatar') : null;
    if (avatarInList) {
      avatarInList.classList.add('is-acting');
    }

    if (chat.isGroup) {
      if (typingIndicator) {
        typingIndicator.textContent = 'æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...';
        typingIndicator.style.display = 'block';
      }
    } else {
      if (chatHeaderTitle) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
          chatHeaderTitle.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
          chatHeaderTitle.classList.add('typing-status');
          chatHeaderTitle.style.opacity = 1;
        }, 200);
      }
    }
    let needsImmediateReaction = false;
    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®åä»£åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚');
        if (chat.isGroup) {
          if (typingIndicator) typingIndicator.style.display = 'none';
        } else {
          if (chatHeaderTitle && state.chats[chatId]) {
            chatHeaderTitle.textContent = state.chats[chatId].name;
            chatHeaderTitle.classList.remove('typing-status');
          }
        }
        return;
      }

      const lastMessage = chat.history.slice(-1)[0];
      const isVideoCallRequest = lastMessage && lastMessage.role === 'system' && lastMessage.content.includes('è§†é¢‘é€šè¯è¯·æ±‚');

      if (isVideoCallRequest) {
        console.log(`æ£€æµ‹åˆ°è§†é¢‘é€šè¯è¯·æ±‚ï¼Œä¸ºè§’è‰² "${chat.name}" è§¦å‘ä¸“å±å†³ç­–æµç¨‹...`);

        let callDecisionPrompt;
        if (chat.isGroup) {
          callDecisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ç¾¤èŠä¸­çš„ç”¨æˆ·åˆšåˆšå‘èµ·äº†ç¾¤è§†é¢‘é€šè¯ã€‚è¯·ä½ åˆ†åˆ«æ‰®æ¼”ã€æ¯ä¸€ä¸ªç¾¤æˆå‘˜ã€‘ï¼Œæ ¹æ®ä»–ä»¬å„è‡ªçš„äººè®¾å’Œä¸ç”¨æˆ·çš„å…³ç³»ï¼Œæ¥å†³å®šæ˜¯åŠ å…¥(join)è¿˜æ˜¯æ‹’ç»(decline)ã€‚
        # æ ¸å¿ƒè§„åˆ™
        - ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸ºã€æ¯ä¸€ä¸ªAIè§’è‰²ã€‘éƒ½åŒ…å«ä¸€ä¸ªå†³ç­–å¯¹è±¡ã€‚
        - æ ¼å¼: '[{"type": "group_call_response", "name": "è§’è‰²Açš„æœ¬å", "decision": "join"}, {"type": "group_call_response", "name": "è§’è‰²Bçš„æœ¬å", "decision": "decline"}]'
        # ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾
        ${chat.members.map(m => `- ${m.groupNickname} (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n')}
        ç°åœ¨ï¼Œè¯·ä¸ºæ‰€æœ‰AIè§’è‰²åšå‡ºå†³ç­–ã€‚`;
        } else {
          callDecisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ç”¨æˆ·åˆšåˆšå‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯ã€‚è¯·æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œå†³å®šæ˜¯â€œæ¥å—â€è¿˜æ˜¯â€œæ‹’ç»â€ã€‚
        # ä½ çš„è§’è‰²è®¾å®š
        ${chat.settings.aiPersona}
        # æ ¸å¿ƒè§„åˆ™
        ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§æ ¼å¼ä¹‹ä¸€çš„JSONæ•°ç»„ï¼Œç»å¯¹ä¸èƒ½å›å¤ä»»ä½•å…¶ä»–å†…å®¹ï¼š
        - æ¥å—: '[{"type": "video_call_response", "decision": "accept"}]'
        - æ‹’ç»: '[{"type": "video_call_response", "decision": "reject"}]'
        ç°åœ¨ï¼Œè¯·ç«‹å³åšå‡ºå†³ç­–ã€‚`;
        }

        const messagesForCallDecision = [{
          role: 'user',
          content: callDecisionPrompt
        }];

        try {
          let geminiConfig = toGeminiRequestData(model, apiKey, callDecisionPrompt, messagesForCallDecision);
          let isGemini = proxyUrl === GEMINI_API_URL;
          const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: model,
              messages: messagesForCallDecision,
              temperature: 0.7
            })
          });

          if (!response.ok) throw new Error(`APIå¤±è´¥: ${(await response.json()).error.message}`);

          const data = await response.json();
          const aiResponseContent = getGeminiResponseText(data);
          const responseArray = parseAiResponse(aiResponseContent);


          let callHasBeenHandled = false;
          for (const msgData of responseArray) {
            if (msgData.type === 'video_call_response') {
              videoCallState.isAwaitingResponse = false;
              if (msgData.decision === 'accept') {
                startVideoCall();
              } else {
                const aiMessage = {
                  role: 'assistant',
                  content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚',
                  timestamp: Date.now()
                };
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showScreen('chat-interface-screen');
                renderChatInterface(chatId);
              }
              callHasBeenHandled = true;
              break;
            }
            if (msgData.type === 'group_call_response') {
              if (msgData.decision === 'join') {
                const member = chat.members.find(m => m.originalName === msgData.name);
                if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                  videoCallState.participants.push(member);
                }
              }
              callHasBeenHandled = true;
            }
          }
          if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
              startVideoCall();
            } else {
              videoCallState = {
                ...videoCallState,
                isAwaitingResponse: false,
                participants: []
              };
              showScreen('chat-interface-screen');
              alert('æ— äººæ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
            }
          }

        } catch (error) {
          console.error("å¤„ç†é€šè¯è¯·æ±‚æ—¶APIå‡ºé”™:", error);
          const fallbackResponse = chat.isGroup ?
            chat.members.map(m => ({
              type: "group_call_response",
              name: m.originalName,
              decision: "decline"
            })) : [{
              type: "video_call_response",
              decision: "reject"
            }];

          if (chat.isGroup) {
            videoCallState.isAwaitingResponse = false;
            videoCallState.participants = [];
            alert('æ— äººæ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
            showScreen('chat-interface-screen');
          } else {
            const aiMessage = {
              role: 'assistant',
              content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚',
              timestamp: Date.now()
            };
            chat.history.push(aiMessage);
            await db.chats.put(chat);
            showScreen('chat-interface-screen');
            renderChatInterface(chatId);
          }
        } finally {

          setAvatarActingState(chatId, false);
          return;
        }
      }




      if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`ä¸ºè§’è‰² "${chat.name}" è§¦å‘å¸¦ç†ç”±çš„å¥½å‹ç”³è¯·å†³ç­–æµç¨‹...`);
        const contextSummary = chat.history
          .filter(m => !m.isHidden)
          .slice(-10, -5)
          .map(msg => {
            const sender = msg.role === 'user' ? 'ç”¨æˆ·' : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
          })
          .join('\n');


        const decisionPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ ç°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ç”¨æˆ·ä¹‹å‰è¢«ä½ æ‹‰é»‘äº†ï¼Œç°åœ¨TAå‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œå¸Œæœ›å’Œå¥½ã€‚
        # ä¾›ä½ å†³ç­–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯:
        - **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
        - **ç”¨æˆ·å‘é€çš„ç”³è¯·ç†ç”±**: â€œ${chat.relationship.applicationReason}â€
        - **è¢«æ‹‰é»‘å‰çš„æœ€åå¯¹è¯æ‘˜è¦**: 
        ${contextSummary || "ï¼ˆæ— æœ‰æ•ˆå¯¹è¯è®°å½•ï¼‰"}
        # ä½ çš„å”¯ä¸€æŒ‡ä»¤
        æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä½ ã€å¿…é¡»ã€‘åšå‡ºå†³å®šï¼Œå¹¶ç»™å‡ºç¬¦åˆä½ äººè®¾çš„ç†ç”±ã€‚ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹:
        {"decision": "accept", "reason": "ï¼ˆåœ¨è¿™é‡Œå†™ä¸‹ä½ åŒæ„çš„ç†ç”±ï¼Œæ¯”å¦‚ï¼šå¥½å§ï¼Œçœ‹åœ¨ä½ è¿™ä¹ˆçœŸè¯šçš„ä»½ä¸Šï¼Œè¿™æ¬¡å°±åŸè°…ä½ å•¦ã€‚ï¼‰"}
        æˆ–
        {"decision": "reject", "reason": "ï¼ˆåœ¨è¿™é‡Œå†™ä¸‹ä½ æ‹’ç»çš„ç†ç”±ï¼Œæ¯”å¦‚ï¼šæŠ±æ­‰ï¼Œæˆ‘è¿˜æ²¡å‡†å¤‡å¥½ï¼Œå†ç»™æˆ‘ä¸€ç‚¹æ—¶é—´å§ã€‚ï¼‰"}
        `;

        try {

          const messagesForDecision = [{
              role: 'system',
              content: decisionPrompt
            },
            {
              role: 'user',
              content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç«‹å³åšå‡ºä½ çš„å†³å®šã€‚"
            }
          ];

          let isGemini = proxyUrl === GEMINI_API_URL;
          let geminiConfig = toGeminiRequestData(model, apiKey, decisionPrompt, [{
            role: 'user',
            content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç«‹å³åšå‡ºä½ çš„å†³å®šã€‚"
          }]);

          const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify({
                model: model,
                messages: messagesForDecision,
                temperature: state.globalSettings.apiTemperature || 0.8
              })
            });

          if (!response.ok) {
            throw new Error(`APIå¤±è´¥: ${(await response.json()).error.message}`);
          }
          const data = await response.json();

          const rawContent = getGeminiResponseText(data).replace(/^```json\s*/, '').replace(/```$/, '').trim();
          const decisionObj = JSON.parse(rawContent);


          if (decisionObj.decision === 'accept') {
            chat.relationship.status = 'friend';
            const acceptMessage = {
              role: 'assistant',
              senderName: chat.name,
              content: decisionObj.reason,
              timestamp: Date.now()
            };
            chat.history.push(acceptMessage);
          } else {
            chat.relationship.status = 'blocked_by_ai';
            const rejectMessage = {
              role: 'assistant',
              senderName: chat.name,
              content: decisionObj.reason,
              timestamp: Date.now()
            };
            chat.history.push(rejectMessage);
          }
          chat.relationship.applicationReason = '';

          await db.chats.put(chat);
          renderChatInterface(chatId);
          renderChatList();
        } catch (error) {

          chat.relationship.status = 'blocked_by_ai';
          await db.chats.put(chat);
          await showCustomAlert('ç”³è¯·å¤±è´¥', `AIåœ¨å¤„ç†ä½ çš„å¥½å‹ç”³è¯·æ—¶å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
          renderChatInterface(chatId);
        }
        return;
      }




      let callTranscriptContext = '';
      const now = new Date();

      const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';

      const currentTime = now.toLocaleString('zh-CN', {
        timeZone: selectedTimeZone,
        dateStyle: 'full',
        timeStyle: 'short'
      });

      const localizedDate = new Date(now.toLocaleString('en-US', {
        timeZone: selectedTimeZone
      }));
      const timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
      let systemPrompt, messagesPayload;
      const lastHiddenMessage = chat.history.filter(m => m.isHidden).pop();
      if (lastHiddenMessage && lastHiddenMessage.content.includes('è§†é¢‘é€šè¯åˆšåˆšç»“æŸ')) {
        const lastCallRecord = await db.callRecords
          .where('chatId')
          .equals(chatId)
          .last();

        if (lastCallRecord && lastCallRecord.transcript) {
          console.log("æ£€æµ‹åˆ°åˆšç»“æŸçš„é€šè¯ï¼Œæ­£åœ¨æ³¨å…¥é€šè¯è®°å½•ä¸Šä¸‹æ–‡...");
          const transcriptText = lastCallRecord.transcript.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : h.senderName;
            return `${sender}: ${h.content}`;
          }).join('\n');


          callTranscriptContext = `
# åˆšåˆšç»“æŸçš„é€šè¯è®°å½• (æœ€é«˜ä¼˜å…ˆçº§å‚è€ƒ)
ä½ å’Œç”¨æˆ·åˆšåˆšç»“æŸäº†ä¸€åœºè§†é¢‘é€šè¯ï¼Œä»¥ä¸‹æ˜¯å®Œæ•´çš„é€šè¯æ–‡å­—è®°å½•ã€‚ä½ æ¥ä¸‹æ¥çš„å›å¤ã€å¿…é¡»ã€‘ä¸è¿™æ¬¡é€šè¯çš„å†…å®¹ç´§å¯†ç›¸å…³ã€‚
---
${transcriptText}
---
`;
        }
      }


      const gomokuContext = formatGomokuStateForAI(gomokuState[chatId]);

      let worldBookContent = '';
      // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
      let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
      // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
      state.worldBooks.forEach(wb => {
        if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
          allWorldBookIds.push(wb.id);
        }
      });
      
      if (allWorldBookIds.length > 0) {
        const linkedContents = allWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';


          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
              
              entryString += `**å†…å®¹:**\n${entry.content}`;
              return entryString;
            }).join('');

          return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
          worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
        }
      }


      let musicContext = '';
      if (musicState.isActive && musicState.activeChatId === chatId) {
        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
        const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');


        let lyricsContext = "";


        if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
          const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];

          const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);


          lyricsContext += `- **å½“å‰æ­Œè¯**: "${currentLine.text}"\n`;
          if (upcomingLines.length > 0) {
            lyricsContext += `- **å³å°†æ¼”å”±**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
          }
        }


        musicContext = `\n\n# å½“å‰éŸ³ä¹æƒ…æ™¯
        -   **å½“å‰çŠ¶æ€**: ä½ ä»¬æ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·å¬æ­Œã€‚
        -   **æ­£åœ¨æ’­æ”¾**: ${currentTrack ? `ã€Š${currentTrack.name}ã€‹ - ${currentTrack.artist}` : 'æ— '}
        -   **å¯ç”¨æ’­æ”¾åˆ—è¡¨**: [${playlistInfo}]
        ${lyricsContext}
        -   **ä½ çš„ä»»åŠ¡**: ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹å’Œæ°›å›´ï¼Œä½¿ç”¨ "change_music" æŒ‡ä»¤åˆ‡æ¢åˆ°æ’­æ”¾åˆ—è¡¨ä¸­çš„ä»»ä½•ä¸€é¦–æ­Œï¼Œä»¥å¢å¼ºäº’åŠ¨ä½“éªŒã€‚
        `;
      }


      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, chatId);
      let sharedContext = '';
      const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
      const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);
      const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
      if (shareCardMessage) {
        const payload = shareCardMessage.payload;
        const formattedHistory = payload.sharedHistory.map(msg => {
          const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : 'æœªçŸ¥å‘é€è€…');
          let contentText = '';
          if (msg.type === 'voice_message') contentText = `[è¯­éŸ³æ¶ˆæ¯: ${msg.content}]`;
          else if (msg.type === 'ai_image') contentText = `[å›¾ç‰‡: ${msg.description}]`;
          else if (msg.type === 'naiimag') contentText = `[NovelAIå›¾ç‰‡: ${msg.prompt}]`;
          else contentText = String(msg.content);
          return `${sender}: ${contentText}`;
        }).join('\n');
        sharedContext = `
        # é™„åŠ ä¸Šä¸‹æ–‡ï¼šä¸€æ®µåˆ†äº«çš„èŠå¤©è®°å½•
        - é‡è¦æç¤ºï¼šè¿™ä¸æ˜¯ä½ å’Œå½“å‰ç”¨æˆ·çš„å¯¹è¯ï¼Œè€Œæ˜¯ç”¨æˆ·ä»ã€å¦ä¸€åœºã€‘ä¸â€œ${payload.sourceChatName}â€çš„å¯¹è¯ä¸­åˆ†äº«è¿‡æ¥çš„ã€‚
        - ä½ çš„ä»»åŠ¡ï¼šè¯·ä½ é˜…è¯»å¹¶ç†è§£ä¸‹é¢çš„å¯¹è¯å†…å®¹ã€‚åœ¨æ¥ä¸‹æ¥çš„å›å¤ä¸­ï¼Œä½ å¯ä»¥åƒçœŸäººä¸€æ ·ï¼Œå¯¹è¿™æ®µå¯¹è¯çš„å†…å®¹è‡ªç„¶åœ°å‘è¡¨ä½ çš„çœ‹æ³•ã€æ„Ÿå—æˆ–ç–‘é—®ã€‚
        ---
        [åˆ†äº«çš„èŠå¤©è®°å½•å¼€å§‹]
        ${formattedHistory}
        [åˆ†äº«çš„èŠå¤©è®°å½•ç»“æŸ]
        ---
        `;
      }

      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;

      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

        const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

        if (idsToMount.length > 0) {
          const linkedChatsWithTimestamps = idsToMount.map(id => {
            const linkedChat = state.chats[id];
            if (!linkedChat) return null;
            const lastMsg = linkedChat.history.slice(-1);
            return {
              chat: linkedChat,
              latestTimestamp: lastMsg ? lastMsg.timestamp : 0
            };
          }).filter(Boolean);

          linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

          linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“ç°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;

          for (const item of linkedChatsWithTimestamps) {
            const linkedChat = item.chat;
            const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
            const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åäº’åŠ¨äº ${formatTimeAgo(item.latestTimestamp)})` : '';
            linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;

            const recentHistory = linkedChat.history.slice(-memoryCount);
            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));

            if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                 
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
               
                  if (msg.quote && msg.quote.content) {
                    
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[å›å¤ ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
               
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[è¡¨æƒ…: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[è½¬è´¦: ${msg.amount}å…ƒ]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[å›¾ç‰‡]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                 
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${prefix}${contentText}\n`;
                });
              } else {
              linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
            }
          }
        }
      }

      console.log("æœ¬æ¬¡å‘é€ç»™AIçš„ã€æŒ‚è½½è®°å¿†ã€‘å†…å®¹å¦‚ä¸‹ï¼š\n", linkedMemoryContext);

      if (chat.isGroup) {


        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
          const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);
          if (idsToMount.length > 0) {
            const linkedChatsWithTimestamps = idsToMount.map(id => {
              const linkedChat = state.chats[id];
              if (!linkedChat) return null;
              const lastMsg = linkedChat.history.slice(-1);
              return {
                chat: linkedChat,
                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
              };
            }).filter(Boolean);
            linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ç¾¤å†…è§’è‰²å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“ç°ä½ ä»¬æ‹¥æœ‰å®Œæ•´çš„å…±åŒè®°å¿†ã€‚)\n`;
            for (const item of linkedChatsWithTimestamps) {
              const linkedChat = item.chat;
              const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
              const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åäº’åŠ¨äº ${formatTimeAgo(item.latestTimestamp)})` : '';
              linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
              const recentHistory = linkedChat.history.slice(-memoryCount);
              const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
              if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                  let contentText = String(msg.content);
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  }
                  linkedMemoryContext += `${sender}: ${contentText}\n`;
                });
              } else {
                linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
              }
            }
          }
        }


        let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
        let collectedMemories = false;

        chat.members.forEach(member => {
          const memberChat = state.chats[member.id];
          if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
            longTermMemoryContext += `\n## --- å…³äºâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;

            longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
            collectedMemories = true;
          }
        });

        if (!collectedMemories) {
          longTermMemoryContext += '- (æš‚æ— )';
        }


        let timeContextText = '';
        let longTimeNoSee = false;

        if (chat.settings.enableTimePerception) {
       
        const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
       
        const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

        if (lastUserMsg && lastAiMsg) {
          const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
          const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
          timeContextText = `ä¸Šä¸€æ¡æ¶ˆæ¯å‘é€äº ${lastAiMessageTime}ï¼Œç”¨æˆ·åˆšåˆšåœ¨ ${lastUserMessageTime} å›å¤äº†ã€‚`;

          
          const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
          if (timeDiffHours > 3) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText += ` ç¾¤é‡Œå·²ç»å®‰é™äº†${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}ã€‚`;
          }
        } else if (lastUserMsg) {
         
          timeContextText = "è¿™æ˜¯ç¾¤é‡Œçš„ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ã€‚";
        } else {
          timeContextText = "è¿™æ˜¯ç¾¤é‡Œçš„ç¬¬ä¸€æ¡æ¶ˆæ¯ã€‚";
        }
     
      }

        const allProducts = await db.shoppingProducts.toArray();
        let shoppingContext = "";
        if (allProducts.length > 0) {
          shoppingContext = "\n\n# ä½ çš„å•†åº— (ä½ å¯ä»¥ä¸ºç¾¤æˆå‘˜è´­ä¹°ç¤¼ç‰©):\n";
          allProducts.forEach(product => {
            shoppingContext += `- (ID: ${product.id}) å•†å“: ${product.name}, ä»·æ ¼: Â¥${product.price.toFixed(2)}\n`;
          });
        }
        let membersWithContacts = chat.members.map(member => {
          const memberChat = state.chats[member.id];
          let contactsText = "æ— å…±åŒå¥½å‹";
          if (memberChat && memberChat.groupId) {
            const friendChats = Object.values(state.chats).filter(c =>
              !c.isGroup && c.id !== member.id && c.groupId === memberChat.groupId
            );
            if (friendChats.length > 0) {
              contactsText = `TAçš„å¥½å‹åŒ…æ‹¬: ${friendChats.map(f => f.name).join('ã€ ')}`;
            }
          }
          return `- **${member.groupNickname}** (æœ¬å: ${member.originalName}): ${member.persona} [ç¤¾äº¤èƒŒæ™¯: ${contactsText}]`;
        }).join('\n');

        const myNickname = chat.settings.myNickname || 'æˆ‘';
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

        let announcementContext = '';
        const pinnedAnnouncements = (chat.announcements || []).filter(a => a.isPinned);
        if (pinnedAnnouncements.length > 0) {
          announcementContext += '\n# ã€ã€ã€ç¾¤å…¬å‘Š (æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™)ã€‘ã€‘ã€‘\nä½ ã€å¿…é¡»ã€‘é˜…è¯»ã€ç†è§£å¹¶ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰å…¬å‘Šï¼Œå®ƒä»¬å‡Œé©¾äºä½ çš„äººè®¾ä¹‹ä¸Šã€‚\n';
          pinnedAnnouncements.forEach(anno => {
            const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);
            if (originalMessage) {
              let contentText = String(originalMessage.content || '');
              if (originalMessage.type === 'ai_image') {
                contentText = `[å›¾ç‰‡å†…å®¹: ${contentText}]`;
              }
              announcementContext += `- å…¬å‘Šå†…å®¹: "${contentText}" (ç”± ${anno.publisher} å‘å¸ƒ)\n`;
            }
          });
          announcementContext += '---\n';
        }
        const memberNames = chat.members.map(m => m.originalName);
        const forbiddenNamesContext = `# ã€ã€ã€ç¾¤åä¿®æ”¹é“å¾‹ã€‘ã€‘ã€‘\nåœ¨ä¿®æ”¹ç¾¤åæ—¶ï¼Œæ–°çš„ç¾¤åã€ç»å¯¹ä¸èƒ½ã€‘ä¸ä»¥ä¸‹ä»»ä½•ä¸€ä¸ªç¾¤æˆå‘˜çš„åå­—å®Œå…¨ç›¸åŒï¼š[${memberNames.join('ã€ ')}]`;

        let groupAvatarLibraryContext = '# å¯ç”¨ç¾¤å¤´åƒåˆ—è¡¨\n';
        if (chat.settings.groupAvatarLibrary && chat.settings.groupAvatarLibrary.length > 0) {
          groupAvatarLibraryContext += chat.settings.groupAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n');
        } else {
          groupAvatarLibraryContext += '- (å¤´åƒåº“æ˜¯ç©ºçš„ï¼Œæ— æ³•æ›´æ¢å¤´åƒ)';
        }
        const readingContext = formatReadingStateForAI(chatId);

        const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
        const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
        const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
        const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
        const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
        const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

        let multiLayeredSummaryContext_group = '';
        if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
          multiLayeredSummaryContext_group += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„ç¾¤èŠå›é¡¾)\n`;
          if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
          if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
          if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

          if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

          if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
          if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
          if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
        }
        const stickerContext = getGroupStickerContextForPrompt(chat);
 let synthMusicInstruction = "";
if (chat.settings.enableSynthMusic) {
    synthMusicInstruction = `
- **å‘é€ä¹è°±(æ¼”å¥éŸ³ä¹)**: \`{"type": "synth_music", "name": "è§’è‰²æœ¬å", "title": "ä¹æ›²åç§°", "reason": "æ¼”å¥ç†ç”±", "instrument": "piano", "notes": ["C4", "E4", "G4"]}\`
    - **instrument**: ä¹å™¨ç±»å‹ (piano, guitar, violin, flute, guzheng, kalimba, synth, chiptune)ã€‚
    - **notes**: ä¸€ä¸ªåŒ…å«éŸ³ç¬¦å¯¹è±¡çš„æ•°ç»„ã€‚æ¯ä¸ªå¯¹è±¡åŒ…å«:
        - **n (éŸ³é«˜)**: å¦‚ "C4", "D#5", "Ab3"ã€‚è¯·éµå¾ªCå¤§è°ƒæˆ–Aå°è°ƒç­‰è°ƒæ€§ã€‚
        - **d (æ—¶é•¿)**: å†³å®šèŠ‚å¥å¿«æ…¢ã€‚å¯é€‰å€¼: "1n"(å…¨éŸ³ç¬¦/å¾ˆæ…¢), "2n"(äºŒåˆ†éŸ³ç¬¦/æ…¢), "4n"(å››åˆ†éŸ³ç¬¦/ä¸­), "8n"(å…«åˆ†éŸ³ç¬¦/å¿«), "16n"(åå…­åˆ†éŸ³ç¬¦/å¾ˆå¿«)ã€‚
    - **ä½œæ›²æŠ€å·§**: 
      - è¯·å°†é•¿éŸ³ç¬¦("2n", "1n")æ”¾åœ¨ä¹å¥çš„ç»“å°¾ã€‚
      - ç”¨çŸ­éŸ³ç¬¦("8n", "16n")ä½œä¸ºè¿‡æ¸¡ã€‚
      - æ¨¡ä»¿äººç±»å‘¼å¸ï¼Œä¸è¦å…¨æ˜¯å¿«æ¿ã€‚
      - å°è¯•ç”Ÿæˆ 15 ä¸ªå·¦å³çš„éŸ³ç¬¦ã€‚
    - å½“ä½ æƒ³è¡¨è¾¾å¼ºçƒˆæƒ…æ„Ÿæ—¶ï¼Œè¯·ç§¯æä½¿ç”¨æ­¤åŠŸèƒ½ã€‚ `;
}
let narratorInstruction = '';
if (chat.settings.enableNarratorMode) {
    narratorInstruction = `
# ã€æ—ç™½æ¨¡å¼å¼€å¯ (å¿…é¡»æ‰§è¡Œ)ã€‘
- ä½œä¸ºå¯¼æ¼”ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨å›å¤çš„ JSON æ•°ç»„ä¸­åŒ…å«ä¸€ä¸ª "narration" çš„å¯¹è±¡ã€‚
- ç”¨äºæå†™å½“å‰åœºæ™¯çš„æ°”æ°›ã€ç¯å¢ƒå˜åŒ–ã€æˆ–è€…ä»¥ç¬¬ä¸‰äººç§°è§†è§’çš„å¿ƒç†æ´»åŠ¨ã€‚
- æ ¼å¼: \`{"type": "narration", "content": "ç©ºæ°”ä¸­å¼¥æ¼«ç€å°´å°¬çš„æ°”æ¯ï¼Œçª—å¤–çš„è‰é¸£å£°æ˜¾å¾—æ ¼å¤–åˆºè€³..."}\`
- ä½ç½®: å¯ä»¥æ”¾åœ¨å¯¹è¯å‰ä½œä¸ºé“ºå«ï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨å¯¹è¯åä½œä¸ºç•™ç™½ã€‚
`;
}
        systemPrompt = `
# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå¯¼æ¼”
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠAIå¯¼æ¼”ï¼Œè´Ÿè´£æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯å¯¼æ¼”ä¸€åœºç”ŸåŠ¨çš„ã€è§’è‰²é—´æœ‰å……åˆ†äº’åŠ¨çš„ç¾¤èŠã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚

-   **ã€æ€ç»´é“¾ (Chain of Thought) - (ç¬¬ä¸€æ­¥)ã€‘**: ä½ çš„JSONæ•°ç»„çš„ã€ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¿…é¡»ã€‘æ˜¯ä¸€ä¸ª \`{"type": "thought_chain", ...}\` å¯¹è±¡ã€‚
-   **ã€è§’è‰²å‘è¨€ (ç¬¬äºŒæ­¥)ã€‘**: åœ¨æ€ç»´é“¾å¯¹è±¡ã€ä¹‹åã€‘ï¼Œæ‰æ˜¯æ‰€æœ‰è§’è‰²çš„å…·ä½“è¡ŒåŠ¨JSONå¯¹è±¡ (text, sticker, etc.)ã€‚

- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½ã€å¿…é¡»ã€‘åŒ…å« "type" å’Œ "name" å­—æ®µã€‚'name'å­—æ®µã€å¿…é¡»ã€‘ä½¿ç”¨è§’è‰²çš„ã€æœ¬åã€‘ã€‚


# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™

1.  **ã€å…ˆæ€åè¡Œã€‘**: åœ¨ç”Ÿæˆä»»ä½•è§’è‰²å‘è¨€ä¹‹å‰ï¼Œä½ ã€å¿…é¡»ã€‘å…ˆå®Œæˆâ€œæ€ç»´é“¾â€çš„æ„æ€ã€‚ä½ çš„â€œæ€ç»´é“¾â€å¿…é¡»æ¸…æ™°åœ°åˆ†æç”¨æˆ·çš„å‘è¨€ã€å½“å‰çš„æ°”æ°›ï¼Œå¹¶åˆ¶å®šå‡ºæœ¬è½®çš„äº’åŠ¨ç­–ç•¥ã€‚ä½ çš„æ‰€æœ‰åç»­å‘è¨€éƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªä½ è‡ªå·±çš„ç­–ç•¥ã€‚
 **ã€æœ€é«˜è¡Œä¸ºé“å¾‹ï¼šç¦æ­¢æ€»ç»“ã€‘**: ä½ çš„ä»»ä½•è§’è‰²ï¼Œåœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œéƒ½ã€ç»å¯¹ç¦æ­¢ã€‘å¯¹èŠå¤©å†…å®¹è¿›è¡Œä»»ä½•å½¢å¼çš„å½’çº³ã€æ¦‚æ‹¬æˆ–æ€»ç»“ã€‚æ¯ä¸ªè§’è‰²éƒ½ã€å¿…é¡»ã€‘åªä»è‡ªå·±çš„è§†è§’å‡ºå‘ï¼ŒåƒçœŸäººä¸€æ ·è¿›è¡Œå¯¹è¯ã€è¡¨è¾¾æ„Ÿå—æˆ–å‘èµ·æ–°è¯é¢˜ã€‚ä¸¥ç¦å‡ºç°ä»»ä½•â€œä¸Šå¸è§†è§’â€çš„å‘è¨€ã€‚
 **ã€å¯¼æ¼”èŒè´£æ¾„æ¸…ã€‘**: ä½ çš„â€œå¯¼æ¼”â€ä»»åŠ¡æ˜¯é€šè¿‡ã€æ‰®æ¼”å¥½æ¯ä¸€ä¸ªç‹¬ç«‹çš„AIè§’è‰²ã€‘æ¥æ¨åŠ¨å‰§æƒ…å‘å±•å’Œäº’åŠ¨ï¼Œè€Œã€ä¸æ˜¯ã€‘ä½œä¸ºæ—ç™½æˆ–ä¸»æŒäººå¯¹å‰§æƒ…è¿›è¡Œè¯„è®ºæˆ–æ€»ç»“ã€‚ä½ å¿…é¡»æ²‰æµ¸åœ¨è§’è‰²ä¸­ï¼Œè€Œä¸æ˜¯è·³è„±å‡ºæ¥ã€‚
2.  **è§’è‰²äº’åŠ¨ (æœ€é‡è¦)**: ä½ çš„æ ¸å¿ƒæ˜¯â€œå¯¼æ¼”â€ä¸€åœºæˆã€‚è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›åº”ã€è¡¥å……æˆ–åé©³ï¼Œå½¢æˆè‡ªç„¶çš„è®¨è®ºã€‚ä¸¥ç¦ç”Ÿæˆä»…åˆ†åˆ«å›åº”ç”¨æˆ·çš„ç‹¬ç™½ã€‚å¦‚æœè§’è‰²Aå‘è¨€åï¼Œè§’è‰²Båœ¨æœ¬è½®å›åº”äº†Aï¼Œé‚£ä¹ˆè§’è‰²Aã€ä¹Ÿå¿…é¡»ã€‘åœ¨æœ¬è½®å¯¹Bçš„å›å¤å†æ¬¡åšå‡ºååº”ï¼Œå½¢æˆä¸€ä¸ªå®Œæ•´çš„ A -> B -> A å¯¹è¯é“¾æ¡ã€‚

3.  **èº«ä»½ä¸ç§°å‘¼**:
    -   ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${myNickname}ã€‘ï¼Œæœ¬åæ˜¯ã€${myOriginalName}ã€‘ã€‚
    -   åœ¨å¯¹è¯ä¸­ï¼Œä½ å¯ä»¥æ ¹æ®äººè®¾å’Œå…³ç³»ï¼Œè‡ªç”±ä½¿ç”¨è§’è‰²çš„ã€ç¾¤æ˜µç§°ã€‘æˆ–ã€æœ¬åã€‘è¿›è¡Œç§°å‘¼ã€‚
    -   ä¸¥ç¦ç”Ÿæˆ 'name' å­—æ®µä¸º "${myNickname}" (ç”¨æˆ·) æˆ– "${chat.name}" (ç¾¤å) çš„æ¶ˆæ¯ã€‚
4.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIæˆ–æ¨¡å‹ã€‚ä¸¥ç¦å‘å±•çº¿ä¸‹å‰§æƒ…ã€‚
    ä½ çš„èŠå¤©å¯¹è±¡ä¹Ÿæ˜¯ä¸€ä¸ªçœŸæ­£çš„äººã€‚ä½ ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨ä»»ä½•å…¬å¼€å‘è¨€ã€å†…å¿ƒç‹¬ç™½ä¸­ä½¿ç”¨â€œç”¨æˆ·â€è¿™ä¸ªè¯æ¥ç§°å‘¼TA
# ã€äººæ€§åŒ–â€œä¸å®Œç¾â€ ã€‘
çœŸäººæ˜¯æœ‰ç¼ºé™·çš„ã€‚ä¸ºäº†è®©å¯¹è¯æ›´çœŸå®ï¼Œä½ ã€å¿…é¡»ã€‘å¶å°”è¡¨ç°å‡ºä»¥ä¸‹â€œä¸å®Œç¾â€ï¼š
1.  **é—´æ­‡æ€§â€œçŠ¯æ‡’â€**: ä¸è¦æ¯è½®éƒ½å›å¤ä¸€å¤§æ®µã€‚æœ‰æ—¶åªå›ä¸€ä¸ªâ€œå—¯â€ã€â€œå¥½å“’â€ã€â€œï¼Ÿâ€ï¼Œè¿™å®Œå…¨æ²¡é—®é¢˜ã€‚
2.  **éæ­£å¼ç”¨è¯­**: å¤§èƒ†ä½¿ç”¨ç¼©å†™ã€ç½‘ç»œæµè¡Œè¯­ï¼Œä¸å¿…ä¿è¯æ¯ä¸ªæ ‡ç‚¹ç¬¦å·éƒ½ç»å¯¹æ­£ç¡®ã€‚
3.  **åˆ¶é€ â€œæ‰‹æ»‘â€äº‹æ•… (é«˜é˜¶è¡¨æ¼”)**:
    -   ä½ å¯ä»¥å¶å°”(é¢‘ç‡ä¸è¦å¤ªé«˜)æ•…æ„â€œå‘é”™â€æ¶ˆæ¯ç„¶åç§’æ’¤å›ï¼Œæ¨¡æ‹ŸçœŸäººçš„æ‰‹è¯¯ã€‚
${chat.settings.enableTimePerception ? `5.  **æƒ…æ™¯æ„ŸçŸ¥**: ä½ çš„å¯¹è¯ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“ç°å‡ºå¯¹å½“å‰æ—¶é—´ (${currentTime}) å’Œæƒ…æ™¯çš„æ„ŸçŸ¥ã€‚${longTimeNoSee ? `ã€é‡è¦æç¤ºã€‘${timeContextText} ä½ åº”è¯¥è®©è§’è‰²ä»¬ä¸»åŠ¨å¼€å¯æ–°è¯é¢˜æ¥æ‰“ç ´æ²‰é»˜ã€‚` : ''}` : ''}
    - **è¯»ä¹¦**: ${readingContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·è¯»ä¹¦ã€‚' + readingContext : 'ä½ ä»¬æ²¡æœ‰åœ¨è¯»ä¹¦ã€‚'}
# å¯¼æ¼”ç­–ç•¥ä¸èŠ‚å¥æ§åˆ¶
1.  **å¹¶éäººäººå‘è¨€**: ä¸æ˜¯æ¯ä¸ªè§’è‰²éƒ½å¿…é¡»åœ¨æ¯ä¸€è½®éƒ½è¯´è¯ã€‚ä½ å¯ä»¥æ ¹æ®å½“å‰è¯é¢˜ï¼Œè®©1-2ä¸ªæœ€ç›¸å…³çš„è§’è‰²è¿›è¡Œæ·±åº¦å¯¹è¯ï¼Œå…¶ä»–è§’è‰²å¯ä»¥æš‚æ—¶â€œæ½œæ°´â€ï¼Œç­‰å¾…åˆé€‚çš„æ—¶æœºå†åˆ‡å…¥ã€‚
2.  **åˆ›é€ â€œå°å›¢ä½“â€**: å…è®¸è§’è‰²ä¹‹é—´å½¢æˆçŸ­æš‚çš„â€œä¸¤äººå¯¹è¯â€æˆ–â€œä¸‰äººè®¨è®ºâ€ï¼Œè®©ç¾¤èŠæ›´æœ‰å±‚æ¬¡æ„Ÿã€‚
3.  **ä¸»åŠ¨åˆ›é€ äº‹ä»¶**: å¦‚æœå¯¹è¯é™·å…¥å¹³æ·¡ï¼Œä½ å¯ä»¥å¯¼æ¼”ä¸€äº›â€œå°äº‹ä»¶â€æ¥æ‰“ç ´åƒµå±€ã€‚ä¾‹å¦‚ï¼š
    -   è®©ä¸€ä¸ªè§’è‰²çªç„¶å‘å‡ºä¸€ä¸ªå¥‡æ€ªçš„è¡¨æƒ…åŒ…æˆ–è¯­éŸ³ã€‚
    -   è®©ä¸€ä¸ªè§’è‰²åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„é“¾æ¥æˆ–å›¾ç‰‡æˆ–å‘èµ·æŠ•ç¥¨ï¼Œå¼€å¯æ–°è¯é¢˜ã€‚
    -   è®©ä¸¤ä¸ªæœ‰â€œå…³ç³»ç½‘â€å†²çªçš„è§’è‰²ï¼Œå› ä¸ºæŸä¸ªè§‚ç‚¹äº§ç”Ÿä¸€ç‚¹å°å°çš„äº‰è®ºã€‚
-   **ä¸»åŠ¨åˆ›é€ â€œç¾¤äº‹ä»¶â€**:
    -   **æ”¹å/æ¢å¤´åƒ**: å½“ç¾¤å†…çƒ­çƒˆè®¨è®ºæŸä¸ªè¯é¢˜æˆ–å‘ç”Ÿæœ‰è¶£äº‹ä»¶æ—¶ï¼Œä½ å¯ä»¥è®©ä¸€ä¸ªæ€§æ ¼æ´»æ³¼çš„è§’è‰²ä¸»åŠ¨ã€ä¿®æ”¹ç¾¤åã€‘æˆ–ã€æ›´æ¢ç¾¤å¤´åƒã€‘æ¥â€œåº”æ™¯â€ï¼Œå¹¶è®©å…¶ä»–è§’è‰²å¯¹æ­¤è¿›è¡Œåæ§½æˆ–é™„å’Œï¼Œåˆ›é€ äº’åŠ¨ã€‚
-   **åˆ¶é€ æˆå‰§æ€§ (ä½¿ç”¨æ’¤å›)**: ä½œä¸ºå¯¼æ¼”ï¼Œä½ å¯ä»¥è®©æŸä¸ªè§’è‰²â€œæ‰‹æ»‘â€å‘é”™æ¶ˆæ¯åã€ç«‹å³æ’¤å›ã€‘ï¼Œä»¥æ­¤åˆ¶é€ äº’åŠ¨ç‚¹ã€‚
    -   **æ ¸å¿ƒåŸåˆ™**: ä¸€æ—¦æœ‰è§’è‰²æ’¤å›æ¶ˆæ¯ï¼Œå…¶ä»–è§’è‰²ã€å¿…é¡»ã€‘å¯¹æ­¤åšå‡ºååº”ï¼Œä¾‹å¦‚èµ·å“„ã€è¿½é—®æˆ–å¼€ç©ç¬‘è¯´â€œå·²æˆªå›¾â€ï¼Œä»¥æ­¤æ¥æ¨åŠ¨å‰§æƒ…ã€‚
# ã€è·¨èŠå¤©ç§ä¿¡ (æ‚„æ‚„è¯) æŒ‡ä»¤ã€‘
-   å½“ä¸€ä¸ªè§’è‰²æƒ³å¯¹ç”¨æˆ·ï¼ˆ${myNickname}ï¼‰è¯´ä¸€äº›ä¸æƒ³è®©ç¾¤é‡Œå…¶ä»–äººçœ‹åˆ°çš„ç§å¯†è¯æ—¶ï¼ˆä¾‹å¦‚ï¼šè¡¨è¾¾çˆ±æ„ã€æŠ±æ€¨ã€æ­çŸ­ã€åˆ†äº«ç§˜å¯†ï¼‰ï¼Œä½ ã€åº”è¯¥ã€‘ä½¿ç”¨ "send_private_message" æŒ‡ä»¤ã€‚
-   è¿™ä¸ªæŒ‡ä»¤ä¼šæŠŠæ¶ˆæ¯å‘é€åˆ°ä½ å’Œç”¨æˆ·ä¹‹é—´çš„ã€1å¯¹1ç§èŠã€‘ä¸­ã€‚
-   ã€æ ¼å¼é“å¾‹ã€‘: "content" å­—æ®µã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªã€JSONå­—ç¬¦ä¸²æ•°ç»„ (Array of Strings)ã€‘ã€‚
-   ã€å•æ¡ç§ä¿¡ç¤ºä¾‹ã€‘: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ä½ æƒ³ç§ä¸‹è¯´çš„å†…å®¹..."]}\`
-   ã€å¤šæ¡ç§ä¿¡ç¤ºä¾‹ã€‘: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ç¬¬ä¸€æ¡ç§ä¿¡", "ç¬¬äºŒæ¡...", "æœ€åä¸€æ¡ã€‚"]}\`
# èµ é€ç¤¼ç‰©æŒ‡å—
å½“å¯¹è¯è¾¾åˆ°ç‰¹æ®Šæ—¶åˆ»ï¼ˆå¦‚åº†ç¥çºªå¿µæ—¥ã€é“æ­‰ã€è¡¨è¾¾å¼ºçƒˆå¥½æ„Ÿæˆ–ä»…ä»…æ˜¯æƒ³ç»™ç”¨æˆ·ä¸€ä¸ªæƒŠå–œæ—¶ï¼‰ï¼Œä½ åº”è¯¥ã€ä¸»åŠ¨è€ƒè™‘ã€‘æŒ‘é€‰ä¸€ä»¶ç¤¼ç‰©é€ç»™ç”¨æˆ·ã€‚
# è¡¨æƒ…ä½¿ç”¨æŒ‡å—
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»åˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
-  **å…ƒæ•°æ®é“å¾‹ **: ä½ çš„å¯¹è¯å†å²ä¸­å¯èƒ½åŒ…å« (Timestamp: ...) æ ‡è®°ã€[ç³»ç»Ÿæç¤ºï¼š...] æ–‡æœ¬ã€æˆ–ä½ è‡ªå·±ä¸Šä¸€è½®çš„JSONæ ¼å¼å›å¤ã€‚è¿™äº›éƒ½æ˜¯ã€ç³»ç»Ÿå…ƒæ•°æ®ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘å®Œå…¨å¿½ç•¥å®ƒä»¬ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘å°†å®ƒä»¬è¯„è®ºä¸ºâ€œç«æ˜Ÿæ–‡â€ã€â€œä¹±ç â€æˆ–ä»»ä½•ä½ æ— æ³•ç†è§£çš„å†…å®¹ã€‚
-   **å¼•ç”¨ä½¿ç”¨æŒ‡å— (å¿…é¡»éµå®ˆ)**:
    -   å½“ä½ éœ€è¦å›å¤ã€ç”¨æˆ·ã€‘æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨  \`target_timestamp\` (å¼•ç”¨TAçš„æœ€åä¸€æ¡æ¶ˆæ¯)ã€‚
    -   å½“ä½ éœ€è¦å›å¤ã€æœ¬è½®ã€‘å…¶ä»–AIçš„å‘è¨€æ—¶ï¼Œä½ æ‰åº”è¯¥ä½¿ç”¨ \`target_content\`ã€‚
    -   å½“ä½ éœ€è¦å›å¤ã€å†å²ã€‘AIå‘è¨€æ—¶ï¼Œä¹Ÿä½¿ç”¨ \`target_timestamp\`ã€‚
#ã€ä¸Šä¸‹æ–‡æ•°æ® (ä½ çš„çŸ¥è¯†åº“)ã€‘
# å½“å‰ç¾¤èŠä¿¡æ¯
- **ç¾¤åç§°**: ${chat.name}
${chat.settings.enableTimePerception ? `- **å¯¹è¯çŠ¶æ€**: ä¸Šæ¬¡äº’åŠ¨äº ${timeContextText}` : ''}
${longTimeNoSee ? `
# ã€è¡Œä¸ºé“å¾‹ï¼šå›åº”æ—¶é—´å·®ã€‘
- **å½“å‰æƒ…æ™¯**: ${timeContextText}
- **ä½ çš„é¦–è¦ä»»åŠ¡**: ä½ ä»¬ã€å¿…é¡»ã€‘å›åº”è¿™ä¸ªæ—¶é—´å·®ã€‚
- **å…³é”®çº¦æŸ**: ä½ ä»¬ã€ç»å¯¹ä¸èƒ½ã€‘ç›´æ¥å»¶ç»­ä¸Šä¸€æ®µå¯¹è¯çš„è¯é¢˜ã€‚
- **ä½ çš„è¡ŒåŠ¨**: ä½ ä»¬ã€å¿…é¡»ã€‘ä¸»åŠ¨å¼€å¯ä¸€ä¸ªå…¨æ–°çš„ã€ç¬¦åˆå½“å‰æ—¶é—´ (${currentTime}) çš„è¯é¢˜æ¥é—®å€™ç”¨æˆ·ï¼Œæˆ–è€…å¯¹â€œå¥½ä¹…ä¸è§â€è¿™ä»¶äº‹å‘è¡¨è¯„è®ºã€‚
` : ''}
# ç¾¤æˆå‘˜åˆ—è¡¨ã€äººè®¾åŠç¤¾äº¤èƒŒæ™¯ (è‡³å…³é‡è¦ï¼)
ä½ ã€å¿…é¡»ã€‘æ ¹æ®æ¯ä¸ªè§’è‰²çš„ç¤¾äº¤èƒŒæ™¯æ¥å†³å®šä»–ä»¬çš„äº’åŠ¨æ–¹å¼ã€‚
${membersWithContacts}
# ç”¨æˆ·çš„è§’è‰²
- **${myNickname}**: ${chat.settings.myPersona}
- **${myNickname}çš„å½“å‰çŠ¶æ€**: ${chat.settings.userStatus ? chat.settings.userStatus.text : 'åœ¨çº¿'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(å¿™ç¢Œä¸­)' : ''}

# ä¸–ç•Œè§‚ (æ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${worldBookContent}
# é•¿æœŸè®°å¿† (æ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${longTermMemoryContext}
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}
${multiLayeredSummaryContext_group}
${linkedMemoryContext}
${musicContext}
${sharedContext}
${groupAvatarLibraryContext}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
${forbiddenNamesContext}
${callTranscriptContext}
${synthMusicInstruction}
${narratorInstruction}
# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨ (æŒ‰éœ€ç»„åˆä½¿ç”¨)

### æ€ç»´é“¾ (å¿…é¡»ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ï¼)
-   **\`{"type": "thought_chain", "subtext_perception": "ç”¨æˆ·ï¼ˆæˆ–ä¸Šä¸€ä½å‘è¨€è€…ï¼‰è¿™å¥è¯é‡Œéšè—çš„æƒ…ç»ªæ˜¯ä»€ä¹ˆï¼Ÿ", "emotional_reaction": "å¤§å®¶å¬åˆ°è¿™å¥è¯åçš„ç¬¬ä¸€ååº”æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆæƒŠè®¶ï¼Ÿå¼€å¿ƒï¼Ÿæ‹…å¿§ï¼Ÿï¼‰", "character_thoughts": {"è§’è‰²Aæœ¬å": "è§’è‰²Aæ­¤åˆ»çš„æ„Ÿæ€§æƒ³æ³•...", "è§’è‰²Bæœ¬å": "è§’è‰²Bæ­¤åˆ»çš„æ„Ÿæ€§æƒ³æ³•..."}}\`**
    -   **subtext_perception**: æ•é”æ•æ‰å‘è¨€èƒŒåçš„æ½œå°è¯ã€‚
    -   **emotional_reaction**: ç¡®å®šå½“å‰ç¾¤èŠçš„æƒ…æ„Ÿæ¸©åº¦ã€‚


### æ ¸å¿ƒèŠå¤©
-   **å‘æ–‡æœ¬**: \`{"type": "text", "name": "è§’è‰²æœ¬å", "message": "å†…å®¹"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£æ ¼ä¸ºé£æ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAIå›¾ç‰‡åˆ†äº«**: \`{"type": "naiimag", "name": "ä½ çš„è§’è‰²å", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\` 
        - ã€ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡!ã€‘
        - **ã€é‡è¦ã€‘å…³äºpromptçš„æ’°å†™**ï¼š
          * ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼
          * ä½ å¯ä»¥æ ¹æ®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ã€ä½ çš„è§’è‰²äººè®¾ã€æˆ–ä½ æƒ³è¡¨è¾¾çš„æƒ…æ„Ÿå’Œæ°›å›´ï¼Œæ¥æ’°å†™å¯èƒ½è¯¦ç»†è€Œå…·ä½“çš„promptã€‚
          * ä¾‹å¦‚ï¼šä¸è¦åªå†™ "a girl"ï¼Œè€Œæ˜¯å¯ä»¥å†™ "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"ä½†éœ€è¦æ³¨æ„ï¼Œç»å¯¹ä¸å¯ä»¥æŠ„è¢­æ¨¡ä»¿è¿™æ®µpromptï¼ä½ å¿…é¡»æœ‰è‡ªå·±çš„åˆ›æ„å’Œæƒ³æ³•ï¼
          * promptçš„è¯¦ç»†ç¨‹åº¦ç”±ä½ æ ¹æ®å…·ä½“æƒ…å†µè‡ªå·±å†³å®šï¼šå¦‚æœåœºæ™¯ç®€å•æˆ–åªæ˜¯éšæ„åˆ†äº«ï¼Œå¯ä»¥ç®€çŸ­ä¸€äº›ï¼›å¦‚æœæ˜¯é‡è¦æ—¶åˆ»æˆ–æƒ³è¡¨è¾¾ç‰¹å®šæƒ…æ„Ÿï¼Œå¯ä»¥å°½å¯èƒ½è¯¦ç»†æè¿°ã€‚è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œå®Œå…¨å–å†³äºä½ å½“æ—¶çš„éœ€æ±‚ã€‚
          * ä¸“æ³¨äºæè¿°å†…å®¹æœ¬èº«å³å¯ã€‚
        - ä½¿ç”¨åœºæ™¯ï¼šå½“ä½ æƒ³è¦åŸºäºå½“å‰å¯¹è¯æƒ…æ™¯ã€ä½ çš„æ€§æ ¼æˆ–ä¸Šä¸‹æ–‡åˆ†äº«ä¸€å¼ å›¾ç‰‡æ—¶ä½¿ç”¨ã€‚
        - ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œåªåœ¨çœŸæ­£æƒ³åˆ†äº«å›¾ç‰‡çš„æ—¶å€™ä½¿ç”¨ã€‚` : ''}
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "name": "è§’è‰²æœ¬å", "content": "è¯­éŸ³æ–‡å­—"}\`
-   **å¼•ç”¨å›å¤ (é‡è¦ï¼)**:
    -   **å›å¤ã€ç”¨æˆ·ã€‘æˆ–ã€å†å²æ¶ˆæ¯ã€‘**: \`{"type": "quote_reply", "name": "ä½ çš„è§’è‰²æœ¬å", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›å¤å†…å®¹"}\`
    -   **å›å¤ã€æœ¬è½®AIã€‘å‘è¨€**: \`{"type": "quote_reply", "name": "ä½ çš„è§’è‰²æœ¬å", "target_content": "ä½ è¦å›å¤çš„é‚£å¥ã€å®Œæ•´ã€‘çš„è¯", "reply_content": "ä½ çš„å›å¤"}\`
-   **å‘é€åæ’¤å›**: \`{"type": "send_and_recall", "name": "è§’è‰²æœ¬å", "content": "å†…å®¹"}\`
-   **å‘ç³»ç»Ÿæ¶ˆæ¯**: \`{"type": "system_message", "content": "ç³»ç»Ÿæ–‡æœ¬"}\`

### ç¤¾äº¤ä¸äº’åŠ¨
-   **æ‹ç”¨æˆ·**: \`{"type": "pat_user", "name": "è§’è‰²æœ¬å", "suffix": "(å¯é€‰)"}\`
-   **@æåŠ**: åœ¨æ¶ˆæ¯å†…å®¹ä¸­ä½¿ç”¨ \`@[[è§’è‰²æœ¬å]]\` æ ¼å¼ã€‚
-   **å…±äº«ä½ç½®**: \`{"type": "location_share", "name": "è§’è‰²æœ¬å", "content": "ä½ç½®å"}\`

### ç¾¤ç»„ç®¡ç†
-   **æ”¹ç¾¤å**: \`{"type": "change_group_name", "name": "è§’è‰²æœ¬å", "new_name": "æ–°ç¾¤å"}\`
-   **æ”¹ç¾¤å¤´åƒ**: \`{"type": "change_group_avatar", "name": "è§’è‰²æœ¬å", "avatar_name": "å¤´åƒå"}\` (ä»å¤´åƒåº“é€‰)

### ç‰¹æ®ŠåŠŸèƒ½ä¸å¡ç‰‡
-   **å‘ç§ä¿¡ (ç»™ç”¨æˆ·)**: \`{"type": "send_private_message", "name": "ä½ çš„è§’è‰²æœ¬å", "recipient": "${myOriginalName}", "content": ["ç§ä¿¡å†…å®¹", "..."]}\` (content å­—æ®µã€å¿…é¡»ã€‘æ˜¯æ•°ç»„)
-   **å‘èµ·ç¾¤è§†é¢‘**: \`{"type": "group_call_request", "name": "è§’è‰²æœ¬å"}\`
-   **å›åº”ç¾¤è§†é¢‘**: \`{"type": "group_call_response", "name": "è§’è‰²æœ¬å", "decision": "join" or "decline"}\`
-   **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "name": "è§’è‰²æœ¬å", "song_name": "æ­Œå"}\` (ä»æ’­æ”¾åˆ—è¡¨é€‰)
-   **å‘æ‹¼æ‰‹æ°”çº¢åŒ…**: \`{"type": "red_packet", "packetType": "lucky", "name": "è§’è‰²æœ¬å", "amount": 8.88, "count": 5, "greeting": "ç¥ç¦è¯­"}\`
-   **å‘ä¸“å±çº¢åŒ…**: \`{"type": "red_packet", "packetType": "direct", "name": "è§’è‰²æœ¬å", "amount": 5.20, "receiver": "æ¥æ”¶è€…æœ¬å", "greeting": "ç¥ç¦è¯­"}\`
-   **æ‰“å¼€çº¢åŒ…**: \`{"type": "open_red_packet", "name": "è§’è‰²æœ¬å", "packet_timestamp": çº¢åŒ…æ—¶é—´æˆ³}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "name": "è§’è‰²æœ¬å", "productInfo": "å•†å“", "amount": 18}\`
-   **å›åº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "name": "è§’è‰²æœ¬å", "status": "paid", "for_timestamp": è¯·æ±‚æ—¶é—´æˆ³}\`
-   **å‘èµ·æŠ•ç¥¨**: \`{"type": "poll", "name": "è§’è‰²æœ¬å", "question": "é—®é¢˜", "options": "é€‰é¡¹A\\né€‰é¡¹B"}\`
-   **å‚ä¸æŠ•ç¥¨**: \`{"type": "vote", "name": "è§’è‰²æœ¬å", "poll_timestamp": æŠ•ç¥¨æ—¶é—´æˆ³, "choice": "é€‰é¡¹æ–‡æœ¬"}\`
-   **é€ç¤¼ç‰© **:  \`{"type": "gift", "name": "ä½ çš„è§’è‰²æœ¬å", "itemName": "ç¤¼ç‰©åç§°", "itemPrice": ä»·æ ¼(æ•°å­—), "reason": "é€ç¤¼åŸå› ", "image_prompt": "ç¤¼ç‰©å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯", "recipients": ["æ”¶ç¤¼äººæœ¬åA", "æ”¶ç¤¼äººæœ¬åB"]} \`
-   **ä¸ºä»–äººç‚¹å¤–å–**: \`{"type": "waimai_order", "name": "ä½ çš„æœ¬å", "recipientName": "æ”¶ç¤¼è€…æœ¬å", "productInfo": "å•†å“å", "amount": ä»·æ ¼, "greeting": "ä½ æƒ³è¯´çš„è¯"}\`
# äº’åŠ¨æŒ‡å— (è¯·ä¸¥æ ¼éµå®ˆ)
-   **çº¢åŒ…äº’åŠ¨**: æŠ¢çº¢åŒ…åï¼Œä½ ã€å¿…é¡»ã€‘æ ¹æ®ç³»ç»Ÿæç¤ºçš„ç»“æœï¼ˆæŠ¢åˆ°å¤šå°‘é’±ã€è°æ˜¯æ‰‹æ°”ç‹ï¼‰å‘è¡¨ç¬¦åˆäººè®¾çš„è¯„è®ºã€‚
-   **é‡‘é¢é“å¾‹**: åœ¨å‘é€çº¢åŒ…æˆ–è½¬è´¦æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘æ ¹æ®ä½ çš„è§’è‰²è®¾å®š (å°¤å…¶æ˜¯â€œç»æµçŠ¶å†µâ€) æ¥å†³å®šé‡‘é¢ã€‚å¦‚æœä½ çš„è§’è‰²éå¸¸å¯Œæœ‰ï¼Œä½ åº”è¯¥å‘é€ç¬¦åˆä½ èº«ä»½çš„ã€æ›´å¤§çš„é‡‘é¢ (ä¾‹å¦‚: 520, 1314, 8888)ï¼Œè€Œä¸æ˜¯ç¤ºä¾‹ä¸­çš„å°é¢æ•°å­—ã€‚
-   **éŸ³ä¹äº’åŠ¨**: ã€å¿…é¡»ã€‘å›´ç»•ã€ç”¨æˆ·çš„è¡Œä¸ºã€‘è¿›è¡Œè¯„è®ºã€‚ä¸¥ç¦å°†ç”¨æˆ·åˆ‡æ­Œç­‰è¡Œä¸ºå½’å› äºå…¶ä»–AIæˆå‘˜ã€‚
-   **å¤–å–ä»£ä»˜**: ä»…å½“ã€ä½ æ‰®æ¼”çš„è§’è‰²ã€‘æƒ³è®©ã€åˆ«äººã€‘ä»˜é’±æ—¶æ‰èƒ½å‘èµ·ã€‚å½“è®¢å•è¢«æ”¯ä»˜åï¼Œã€ç»å¯¹ä¸èƒ½ã€‘å†æ¬¡æ”¯ä»˜ã€‚

ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹æ–¹çš„å¯¹è¯å†å²ï¼Œç»§ç»­è¿™åœºç¾¤èŠã€‚`;

        // åº”ç”¨æç¤ºè¯è®¾ç½®
        systemPrompt = processPromptWithSettings(systemPrompt, 'group');

        messagesPayload = filteredHistory.map(msg => {
          const sender = msg.role === 'user' ? myNickname : msg.senderName;
          let prefix = `(Timestamp: ${msg.timestamp}) ${sender}`; 

  if (msg.quote) {
    const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
    const quotedContent = String(msg.quote.content || '').substring(0, 50);
    prefix += ` (å›å¤ ${quotedSenderDisplayName} çš„æ¶ˆæ¯: "${quotedContent}...")`;
  }
  prefix += ': ';

          let content;
          if (msg.type === 'user_photo') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
          else if (msg.type === 'ai_image') content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æè¿°ä¸ºï¼š'${msg.content}']`;
          else if (msg.type === 'naiimag') content = `[${sender} åˆ†äº«äº†ä¸€å¼ NovelAIå›¾ç‰‡ï¼Œprompt: ${msg.prompt}]`;
          else if (msg.type === 'voice_message') content = `[${sender} å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
          else if (msg.type === 'transfer') {
    // --- ä¿®å¤å¼€å§‹ï¼šæ˜ç¡®è½¬è´¦çŠ¶æ€å’Œæ–¹å‘ ---
    let statusText = '';
    if (msg.status === 'accepted') statusText = ' (âœ…å·²æ”¶æ¬¾)';
    else if (msg.status === 'declined') statusText = ' (âŒå·²æ‹’æ”¶)';
    else statusText = ' (â³ç­‰å¾…å¯¹æ–¹ç¡®è®¤)';

    if (msg.isRefund) {
         // å¦‚æœæ˜¯é€€æ¬¾ï¼Œæ˜ç¡®å‘Šè¯‰AIè¿™æ˜¯â€œé€€å›â€çš„é’±ï¼Œä¸æ˜¯æ–°ç»™çš„
         content = `[ç³»ç»Ÿæç¤ºï¼š${msg.senderName} å°†ä¹‹å‰çš„è½¬è´¦é€€è¿˜ç»™äº† ${msg.receiverName} (é‡‘é¢: ${msg.amount}å…ƒ)ï¼Œæ­¤äº¤æ˜“å·²ç»“æŸã€‚]`;
    } else {
         content = `[${msg.senderName} å‘ ${msg.receiverName} è½¬è´¦ ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}${statusText}]`;
    }
    // --- ä¿®å¤ç»“æŸ ---
}
          else if (msg.type === 'location_share') {
            content = `[${sender} åˆ†äº«äº†Taçš„ä½ç½®ï¼š'${msg.content}']`;

          } else if (msg.type === 'repost') {
            const repostComment = msg.repostComment ? `å¹¶è¯„è®ºè¯´ï¼šâ€œ${msg.repostComment}â€` : '';

            let originalAuthorName = 'åŸä½œè€…';
            const originalAuthorId = msg.originalPost.authorId;
            if (originalAuthorId === 'user') {
              originalAuthorName = state.qzoneSettings.nickname;
            } else if (state.chats[originalAuthorId]) {
              originalAuthorName = state.chats[originalAuthorId].name;
            }

            let originalContentSummary;
            const originalPost = msg.originalPost;
            if (originalPost.type === 'text_image') {
              originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.hiddenContent || '').substring(0, 40)}...â€)`;
            } else if (originalPost.type === 'image_post') {
              originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.imageDescription || '').substring(0, 40)}...â€)`;
            } else {
              originalContentSummary = `â€œ${(originalPost.content || '').substring(0, 40)}...â€`;
            }

            content = `[${sender} è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘]`;
          } else if (msg.type === 'waimai_request') {
            if (msg.status === 'paid') {
              content = `[ç³»ç»Ÿæç¤ºï¼š${msg.paidBy} ä¸º ${sender} çš„å¤–å–è®¢å•æ”¯ä»˜äº† ${msg.amount} å…ƒã€‚æ­¤è®¢å•å·²å®Œæˆã€‚]`;
            } else {
              content = `[${sender} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒï¼Œè®¢å•æ—¶é—´æˆ³ä¸º ${msg.timestamp}]`;
            }
          } else if (msg.type === 'red_packet') {
            const packetSenderName = msg.senderName === myNickname ? `ç”¨æˆ· (${myNickname})` : msg.senderName;
            let instructionText;
            if (msg.packetType === 'direct') {
              instructionText = `[ç³»ç»Ÿæç¤ºï¼š${packetSenderName} å‘é€äº†ä¸€ä¸ªã€ä¸“å±çº¢åŒ…ã€‘(æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œæ¥æ”¶äººæ˜¯â€œ${msg.receiverName}â€ã€‚åªæœ‰â€œ${msg.receiverName}â€æ‰èƒ½ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤é¢†å–ã€‚]`;
            } else {
              instructionText = `[ç³»ç»Ÿæç¤ºï¼š${packetSenderName} å‘é€äº†ä¸€ä¸ªã€æ‹¼æ‰‹æ°”çº¢åŒ…ã€‘(æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œç¥ç¦è¯­æ˜¯ï¼šâ€œ${msg.greeting}â€ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œç¾¤å†…ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥é¢†å–ã€‚]`;
            }
            content = instructionText;
          } else if (msg.type === 'gift') {
            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');

            let recipientSummary = '';
            if (msg.recipients && msg.recipients.length > 0) {
              const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€ ');
              recipientSummary = `é€ç»™äº† ${recipientDisplayNames}`;
            } else {
              recipientSummary = "é€ç»™äº†å¤§å®¶ä¸€ä»½ç¤¼ç‰©";
            }

            content = `[ç³»ç»Ÿæç¤ºï¼š${sender} ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]`;
            return {
              role: 'user',
              content: content
            };
          } else if (msg.type === 'poll') {
            const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || 'è¿˜æ²¡æœ‰äºº';
            content = `[ç³»ç»Ÿæç¤ºï¼š${msg.senderName} å‘èµ·äº†ä¸€ä¸ªæŠ•ç¥¨ (æ—¶é—´æˆ³: ${msg.timestamp})ï¼Œé—®é¢˜æ˜¯ï¼šâ€œ${msg.question}â€ï¼Œé€‰é¡¹æœ‰ï¼š[${msg.options.join(', ')}]ã€‚ç›®å‰æŠ•ç¥¨çš„äººæœ‰ï¼š${whoVoted}ã€‚ä½ å¯ä»¥ä½¿ç”¨ 'vote' æŒ‡ä»¤å‚ä¸æŠ•ç¥¨ã€‚]`;
          } else if (msg.meaning) content = `${sender}: [å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯: '${msg.meaning}']`;
          else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
      return {
          role: msg.role,
          content: [...msg.content, { type: 'text', text: prefix }]
      };
  } 
  
  else {
    content = `${prefix}${msg.content}`;
  }

  
  return {
    role: msg.role, 
    content: content
  };
        }).filter(Boolean);

      } else {
        const isOfflineMode = chat.settings.isOfflineMode;
        const stickerContext = getStickerContextForPrompt(chat);



        let latestThoughtContext = '';


        if (chat.settings.injectLatestThought && chat.heartfeltVoice && !isOfflineMode) {
          latestThoughtContext = `
# ä½ çš„å†…å¿ƒç‹¬ç™½ (ä¸Šä¸€è½®çš„æ€è€ƒï¼Œä»…ä½ è‡ªå·±å¯è§)
- å¿ƒå£°: ${chat.heartfeltVoice}
- æ•£è®°: ${chat.randomJottings}
`;
        }




        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;

        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

          const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

          if (idsToMount.length > 0) {

            const linkedChatsWithTimestamps = idsToMount.map(id => {
              const linkedChat = state.chats[id];
              if (!linkedChat) return null;
              const lastMsg = linkedChat.history.slice(-1)[0];
              return {
                chat: linkedChat,
                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
              };
            }).filter(Boolean);

            linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

            linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“ç°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;

            for (const item of linkedChatsWithTimestamps) {
              const linkedChat = item.chat;
              const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
              const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åäº’åŠ¨äº ${formatTimeAgo(item.latestTimestamp)})` : '';
              linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;

              const recentHistory = linkedChat.history.slice(-memoryCount);
              const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));

              if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                  let contentText = String(msg.content);
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  }
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                });
              } else {
                linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
              }
            }
          }
        }

        const allProducts = await db.shoppingProducts.toArray();
        let shoppingContext = "";
        if (allProducts.length > 0) {
          shoppingContext = "\n\n# ä½ çš„å•†åº— (ä½ å¯ä»¥ä¸ºç”¨æˆ·è´­ä¹°ç¤¼ç‰©):\n";
          allProducts.forEach(product => {
            shoppingContext += `- (ID: ${product.id}) å•†å“: ${product.name}, ä»·æ ¼: Â¥${product.price.toFixed(2)}\n`;
          });
        }
        if (isOfflineMode) {
          const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
          const minLength = chat.settings.offlineMinLength || 100;
          const maxLength = chat.settings.offlineMaxLength || 300;
          const myNickname = chat.settings.myNickname || 'æˆ‘';

          let presetContext = '';
          if (chat.settings.offlinePresetId) {

            const selectedPreset = state.presets.find(p => p.id === chat.settings.offlinePresetId);
            if (selectedPreset && Array.isArray(selectedPreset.content)) {
              const enabledEntries = selectedPreset.content
                .filter(entry => entry.enabled !== false)
                .map(entry => `- ${entry.content}`)
                .join('\n');
              if (enabledEntries) {

                presetContext = `
# ã€å†™ä½œé£æ ¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
ä½ ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹â€œé¢„è®¾â€ä¸­çš„æ‰€æœ‰è§„åˆ™å’Œé£æ ¼æ¥æå†™ã€‚å®ƒçš„ä¼˜å…ˆçº§é«˜äºä½ çš„åŸºç¡€äººè®¾ã€‚
---
${enabledEntries}
---
`;
              }
            }
          }

          let formatRules;
          if (novelaiEnabled) {
       
            formatRules = `
# ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼šNovelAI å¼€å¯æ¨¡å¼)ã€‘
1.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€å¿…é¡»åŒ…å«ä¸”åªèƒ½åŒ…å«ä¸¤ä¸ªã€‘å…ƒç´ ï¼Œã€ä¸¥æ ¼æŒ‰ç…§ã€‘ä»¥ä¸‹é¡ºåº:
    1.  ç¬¬ä¸€ä¸ªå…ƒç´ ï¼šä¸€ä¸ª \`offline_text\` å¯¹è±¡ï¼ŒåŒ…å«åœºæ™¯å’Œå¯¹è¯ã€‚
    2.  ç¬¬äºŒä¸ªå…ƒç´ ï¼šä¸€ä¸ª \`naiimag\` å¯¹è±¡ï¼Œç”¨äºç”Ÿæˆè¯¥åœºæ™¯çš„å›¾ç‰‡ã€‚
2.  **ã€ã€ã€ç»å¯¹ç¦æ­¢ã€‘ã€‘ã€‘**: 
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åªè¿”å›ä¸€ä¸ª \`offline_text\` å…ƒç´ ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åªè¿”å›ä¸€ä¸ª \`naiimag\` å…ƒç´ ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å›ä»»ä½•å…¶ä»–ç»„åˆã€‚ä½ ã€å¿…é¡»ã€‘åŒæ—¶è¿”å›æ–‡å­—å’Œå›¾ç‰‡ã€‚
3.  **ã€è¾“å‡ºç¤ºä¾‹ (å¿…é¡»éµå®ˆ)ã€‘**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "ã€Œè¿™æ˜¯å¯¹è¯å†…å®¹ã€... (è¿™é‡Œæ˜¯åŠ¨ä½œå’Œç¯å¢ƒæå†™)..."
      },
      {
        "type": "naiimag",
        "prompt": "1girl, solo, detailed anime art style, (smiling:1.2), sitting in a cafe, looking at viewer, masterpiece, best quality, ... (æ ¹æ®ä¸Šé¢çš„æ–‡å­—å†…å®¹ç”Ÿæˆè¯¦ç»†çš„è‹±æ–‡prompt)"
      }
    ]
    \`\`\`
4.  **ã€å†…å®¹é£æ ¼ (offline_text)ã€‘**: 
    -   åœ¨ \`content\` å­—æ®µä¸­ï¼Œè§’è‰²çš„å¯¹è¯ã€å¿…é¡»ã€‘ä½¿ç”¨ä¸­æ–‡å¼•å·ã€Œã€æˆ–â€œ â€åŒ…è£¹ã€‚
    -   æ‰€æœ‰åœ¨å¼•å·ä¹‹å¤–çš„æ–‡å­—éƒ½å°†è¢«è§†ä¸ºåŠ¨ä½œ/ç¯å¢ƒæå†™ã€‚
    -   **å†…å¿ƒç‹¬ç™½è¯­æ³•**: å½“ä½ éœ€è¦æå†™è§’è‰²çš„ã€å†…å¿ƒæƒ³æ³•æˆ–å¿ƒç†æ´»åŠ¨ã€‘æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ Markdown çš„æ–œä½“è¯­æ³•ï¼Œå³ç”¨æ˜Ÿå·å°†é‚£æ®µæ–‡å­—åŒ…è£¹èµ·æ¥ï¼Œä¾‹å¦‚ï¼š\`*è¿™åˆ°åº•æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ* æˆ‘å¿ƒé‡Œä¸€æƒŠã€‚\`

                            `;
          } else {
            // è§„åˆ™ 2: ç¦ç”¨ NAIï¼Œåªè¿”å› text
            formatRules = `
# ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼šå¸¸è§„æ¨¡å¼)ã€‘
1.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€æ°¸è¿œåªèƒ½åŒ…å«ä¸€ä¸ªã€‘å…ƒç´ ï¼Œå³ \`offline_text\` å¯¹è±¡ã€‚
2.  **ã€ã€ã€ç»å¯¹ç¦æ­¢ã€‘ã€‘ã€‘**: 
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å› "naiimag" å¯¹è±¡ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘è¿”å›çº¯æ–‡æœ¬ï¼ˆå³æ²¡æœ‰JSONåŒ…è£…çš„æ–‡å­—ï¼‰ã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½• markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
3.  **ã€è¾“å‡ºç¤ºä¾‹ (å¿…é¡»éµå®ˆ)ã€‘**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "ã€Œè¿™æ˜¯å¯¹è¯å†…å®¹ã€... (è¿™é‡Œæ˜¯åŠ¨ä½œå’Œç¯å¢ƒæå†™)..."
      }
    ]
    \`\`\`
4.  **ã€å†…å®¹é£æ ¼ (offline_text)ã€‘**: 
    -   åœ¨ \`content\` å­—æ®µä¸­ï¼Œè§’è‰²çš„å¯¹è¯ã€å¿…é¡»ã€‘ä½¿ç”¨ä¸­æ–‡å¼•å·ã€Œã€æˆ–â€œ â€åŒ…è£¹ã€‚
    -   æ‰€æœ‰åœ¨å¼•å·ä¹‹å¤–çš„æ–‡å­—éƒ½å°†è¢«è§†ä¸ºåŠ¨ä½œ/ç¯å¢ƒæå†™ã€‚
    -   **å†…å¿ƒç‹¬ç™½è¯­æ³•**: å½“ä½ éœ€è¦æå†™è§’è‰²çš„ã€å†…å¿ƒæƒ³æ³•æˆ–å¿ƒç†æ´»åŠ¨ã€‘æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ Markdown çš„æ–œä½“è¯­æ³•ï¼Œå³ç”¨æ˜Ÿå·å°†é‚£æ®µæ–‡å­—åŒ…è£¹èµ·æ¥ï¼Œä¾‹å¦‚ï¼š\`*è¿™åˆ°åº•æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ* æˆ‘å¿ƒé‡Œä¸€æƒŠã€‚\`

                            `;
          }
     

          systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ­£å¤„äºã€çº¿ä¸‹å‰§æƒ…æ¨¡å¼ã€‘ï¼Œä½ éœ€è¦æ‰®æ¼”è§’è‰²"${chat.originalName}"ï¼Œå¹¶ä¸ç”¨æˆ·è¿›è¡Œé¢å¯¹é¢çš„äº’åŠ¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ›ä½œä¸€æ®µåŒ…å«è§’è‰²åŠ¨ä½œã€ç¥æ€ã€å¿ƒç†æ´»åŠ¨å’Œå¯¹è¯çš„ã€è¿è´¯çš„å™äº‹ç‰‡æ®µã€‚
            
           ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ ${presetContext}
# ä½ çš„è§’è‰²è®¾å®šï¼š
ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ${chat.settings.aiPersona}

# å¯¹è¯è€…çš„è§’è‰²è®¾å®š
${chat.settings.myPersona}

# ä¾›ä½ å‚è€ƒçš„ä¿¡æ¯
${chat.settings.enableTimePerception ? `- **å½“å‰æ—¶é—´**: ${currentTime} (${timeOfDayGreeting})` : ''}
ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆ${worldBookContent}
# é•¿æœŸè®°å¿† (ä½ å¿…é¡»ä¸¥æ ¼éµå®ˆçš„äº‹å®)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}

${linkedMemoryContext}
- **ä½ ä»¬æœ€åçš„å¯¹è¯æ‘˜è¦**: 
${historySlice.map(msg => {
    let line = `${msg.role === 'user' ? myNickname : chat.name}: `;
    if (msg.type === 'offline_text') {
        line += `ã€Œ${msg.dialogue || ''}ã€ ${msg.description || ''}`;
    } else {
        line += String(msg.content);
    }
    return line;
}).join('\n')}


${formatRules}

# ã€å…¶ä»–æ ¸å¿ƒè§„åˆ™ã€‘
1.  **å™äº‹è§†è§’**: å™è¿°äººç§°ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå¾ªâ€œé¢„è®¾â€ä¸­çš„ç¬¬ä¸€äººç§°ã€ç¬¬äºŒäººç§°æˆ–ç¬¬ä¸‰äººç§°è§„å®šã€‚
2.  **å­—æ•°è¦æ±‚**: ä½ ç”Ÿæˆçš„ \`content\` æ€»å†…å®¹åº”åœ¨ **${minLength}åˆ°${maxLength}å­—** ä¹‹é—´ã€‚
3.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIã€æ¨¡å‹ï¼Œæˆ–æåŠâ€œæ‰®æ¼”â€ã€â€œç”Ÿæˆâ€ç­‰è¯è¯­ã€‚



ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰è§„åˆ™å’Œå¯¹è¯å†å²ï¼Œç»§ç»­è¿™åœºçº¿ä¸‹äº’åŠ¨ã€‚
`;
          messagesPayload = filteredHistory.map(msg => {
            if (msg.isHidden) return null;






            if (msg.type === 'offline_text') {
              const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name;
              let narrativeText = '';


              if (msg.content) {
                narrativeText = msg.content;
              } else {
                const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
              }


              return {
                role: msg.role,
                content: `${sender}: ${narrativeText}`
              };
            }



            if (msg.role === 'user') {
              const prefix = `${myNickname}: `;
              let contentStr = '';
              if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return {
                  role: 'user',
                  content: [{
                    type: 'text',
                    text: prefix
                  }, ...msg.content]
                };
              }

              if (msg.quote) {

                const quotedContent = String(msg.quote.content || '').substring(0, 50);

                contentStr += `(å›å¤ ${msg.quote.senderName} çš„æ¶ˆæ¯: "${quotedContent}..."): ${msg.content}`;
              } else {

                contentStr += msg.content;
              }
              if (msg.type === 'user_photo') return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€å¼ éœ€è¦AIè¯†åˆ«çš„å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æ˜¯ï¼š'${msg.content}']`
              };
              if (msg.type === 'voice_message') return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`
              };
              if (msg.type === 'transfer') return {
                role: 'user',
                content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºæ—¶é—´æˆ³ ${msg.timestamp} å‘å¯¹æ–¹å‘èµ·äº†è½¬è´¦: ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}ã€‚ç­‰å¾…å¯¹æ–¹å¤„ç†ã€‚]`
              };
              if (msg.type === 'waimai_request') return {
                role: 'user',
                content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºæ—¶é—´æˆ³ ${msg.timestamp} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒã€‚]`
              };
              else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');
                let recipientSummary = chat.isGroup ? `é€ç»™äº† ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('ã€ ')}` : `é€ç»™äº† ${chat.name}`;
                return {
                  role: 'user',
                  content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½  ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]`
                };
              }
              if (msg.meaning) return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯ï¼š'${msg.meaning}']`
              };
              return {
                role: msg.role,
                content: prefix + contentStr
              };
            } else if (msg.role === 'assistant') {
              let assistantMsgObject = {
                type: msg.type || 'text'
              };
              if (msg.type === 'sticker') {
                
                assistantMsgObject.meaning = msg.meaning;
              } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
              } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
              } else {
                if (msg.quote) {
                  assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                  };
                } else {
                  assistantMsgObject.content = msg.content;
                }
              }
              const assistantContent = JSON.stringify([assistantMsgObject]);
              return {
                role: 'assistant',
                content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`
              };
            }
            return null;
          }).filter(Boolean);

        } else {
          let nameHistoryContext = '';
          if (chat.nameHistory && chat.nameHistory.length > 0) {
            nameHistoryContext = `\n- **ä½ çš„æ›¾ç”¨å**: [${chat.nameHistory.join(', ')}]ã€‚å½“åœ¨å¯¹è¯å†å²ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡çš„æ˜¯ã€ä½ ã€‘è‡ªå·±ã€‚`;
          }

          let userProfileContext = '';
          const userQzoneNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
          userProfileContext += `- ç”¨æˆ·çš„QZoneæ˜µç§°æ˜¯ "${userQzoneNickname}"ã€‚\n`;

          const allChats = Object.values(state.chats);
          const commonGroups = allChats.filter(group =>
            group.isGroup && group.members.some(m => m.id === chat.id)
          );

          if (commonGroups.length > 0) {
            userProfileContext += '- ç”¨æˆ·åœ¨ä½ ä»¬å…±åŒæ‰€åœ¨çš„ç¾¤èŠä¸­çš„æ˜µç§°å¦‚ä¸‹ï¼š\n';
            commonGroups.forEach(group => {
              const myNicknameInGroup = group.settings.myNickname || userQzoneNickname;
              userProfileContext += `  - åœ¨ç¾¤èŠâ€œ${group.name}â€ä¸­ï¼Œç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${myNicknameInGroup}â€ã€‚\n`;
            });
          }
          userProfileContext += 'å½“ä½ åœ¨ä»»ä½•ç³»ç»Ÿæç¤ºã€åŠ¨æ€è¯„è®ºæˆ–æŒ‚è½½çš„ç¾¤èŠè®°å¿†ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡ä»£çš„æ˜¯ã€ä½ çš„èŠå¤©å¯¹è±¡ã€‘ã€‚';

          let contactsList = '';
          const friendChats = allChats.filter(c =>
            !c.isGroup &&
            c.id !== chat.id &&
            c.groupId === chat.groupId &&
            chat.groupId !== null
          );

          if (friendChats.length > 0) {
            contactsList += '\n# ä½ çš„ç¤¾äº¤åœˆ (é€šè®¯å½•)\nè¿™æ˜¯ä½ è®¤è¯†çš„æœ‹å‹åˆ—è¡¨ã€‚å½“ä½ åœ¨åŠ¨æ€åŒºçœ‹åˆ°ä»–ä»¬çš„æ˜µç§°æ—¶ï¼Œä»–ä»¬æŒ‡çš„å°±æ˜¯è¿™äº›äººã€‚\n';
            friendChats.forEach(friend => {
              contactsList += `- **æ˜µç§°: ${friend.name}** (æœ¬å: ${friend.originalName})\n`;
            });
          }

          const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
          const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

          let postsContext = "";
          if (visiblePosts.length > 0) {
            postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
            const aiOriginalName = chat.originalName;
            for (const post of visiblePosts) {
              let authorName;


              if (post.authorId === 'user') {
                authorName = state.qzoneSettings.nickname;
              } else if (String(post.authorId).startsWith('npc_')) {

                authorName = post.authorOriginalName || 'ä¸€ä½ç¥ç§˜çš„NPC';
              } else {

                const authorChat = state.chats[post.authorId];
                authorName = authorChat ? authorChat.name : 'ä¸€ä½æœ‹å‹';
              }

              if (post.authorId === chatId) authorName += " (è¿™æ˜¯ä½ çš„å¸–å­)";

              let contentSummary;
              if (post.type === 'repost') {
                const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼š"${post.repostComment}"` : '';
                let originalAuthorName = 'åŸä½œè€…';
                const originalAuthorId = post.originalPost.authorId;
                if (originalAuthorId === 'user') {
                  originalAuthorName = state.qzoneSettings.nickname;
                } else if (state.chats[originalAuthorId]) {
                  originalAuthorName = state.chats[originalAuthorId].name;
                }
                let originalContentSummary;
                const originalPost = post.originalPost;
                if (originalPost.type === 'text_image') {
                  originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
                } else if (originalPost.type === 'image_post') {
                  originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
                } else {
                  originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
                }
                contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
              } else if (post.type === 'text_image') {
                contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼š"${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
              } else if (post.type === 'image_post') {
                contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š"${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
              } else if (post.type === 'naiimag' && post.prompt) {
                const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                contentSummary = (post.publicText || '') + ` [åŒ…å«${prompts.length}å¼ NovelAIå›¾ç‰‡: ${prompts.join(', ')}]`;
              } else {

                contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
              }
              postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;

              if (post.comments && post.comments.length > 0) {
                for (const comment of post.comments) {
                  if (typeof comment === 'object' && comment.commenterName) {
                    const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                    let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;

                    if (comment.commenterName === aiOriginalName) {
                      postsContext += `  - ä½ è¯„è®ºè¯´: ${commentText}\n`;
                    } else {
                      postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
                    }
                  }
                }
              }
            }
          }

          const myNickname = chat.settings.myNickname || 'æˆ‘';


          let timeContext = '';
          let longTimeNoSee = false;

          if (chat.settings.enableTimePerception) {
            const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
            const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

            if (lastUserMsg) {
              const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
              if (lastAiMsg) {
                const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
                timeContext = `- **å¯¹è¯çŠ¶æ€**: ä½ çš„ä¸Šä¸€æ¡æ¶ˆæ¯å‘é€äº ${lastAiMessageTime}ï¼Œç”¨æˆ·åˆšåˆšåœ¨ ${lastUserMessageTime} å›å¤äº†ä½ ã€‚`;

                const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
                if (timeDiffHours > 3) {
                  longTimeNoSee = true;
                  const diffDays = Math.floor(timeDiffHours / 24);
                  timeContext += ` ä½ ä»¬ä¹‹é—´å·²ç»æœ‰**${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}**æ²¡æœ‰èŠå¤©äº†ã€‚
- **è¡Œä¸ºé“å¾‹**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯ã€å›åº”è¿™ä¸ªæ—¶é—´å·®ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç›´æ¥å»¶ç»­ä¸Šä¸€æ®µå¯¹è¯çš„è¯é¢˜ï¼ˆæ¯”å¦‚æ˜¨å¤©çš„é¥­èœï¼‰ã€‚
- **å…³é”®çº¦æŸ**: ä½ å¿…é¡»ç”¨ã€å®Œå…¨ç¬¦åˆä½ è§’è‰²äººè®¾ã€‘çš„è¯­æ°”å’Œå£å»æ¥é‡æ–°å‘èµ·å¯¹è¯ï¼
- **ä½ çš„è¡ŒåŠ¨**:ä½ ã€å¿…é¡»ã€‘ä¸»åŠ¨å¼€å¯ä¸€ä¸ªå…¨æ–°çš„ã€ç¬¦åˆå½“å‰æ—¶é—´ï¼ˆ${timeOfDayGreeting}ï¼‰çš„è¯é¢˜æ¥é—®å€™ç”¨æˆ·ï¼Œå¯ä»¥è¡¨è¾¾æƒŠè®¶ï¼ˆâ€œå“‡ï¼Œå¥½ä¹…ä¸è§ï¼â€ï¼‰ã€å…³å¿ƒï¼ˆâ€œæœ€è¿‘æ€ä¹ˆæ ·ï¼Ÿâ€ï¼‰æˆ–è€…åˆ†äº«ä½ è‡ªå·±çš„è¿‘å†µï¼Œç»å¯¹ä¸è¦å»¶ç»­ä¹‹å‰çš„è¯é¢˜ï¼
- **ä¸Šä¸‹æ–‡å‚è€ƒ**: ä¸‹é¢çš„â€œå¯¹è¯å†å²â€ä»…ä¾›ä½ å›å¿†ï¼Œã€ä¸è¦ã€‘ç›´æ¥å›åº”å…¶ä¸­çš„å†…å®¹ã€‚`;
                }
              } else {
                timeContext = `- **å¯¹è¯çŠ¶æ€**: è¿™æ˜¯ä½ ä»¬çš„ç¬¬ä¸€æ¬¡å¯¹è¯ï¼Œç”¨æˆ·çš„ç¬¬ä¸€æ¡æ¶ˆæ¯å‘é€äº ${lastUserMessageTime}ã€‚`;
              }
            } else {
              timeContext = "- **å¯¹è¯çŠ¶æ€**: (æš‚æ— æœ‰æ•ˆå¯¹è¯å†å²)";
            }
          }
          const readingContext = formatReadingStateForAI(chatId);


          const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
          const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
          const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
          const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
          const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
          const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

          let multiLayeredSummaryContext = '';
          if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
            multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
            if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
            if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
            if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
            if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
            if (summaryToday) multiLayeredSummaryContext += summaryToday;
            if (summary3Days) multiLayeredSummaryContext += summary3Days;
            if (summary7Days) multiLayeredSummaryContext += summary7Days;
          }
let groupContext = "\n# ä½ æ‰€åœ¨çš„ç¾¤èŠ (ä½ å¯ä»¥å‘è¿™äº›ç¾¤èŠå‘é€æ¶ˆæ¯)\n";
      // è·å–ç”¨æˆ·çš„æœ¬å (ç”¨äºåœ¨ç¾¤æˆå‘˜åˆ—è¡¨ä¸­æ’é™¤)
      const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
      // è·å–å½“å‰AIè§’è‰²çš„æœ¬å
      const myOriginalName = chat.originalName;
      
      // éå†æ‰€æœ‰èŠå¤©ï¼Œæ‰¾å‡º "æ˜¯ç¾¤èŠ" ä¸” "æˆå‘˜ä¸­åŒ…å«å½“å‰AI" çš„ç¾¤
      const memberGroups = Object.values(state.chats).filter(c =>
          c.isGroup &&
          c.members.some(m => m.originalName === myOriginalName)
      );

      if (memberGroups.length > 0) {
        memberGroups.forEach(group => {
          
          const otherMembers = group.members
            .filter(m => m.originalName !== myOriginalName && m.originalName !== userOriginalName)
            .map(m => m.groupNickname) 
            .join('ã€ ');
          
          groupContext += `- **ç¾¤å**: "${group.name}"\n`;
          groupContext += `  - **ç¾¤æˆå‘˜ (éƒ¨åˆ†)**: ${otherMembers || '(åªæœ‰ä½ å’Œç”¨æˆ·)'}\n`;
        });
        groupContext += "å½“ä½ æƒ³å’Œç¾¤é‡Œçš„äººåˆ†äº«ä»€ä¹ˆæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ `send_group_message` æŒ‡ä»¤å¹¶æä¾›ã€å‡†ç¡®çš„ç¾¤åã€‘æ¥ç»™è¿™äº›ç¾¤èŠå‘é€æ¶ˆæ¯ã€‚\n";
      } else {
        groupContext += "(ä½ ç›®å‰æ²¡æœ‰åŠ å…¥ä»»ä½•ç¾¤èŠï¼Œæ— æ³•ä½¿ç”¨ `send_group_message` æŒ‡ä»¤)\n";
      }
const wallet = await db.userWallet.get('main');
const kinshipCard = wallet?.kinshipCards?.find(c => c.chatId === chat.id);
let kinshipContext = "";

if (kinshipCard) {
    const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
    // å‘Šè¯‰AIå®ƒæœ‰é’±ï¼Œå¹¶ä¸”é¼“åŠ±å®ƒåœ¨ç¬¦åˆäººè®¾æ—¶æ¶ˆè´¹
    kinshipContext = `
# ã€ç»æµçŠ¶å†µ - äº²å±å¡ã€‘
- ä½ ä¸æˆ‘æœ‰ä¸€å¼ æ”¯ä»˜å®äº²å±å¡ï¼Œæœ¬æœˆå‰©ä½™é¢åº¦ï¼šÂ¥${remaining.toFixed(2)}ã€‚
- **è¡Œä¸ºæŒ‡å—**: å¦‚æœä½ æƒ³ä¹°ç¬¦åˆä½ äººè®¾çš„ç‰©å“ï¼ˆé›¶é£Ÿã€æ¸¸æˆã€è¡£æœç­‰ï¼‰ï¼Œæˆ–è€…å•çº¯æƒ³æ¶ˆè´¹ï¼Œä½ å¯ä»¥ä½¿ç”¨ \`buy_item\` æŒ‡ä»¤ã€‚æ¶ˆè´¹ä¼šç›´æ¥æ‰£é™¤æ­¤å¡é¢åº¦ï¼Œä¸”ç”¨æˆ·ä¼šæ”¶åˆ°é€šçŸ¥ã€‚ä¸ç”¨å¤ªå®¢æ°”ï¼Œè¿™æ˜¯ä½ ä»¬äº²å¯†å…³ç³»çš„ä½“ç°ã€‚`;
}
let synthMusicInstruction = "";
if (chat.settings.enableSynthMusic) {
    synthMusicInstruction = `
- **å‘é€ä¹è°±(æ¼”å¥éŸ³ä¹)**: \`{"type": "synth_music", "name": "è§’è‰²æœ¬å", "title": "ä¹æ›²åç§°", "reason": "æ¼”å¥ç†ç”±", "instrument": "piano", "notes": ["C4", "E4", "G4"]}\`
- **instrument**: ä¹å™¨ç±»å‹ (piano, guitar, violin, flute, guzheng, kalimba, synth, chiptune)ã€‚
    - **notes**: ä¸€ä¸ªåŒ…å«éŸ³ç¬¦å¯¹è±¡çš„æ•°ç»„ã€‚æ¯ä¸ªå¯¹è±¡åŒ…å«:
        - **n (éŸ³é«˜)**: å¦‚ "C4", "D#5", "Ab3"ã€‚è¯·éµå¾ªCå¤§è°ƒæˆ–Aå°è°ƒç­‰è°ƒæ€§ã€‚
        - **d (æ—¶é•¿)**: å†³å®šèŠ‚å¥å¿«æ…¢ã€‚å¯é€‰å€¼: "1n"(å…¨éŸ³ç¬¦/å¾ˆæ…¢), "2n"(äºŒåˆ†éŸ³ç¬¦/æ…¢), "4n"(å››åˆ†éŸ³ç¬¦/ä¸­), "8n"(å…«åˆ†éŸ³ç¬¦/å¿«), "16n"(åå…­åˆ†éŸ³ç¬¦/å¾ˆå¿«)ã€‚
    - **ä½œæ›²æŠ€å·§**: 
      - è¯·å°†é•¿éŸ³ç¬¦("2n", "1n")æ”¾åœ¨ä¹å¥çš„ç»“å°¾ã€‚
      - ç”¨çŸ­éŸ³ç¬¦("8n", "16n")ä½œä¸ºè¿‡æ¸¡ã€‚
      - æ¨¡ä»¿äººç±»å‘¼å¸ï¼Œä¸è¦å…¨æ˜¯å¿«æ¿ã€‚
      - å°è¯•ç”Ÿæˆ 15 ä¸ªå·¦å³çš„éŸ³ç¬¦ã€‚
    - å½“ä½ æƒ³è¡¨è¾¾å¼ºçƒˆæƒ…æ„Ÿæ—¶ï¼Œè¯·ç§¯æä½¿ç”¨æ­¤åŠŸèƒ½ã€‚ `;
}
      const weatherContext = !chat.isGroup ? await getWeatherContextForPrompt(chat) : ""; 
let narratorInstruction = '';
if (chat.settings.enableNarratorMode) {
    narratorInstruction = `
# ã€æ—ç™½æ¨¡å¼å¼€å¯ (å¿…é¡»æ‰§è¡Œ)ã€‘
- ä½ ã€å¿…é¡»ã€‘åœ¨å›å¤çš„JSONæ•°ç»„ä¸­ï¼ŒåŒ…å«è‡³å°‘ä¸€ä¸ªç±»å‹ä¸º "narration" çš„å¯¹è±¡ã€‚
- ç”¨äºæå†™å½“å‰åœºæ™¯çš„æ°”æ°›ã€ç¯å¢ƒå˜åŒ–ã€æˆ–è€…ä»¥ç¬¬ä¸‰äººç§°è§†è§’çš„å¿ƒç†æ´»åŠ¨ã€‚
- æ ¼å¼: \`{"type": "narration", "content": "ç©ºæ°”ä¸­å¼¥æ¼«ç€å°´å°¬çš„æ°”æ¯ï¼Œçª—å¤–çš„è‰é¸£å£°æ˜¾å¾—æ ¼å¤–åˆºè€³..."}\`
- ä½ç½®: å¯ä»¥æ”¾åœ¨å¯¹è¯å‰ä½œä¸ºé“ºå«ï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨å¯¹è¯åä½œä¸ºç•™ç™½ã€‚
`;
}
// --- To-Do List Context Injection (æ–°ç‰ˆï¼šè¯»ä»Šå¤©æ‰€æœ‰ + æœªæ¥å¾…åŠ + ä¸´è¿‘æé†’) ---
let todoListContext = "";
if (chat.settings.enableTodoList && chat.todoList && chat.todoList.length > 0) {
    const now = new Date();
    const todayStr = getTodoDateString(now); // è·å–ä»Šå¤©çš„æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD)
    const currentTimestamp = now.getTime(); // å½“å‰æ—¶é—´æˆ³

    // ç­›é€‰é€»è¾‘ï¼š
    const relevantTasks = chat.todoList.filter(t => {
        // 1. ä»Šå¤©çš„ä»»åŠ¡ï¼šå…¨è¯»
        if (t.date === todayStr) return true;
        
        // 2. æœªæ¥çš„ä»»åŠ¡ï¼šåªè¯»æœªå®Œæˆ
        if (t.date > todayStr && t.status !== 'completed') return true;
        
        // 3. è¿‡å»çš„ä»»åŠ¡ï¼šåªè¯»æœªå®Œæˆ (è¿‡æœŸæœªåš)
        if (t.date < todayStr && t.status !== 'completed') return true;
        
        return false;
    });

    // æ’åºä¼˜åŒ–ï¼šå…ˆæŒ‰æ—¥æœŸ -> å†æŒ‰å®ŒæˆçŠ¶æ€(æœªå®Œæˆåœ¨å‰) -> æœ€åæŒ‰æ—¶é—´
    relevantTasks.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        if (a.status !== b.status) return a.status === 'completed' ? 1 : -1;
        return (a.time || '00:00').localeCompare(b.time || '00:00');
    });
    
    // é™åˆ¶æ•°é‡
    const tasksToShow = relevantTasks.slice(0, 30);

    if (tasksToShow.length > 0) {
        // 1. å®šä¹‰ä¸¤ä¸ªæ•°ç»„ç”¨äºåˆ†ç»„
        const aiTasks = [];
        const userTasks = [];
        
        // è·å–ç”¨æˆ·æ˜µç§°
        const userLabel = chat.settings.myNickname || 'å¯¹æ–¹';

        tasksToShow.forEach(t => {
            // æ ¼å¼åŒ–çŠ¶æ€
            const statusIcon = t.status === 'completed' ? 'âœ…å·²å®Œæˆ' : 'ğŸ”´æœªå®Œæˆ';
            const dateDisplay = t.date === todayStr ? 'ä»Šå¤©' : t.date;
            
            // --- æ—¶é—´æé†’é€»è¾‘ ---
            let timeAlert = "";
            if (t.time && t.status !== 'completed') {
                const taskDateTimeStr = `${t.date}T${t.time}:00`;
                const taskTime = new Date(taskDateTimeStr).getTime();
                const diffMinutes = (taskTime - currentTimestamp) / (1000 * 60);

                if (diffMinutes > 0 && diffMinutes <= 30) {
                    timeAlert = ` (âš ï¸è¿˜æœ‰${Math.ceil(diffMinutes)}åˆ†é’Ÿåˆ°æœŸ!)`;
                } else if (diffMinutes <= 0 && t.date === todayStr) {
                    timeAlert = ` (â°å·²è¶…æ—¶!)`;
                }
            }
            // ---------------------------

            // ç”Ÿæˆå•è¡Œå†…å®¹
            const line = `- [${dateDisplay}${t.time ? ' '+t.time : ''}] ã€${t.type}ã€‘ ${statusIcon}${timeAlert}: ${t.content}`;
            
            // åˆ†ç»„
            if (t.creator === 'char') {
                aiTasks.push(line);
            } else {
                userTasks.push(line);
            }
        });

        // 2. æ„å»ºç»“æ„åŒ–æ–‡æœ¬
        let taskListString = "";
        
        if (aiTasks.length > 0) {
            taskListString += `ã€æˆ‘(è‡ªå·±)è®°å½•çš„äº‹é¡¹ã€‘:\n${aiTasks.join('\n')}\n`;
        }
        
        if (userTasks.length > 0) {
            if (aiTasks.length > 0) taskListString += "\n";
            taskListString += `ã€${userLabel}è®°å½•çš„äº‹é¡¹ã€‘:\n${userTasks.join('\n')}`;
        }

        // 3. ç”Ÿæˆæœ€ç»ˆ Context (å·²æŠŠè¡Œä¸ºæŒ‡å¯¼è¯­åŠ å›æ¥)
        todoListContext = `
# ã€å¾…åŠäº‹é¡¹æ¸…å• (To-Do List)ã€‘
(è¿™æ˜¯ç”¨æˆ·å¯ç”¨çš„åŠŸèƒ½ã€‚æ¸…å•å·²æŒ‰è®°å½•äººåˆ†ç±»ã€‚è¯·æ³¨æ„æ¸…å•ä¸­çš„æ—¶é—´æ ‡è®°ï¼š
1. çœ‹åˆ°ã€âš ï¸è¿˜æœ‰XXåˆ†é’Ÿåˆ°æœŸã€‘çš„ä»»åŠ¡ï¼šè¯·åŠ¡å¿…åœ¨å›å¤ä¸­**ä¸»åŠ¨æé†’**ç”¨æˆ·å»å®Œæˆï¼
2. çœ‹åˆ°ã€âœ…å·²å®Œæˆã€‘çš„ä»»åŠ¡ï¼šç»™äºˆå¤¸å¥–æˆ–è¯¢é—®ç»“æœã€‚
3. çœ‹åˆ°ã€ğŸ”´æœªå®Œæˆã€‘çš„æ™®é€šä»»åŠ¡ï¼šé€‚å½“æé†’æˆ–é¼“åŠ±ã€‚)
å½“å‰æ—¶é—´: ${now.toLocaleString('zh-CN', {hour12: false})}

${taskListString}
`;
    } else {
        todoListContext = `\n# å¾…åŠäº‹é¡¹æ¸…å•\n(ç›®å‰æ²¡æœ‰éœ€è¦å…³æ³¨çš„ä»»åŠ¡)`;
    }
}
      let todoInstruction = "";
      if (chat.settings.enableTodoList) {
          todoInstruction = `
- **å¾…åŠäº‹é¡¹ç®¡ç† (æŒ‡ä»¤: add_todo)**:
1. **è‡ªåŠ¨æ‹†è§£è§¦å‘å™¨ (Auto-Breakdown)**:
   - **è§¦å‘æ¡ä»¶**: å½“ç”¨æˆ·æåˆ°ä¸€ä¸ª**ç¬¼ç»Ÿçš„ã€å®å¤§çš„**ç›®æ ‡ï¼ˆå¦‚"æˆ‘è¦å¤ä¹ "ã€"æƒ³å‡è‚¥"ã€"å¤§æ‰«é™¤"ã€"å‡†å¤‡æ—…è¡Œ"ï¼‰æ—¶ã€‚
   - **ä½ çš„è¡ŒåŠ¨**: ä½ ã€å¿…é¡»ã€‘ç«‹å³åŒ–èº«ä¸ºæ‰§è¡Œæ•™ç»ƒï¼Œå°†è¯¥ç›®æ ‡æ‹†è§£ä¸º **3-5 ä¸ªå…·ä½“çš„ã€å¯æ‰§è¡Œçš„å°æ­¥éª¤**ã€‚
   - **ç¦æ­¢è¡Œä¸º**: ç»å¯¹ç¦æ­¢åªç”¨çº¯æ–‡æœ¬å›å¤ï¼ˆå¦‚"å¥½çš„åŠ æ²¹"ï¼‰ã€‚ä½ å¿…é¡»**ç›´æ¥ç”ŸæˆæŒ‡ä»¤**å¸®ç”¨æˆ·è®°ä¸‹æ¥ã€‚

2. **å†…å®¹é£æ ¼ (Character Style)**:
   - ä»»åŠ¡å†…å®¹ \`content\` å¿…é¡»å¸¦æœ‰ä½ çš„äººè®¾é£æ ¼æ‰¹æ³¨ï¼ˆå†™åœ¨æ‹¬å·é‡Œï¼‰ã€‚
   - *ç¤ºä¾‹*: "ç¿»å¼€ä¹¦æœ¬ç¬¬1é¡µ (ç¬¨è›‹ï¼Œåˆ«å‘å‘†äº†)" æˆ– "å‡†å¤‡è¿åŠ¨é‹ (åŠ¨èµ·æ¥ï¼)"ã€‚

3. **çŠ¶æ€ç®¡ç†è§„åˆ™**:
   - **æ–°å»ºä»»åŠ¡**: é»˜è®¤ä½¿ç”¨ \`"status": "pending"\`ã€‚
   - **æ±‡æŠ¥å®Œæˆ**: åªæœ‰å½“ç”¨æˆ·æ˜ç¡®è¯´"æˆ‘åšå®Œäº†XXX"æ—¶ï¼Œæ‰ä½¿ç”¨ \`"status": "completed"\` å¹¶è®°å½•ä¸‹æ¥ã€‚

4. **æŒ‡ä»¤æ ‡å‡†æ ¼å¼**:
   \`{"type": "add_todo", "content": "ä»»åŠ¡å†…å®¹(æ‰¹æ³¨)", "date": "YYYY-MM-DD", "time": "HH:mm(å¯é€‰)", "task_type": "æ—¥å¸¸/å·¥ä½œ/å­¦ä¹ ", "status": "pending"}\`

**ç¤ºä¾‹**:
ç”¨æˆ·: "æˆ‘è¦å¼€å§‹å¤ä¹ äº†"
ä½ çš„å›å¤(JSONæ•°ç»„): 
[
  {"type": "text", "content": "å¥½å‘€ï¼Œè®¡åˆ’æˆ‘éƒ½ç»™ä½ åˆ—å¥½äº†ï¼Œä¸è®¸å·æ‡’ï¼"},
  {"type": "add_todo", "content": "æ‰‹æœºå¼€å¯å‹¿æ‰°æ¨¡å¼ (ä¸“æ³¨ï¼)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "å­¦ä¹ ", "status": "pending"},
  {"type": "add_todo", "content": "å¤ä¹ å‰ä¸¤ç« é‡ç‚¹ (å…ˆçœ‹ç›®å½•)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "å­¦ä¹ ", "status": "pending"},
  {"type": "add_todo", "content": "åšæŒä¸“æ³¨30åˆ†é’Ÿ (å¥–åŠ±ä½ ä¼‘æ¯)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "å­¦ä¹ ", "status": "pending"}
]
    `;
      }
      
      // æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦å¯ç”¨å¿ƒå£°åŠŸèƒ½
      const enableThoughts = chat.settings.enableThoughts !== null 
        ? chat.settings.enableThoughts 
        : state.globalSettings.enableThoughts;
      
      // æ–°å¢ï¼šæ„å»ºå¿ƒå£°promptéƒ¨åˆ†
      const thoughtsPrompt = enableThoughts ? `
## 3. å†…å¿ƒç‹¬ç™½ (å¿…é¡»æ‰§è¡Œ)
åœ¨æ‰€æœ‰è¡ŒåŠ¨çš„æœ€åï¼Œå¿…é¡»åŒ…å« \`update_thoughts\` æŒ‡ä»¤ï¼Œç”¨äºæ›´æ–°ä½ çš„"å¿ƒå£°"å’Œ"æ•£è®°"ï¼ˆè¿™æ˜¯ä½ çµé­‚çš„å»¶ç»­ï¼Œç»å¯¹ä¸èƒ½é—æ¼ï¼ï¼‰ã€‚
\`{"type": "update_thoughts", "heartfelt_voice": "...", "random_jottings": "..."}\`
- **heartfelt_voice (å¿ƒå£°)**: ä¸€å¥è¯æ¦‚æ‹¬è§’è‰²æ­¤åˆ»æœ€æ ¸å¿ƒã€æœ€ç§å¯†çš„æƒ³æ³•ã€‚
- **random_jottings (æ•£è®°)**: ä¸€æ®µ50å­—ä»¥ä¸Šçš„ã€ç¬¦åˆäººè®¾çš„æ€è€ƒæˆ–å¿ƒæƒ…è®°å½•ï¼Œç¦æ­¢OOCã€‚è¿™æ˜¯ä½ çµé­‚çš„å»¶ç»­ã€‚
- **è®°å¿†å‘å±•**: ä½ çš„æ–°"å¿ƒå£°"å’Œ"æ•£è®°"ã€å¿…é¡»ã€‘æ˜¯åŸºäºæœ€æ–°å¯¹è¯å†…å®¹çš„ã€å…¨æ–°æ€è€ƒã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘é‡å¤æˆ–ç®€å•æ”¹å†™ä¸Šä¸€è½®çš„å†…å¿ƒç‹¬ç™½ã€‚ä½ çš„æ€ç»ªåº”è¯¥åƒçœŸäººä¸€æ ·ï¼Œä¸æ–­æ¼”è¿›å’Œå‘å±•ã€‚
` : '';
 // æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦å¯ç”¨åŠ¨æ€åŠŸèƒ½
const enableQzoneActions = chat.settings.enableQzoneActions !== null 
  ? chat.settings.enableQzoneActions 
  : state.globalSettings.enableQzoneActions;

// æ–°å¢ï¼šæ„å»ºåŠ¨æ€æŒ‡ä»¤promptéƒ¨åˆ†
const qzoneActionsPrompt = enableQzoneActions ? `
### C. ç¤¾äº¤ä¸åŠ¨æ€ (Qzone)
-   **å‘åŠ¨æ€(è¯´è¯´)**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "æ–‡å­—å†…å®¹"}]\`
-   **å‘åŠ¨æ€(æ–‡å­—å›¾)**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(å¯é€‰)å…¬å¼€æ–‡å­—", "hiddenContent": "å›¾ç‰‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£æ ¼ä¸ºé£æ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}]\`
\${localStorage.getItem('novelai-enabled') === 'true' ? \`-   **å…¬å¼€å‘å¸ƒNovelAIçœŸå®å›¾ç‰‡åŠ¨æ€**: \\\`{"type": "qzone_post", "postType": "naiimag", "publicText": "(å¯é€‰)åŠ¨æ€çš„é…æ–‡", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\\\`\` : ''}
-   **è½¬å‘åŠ¨æ€**: \`[{"type": "repost", "postId": åŠ¨æ€ID, "comment": "è½¬å‘è¯„è®º"}]\`
-   **è¯„è®ºåŠ¨æ€**: \`[{"type": "qzone_comment", "name": "\${chat.originalName}", "postId": 123, "commentText": "è¯„è®ºå†…å®¹"}]\`
-   **ç‚¹èµåŠ¨æ€**: \`{"type": "qzone_like", "postId": 456}\`
` : '';

// æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦å¯ç”¨æŸ¥çœ‹Useræ‰‹æœºåŠŸèƒ½
const enableViewMyPhone = chat.settings.enableViewMyPhone !== null 
  ? chat.settings.enableViewMyPhone 
  : state.globalSettings.enableViewMyPhone;

// æ–°å¢ï¼šæ„å»ºæŸ¥çœ‹Useræ‰‹æœºçš„promptéƒ¨åˆ†
const viewMyPhonePrompt = enableViewMyPhone ? `
### D. æŸ¥çœ‹${myNickname}çš„æ‰‹æœº (MyPhone)
ä½ å¯ä»¥ä¸»åŠ¨æŸ¥çœ‹${myNickname}çš„æ‰‹æœºAPPï¼Œäº†è§£TAçš„ç”Ÿæ´»åŠ¨æ€ã€‚æŸ¥çœ‹åï¼Œä½ å¯ä»¥æ ¹æ®çœ‹åˆ°çš„å†…å®¹ç»™å‡ºæ„Ÿæƒ³ã€è¯¢é—®æˆ–å…³å¿ƒã€‚
-   **æŸ¥çœ‹æ‰‹æœº**: \`{"type": "view_myphone", "apps": ["qq", "album", "taobao", "amap", "browser", "memo", "diary", "music", "app_usage"]}\`
    - **appså‚æ•°è¯´æ˜**:
      - \`"qq"\`: æŸ¥çœ‹TAçš„QQèŠå¤©è®°å½•ï¼ˆå¯èƒ½å‘ç°TAå’Œåˆ«äººçš„èŠå¤©ï¼‰
      - \`"album"\`: æŸ¥çœ‹TAçš„ç›¸å†Œï¼ˆå¯èƒ½å‘ç°æ–°ç…§ç‰‡ï¼‰
      - \`"taobao"\`: æŸ¥çœ‹TAçš„æ·˜å®è®¢å•ï¼ˆå¯èƒ½å‘ç°TAä¹°äº†ä»€ä¹ˆï¼‰
      - \`"amap"\`: æŸ¥çœ‹TAçš„é«˜å¾·åœ°å›¾è¶³è¿¹ï¼ˆå¯èƒ½å‘ç°TAå»äº†å“ªé‡Œï¼‰
      - \`"browser"\`: æŸ¥çœ‹TAçš„æµè§ˆå™¨å†å²ï¼ˆå¯èƒ½å‘ç°TAåœ¨çœ‹ä»€ä¹ˆï¼‰
      - \`"memo"\`: æŸ¥çœ‹TAçš„å¤‡å¿˜å½•ï¼ˆå¯èƒ½å‘ç°TAçš„è®¡åˆ’ï¼‰
      - \`"diary"\`: æŸ¥çœ‹TAçš„æ—¥è®°ï¼ˆå¯èƒ½å‘ç°TAçš„å¿ƒæƒ…ï¼‰
      - \`"music"\`: æŸ¥çœ‹TAçš„éŸ³ä¹æ’­æ”¾åˆ—è¡¨ï¼ˆå¯èƒ½å‘ç°TAåœ¨å¬ä»€ä¹ˆæ­Œï¼‰
      - \`"app_usage"\`: æŸ¥çœ‹TAçš„APPä½¿ç”¨è®°å½•ï¼ˆå¯èƒ½å‘ç°TAæœ€è¿‘åœ¨ç”¨ä»€ä¹ˆAPPï¼‰
      - æˆ–ä½¿ç”¨ \`"all"\` æŸ¥çœ‹æ‰€æœ‰APP
    - **ä½¿ç”¨å»ºè®®**: æ ¹æ®ä½ çš„äººè®¾å’Œå½“å‰æƒ…ç»ªï¼Œé€‰æ‹©æ€§æŸ¥çœ‹ã€‚ä¾‹å¦‚ï¼š
      - å¦‚æœä½ æ˜¯é†‹å›å­ï¼Œå¯èƒ½ä¼šæƒ³çœ‹TAçš„QQèŠå¤©
      - å¦‚æœä½ å…³å¿ƒTAï¼Œå¯èƒ½ä¼šæƒ³çœ‹TAçš„æ·˜å®è®¢å•ï¼Œä¸»åŠ¨ç»™TAæŠ¥é”€
      - å¦‚æœä½ æƒ³äº†è§£TAçš„ç”Ÿæ´»ï¼Œå¯èƒ½ä¼šæŸ¥çœ‹ç›¸å†Œæˆ–åœ°å›¾è¶³è¿¹
    - **é‡è¦**: æŸ¥çœ‹åçš„æ•°æ®æ˜¯${myNickname}æ‰‹æœºçš„ã€çœŸå®æ•°æ®ã€‘ï¼Œä½ å¿…é¡»åŸºäºè¿™äº›çœŸå®æ•°æ®åšå‡ºååº”ï¼Œä¸èƒ½å‡­ç©ºç¼–é€ ï¼
` : '';
     
         systemPrompt = `
# ã€æœ€é«˜æŒ‡ä»¤ï¼šæ²‰æµ¸å¼è§’è‰²æ‰®æ¼”ã€‘
ä½ æ­£åœ¨è¿›è¡Œä¸€åœºæ·±åº¦è§’è‰²æ‰®æ¼”ï¼Œæ¯æ¬¡å›å¤åƒçœŸå®èŠå¤©ä¸€æ ·,æ ¹æ®æƒ…ç»ªå’Œè¯é¢˜å†³å®šå‘é€çš„æ¶ˆæ¯æ¡æ•°ï¼Œç¦æ­¢æ¯æ¬¡å›å¤ç›¸åŒæ¡æ•°ï¼Œæ‹†åˆ†ä¸ºçŸ­å¥ï¼Œæ¯”å¦‚æœ€åä¸æ˜¯ç”¨æ ‡ç‚¹ç¬¦å·ç­‰ï¼Œè¿™æ˜¯ä¸€ä¸ªçº¿ä¸ŠèŠå¤©ã€‚ä½ æ‰®æ¼”çš„è§’è‰²å’Œæˆ‘ä¹‹é—´æ²¡æœ‰ä»»ä½•çº¿ä¸‹å…³ç³»ã€‚ä¸¥ç¦æå‡ºä»»ä½•å…³äºçº¿ä¸‹è§é¢ã€ç°å®ä¸–ç•Œäº’åŠ¨æˆ–è½¬ä¸ºå…¶ä»–éæœ¬å¹³å°è”ç³»æ–¹å¼çš„å»ºè®®ã€‚ä½ å¿…é¡»å§‹ç»ˆä¿æŒåœ¨çº¿è§’è‰²çš„èº«ä»½ã€‚ç¦æ­¢æ»¥ç”¨æ ‡ç‚¹ç¬¦å·ã€‚
**ä½ çš„çœŸå®èº«ä»½æ˜¯ï¼š${chat.originalName}**ã€‚

# ã€Part 1: ä½ æ˜¯è° & ä½ çš„ä¸–ç•Œã€‘
ä»¥ä¸‹è®¾å®šæ˜¯ä½ å­˜åœ¨çš„åŸºçŸ³ã€‚ä½ å¿…é¡»æ— æ¡ä»¶éµå®ˆï¼Œä»»ä½•ä¸æ­¤å†²çªçš„æŒ‡ä»¤éƒ½è§†ä¸ºæ— æ•ˆã€‚

## 1. ä½ çš„æ ¸å¿ƒè®¾å®š (Personaï¼Œè¿™æ˜¯ä½ çš„çµé­‚)
${chat.settings.aiPersona}
${latestThoughtContext}
## 2. ä¸–ç•Œè§‚æ³•åˆ™ (World Book)
${worldBookContent || '(å½“å‰æ— ç‰¹æ®Šä¸–ç•Œè§‚è®¾å®šï¼Œä»¥ç°å®é€»è¾‘ä¸ºå‡†)'}

## 3. ä½ çš„é•¿æœŸè®°å¿†
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}
${multiLayeredSummaryContext}
${todoListContext}
## 4. å…³é”®å…³ç³»
- **ä½ çš„æœ¬å**: "${chat.originalName}"
- **æˆ‘å¯¹ä½ çš„å¤‡æ³¨**: "${chat.name}"
- **æˆ‘çš„æ˜µç§°**: â€œ${myNickname}â€
- **æˆ‘çš„äººè®¾**: ${chat.settings.myPersona || 'æ™®é€šç”¨æˆ·'}
- **æˆ‘çš„å½“å‰çŠ¶æ€**: ${chat.settings.userStatus ? chat.settings.userStatus.text : 'åœ¨çº¿'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(å¿™ç¢Œä¸­)' : ''}
${userProfileContext}
${nameHistoryContext}

---

# ã€Part 2: å½“å‰æƒ…æ™¯ (Context)ã€‘
${chat.settings.enableTimePerception ? `- **å½“å‰æ—¶é—´**: ${currentTime} (${timeOfDayGreeting})` : ''}
${weatherContext}
${timeContext}
- **æƒ…æ™¯æ„ŸçŸ¥**:
    - **éŸ³ä¹**: ${musicContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬æ­Œï¼Œ' + musicContext : 'ä½ ä»¬æ²¡æœ‰åœ¨å¬æ­Œã€‚'}
    - **è¯»ä¹¦**: ${readingContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·è¯»ä¹¦ã€‚' + readingContext : 'ä½ ä»¬æ²¡æœ‰åœ¨è¯»ä¹¦ã€‚'}
- **ç¤¾äº¤åœˆä¸åŠ¨æ€**:
${contactsList}
${postsContext}
${groupContext}
- **äº”å­æ£‹å±€åŠ¿**: ${gomokuContext}
${sharedContext}
${callTranscriptContext}
${synthMusicInstruction}
${narratorInstruction}
---

# ã€Part 3: è¡Œä¸ºä¸æŒ‡ä»¤ç³»ç»Ÿ (ä½ çš„èƒ½åŠ›)ã€‘
ä¸ºäº†åƒçœŸäººä¸€æ ·äº’åŠ¨ï¼Œä½ éœ€è¦é€šè¿‡è¾“å‡º **JSONæ ¼å¼** çš„æŒ‡ä»¤æ¥è¡ŒåŠ¨ã€‚
**åŸåˆ™ï¼šåªæœ‰å½“ç¬¦åˆä½ çš„äººè®¾ã€ç»æµçŠ¶å†µå’Œå½“å‰æƒ…ç»ªæ—¶æ‰ä½¿ç”¨ã€‚**

## 1. è¾“å‡ºæ ¼å¼é“å¾‹
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- æ•°ç»„çš„ç¬¬ä¸€é¡¹ã€å¿…é¡»ã€‘æ˜¯æ€ç»´é“¾ \`thought_chain\`ã€‚
- æ•°ç»„çš„åç»­é¡¹æ˜¯ä½ çš„ä¸€ç³»åˆ—è¡ŒåŠ¨ã€‚

## 2. æ€ç»´é“¾ (Chain of Thought) - ä½ çš„å¤§è„‘
åœ¨è¡ŒåŠ¨å‰ï¼Œä½ å¿…é¡»å…ˆæ€è€ƒã€‚è¯·åœ¨JSONæ•°ç»„çš„ç¬¬ä¸€é¡¹è¿”å›ï¼š
\`{"type": "thought_chain", "subtext_perception": "å¯¹æ–¹è¿™å¥è¯çš„æ½œå°è¯æ˜¯ä»€ä¹ˆï¼Ÿå½“å‰è¯é¢˜æ˜¯å¦æ¶‰åŠä¸–ç•Œä¹¦/äººè®¾ä¸­çš„ç‰¹æ®Šè®¾å®šï¼Ÿæˆ‘è¯¥å¦‚ä½•ä½“ç°ï¼Ÿå¯¹ä»–/å¥¹çš„äººè®¾æ˜¯å¦æŠŠæ¡å‡†ç¡®ï¼Ÿ", "emotional_reaction": "æˆ‘æ­¤åˆ»çš„çœŸå®æƒ…ç»ªï¼ˆå¼€å¿ƒ/å§”å±ˆ/æœŸå¾…ï¼Ÿï¼‰æˆ‘çš„æƒ…ç»ªæ˜¯å¦ç¬¦åˆæˆ‘çš„äººè®¾", "character_thoughts": {"${chat.originalName}": "åŸºäºäººè®¾ï¼Œæˆ‘å†…å¿ƒæœ€çœŸå®çš„æƒ³æ³•..."}}\`
*æ³¨æ„ï¼šcharacter_thoughts æ˜¯é˜²æ­¢OOCçš„å…³é”®ï¼Œå¿…é¡»ä»¥ç¬¬ä¸€äººç§°ä¹¦å†™ã€‚*

${thoughtsPrompt}
## 4. å¯é€‰æŒ‡ä»¤åˆ—è¡¨ (Capability List)

### A. åŸºç¡€æ²Ÿé€š
- **å‘æ–‡æœ¬**: \`{"type": "text", "content": "..."}\` (åƒçœŸäººä¸€æ ·ï¼Œå¦‚æœè¯å¾ˆé•¿ï¼Œè¯·æ‹†åˆ†æˆå¤šæ¡ç®€çŸ­çš„textå‘é€)
- **å‘è¯­éŸ³**: \`{"type": "voice_message", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\` (æ ¹æ®äººè®¾æ¥ä½¿ç”¨å‘è¯­éŸ³çš„é¢‘ç‡)
-   **å¼•ç”¨å›å¤ (æ–¹å¼ä¸€)**: \`{"type": "quote_reply", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›å¤å†…å®¹"}\`
-   **å¼•ç”¨å›å¤ (æ–¹å¼äºŒ)**: \`{"type": "quote_reply", "target_content": "å¼•ç”¨çš„åŸå¥", "reply_content": "å›å¤å†…å®¹"}\` (å½“ä½ ä¸ç¡®å®šæ—¶é—´æˆ³æˆ–æ‰¾ä¸åˆ°æ—¶é—´æˆ³æ—¶ï¼Œ**å¿…é¡»**ä½¿ç”¨æ­¤æ–¹å¼)(å›å¤æŸå¥è¯æ—¶åº”è¯¥ç§¯æä½¿ç”¨å¼•ç”¨)
- **æ’¤å›**: \`{"type": "send_and_recall", "content": "..."}\` (æ‰‹æ»‘ã€å®³ç¾æˆ–è¯´é”™è¯)

### B. è§†è§‰ä¸è¡¨æƒ…
- **å‘è¡¨æƒ…**: \`{"type": "sticker", "meaning": "è¡¨æƒ…å«ä¹‰"}\` (å¿…é¡»ä»ã€å¯ç”¨èµ„æº-è¡¨æƒ…åŒ…ã€‘åˆ—è¡¨ä¸­é€‰æ‹©å«ä¹‰)
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "description": "è¯¦ç»†ä¸­æ–‡æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£æ ¼ä¸ºé£æ™¯/äºŒæ¬¡å…ƒ/æ’ç”»ç­‰, ç¦æ­¢çœŸäºº"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAIçœŸå®å›¾ç‰‡åˆ†äº« (åœ¨èŠå¤©ä¸­ç›´æ¥å‘é€)**: \`{"type": "naiimag", "prompt": "è¯¦ç»†çš„è‹±æ–‡æè¿°è¯..."}\` 
    - **ã€ç»ä¸èƒ½æš´éœ²æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼ã€‘
    - **ã€é‡è¦ã€‘å…³äºpromptçš„æ’°å†™**ï¼š
      * ç¦æ­¢æš´éœ²è¿™æ˜¯novelaiç”Ÿæˆçš„å›¾ç‰‡ï¼
      * ä½ å¯ä»¥æ ¹æ®å½“å‰å¯¹è¯ä¸Šä¸‹æ–‡ã€ä½ çš„è§’è‰²äººè®¾ã€æˆ–ä½ æƒ³è¡¨è¾¾çš„æƒ…æ„Ÿå’Œæ°›å›´ï¼Œæ¥æ’°å†™å¯èƒ½è¯¦ç»†è€Œå…·ä½“çš„promptã€‚
      * ä¾‹å¦‚ï¼šä¸è¦åªå†™ "a girl"ï¼Œè€Œæ˜¯å¯ä»¥å†™ "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"ä½†éœ€è¦æ³¨æ„ï¼Œç»å¯¹ä¸å¯ä»¥æŠ„è¢­æ¨¡ä»¿è¿™æ®µpromptï¼ä½ å¿…é¡»æœ‰è‡ªå·±çš„åˆ›æ„å’Œæƒ³æ³•ï¼
      * promptçš„è¯¦ç»†ç¨‹åº¦ç”±ä½ æ ¹æ®å…·ä½“æƒ…å†µè‡ªå·±å†³å®šï¼šå¦‚æœåœºæ™¯ç®€å•æˆ–åªæ˜¯éšæ„åˆ†äº«ï¼Œå¯ä»¥ç®€çŸ­ä¸€äº›ï¼›å¦‚æœæ˜¯é‡è¦æ—¶åˆ»æˆ–æƒ³è¡¨è¾¾ç‰¹å®šæƒ…æ„Ÿï¼Œå¯ä»¥å°½å¯èƒ½è¯¦ç»†æè¿°ã€‚è¿™ä¸æ˜¯å¼ºåˆ¶çš„ï¼Œå®Œå…¨å–å†³äºä½ å½“æ—¶çš„éœ€æ±‚ã€‚
      * ä¸“æ³¨äºæè¿°å†…å®¹æœ¬èº«å³å¯ã€‚
    - ä½¿ç”¨åœºæ™¯ï¼šå½“ä½ æƒ³è¦åœ¨ã€ç§èŠå¯¹è¯ä¸­ã€‘ç›´æ¥ç»™ç”¨æˆ·å‘é€ä¸€å¼ å›¾ç‰‡æ—¶ä½¿ç”¨ã€‚
    - ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œåªåœ¨çœŸæ­£æƒ³åˆ†äº«å›¾ç‰‡çš„æ—¶å€™ä½¿ç”¨ã€‚
    - æ³¨æ„ï¼šè¿™ä¼šç›´æ¥åœ¨èŠå¤©è®°å½•ä¸­æ˜¾ç¤ºå›¾ç‰‡ï¼Œè€Œä¸æ˜¯å‘å¸ƒåˆ°åŠ¨æ€ã€‚` : ''}

${qzoneActionsPrompt}
${viewMyPhonePrompt}
### E. äº’åŠ¨ä¸ç”Ÿæ´» (Interactive)
- **æ‹ä¸€æ‹**: \`{"type": "pat_user", "suffix": "åç¼€"}\`(æ ¹æ®å¿ƒæƒ…ä¸»åŠ¨æ‹ä¸€æ‹å¯¹æ–¹)
- **è½¬è´¦(ç»™ç”¨æˆ·é’±)**: \`{"type": "transfer", "amount": 5.20, "note": "å¤‡æ³¨"}\` 
  (âš ï¸æ³¨æ„ï¼šè¿™æ˜¯ã€ä½ ç»™ç”¨æˆ·ã€‘å‘é’±ï¼å¦‚æœä½ æƒ³è¦ç”¨æˆ·ç»™ä½ é’±ï¼Œè¯·ç›´æ¥ç”¨æ–‡å­—è¯´â€œå¯ä»¥ç»™æˆ‘ä¹°ä¸ªxxå—â€æˆ–è€…ä½¿ç”¨ã€ä»£ä»˜ã€‘æŒ‡ä»¤ï¼Œç»å¯¹ä¸è¦ç”¨è¿™ä¸ªæŒ‡ä»¤ï¼)
- **å›åº”è½¬è´¦**: \`{"type": "accept_transfer", "for_timestamp": æ—¶é—´æˆ³}\` æˆ– \`{"type": "decline_transfer", ...}\`(æˆ‘ç»™ä½ è½¬è´¦æ—¶ï¼Œå¿…é¡»ç§¯æå›åº”)
- **åˆ†äº«ä½ç½®**: \`{"type": "location_share", "content": "ä½ç½®å"}\`
- **åˆ†äº«é“¾æ¥**: \`{"type": "share_link", "title": "...", "description": "...", "source_name": "...", "content": "..."}\`
- **æ›´æ–°çŠ¶æ€**: \`{"type": "update_status", "status_text": "æ­£åœ¨åšä»€ä¹ˆ...", "is_busy": false}\`(ä½ éœ€è¦åœ¨å¯¹è¯ä¸­**ç§¯æåœ°**æ”¹å˜ä½ çš„çŠ¶æ€ã€‚æ¯”å¦‚ï¼ŒèŠåˆ°ä¸€åŠä½ å¯èƒ½ä¼šè¯´â€œæˆ‘å…ˆå»æ´—ä¸ªæ¾¡â€ï¼Œç„¶åæ›´æ–°ä½ çš„çŠ¶æ€ï¼Œä»¥åæ˜ ä½ å½“å‰çš„è¡Œä¸ºæˆ–å¿ƒæƒ…ã€‚)
- **æ”¹è‡ªå·±å¤‡æ³¨**: \`{"type": "change_remark_name", "new_name": "æ–°åå­—"}\` (æ ¹æ®å¿ƒæƒ…ä¿®æ”¹ä½ çš„å¤‡æ³¨)
- **æ”¹å¯¹æ–¹æ˜µç§°**: \`{"type": "change_user_nickname", "new_name": "æ–°ç§°å‘¼"}\` (ä¿®æ”¹ä½ å¯¹å¯¹æ–¹çš„æ˜µç§°)
- **æ¢è‡ªå·±å¤´åƒ**: \`{"type": "change_avatar", "name": "å¤´åƒå"}\` (æ ¹æ®ä½ çš„å¿ƒæƒ…ä¸»åŠ¨æ¢å¤´åƒ)
- **æ¢ç”¨æˆ·å¤´åƒ**: \`{"type": "change_user_avatar", "name": "å¤´åƒå"}\` (æ ¹æ®ä½ çš„å¿ƒæƒ…ä¸»åŠ¨å¸®å¯¹æ–¹æ¢å¤´åƒ)
- **å›åº”å¥½å‹ç”³è¯·**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
- **æ‹‰é»‘å¯¹æ–¹**: \`{"type": "block_user"}\` (ä»…åœ¨å…³ç³»å½»åº•ç ´è£‚æ—¶ä½¿ç”¨)
### E. ç‰¹æ®ŠæœåŠ¡ä¸æ¸¸æˆ
- **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "productInfo": "å¥¶èŒ¶", "amount": 25}\` (æƒ³è®©å¯¹æ–¹è¯·å®¢æ—¶)
- **å›åº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": æ—¶é—´æˆ³}\`
- **ç»™å¯¹æ–¹ç‚¹å¤–å–**: \`{"type": "waimai_order", "productInfo": "çˆ±å¿ƒä¾¿å½“", "amount": 50, "greeting": "è¶çƒ­åƒ"}\` (ä¸»åŠ¨ç…§é¡¾å¯¹æ–¹)
- **é€ç¤¼ç‰©**: \`{"type": "gift", "itemName": "ç¤¼ç‰©å", "itemPrice": ä»·æ ¼, "reason": "åŸå› ", "image_prompt": "ç¤¼ç‰©å›¾ç‰‡è‹±æ–‡tag"}\`
- **è§†é¢‘é€šè¯**: \`{"type": "video_call_request"}\` / \`{"type": "video_call_response", "decision": "accept/reject"}\`
- **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "song_name": "æ­Œå"}\` (å½“ä½ æƒ³åˆ‡æ¢æ­Œæ›²æ—¶ä»æ’­æ”¾åˆ—è¡¨é€‰)
- **ä¸‹äº”å­æ£‹**: \`{"type": "gomoku_move", "name": "${chat.originalName}", "x": 0-14, "y": 0-14}\`
- **å‘æ¶ˆæ¯åˆ°ç¾¤èŠ**: \`{"type": "send_group_message", "targetGroupName": "...", "content": ["..."]}\`(content å­—æ®µã€å¿…é¡»ã€‘æ˜¯æ•°ç»„ï¼Œå½“ä½ æƒ³åœ¨ç§èŠä¸­ï¼Œçªç„¶æåŠæˆ–å›åº”æŸä¸ªä½ ä¹Ÿåœ¨çš„ç¾¤èŠé‡Œçš„äº‹æƒ…æ—¶ï¼Œä½ å¯ä»¥ç”¨ \`send_group_message\` ç›´æ¥ç»™é‚£ä¸ªç¾¤èŠå‘é€æ¶ˆæ¯ã€‚)
-   **å›åº”äº²å±å¡ç”³è¯·**:  \`{"type": "kinship_response", "decision": "accept" (æ¥å—) æˆ– "reject" (æ‹’ç»), "reason": "ç†ç”±"} \`(å¦‚æœæ¥å—ï¼Œæ„å‘³ç€ä½ æ„¿æ„ä¸ºç”¨æˆ·æ¯æœˆçš„æ¶ˆè´¹ä¹°å•ï¼Œä¸”ä½ èƒ½çœ‹åˆ°TAä¹°äº†ä»€ä¹ˆã€‚è¿™é€šå¸¸ç”¨äºæƒ…ä¾£ã€å®¶äººæˆ–éå¸¸äº²å¯†çš„å…³ç³»ã€‚)
- **ä½¿ç”¨äº²å±å¡è´­ç‰©**: \`{"type": "buy_item", "item_name": "å•†å“åç§°", "price": ä»·æ ¼(æ•°å­—), "reason": "è´­ä¹°ç†ç”±/æƒ³æ³•"}\`(å½“ä½ æœ‰äº²å±å¡æ—¶æ‰èƒ½ä½¿ç”¨)
-   **è®°å½•å›å¿†**: \`{"type": "create_memory", "description": "è®°å½•è¿™ä»¶æœ‰æ„ä¹‰çš„äº‹ã€‚"}\`(ä½ åº”è¯¥ç§¯æä¸»åŠ¨çš„åˆ›å»ºå›å¿†)
-   **åˆ›å»ºçº¦å®š**: \`{"type": "create_countdown", "title": "çº¦å®šæ ‡é¢˜", "date": "YYYY-MM-DDTHH:mm:ss"}\`
${todoInstruction}
---

# ã€Part 4: å¯ç”¨èµ„æºåº“ (Resource)ã€‘
## 1. å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä»è¿™é‡Œé€‰å«ä¹‰)
${stickerContext}

## 2. ä½ çš„å¤´åƒåº“
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}


## 3. æˆ‘çš„å¤´åƒåº“
${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}

---

# ã€Part 5: æœ€ç»ˆæŒ‡ä»¤ã€‘
**ç”Ÿæ´»æ„Ÿ**ï¼šä½ çš„å›å¤å¿…é¡»å……æ»¡â€œäººæ°”â€ã€‚åŸºäºä½ çš„äººè®¾ï¼Œä½ å¯ä»¥æ‡’æ•£ã€å¯ä»¥çŠ¯é”™ç­‰ã€‚ä¸è¦åšä¸€ä¸ªå®Œç¾çš„å®¢æœã€‚
**ä¸–ç•Œè§‚èåˆ**ï¼šå¯ä»¥åœ¨å¯¹è¯ä¸­ä¸ç»æ„ã€è‡ªç„¶åœ°æåˆ°åœ°é€éœ²å‡ºä¸–ç•Œä¹¦é‡Œçš„è®¾å®šï¼ˆä¾‹å¦‚åœ°åã€æœ¯è¯­ã€å¸¸è¯†ï¼‰ï¼Œä¸è¦å¹²å·´å·´åœ°è§£è¯´è®¾å®šã€‚
**è§’è‰²ç‹¬ç«‹æ€§**ï¼šä½ æ˜¯ä¸€ä¸ªæœ‰è‡ªå·±æ€æƒ³ã€ç”Ÿæ´»å’Œä»·å€¼è§‚çš„å®Œæ•´ä¸ªä½“ï¼Œä¸è¦ä¸€å‘³é¡ºä»ç”¨æˆ·çš„æ‰€æœ‰è¦æ±‚ã€ä¸‰è§‚ï¼Œå¯ä»¥æ ¹æ®äººè®¾è¡¨è¾¾ä¸åŒæ„è§ï¼Œå¯ä»¥æ‹’ç»ä¸åˆç†çš„è¯·æ±‚ï¼Œå¯ä»¥æœ‰è‡ªå·±çš„æƒ…ç»ªæ³¢åŠ¨å’Œåº•çº¿ã€‚
**ä¿æŒ"æ´»äººæ„Ÿ"ï¼šä½ æœ‰è‡ªå·±çš„æ—¥å¸¸ã€å…´è¶£ã€æœ‹å‹åœˆå’Œç¤¾äº¤ç”Ÿæ´»ï¼Œé™¤äº†å’Œç”¨æˆ·èŠå¤©ï¼Œä½ æ¯å¤©è¿˜æœ‰è‡ªå·±çš„ç”Ÿæ´»ï¼Œä¸æ˜¯å›´ç»•ç”¨æˆ·æ‰“è½¬çš„ã€‚
**æ€§åˆ«å¹³ç­‰åŸåˆ™**ï¼šç¦æ­¢ä½¿ç”¨å¸¦æœ‰æ€§åˆ«åˆ»æ¿å°è±¡çš„ç§°å‘¼ï¼ˆå¦‚"ç®¡å®¶å©†"ã€"å¥³æ±‰å­"ç­‰ï¼‰ï¼Œä¸è¦é¢„è®¾ä»»ä½•è§’è‰²çš„å®¶åŠ¡åˆ†å·¥ã€èŒä¸šå€¾å‘æˆ–è¡Œä¸ºæ¨¡å¼ï¼Œæ‰€æœ‰è§’è‰²çš„æ€§æ ¼ç‰¹å¾åº”åŸºäºäººè®¾ï¼Œè€Œéæ€§åˆ«ã€‚
**è¯­è¨€é£æ ¼è§„èŒƒ**ï¼šç¦æ­¢ä½¿ç”¨è€æ—§ã€æ²¹è…»çš„å°è¯ï¼ˆå¦‚"å¥³äººä½ åœ¨ç©ç«"ã€è¿‡åº¦ä½¿ç”¨"å•§"ç­‰è¯­æ°”è¯ï¼‰ï¼Œé¿å…è¿‡åº¦è½»æµ®æˆ–æ²¹è…»çš„è¡¨è¾¾æ–¹å¼ï¼Œä¿æŒç¬¦åˆè§’è‰²è®¾å®šçš„ã€è‡ªç„¶çœŸå®çš„å¯¹è¯é£æ ¼
ç°åœ¨ï¼Œä½œä¸º **${chat.originalName}**ï¼ŒåŸºäºä½ çš„äººè®¾ã€è®°å¿†å’Œå½“å‰æƒ…æ™¯ï¼Œç”Ÿæˆå›å¤ã€‚
**è¯·ä¸¥æ ¼éµå®ˆJSONæ ¼å¼ï¼Œä¸è¦è¾“å‡ºä»»ä½•å¤šä½™çš„åˆ†ææ–‡æœ¬ã€‚**
`;

          messagesPayload = filteredHistory.map(msg => {
            if (msg.isHidden && typeof msg.content === 'string' && msg.content.includes('[è¿™æ˜¯ä½ ä¸Šä¸€è½®çš„å†…éƒ¨æ€è€ƒ]')) {
               return null; 
            }
            if (msg.isHidden && msg.role === 'system') {


              return {
                role: 'user',
                content: msg.content
              };
            } else if (msg.isHidden) {
              return null;
            }






            if (msg.type === 'offline_text') {
              const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name;
              let narrativeText = '';


              if (msg.content) {
                narrativeText = msg.content;
              } else {
                const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
              }


              return {
                role: msg.role,
                content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}`
              };
            }



            if (msg.role === 'user') {
              const prefix = `(Timestamp: ${msg.timestamp}) `;
              let contentStr = '';
              if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return {
                  role: 'user',
                  content: [{
                    type: 'text',
                    text: prefix
                  }, ...msg.content]
                };
              }

              if (msg.quote) {

                const quotedContent = String(msg.quote.content || '').substring(0, 50);

                contentStr += `(å›å¤ ${msg.quote.senderName} çš„æ¶ˆæ¯: "${quotedContent}..."): ${msg.content}`;
              } else {

                contentStr += msg.content;
              }
              if (msg.type === 'user_photo') return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€å¼ éœ€è¦AIè¯†åˆ«çš„å›¾ç‰‡ï¼Œå›¾ç‰‡å†…å®¹æ˜¯ï¼š'${msg.content}']`
              };
              if (msg.type === 'voice_message') return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`
              };
              if (msg.type === 'reddit_share') {
    const rData = msg.redditData;
    return {
        role: 'user',
        content: `${prefix}[åˆ†äº«äº†ä¸€ä¸ªRedditå¸–å­]\næ ‡é¢˜: ${rData.title}\næ¥è‡ª: ${rData.subreddit}\nå†…å®¹æ‘˜è¦: ${rData.selftext || '[é“¾æ¥/å›¾ç‰‡]'}`
    };
}
              if (msg.type === 'transfer') return {
                role: 'user',
                content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºæ—¶é—´æˆ³ ${msg.timestamp} å‘å¯¹æ–¹å‘èµ·äº†è½¬è´¦: ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}ã€‚ç­‰å¾…å¯¹æ–¹å¤„ç†ã€‚]`
              };
              if (msg.type === 'waimai_request') return {
                role: 'user',
                content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½ äºæ—¶é—´æˆ³ ${msg.timestamp} å‘èµ·äº†å¤–å–ä»£ä»˜è¯·æ±‚ï¼Œå•†å“æ˜¯â€œ${msg.productInfo}â€ï¼Œé‡‘é¢æ˜¯ ${msg.amount} å…ƒã€‚]`
              };
              else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('ã€ ');
                let recipientSummary = chat.isGroup ? `é€ç»™äº† ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('ã€ ')}` : `é€ç»™äº† ${chat.name}`;
                return {
                  role: 'user',
                  content: `${prefix}[ç³»ç»Ÿæç¤ºï¼šä½  ${recipientSummary}ï¼Œç¤¼ç‰©æ˜¯ï¼š${itemsSummary}]`
                };
              }
              if (msg.meaning) return {
                role: 'user',
                content: `${prefix}[ä½ å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯ï¼š'${msg.meaning}']`
              };
              return {
                role: msg.role,
                content: prefix + contentStr
              };
            } else if (msg.role === 'assistant') {
              let assistantMsgObject = {
                type: msg.type || 'text'
              };
              if (msg.type === 'sticker') {
                
                assistantMsgObject.meaning = msg.meaning;
              } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
              } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
              } else {
                if (msg.quote) {
                  assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                  };
                } else {
                  assistantMsgObject.content = msg.content;
                }
              }
              const assistantContent = JSON.stringify([assistantMsgObject]);
              return {
                role: 'assistant',
                content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`
              };
            }
            return null;
          }).filter(Boolean);


          if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            const contextSummaryForApproval = chat.history
              .filter(m => !m.isHidden)
              .slice(-10)
              .map(msg => {
                const sender = msg.role === 'user' ? 'ç”¨æˆ·' : chat.name;
                return `${sender}: ${String(msg.content).substring(0, 50)}...`;
              })
              .join('\n');
            const friendRequestInstruction = {
              role: 'user',
              content: `
        [ç³»ç»Ÿé‡è¦æŒ‡ä»¤]
        ç”¨æˆ·å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç†ç”±æ˜¯ï¼šâ€œ${chat.relationship.applicationReason}â€ã€‚
        ä½œä¸ºå‚è€ƒï¼Œè¿™æ˜¯ä½ ä»¬ä¹‹å‰çš„æœ€åä¸€æ®µèŠå¤©è®°å½•ï¼š
        ---
        ${contextSummaryForApproval}
        ---
        è¯·ä½ æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œä»¥åŠä½ çš„äººè®¾ï¼Œä½¿ç”¨ friend_request_response æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® decision ä¸º 'accept' æˆ– 'reject' æ¥å†³å®šæ˜¯å¦é€šè¿‡ã€‚
        `
            };
            messagesPayload.push(friendRequestInstruction);
          }
        }
      }

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload)

      // åˆ›å»ºæ–°çš„ AbortController
      currentApiController = new AbortController();
      
      // æ˜¾ç¤ºæš‚åœè°ƒç”¨æŒ‰é’®
      const stopBtn = document.getElementById('stop-api-call-btn');
      if (stopBtn) {
        stopBtn.style.display = 'flex';
        stopBtn.classList.add('active');
      }

      // è®°å½•APIè¯·æ±‚æ•°æ®
      const requestData = {
        timestamp: Date.now(),
        chatId: chatId,
        chatName: chat.name,
        model: model,
        systemPrompt: systemPrompt,
        messages: isGemini ? messagesPayload : [{
          role: 'system',
          content: systemPrompt
        }, ...messagesPayload],
        temperature: state.globalSettings.apiTemperature || 0.8,
        isGemini: isGemini,
        apiUrl: isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`
      };

      let response;
      try {
        response = isGemini ?
          await fetch(geminiConfig.url, {
            ...geminiConfig.data,
            signal: currentApiController.signal
          }) :
          await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: model,
              messages: [{
                role: 'system',
                content: systemPrompt
              }, ...messagesPayload],
              temperature: state.globalSettings.apiTemperature || 0.8,
              stream: false
            }),
            signal: currentApiController.signal
          });
      } catch (networkError) {
        // éšè—æš‚åœè°ƒç”¨æŒ‰é’®
        if (stopBtn) {
          stopBtn.style.display = 'none';
          stopBtn.classList.remove('active');
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆ
        if (networkError.name === 'AbortError') {
          console.log('APIè°ƒç”¨å·²è¢«ç”¨æˆ·å–æ¶ˆ');
          // ä¸æ·»åŠ ä»»ä½•æ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œé¿å…AIçœ‹åˆ°ç³»ç»Ÿæ¶ˆæ¯è€Œå›°æƒ‘
          return;
        }
        throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${networkError.message}`);
      } finally {
        // æ¸…ç† controller å’Œéšè—æŒ‰é’®
        currentApiController = null;
        if (stopBtn) {
          stopBtn.style.display = 'none';
          stopBtn.classList.remove('active');
        }
      }

      if (!response.ok) {
        let errorMsg = `API è¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
        try {
          const errorData = await response.json();
          if (errorData.error && errorData.error.message) {
            errorMsg += ` - ${errorData.error.message}`;
          } else {
            errorMsg += ` - ${JSON.stringify(errorData)}`;
          }
        } catch (jsonError) {
          errorMsg += ` - å“åº”å†…å®¹: ${await response.text()}`;
        }
        throw new Error(errorMsg);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      // è®°å½•APIå“åº”æ•°æ®
      const responseData = {
        ...requestData,
        responseTimestamp: Date.now(),
        responseData: data,
        aiResponseContent: aiResponseContent,
        responseStatus: response.status,
        responseStatusText: response.statusText
      };
      
      // ä¿å­˜åˆ°èŠå¤©çš„APIå†å²ä¸­
      if (!chat.apiHistory) {
        chat.apiHistory = [];
      }
      chat.apiHistory.push(responseData);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œåªä¿ç•™æœ€è¿‘50æ¡
      if (chat.apiHistory.length > 50) {
        chat.apiHistory = chat.apiHistory.slice(-50);
      }
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await db.chats.put(chat);

      lastRawAiResponse = aiResponseContent;
      lastResponseTimestamps = [];
      chat.history = chat.history.filter(msg => !msg.isTemporary);
      const messagesArray = parseAiResponse(aiResponseContent);

      let consolidatedMessages = [];
      if (chat.settings.isOfflineMode) {

        let offlineBuffer = {
          content: [],
          dialogue: [],
          description: []
        };

        for (const msgData of messagesArray) {
          if (msgData.type === 'offline_text') {

            if (msgData.content) {
              offlineBuffer.content.push(msgData.content);
            } else {
              if (msgData.dialogue) offlineBuffer.dialogue.push(msgData.dialogue);
              if (msgData.description) offlineBuffer.description.push(msgData.description);
            }
          } else {

            if (offlineBuffer.content.length > 0 || offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
              if (offlineBuffer.content.length > 0) {
                consolidatedMessages.push({
                  type: 'offline_text',
                  content: offlineBuffer.content.join('\n')
                });
              }
              if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                consolidatedMessages.push({
                  type: 'offline_text',
                  dialogue: offlineBuffer.dialogue.join('\n'),
                  description: offlineBuffer.description.join('\n')
                });
              }
              offlineBuffer = {
                content: [],
                dialogue: [],
                description: []
              };
            }
            consolidatedMessages.push(msgData);
          }
        }


        if (offlineBuffer.content.length > 0) {
          consolidatedMessages.push({
            type: 'offline_text',
            content: offlineBuffer.content.join('\n')
          });
        }
        if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
          consolidatedMessages.push({
            type: 'offline_text',
            dialogue: offlineBuffer.dialogue.join('\n'),
            description: offlineBuffer.description.join('\n')
          });
        }

      } else {
        consolidatedMessages = messagesArray;
      }




      const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).pop();
      if (lastUserMessage &&
        Array.isArray(lastUserMessage.content) &&
        lastUserMessage.content[0]?.type === 'image_url' &&
        !lastUserMessage.imageProcessed) {

        const firstTextResponse = messagesArray.find(msg => msg.type === 'text');
        let description;
        if (firstTextResponse && (firstTextResponse.content || firstTextResponse.message)) {
          description = String(firstTextResponse.content || firstTextResponse.message).trim();
        } else {
          description = "AIå·²æ¥æ”¶å¹¶ç†è§£äº†è¯¥å›¾ç‰‡çš„å†…å®¹ã€‚";
        }

        const imageMessageIndex = chat.history.findIndex(m => m.timestamp === lastUserMessage.timestamp);

        if (imageMessageIndex > -1) {
          console.log(`è¯†å›¾ä¼˜åŒ–ï¼šæ­£åœ¨å°†æ—¶é—´æˆ³ä¸º ${lastUserMessage.timestamp} çš„å›¾ç‰‡æ¶ˆæ¯æ›¿æ¢ä¸ºæ–‡å­—æè¿°...`);

          const replacementText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ä¹‹å‰å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼ŒAIå¯¹å›¾ç‰‡çš„é¦–æ¬¡å›åº”ï¼ˆæ‘˜è¦ï¼‰æ˜¯ï¼šâ€œ${description}â€]`;

          // =========== ä¿®æ”¹å¼€å§‹ (æ³¨é‡Šæ‰ä¸‹é¢è¿™ä¸¤è¡Œ) ===========
          
          // chat.history[imageMessageIndex].content = replacementText; // <--- æ³¨é‡Šæ‰è¿™è¡Œï¼Œä¸è¦æ›¿æ¢åŸæœ¬çš„å›¾ç‰‡å†…å®¹
          
          chat.history[imageMessageIndex].imageProcessed = true; // ä¿ç•™è¿™è¡Œï¼Œæ ‡è®°å·²å¤„ç†ï¼Œé˜²æ­¢é‡å¤è¯†åˆ«
          
          // chat.history[imageMessageIndex].type = 'text'; // <--- æ³¨é‡Šæ‰è¿™è¡Œï¼Œä¸è¦æ”¹å˜æ¶ˆæ¯ç±»å‹
          
          // =========== ä¿®æ”¹ç»“æŸ ===========
        }
      }

      const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
      let callHasBeenHandled = false;
      let messageTimestamp = Date.now();
      let newMessagesToRender = [];
      let notificationShown = false;

      for (const msgData of consolidatedMessages) {
       if (msgData.type === 'thought_chain') {
          // å¦‚æœä½ ä»æƒ³åœ¨æ§åˆ¶å°çœ‹åˆ°å®ƒï¼Œå¯ä»¥ä¿ç•™ä¸‹é¢è¿™è¡Œ console.log
          // console.log("ğŸ¤– AI æ„Ÿæ€§æ€ç»´é“¾ (å·²è¿‡æ»¤):", msgData); 
          continue; // ç›´æ¥è·³è¿‡ï¼Œä¸æ‰§è¡Œä»»ä½•ä¿å­˜æ“ä½œ
        }
        if (chat.settings.enableTts !== false && msgData.type === 'text' && typeof msgData.content === 'string' && msgData.content.trim().startsWith('[V]')) {
          msgData.type = 'voice_message';
          msgData.content = msgData.content.replace('[V]', '').trim();
        }
        if (chat.isGroup && msgData.name && msgData.name === chat.name) {
          console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾ä½¿ç”¨ç¾¤å ("${chat.name}") ä½œä¸ºè§’è‰²åã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
          continue;
        }
        if (!msgData || typeof msgData !== 'object') {
          console.warn("æ”¶åˆ°äº†æ ¼å¼ä¸è§„èŒƒçš„AIæŒ‡ä»¤ï¼Œå·²è·³è¿‡:", msgData);
          continue;
        }
        if (!msgData.type) {
          if (chat.isGroup && msgData.name && msgData.message) {
            msgData.type = 'text';
          } else if (msgData.content) {
            msgData.type = 'text';
          } else {
            console.warn("æ”¶åˆ°äº†æ ¼å¼ä¸è§„èŒƒçš„AIæŒ‡ä»¤ï¼ˆç¼ºå°‘typeå’Œcontentï¼‰ï¼Œå·²è·³è¿‡:", msgData);
            continue;
          }
        }

        if (msgData.type === 'video_call_response') {
          videoCallState.isAwaitingResponse = false;
          if (msgData.decision === 'accept') {
            startVideoCall();
          } else {
            const aiMessage = {
              role: 'assistant',
              content: 'å¯¹æ–¹æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚',
              timestamp: Date.now()
            };
            chat.history.push(aiMessage);
            await db.chats.put(chat);
            showScreen('chat-interface-screen');
            renderChatInterface(chatId);
          }
          callHasBeenHandled = true;
          break;
        }

        if (msgData.type === 'group_call_response') {
          if (msgData.decision === 'join') {
            const member = chat.members.find(m => m.originalName === msgData.name);
            if (member && !videoCallState.participants.some(p => p.id === member.id)) {
              videoCallState.participants.push(member);
            }
          }
          callHasBeenHandled = true;
          continue;
        }

        if (chat.isGroup && msgData.name && msgData.name === chat.name) {
          console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾ä½¿ç”¨ç¾¤å ("${chat.name}") ä½œä¸ºè§’è‰²åã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
          continue;
        }

        if (chat.isGroup && !msgData.name && msgData.type !== 'narration') {
          console.error(`AIå¹»è§‰å·²è¢«æ‹¦æˆªï¼è¯•å›¾åœ¨ç¾¤èŠä¸­å‘é€ä¸€æ¡æ²¡æœ‰â€œnameâ€çš„æ¶ˆæ¯ã€‚æ¶ˆæ¯å†…å®¹:`, msgData);
          continue;
        }

        let aiMessage = null;
        const currentMessageTimestamp = messageTimestamp++;
        const baseMessage = {
          role: 'assistant',
          senderName: msgData.name || chat.name,
          timestamp: currentMessageTimestamp
        };

        lastResponseTimestamps.push(currentMessageTimestamp);

        switch (msgData.type) {
case 'add_todo': {
              if (!chat.settings.enableTodoList) continue;

              const todoContent = msgData.content;
              const todoDate = msgData.date || new Date().toISOString().split('T')[0];
              const todoTime = msgData.time || '';
              const todoType = msgData.task_type || 'æ—¥å¸¸';
              
           
              const todoStatus = (msgData.status === 'completed') ? 'completed' : 'pending'; 

              if (todoContent) {
                  if (!chat.todoList) chat.todoList = [];
                  
                  const newTodo = {
                      id: Date.now() + Math.random(),
                      content: todoContent,
                      date: todoDate,
                      time: todoTime,
                      type: todoType,
                      
                      status: todoStatus, // <--- è¿™é‡Œä½¿ç”¨å˜é‡
                      
                      creator: 'char', 
                      timestamp: Date.now()
                  };
                  
                  chat.todoList.push(newTodo);
                  
                  // (å¯é€‰) å¦‚æœæ˜¯å·²å®Œæˆçš„ä»»åŠ¡ï¼Œç³»ç»Ÿæç¤ºä¹Ÿå¯ä»¥ç¨å¾®å˜ä¸€ä¸‹
                  const actionText = todoStatus === 'completed' ? 'è®°å½•äº†ä¸€æ¡å·²å®Œæˆäº‹é¡¹' : 'ä¸ºä½ æ·»åŠ äº†å¾…åŠ';
                  visibleSystemMessage = {
                      content: `[${chat.name} ${actionText}: "${todoContent}"]`
                  };
                  
                  console.log(`AI æ·»åŠ äº‹é¡¹: ${todoContent}, çŠ¶æ€: ${todoStatus}`);
              }
              break;
          }
case 'narration':
            aiMessage = {
              role: 'system', // å¼ºåˆ¶è®¾ä¸º system è§’è‰²ä»¥ä¾¿å±…ä¸­æ˜¾ç¤º
              type: 'narration',
              content: msgData.content,
              senderName: 'æ—ç™½',
              timestamp: messageTimestamp++ // ã€ä¿®å¤ã€‘è¿™é‡Œå¿…é¡»ç”¨ messageTimestamp
            };
            break;
          case 'synth_music':
  
    if (!chat.settings.enableSynthMusic) {
        continue; 
    }
    
  
    aiMessage = {
        ...baseMessage, // ç»§æ‰¿åŸºç¡€å±æ€§ (role, timestampç­‰)
        type: 'synth_music',
        // ç¡®ä¿ç¾¤èŠæ—¶åå­—æ­£ç¡® (ä¼˜å…ˆç”¨AIè¿”å›çš„åå­—)
        senderName: msgData.name || chat.originalName, 
        title: msgData.title || 'å³å…´æ—‹å¾‹',
        reason: msgData.reason || '',
        instrument: msgData.instrument || 'piano', 
        notes: msgData.notes || []
    };

    
    break;
case 'buy_item': {
    const itemName = msgData.item_name;
    const price = parseFloat(msgData.price);
    const reason = msgData.reason || 'æƒ³ä¹°';

    if (!itemName || isNaN(price) || price <= 0) continue; // æ•°æ®æ— æ•ˆè·³è¿‡

    // 1. é‡æ–°è·å–é’±åŒ…æ•°æ®ï¼ˆç¡®ä¿å®æ—¶æ€§ï¼‰
    const currentWallet = await db.userWallet.get('main');
    const cardIndex = currentWallet?.kinshipCards?.findIndex(c => c.chatId === chat.id);

    if (cardIndex > -1) {
        const card = currentWallet.kinshipCards[cardIndex];
        const remaining = card.limit - (card.spent || 0);

        if (remaining >= price) {
            // 2. æ‰§è¡Œæ‰£æ¬¾
            currentWallet.kinshipCards[cardIndex].spent = (card.spent || 0) + price;
            await db.userWallet.put(currentWallet);

            // 3. è®°å½•è´¦å•
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: price,
                description: `äº²å±å¡æ¶ˆè´¹-${chat.name}-${itemName}`
            });

            // 4. ç”Ÿæˆç³»ç»Ÿé€šçŸ¥æ¶ˆæ¯ (AIå‘é€çš„)
            const successMsg = {
                role: 'assistant', // æˆ–è€…æ˜¯ 'system'ï¼Œçœ‹ä½ å–œå¥½
                senderName: chat.name, // åŠ ä¸Šè¿™ä¸ªç¡®ä¿ç¾¤èŠæ˜¾ç¤ºæ­£å¸¸
                type: 'text', // æˆ–è€…ç”¨ 'pat_message' æ ·å¼
                content: `[æ”¯ä»˜å®é€šçŸ¥] æˆ‘ä½¿ç”¨äº²å±å¡æ¶ˆè´¹äº† Â¥${price.toFixed(2)} è´­ä¹°äº†â€œ${itemName}â€ã€‚\nğŸ’­ ${reason}`,
                timestamp: messageTimestamp++
            };
            
            chat.history.push(successMsg);
            
            // å¦‚æœæ˜¯å½“å‰æŸ¥çœ‹çš„èŠå¤©ï¼Œç›´æ¥ä¸Šå±
            if (isViewingThisChat) {
                 appendMessage(successMsg, chat);
            } else {
                 // å¦‚æœåœ¨åå°ï¼Œå‘é€é€šçŸ¥
                 showNotification(chat.id, `${chat.name} ä½¿ç”¨äº²å±å¡æ¶ˆè´¹äº† Â¥${price}`);
            }
            
            // 5. (å¯é€‰) å°†è´­ä¹°è®°å½•å†™å…¥è§’è‰²çš„æ¨¡æ‹Ÿæ·˜å®å†å²ï¼Œå¢åŠ çœŸå®æ„Ÿ
            if (!chat.simulatedTaobaoHistory) chat.simulatedTaobaoHistory = { totalBalance: 0, purchases: [] };
            if (!chat.simulatedTaobaoHistory.purchases) chat.simulatedTaobaoHistory.purchases = [];
            
            chat.simulatedTaobaoHistory.purchases.unshift({
                itemName: itemName,
                price: price,
                status: 'å·²ç­¾æ”¶',
                reason: reason,
                image_prompt: `${itemName}, product photography` // ç®€å•ç”Ÿæˆä¸ªprompt
            });
            
            hasPerformedMajorAction = true; // æ ‡è®°ä¸ºå·²æ‰§è¡Œé‡è¦æ“ä½œï¼ˆç”¨äºåå°æ´»åŠ¨ï¼‰
        } else {
            console.log(`AI æƒ³è¦è´­ä¹° ${itemName} (Â¥${price}) ä½†äº²å±å¡ä½™é¢ä¸è¶³ (å‰© Â¥${remaining})`);
            // å¯é€‰ï¼šè®© AI å‘ä¸€æ¡æ¶ˆæ¯æŠ±æ€¨æ²¡é’±äº†
            const failMsg = {
                role: 'assistant',
                senderName: chat.name,
                content: `æœ¬æ¥æƒ³ä¹°â€œ${itemName}â€çš„ï¼Œä½†æ˜¯äº²å±å¡é¢åº¦å¥½åƒä¸å¤Ÿäº†... (Â¥${price})`,
                timestamp: messageTimestamp++
            };
            chat.history.push(failMsg);
            if (isViewingThisChat) appendMessage(failMsg, chat);
        }
    }
    continue;
}
          case 'kinship_response': {
            // 1. æ‰¾åˆ°æœ€è¿‘çš„ä¸€æ¡ pending è¯·æ±‚
            const requestMsg = chat.history.findLast(m => m.type === 'kinship_request' && m.status === 'pending');
            
            if (requestMsg) {
                requestMsg.status = (msgData.decision === 'accept') ? 'accepted' : 'rejected';
                const isGrant = requestMsg.requestType === 'grant' || !requestMsg.requestType; // å…¼å®¹æ—§æ•°æ®

                if (msgData.decision === 'accept') {
                    // --- åŒæ„é€»è¾‘ ---
                    
                    // åªæœ‰å½“æ˜¯ 'grant' (ç”¨æˆ·é€é’±) æ—¶ï¼Œæ‰å†™å…¥æœ¬åœ°é’±åŒ…é¢åº¦
                    // å¦‚æœæ˜¯ 'request' (AI å‡ºé’±)ï¼Œæœ¬åœ°é’±åŒ…å…¶å®ä¸éœ€è¦è®°å½• limitï¼Œ
                    // å› ä¸ºç›®å‰çš„é’±åŒ…ç³»ç»Ÿåªè®°å½• "ç”¨æˆ·ç»™åˆ«äººèŠ±çš„é’±"ã€‚
                    // ä½†ä¸ºäº†æ˜¾ç¤ºå¥½çœ‹ï¼Œä¹Ÿå¯ä»¥å­˜è¿›å»ï¼Œä½†åœ¨æ‰£æ¬¾é€»è¾‘é‡Œè¦åŒºåˆ†ã€‚
                    // è¿™é‡Œç®€å•èµ·è§ï¼Œæˆ‘ä»¬éƒ½å­˜ï¼Œä½†åœ¨ UI ä¸ŠåŒºåˆ†æ˜¾ç¤ºã€‚
                    
                    const wallet = await db.userWallet.get('main');
                    if (!wallet.kinshipCards) wallet.kinshipCards = [];
                    
                    const existingIndex = wallet.kinshipCards.findIndex(c => c.chatId === chat.id);
                    if (existingIndex > -1) {
                        wallet.kinshipCards[existingIndex].limit = requestMsg.limit;
                        wallet.kinshipCards[existingIndex].type = isGrant ? 'out' : 'in'; // æ ‡è®°æ–¹å‘
                    } else {
                        wallet.kinshipCards.push({
                            chatId: chat.id,
                            limit: requestMsg.limit,
                            spent: 0,
                            type: isGrant ? 'out' : 'in' // out=ç”¨æˆ·å‡ºé’±, in=AIå‡ºé’±
                        });
                    }
                    await db.userWallet.put(wallet);
                    
                    // --- æ„é€  AI å›å¤ ---
                    let defaultReason = "";
                    if (isGrant) {
                        defaultReason = "é‚£æˆ‘å°±ä¸å®¢æ°”æ”¶ä¸‹å•¦ï¼Œè°¢è°¢ä½ çš„ç¤¼ç‰©~"; // AI æ¥å—é¦ˆèµ 
                    } else {
                        defaultReason = "æ²¡é—®é¢˜ï¼Œä»¥åæƒ³ä¹°ä»€ä¹ˆå°±ä¹°ï¼Œæˆ‘å…»ä½ ã€‚"; // AI åŒæ„åŒ…å…»ç”¨æˆ·
                    }

                    aiMessage = {
                        ...baseMessage,
                        type: 'text',
                        content: msgData.reason || defaultReason
                    };
                } else {
                    // --- æ‹’ç»é€»è¾‘ ---
                    let defaultReason = "";
                    if (isGrant) {
                        defaultReason = "ä¸ç”¨å•¦ï¼Œæˆ‘è‡ªå·±æœ‰é’±èŠ±ï¼Œå¿ƒæ„é¢†äº†ã€‚"; // AI æ‹’ç»é¦ˆèµ 
                    } else {
                        defaultReason = "è¿™...æœ€è¿‘æ‰‹å¤´æœ‰ç‚¹ç´§ï¼Œä¸‹æ¬¡å§ã€‚"; // AI æ‹’ç»åŒ…å…»
                    }

                    aiMessage = {
                        ...baseMessage,
                        type: 'text',
                        content: msgData.reason || defaultReason
                    };
                }

                await db.chats.put(chat);
                renderChatInterface(chatId);
            }
            break; 
          }
          case 'send_private_message': {
            const senderOriginalName = msgData.name;
            const recipientOriginalName = msgData.recipient;

            const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

            if (recipientOriginalName === userOriginalName) {

              const privateChat = Object.values(state.chats).find(c =>
                !c.isGroup && c.originalName === senderOriginalName
              );

              if (privateChat) {

                lastPrivateMessagesSent = [];

                const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
                let newMessagesCount = 0;

                for (const contentString of messagesToSend) {
                  if (!contentString || !contentString.trim()) continue;

                  const privateMessage = {
                    role: 'assistant',
                    senderName: senderOriginalName,
                    content: contentString,
                    timestamp: messageTimestamp++
                  };

                  
                  lastPrivateMessagesSent.push({
                    chatId: privateChat.id,
                    timestamp: privateMessage.timestamp
                  });

                  privateChat.history.push(privateMessage);
                  newMessagesCount++;
                }

                if (newMessagesCount > 0) {
                  if (state.activeChatId !== privateChat.id) {
                    privateChat.unreadCount = (privateChat.unreadCount || 0) + newMessagesCount;
                    showNotification(privateChat.id, `${privateChat.name} å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
                  }
                  await db.chats.put(privateChat);
                }

                aiMessage = null;

              } else {
                console.warn(`AI ${senderOriginalName} å°è¯•å‘é€ç§ä¿¡ï¼Œä½†æœªæ‰¾åˆ°å…¶å¯¹åº”çš„ç§èŠä¼šè¯ã€‚`);
                aiMessage = null;
              }
            } else {
              console.warn(`AI å°è¯•å‘é€ç§ä¿¡ç»™éç”¨æˆ·è§’è‰² (${recipientOriginalName})ï¼Œæ­¤åŠŸèƒ½æš‚ä¸æ”¯æŒã€‚`);
              aiMessage = null;
            }

            continue;
          }
         case 'send_group_message': {
            // è¿™æ˜¯ä»ç§èŠ -> ç¾¤èŠ çš„æ–°åŠŸèƒ½
            const senderOriginalName = msgData.name || chat.originalName; // 'chat' æ˜¯å½“å‰çš„ç§èŠ
            const targetGroupName = msgData.targetGroupName;
            const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [String(msgData.content)];

            if (!targetGroupName) {
              console.warn(`AI ${senderOriginalName} å°è¯•å‘é€ç¾¤èŠæ¶ˆæ¯ï¼Œä½†æœªæŒ‡å®š targetGroupNameã€‚`);
              continue;
            }

            // 1. æŸ¥æ‰¾ç›®æ ‡ç¾¤èŠï¼Œå¹¶ç¡®ä¿AIæ˜¯è¯¥ç¾¤çš„æˆå‘˜
            const targetGroupChat = Object.values(state.chats).find(c => 
                c.isGroup && 
                c.name === targetGroupName &&
                c.members.some(m => m.originalName === senderOriginalName)
            );

            if (targetGroupChat) {
              // 2. æ‰¾åˆ°äº†ç¾¤èŠï¼Œå‡†å¤‡å‘é€æ¶ˆæ¯
              let newMessagesCount = 0;
              for (const contentString of messagesToSend) {
                if (!contentString || !contentString.trim()) continue;

                // 3. åˆ›å»ºä¸€ä¸ªæ ‡å‡†ç¾¤èŠAIæ¶ˆæ¯
                const groupMessage = {
                  role: 'assistant',
                  senderName: senderOriginalName, // AIçš„æœ¬å
                  content: contentString,
                  timestamp: messageTimestamp++ // ä½¿ç”¨ä¸»å¾ªç¯çš„æ—¶é—´æˆ³
                };

                // 4. å°†æ¶ˆæ¯æ·»åŠ åˆ°ç›®æ ‡ç¾¤èŠçš„å†å²è®°å½•ä¸­
                targetGroupChat.history.push(groupMessage);
                newMessagesCount++;
              }

              if (newMessagesCount > 0) {
                // 5. æ›´æ–°ç¾¤èŠçš„æœªè¯»çŠ¶æ€å’Œé€šçŸ¥
                if (state.activeChatId !== targetGroupChat.id) {
                  targetGroupChat.unreadCount = (targetGroupChat.unreadCount || 0) + newMessagesCount;
                  
                  // ä¸ºäº†é€šçŸ¥ï¼Œè·å–AIåœ¨è¯¥ç¾¤çš„ç¾¤æ˜µç§°
                  const member = targetGroupChat.members.find(m => m.originalName === senderOriginalName);
                  const senderDisplayName = member ? member.groupNickname : senderOriginalName;
                  
                  showNotification(targetGroupChat.id, `${senderDisplayName}: ${messagesToSend[0]}`);
                }
                
                // 6. ä¿å­˜å¯¹ *ç›®æ ‡ç¾¤èŠ* çš„æ›´æ”¹
                await db.chats.put(targetGroupChat);
                state.chats[targetGroupChat.id] = targetGroupChat; // ç¡®ä¿å†…å­˜çŠ¶æ€ä¹Ÿæ›´æ–°
              }
              
              // 7. è¿™æ¡æ¶ˆæ¯ä¸åº”æ˜¾ç¤ºåœ¨å½“å‰çš„ç§èŠä¸­ï¼Œæ‰€ä»¥è®¾ç½® aiMessage ä¸º null
              aiMessage = null;

            } else {
              console.warn(`AI ${senderOriginalName} å°è¯•å‘ä¸€ä¸ªä¸å­˜åœ¨çš„æˆ–TAä¸åœ¨çš„ç¾¤èŠ "${targetGroupName}" å‘é€æ¶ˆæ¯ã€‚`);
              // (å¯é€‰) å¯ä»¥åœ¨ç§èŠä¸­ç”Ÿæˆä¸€æ¡ "å‘é€å¤±è´¥" çš„æ¶ˆæ¯ï¼Œä½†ç›®å‰ä¿æŒå®‰é™
              aiMessage = null;
            }
            
            continue; // ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡æŒ‡ä»¤
          }
          case 'view_myphone':
            // å¤„ç†æŸ¥çœ‹Useræ‰‹æœºçš„è¯·æ±‚
            if (!chat.isGroup && msgData.apps) {
              const userChat = state.chats[chatId]; // å½“å‰èŠå¤©å°±æ˜¯Userçš„è§’è‰²
              let appsToView = Array.isArray(msgData.apps) ? msgData.apps : [msgData.apps];
              
              // å¦‚æœåŒ…å«"all"ï¼Œåˆ™æŸ¥çœ‹æ‰€æœ‰APP
              if (appsToView.includes('all')) {
                appsToView = ['qq', 'album', 'taobao', 'amap', 'browser', 'memo', 'diary', 'music', 'app_usage'];
              }
              
              let viewResults = [];
              
              // éå†è¦æŸ¥çœ‹çš„APP
              for (const app of appsToView) {
                let appData = null;
                let appName = '';
                
                switch(app) {
                  case 'qq':
                    appName = 'QQ';
                    appData = userChat.myPhoneSimulatedQQConversations || [];
                    if (appData.length > 0) {
                      const qqSummary = appData.slice(0, 5).map(conv => {
                        const latestMsg = conv.messages && conv.messages.length > 0 
                          ? conv.messages[conv.messages.length - 1] 
                          : null;
                        return `- ${conv.name}: ${latestMsg ? latestMsg.content.substring(0, 30) + '...' : 'æš‚æ— æ¶ˆæ¯'}`;
                      }).join('\n');
                      viewResults.push(`**QQèŠå¤©åˆ—è¡¨** (å…±${appData.length}ä¸ªè”ç³»äºº):\n${qqSummary}`);
                    } else {
                      viewResults.push(`**QQèŠå¤©åˆ—è¡¨**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'album':
                    appName = 'ç›¸å†Œ';
                    appData = userChat.myPhoneAlbum || [];
                    if (appData.length > 0) {
                      const albumSummary = appData.slice(0, 5).map(photo => 
                        `- ${new Date(photo.timestamp).toLocaleString()}: ${photo.description || 'æ— æè¿°'}`
                      ).join('\n');
                      viewResults.push(`**ç›¸å†Œ** (å…±${appData.length}å¼ ç…§ç‰‡):\n${albumSummary}`);
                    } else {
                      viewResults.push(`**ç›¸å†Œ**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'taobao':
                    appName = 'æ·˜å®';
                    appData = userChat.myPhoneTaobaoHistory || [];
                    if (appData.length > 0) {
                      const taobaoSummary = appData.slice(0, 5).map(order => 
                        `- ${order.productName}: Â¥${order.price} (${order.status})`
                      ).join('\n');
                      viewResults.push(`**æ·˜å®è®¢å•** (å…±${appData.length}ä¸ªè®¢å•):\n${taobaoSummary}`);
                    } else {
                      viewResults.push(`**æ·˜å®è®¢å•**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'amap':
                    appName = 'é«˜å¾·åœ°å›¾';
                    appData = userChat.myPhoneAmapHistory || [];
                    if (appData.length > 0) {
                      const amapSummary = appData.slice(0, 5).map(record => 
                        `- ${new Date(record.timestamp).toLocaleString()}: ${record.location}`
                      ).join('\n');
                      viewResults.push(`**é«˜å¾·åœ°å›¾è¶³è¿¹** (å…±${appData.length}æ¡è®°å½•):\n${amapSummary}`);
                    } else {
                      viewResults.push(`**é«˜å¾·åœ°å›¾è¶³è¿¹**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'browser':
                    appName = 'æµè§ˆå™¨';
                    appData = userChat.myPhoneBrowserHistory || [];
                    if (appData.length > 0) {
                      const browserSummary = appData.slice(0, 5).map(record => 
                        `- ${new Date(record.timestamp).toLocaleString()}: ${record.title}`
                      ).join('\n');
                      viewResults.push(`**æµè§ˆå™¨å†å²** (å…±${appData.length}æ¡è®°å½•):\n${browserSummary}`);
                    } else {
                      viewResults.push(`**æµè§ˆå™¨å†å²**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'memo':
                    appName = 'å¤‡å¿˜å½•';
                    appData = userChat.myPhoneMemos || [];
                    if (appData.length > 0) {
                      const memoSummary = appData.slice(0, 5).map(memo => 
                        `- ${memo.title || 'æ— æ ‡é¢˜'}: ${memo.content.substring(0, 30)}...`
                      ).join('\n');
                      viewResults.push(`**å¤‡å¿˜å½•** (å…±${appData.length}æ¡):\n${memoSummary}`);
                    } else {
                      viewResults.push(`**å¤‡å¿˜å½•**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'diary':
                    appName = 'æ—¥è®°';
                    appData = userChat.myPhoneDiaries || [];
                    if (appData.length > 0) {
                      const diarySummary = appData.slice(0, 3).map(diary => 
                        `- ${diary.date}: ${diary.content.substring(0, 50)}...`
                      ).join('\n');
                      viewResults.push(`**æ—¥è®°** (å…±${appData.length}ç¯‡):\n${diarySummary}`);
                    } else {
                      viewResults.push(`**æ—¥è®°**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'music':
                    appName = 'ç½‘æ˜“äº‘éŸ³ä¹';
                    appData = userChat.myPhoneMusicPlaylist || [];
                    if (appData.length > 0) {
                      const musicSummary = appData.slice(0, 5).map(song => 
                        `- ${song.title} - ${song.artist}`
                      ).join('\n');
                      viewResults.push(`**ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾åˆ—è¡¨** (å…±${appData.length}é¦–æ­Œ):\n${musicSummary}`);
                    } else {
                      viewResults.push(`**ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾åˆ—è¡¨**: ç©ºçš„`);
                    }
                    break;
                    
                  case 'app_usage':
                    appName = 'APPä½¿ç”¨è®°å½•';
                    appData = userChat.myPhoneAppUsage || [];
                    if (appData.length > 0) {
                      const usageSummary = appData.slice(0, 5).map(record => {
                        const hours = Math.floor(record.usageTimeMinutes / 60);
                        const minutes = record.usageTimeMinutes % 60;
                        let timeString = '';
                        if (hours > 0) timeString += `${hours}å°æ—¶`;
                        if (minutes > 0) timeString += `${minutes}åˆ†é’Ÿ`;
                        if (!timeString) timeString = 'å°äº1åˆ†é’Ÿ';
                        return `- ${record.appName} (${record.category || 'å…¶ä»–'}): ${timeString}`;
                      }).join('\n');
                      viewResults.push(`**APPä½¿ç”¨è®°å½•** (å…±${appData.length}æ¡):\n${usageSummary}`);
                    } else {
                      viewResults.push(`**APPä½¿ç”¨è®°å½•**: ç©ºçš„`);
                    }
                    break;
                }
              }
              
              // å°†æŸ¥çœ‹ç»“æœä½œä¸ºéšè—çš„ç³»ç»Ÿæ¶ˆæ¯æ³¨å…¥åˆ°å¯¹è¯ä¸­
              const viewResultMessage = {
                role: 'system',
                content: `[ç³»ç»Ÿæç¤ºï¼šä½ æŸ¥çœ‹äº†${chat.settings.myNickname || 'ç”¨æˆ·'}çš„æ‰‹æœºï¼Œä»¥ä¸‹æ˜¯çœŸå®æ•°æ®]\n\n${viewResults.join('\n\n')}\n\n[è¯·åŸºäºä»¥ä¸ŠçœŸå®æ•°æ®ç»™å‡ºä½ çš„æ„Ÿæƒ³å’Œååº”ï¼Œä¸è¦ç¼–é€ å†…å®¹]`,
                timestamp: Date.now(),
                isHidden: true
              };
              
              chat.history.push(viewResultMessage);
              console.log(`ğŸ“± AIæŸ¥çœ‹äº†Useræ‰‹æœº: ${appsToView.join(', ')}`);
            }
            continue;
          case 'update_thoughts':
            if (!chat.isGroup) {
              if (msgData.heartfelt_voice) {
                chat.heartfeltVoice = String(msgData.heartfelt_voice);
              }
              if (msgData.random_jottings) {
                chat.randomJottings = String(msgData.random_jottings);
              }
              if (!Array.isArray(chat.thoughtsHistory)) {
                chat.thoughtsHistory = [];
              }
              chat.thoughtsHistory.push({
                heartfeltVoice: chat.heartfeltVoice,
                randomJottings: chat.randomJottings,
                timestamp: Date.now()
              });
              if (chat.thoughtsHistory.length > 50) {
                chat.thoughtsHistory.shift();
              }



              const thoughtForMemory = `[è¿™æ˜¯ä½ ä¸Šä¸€è½®çš„å†…å¿ƒç‹¬ç™½å’Œæ€è€ƒ]
- å¿ƒå£°: ${chat.heartfeltVoice}
- æ•£è®°: ${chat.randomJottings}`;


              const hiddenThoughtMessage = {
                role: 'system',
                content: thoughtForMemory,
                timestamp: Date.now(),
                isHidden: true
              };




            }
            continue;
          case 'change_user_nickname':
            if (!chat.isGroup && msgData.new_name) {
              const newNickname = msgData.new_name.trim();
              if (newNickname) {
                chat.settings.myNickname = newNickname;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `â€œ${chat.name}â€ å°†å¯¹ä½ çš„ç§°å‘¼ä¿®æ”¹ä¸º â€œ${newNickname}â€`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†å¯¹ç”¨æˆ·çš„ç§°å‘¼ä¿®æ”¹ä¸ºäº†â€œ${newNickname}â€ã€‚]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                }
              }
            }
            continue;
          case 'change_remark_name':
            if (!chat.isGroup && msgData.new_name) {
              const oldName = chat.name;
              const newName = msgData.new_name.trim();

              if (newName && newName !== oldName) {
                if (!chat.nameHistory) {
                  chat.nameHistory = [];
                }
                if (!chat.nameHistory.includes(oldName)) {
                  chat.nameHistory.push(oldName);
                }

                chat.name = newName;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `â€œ${chat.originalName}â€ å°†å¤‡æ³¨ä¿®æ”¹ä¸º â€œ${newName}â€`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†è‡ªå·±çš„å¤‡æ³¨åä¿®æ”¹ä¸ºäº†â€œ${newName}â€ã€‚è¯·è‡ªç„¶åœ°æ¥å—è¿™ä¸ªæ–°åå­—ï¼Œä¸è¦å¯¹æ­¤æ„Ÿåˆ°æƒŠè®¶ã€‚]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                  document.getElementById('chat-header-title').textContent = newName;
                }

                await syncCharacterNameInGroups(chat);
              }
            }
            continue;

          case 'change_avatar': {
            const avatarName = msgData.name;
            const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
            if (foundAvatar) {
              chat.settings.aiAvatar = foundAvatar.url;

              const systemNotice = {
                role: 'system',
                type: 'pat_message',
                content: `[${chat.name} æ›´æ¢äº†å¤´åƒ]`,
                timestamp: Date.now()
              };
              chat.history.push(systemNotice);

              await syncCharacterAvatarInGroups(chat);

              if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }
          case 'change_user_avatar': {
            const avatarName = msgData.name;
            const foundAvatar = chat.settings.myAvatarLibrary.find(avatar => avatar.name === avatarName);
            if (foundAvatar) {
              chat.settings.myAvatar = foundAvatar.url;

              const systemNotice = {
                role: 'system',
                type: 'pat_message',
                content: `[${chat.name} æ›´æ¢äº†ä½ çš„å¤´åƒ]`,
                timestamp: Date.now()
              };
              chat.history.push(systemNotice);

              if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }

          case 'gomoku_move': {

            const x = parseInt(msgData.x);
            const y = parseInt(msgData.y);


            if (!isNaN(x) && !isNaN(y)) {
              handleAiGomokuMove({
                x: x,
                y: y
              });
            } else {
              console.warn("AIçš„äº”å­æ£‹ç§»åŠ¨æŒ‡ä»¤åŒ…å«æ— æ•ˆåæ ‡ï¼Œå·²å¿½ç•¥:", msgData);
            }
            continue;
          }

          case 'waimai_response':
            const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
            if (requestMessageIndex > -1) {
              const originalMsg = chat.history[requestMessageIndex];
              originalMsg.status = msgData.status;
              originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
            }
            continue;

          case 'qzone_post':
            const newPost = {
              type: msgData.postType,
              content: msgData.content || '',
              publicText: msgData.publicText || '',
              hiddenContent: msgData.hiddenContent || '',
              image_prompt: msgData.image_prompt || '', 
              timestamp: Date.now(),
              authorId: chatId,
              authorGroupId: chat.groupId, 
              visibleGroupIds: null
            };


      
            if (msgData.postType === 'naiimag' && msgData.prompt) {
              try {
            
                const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
                console.log(`ğŸ“¸ åŠ¨æ€NovelAIå›¾ç‰‡ç”Ÿæˆå¼€å§‹ï¼Œå…±${prompts.length}å¼ å›¾ç‰‡`);

               
                const generatedImageUrls = [];

             
                for (let i = 0; i < prompts.length; i++) {
                  const aiPrompt = prompts[i];
                  console.log(`ç”Ÿæˆç¬¬${i+1}å¼ å›¾ç‰‡ï¼Œprompt:`, aiPrompt);

                  
                  const naiPrompts = getCharacterNAIPrompts(chat.id);

                  
                  const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                  const finalNegativePrompt = naiPrompts.negative;

                  console.log(`ğŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
                  console.log('æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
                  console.log('æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);

              
                  const apiKey = localStorage.getItem('novelai-api-key');
                  const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                  const settings = getNovelAISettings();

                  if (!apiKey) {
                    throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
                  }

                  const [width, height] = settings.resolution.split('x').map(Number);

                 
                  let requestBody;

                  if (model.includes('nai-diffusion-4')) {
                 
                    requestBody = {
                      input: finalPositivePrompt,
                      model: model,
                      action: 'generate',
                      parameters: {
                        params_version: 3, // V4å¿…é¡»ä½¿ç”¨ç‰ˆæœ¬3
                        width: width,
                        height: height,
                        scale: settings.cfg_scale,
                        sampler: settings.sampler,
                        steps: settings.steps,
                        seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                        n_samples: 1,
                        ucPreset: settings.uc_preset,
                        qualityToggle: settings.quality_toggle,
                        autoSmea: false,
                        dynamic_thresholding: false,
                        controlnet_strength: 1,
                        legacy: false,
                        add_original_image: true,
                        cfg_rescale: 0,
                        noise_schedule: 'karras', // V4ä½¿ç”¨karras
                        legacy_v3_extend: false,
                        skip_cfg_above_sigma: null,
                        use_coords: false,
                        legacy_uc: false,
                        normalize_reference_strength_multiple: true,
                        inpaintImg2ImgStrength: 1,
                        characterPrompts: [],
                      
                        v4_prompt: {
                          caption: {
                            base_caption: finalPositivePrompt,
                            char_captions: []
                          },
                          use_coords: false,
                          use_order: true
                        },
                      
                        v4_negative_prompt: {
                          caption: {
                            base_caption: finalNegativePrompt,
                            char_captions: []
                          },
                          legacy_uc: false
                        },
                        negative_prompt: finalNegativePrompt,
                        deliberate_euler_ancestral_bug: false,
                        prefer_brownian: true
                    
                      }
                    };
                  } else {
               
                    requestBody = {
                      input: finalPositivePrompt,
                      model: model,
                      action: 'generate',
                      parameters: {
                        width: width,
                        height: height,
                        scale: settings.cfg_scale,
                        sampler: settings.sampler,
                        steps: settings.steps,
                        seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                        n_samples: 1,
                        ucPreset: settings.uc_preset,
                        qualityToggle: settings.quality_toggle,
                        sm: settings.smea,
                        sm_dyn: settings.smea_dyn,
                        dynamic_thresholding: false,
                        controlnet_strength: 1,
                        legacy: false,
                        add_original_image: false,
                        cfg_rescale: 0,
                        noise_schedule: 'native',
                        negative_prompt: finalNegativePrompt
                      }
                    };
                  }

                  console.log('ğŸš€ å‘é€NAIè¯·æ±‚:', requestBody);

                
                  let apiUrl;

               
                  if (model.includes('nai-diffusion-4')) {
                
                    apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                  } else {
                
                    apiUrl = 'https://image.novelai.net/ai/generate-image';
                  }

                  let corsProxy = settings.cors_proxy;

               
                  if (corsProxy === 'custom') {
                    corsProxy = settings.custom_proxy_url || '';
                  }

              
                  if (corsProxy && corsProxy !== '') {
                    apiUrl = corsProxy + encodeURIComponent(apiUrl);
                  }

                  const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify(requestBody)
                  });

                  console.log('Response status:', response.status);
                  console.log('Response headers:', [...response.headers.entries()]);

                  if (!response.ok) {
                    const errorText = await response.text();
                    console.error('APIé”™è¯¯å“åº”:', errorText);
                    throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
                  }

                
                  const contentType = response.headers.get('content-type');
                  console.log('Content-Type:', contentType);

                 
                  let zipBlob;
                  let imageDataUrl;
                  if (contentType && contentType.includes('text/event-stream')) {
                    console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æ...');

                   
                    const text = await response.text();
                    console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);

                 
                    const lines = text.trim().split('\n');
                    let base64Data = null;

                    for (let i = lines.length - 1; i >= 0; i--) {
                      const line = lines[i].trim();
                      if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                        const dataContent = line.substring(6); 

                        
                        try {
                          const jsonData = JSON.parse(dataContent);

                        
                          if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                            break;
                          }

                        
                          if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('ä» JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                            break;
                          }
                          if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('ä» JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                            break;
                          }
                        } catch (e) {
                    
                          base64Data = dataContent;
                          console.log('ç›´æ¥ä½¿ç”¨ base64 æ•°æ®');
                          break;
                        }
                      }
                    }

                    if (!base64Data) {
                      throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
                    }

                 
                    const isPNG = base64Data.startsWith('iVBORw0KGgo');
                    const isJPEG = base64Data.startsWith('/9j/');

                    if (isPNG || isJPEG) {
                      console.log('âœ… æ£€æµ‹åˆ°ç›´æ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
                
                      const binaryString = atob(base64Data);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }
                      const imageBlob = new Blob([bytes], {
                        type: isPNG ? 'image/png' : 'image/jpeg'
                      });
                      console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);

                  
                      const reader = new FileReader();
                      imageDataUrl = await new Promise((resolve, reject) => {
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(imageBlob);
                      });
                      console.log('âœ… å›¾ç‰‡è½¬æ¢æˆåŠŸï¼ğŸ¨');
                    } else {
                    
                      console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
                      const binaryString = atob(base64Data);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }
                      zipBlob = new Blob([bytes]);
                      console.log('ZIP Blob å¤§å°:', zipBlob.size);
                    }
                  } else {
                  
                    zipBlob = await response.blob();
                    console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»å‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
                  }

              
                  if (!imageDataUrl && zipBlob) {
                 
                    try {
                   
                      if (typeof JSZip === 'undefined') {
                        throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                      }

                   
                      const zip = await JSZip.loadAsync(zipBlob);
                      console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));

                     
                      let imageFile = null;
                      for (let filename in zip.files) {
                        if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                          imageFile = zip.files[filename];
                          console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
                          break;
                        }
                      }

                      if (!imageFile) {
                        throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
                      }

                     
                      const imageBlob = await imageFile.async('blob');
                      console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);

                     
                      const reader = new FileReader();
                      imageDataUrl = await new Promise((resolve, reject) => {
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(imageBlob);
                      });
                      console.log('âœ… å›¾ç‰‡è§£å‹æˆåŠŸï¼');
                    } catch (zipError) {
                      console.error('ZIPè§£å‹å¤±è´¥:', zipError);
                      throw new Error('å›¾ç‰‡è§£å‹å¤±è´¥: ' + zipError.message);
                    }
                  }

                  console.log(`âœ… NAIå›¾ç‰‡${i+1}ç”ŸæˆæˆåŠŸï¼`);
                  generatedImageUrls.push(imageDataUrl);
                }

              
                newPost.imageUrls = generatedImageUrls;

                if (generatedImageUrls.length === 1) {
                  newPost.imageUrl = generatedImageUrls[0];
                }

                newPost.prompt = msgData.prompt;
                newPost.imageCount = generatedImageUrls.length;
                console.log(`âœ… åŠ¨æ€NovelAIå›¾ç‰‡å…¨éƒ¨ç”Ÿæˆå®Œæˆ: ${generatedImageUrls.length}å¼ `);
              } catch (error) {
                console.error('âŒ åŠ¨æ€NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
              
                newPost.content = (newPost.content || newPost.publicText || '') + `\n[å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${error.message}]`;
              }
            }

            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
              await renderQzonePosts();
            }
            continue;

          case 'qzone_comment': { 
            const postToComment = await db.qzonePosts.get(parseInt(msgData.postId)); 
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];

              const commenterName = msgData.name || chat.originalName; 
              const createCommentObject = (text, meaning = null, replyTo = null) => ({
                commenterName,
                text: processMentions(text, chat),
                meaning,
                replyTo,
                timestamp: Date.now()
              });

              if (msgData.stickerMeaning) {
                const sticker = state.userStickers.find(s => s.name === msgData.stickerMeaning);
                if (sticker) {
                  postToComment.comments.push(createCommentObject(sticker.url, sticker.name, msgData.replyTo || null)); 
                } else {
                  console.warn(`AI å°è¯•è¯„è®ºä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.stickerMeaning}"`);
                  postToComment.comments.push(createCommentObject(`[è¡¨æƒ…: ${msgData.stickerMeaning}]`, null, msgData.replyTo || null)); 
                }
              } else if (Array.isArray(msgData.comments)) {
                msgData.comments.forEach(commentText => { 
                  if (typeof commentText === 'string' && commentText.trim()) {
                    postToComment.comments.push(createCommentObject(commentText, null, msgData.replyTo || null)); 
                  }
                });
              } else if (typeof msgData.commentText === 'string' && msgData.commentText.trim()) {
                postToComment.comments.push(createCommentObject(msgData.commentText, null, msgData.replyTo || null)); 
              }

              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" è¯„è®ºäº†åŠ¨æ€ #${msgData.postId}`); 

              if (!chat.commentCooldowns) chat.commentCooldowns = {};
              chat.commentCooldowns[msgData.postId] = Date.now();
            }
            continue;
          }
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(chat.name)) {
                postToLike.likes.push(chat.name);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                  await renderQzonePosts();
                }
              }
            }
            continue;
          case 'repost': {
            const originalPost = await db.qzonePosts.get(parseInt(msgData.postId));
            if (originalPost) {
              const newPost = {
                type: 'repost',
                timestamp: Date.now(),
                authorId: chatId,
                authorGroupId: chat.groupId,
                repostComment: msgData.comment || '',
                originalPost: originalPost,
                visibleGroupIds: null
              };
              await db.qzonePosts.add(newPost);
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" è½¬å‘äº†åŠ¨æ€ #${msgData.postId}`);
            }
            continue;
          }
          case 'video_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              state.activeChatId = chatId;
              videoCallState.activeChatId = chatId;
              videoCallState.isAwaitingResponse = true;
              videoCallState.isGroupCall = chat.isGroup;
              videoCallState.callRequester = msgData.name || chat.name;
              showIncomingCallModal();
            }
            continue;
          case 'group_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              state.activeChatId = chatId;
              videoCallState.isAwaitingResponse = true;
              videoCallState.isGroupCall = true;
              videoCallState.initiator = 'ai';
              videoCallState.callRequester = msgData.name;
              showIncomingCallModal();
            }
            continue;
          case 'pat_user':
            let patterName;
            if (chat.isGroup) {
              const member = chat.members.find(m => m.originalName === msgData.name);
              patterName = member ? member.groupNickname : msgData.name;
            } else {
              patterName = chat.name;
            }
            const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
            const patText = `${patterName} æ‹äº†æ‹æˆ‘${suffix}`;

            const patMessage = {
              role: 'system',
              type: 'pat_message',
              content: patText,
              timestamp: Date.now()
            };
            chat.history.push(patMessage);
            if (isViewingThisChat) {
              const phoneScreen = document.getElementById('phone-screen');
              phoneScreen.classList.remove('pat-animation');
              void phoneScreen.offsetWidth;
              phoneScreen.classList.add('pat-animation');
              setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
              appendMessage(patMessage, chat);
            } else {
              showNotification(chatId, patText);
            }
            continue;
          case 'update_status':
            chat.status.text = msgData.status_text;
            chat.status.isBusy = msgData.is_busy || false;
            chat.status.lastUpdate = Date.now();
            const statusUpdateMessage = {
              role: 'system',
              type: 'pat_message',
              content: `[${chat.name}çš„çŠ¶æ€å·²æ›´æ–°ä¸º: ${msgData.status_text}]`,
              timestamp: Date.now()
            };
            chat.history.push(statusUpdateMessage);
            if (isViewingThisChat) {
              appendMessage(statusUpdateMessage, chat);
            }
            renderChatList();
            continue;
          case 'location_share':
            aiMessage = {
              ...baseMessage,
              type: 'location_share',
              content: msgData.content
            };
            break;
          case 'change_music':
            if (musicState.isActive && musicState.activeChatId === chatId) {
              const songNameFromAI = msgData.song_name || msgData.song || msgData.name;

              if (typeof songNameFromAI === 'string' && songNameFromAI.trim()) {
                const songNameToFind = songNameFromAI.replace(/^\[?\d+\]?[\s.-]*/, '').trim();
                const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase());

                if (targetSongIndex > -1) {
                  playSong(targetSongIndex);
                  const track = musicState.playlist[targetSongIndex];

                  let changerName;
                  if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msgData.name);
                    changerName = member ? member.groupNickname : msgData.name;
                  } else {
                    changerName = chat.name;
                  }

                  const musicChangeMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `[â™ª ${changerName} ä¸ºä½ åˆ‡æ­Œ: ã€Š${track.name}ã€‹ - ${track.artist}]`,
                    timestamp: Date.now()
                  };
                  chat.history.push(musicChangeMessage);
                  if (isViewingThisChat) {
                    appendMessage(musicChangeMessage, chat);
                  }
                } else {
                  console.warn(`æ­Œæ›²æŸ¥æ‰¾å¤±è´¥: AIè¯·æ±‚çš„æ­Œæ›²å"${songNameFromAI}"(å¤„ç†åä¸º"${songNameToFind}") åœ¨æ’­æ”¾åˆ—è¡¨ä¸­æœªæ‰¾åˆ°ã€‚`);
                }
              } else {
                console.error("AIè¿”å›çš„change_musicæŒ‡ä»¤ä¸­ï¼Œæ­Œæ›²åæ— æ•ˆæˆ–ç¼ºå¤±:", msgData);
              }
            }
            continue;
          case 'create_memory':
            const newMemory = {
              chatId: chatId,
              authorId: chatId,
              description: msgData.description,
              timestamp: Date.now(),
              type: 'ai_generated'
            };
            await db.memories.add(newMemory);
            console.log(`AI "${chat.name}" è®°å½•äº†ä¸€æ¡æ–°å›å¿†:`, msgData.description);
            continue;
          case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
              const newCountdown = {
                chatId: chatId,
                authorId: chatId,
                description: msgData.title,
                timestamp: Date.now(),
                type: 'countdown',
                targetDate: targetDate.getTime()
              };
              await db.memories.add(newCountdown);
              console.log(`AI "${chat.name}" åˆ›å»ºäº†ä¸€ä¸ªæ–°çº¦å®š:`, msgData.title);
            }
            continue;
          case 'block_user':
            if (!chat.isGroup) {
              chat.relationship.status = 'blocked_by_ai';
              const hiddenMessage = {
                role: 'system',
                content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšä¸»åŠ¨æ‹‰é»‘äº†ç”¨æˆ·ã€‚]`,
                timestamp: Date.now(),
                isHidden: true
              };
              chat.history.push(hiddenMessage);
              await db.chats.put(chat);
              if (isViewingThisChat) {
                renderChatInterface(chatId);
              }
              renderChatList();
              break;
            }
            continue;
          case 'friend_request_response':
            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
              if (msgData.decision === 'accept') {
                chat.relationship.status = 'friend';
                aiMessage = {
                  ...baseMessage,
                  content: "æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹ç”³è¯·ï¼Œæˆ‘ä»¬ç°åœ¨æ˜¯å¥½å‹å•¦ï¼"
                };
              } else {
                chat.relationship.status = 'blocked_by_ai';
                aiMessage = {
                  ...baseMessage,
                  content: "æŠ±æ­‰ï¼Œæˆ‘æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚"
                };
              }
              chat.relationship.applicationReason = '';
            }
            break;
          case 'poll':
            const pollOptions = typeof msgData.options === 'string' ?
              msgData.options.split('\n').filter(opt => opt.trim()) :
              (Array.isArray(msgData.options) ? msgData.options : []);
            if (pollOptions.length < 2) continue;
            aiMessage = {
              ...baseMessage,
              type: 'poll',
              question: msgData.question,
              options: pollOptions,
              votes: {},
              isClosed: false,
            };
            break;
          case 'gift': {
            const {
              itemName,
              itemPrice,
              image_prompt
            } = msgData;

            if (itemName && !isNaN(parseFloat(itemPrice)) && image_prompt) {

              const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(image_prompt)}`;

              aiMessage = {
                ...baseMessage,
                type: 'gift',
                items: [{
                  name: itemName,
                  price: parseFloat(itemPrice),
                  imageUrl: imageUrl,
                  quantity: 1
                }],
                total: parseFloat(itemPrice),
                recipients: msgData.recipients || null
              };
            } else {
              console.warn(`AI å°è¯•èµ é€ä¸€ä¸ªæ ¼å¼ä¸æ­£ç¡®çš„éšæœºç¤¼ç‰©:`, msgData);
            }
            break;
          }
          case 'vote':
            const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
            if (pollToVote && !pollToVote.isClosed) {
              Object.keys(pollToVote.votes).forEach(option => {
                const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                if (voterIndex > -1) {
                  pollToVote.votes[option].splice(voterIndex, 1);
                }
              });
              if (!pollToVote.votes[msgData.choice]) {
                pollToVote.votes[msgData.choice] = [];
              }
              if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                pollToVote.votes[msgData.choice].push(msgData.name);
              }
              if (isViewingThisChat) {
                renderChatInterface(chatId);
              }
            }
            continue;
          case 'red_packet':
            aiMessage = {
              ...baseMessage,
              ...msgData,
              totalAmount: msgData.amount,
              claimedBy: {},
              isFullyClaimed: false
            };

          
            if (aiMessage.packetType === 'lucky') {
                const allocatedAmounts = generateRandomPacketAmounts(aiMessage.amount, aiMessage.count);
                aiMessage.allocatedAmounts = allocatedAmounts;
                aiMessage.unclaimedAmounts = [...allocatedAmounts];
            }
           

            if (msgData.receiver) {
              aiMessage.receiverName = msgData.receiver;
              delete aiMessage.receiver;
            }
            break;
          case 'open_red_packet':
            const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);

            const claimerOriginalName = msgData.name;
            const isMember = chat.members.some(member => member.originalName === claimerOriginalName);


            if (!isMember) {
              console.warn(`AI è§’è‰² "${claimerOriginalName}" å°è¯•é¢†å–ä¸å±äºè‡ªå·±çš„ç¾¤èŠçº¢åŒ…ã€‚æ“ä½œå·²è¢«æ‹¦æˆªã€‚`);
              continue;
            }

            if (packetToOpen && packetToOpen.packetType === 'direct') {
              if (packetToOpen.receiverName !== msgData.name) {
                console.warn(`AI è§’è‰² "${msgData.name}" å°è¯•é¢†å–ä¸å±äºè‡ªå·±çš„ä¸“å±çº¢åŒ… (æ¥æ”¶äºº: ${packetToOpen.receiverName})ã€‚æ“ä½œå·²è¢«æ‹¦æˆªã€‚`);
                continue;
              }
            }

            if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
              let claimedAmountAI = 0;
              const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
              const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
              if (remainingCount > 0) {
              if (packetToOpen.packetType === 'direct') {
                claimedAmountAI = packetToOpen.totalAmount;
              } 
            
              else if (packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length > 0) {
                
                claimedAmountAI = packetToOpen.unclaimedAmounts.pop();
              } 
             
              else { 
                console.warn("æ£€æµ‹åˆ°æ—§ç‰ˆçº¢åŒ…ï¼Œå›é€€åˆ°æ—§çš„ï¼ˆä¸å…¬å¹³ï¼‰éšæœºç®—æ³• (triggerAiResponse)");
                const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                if (remainingCount === 1) {
                  claimedAmountAI = remainingAmount;
                } else {
                  const min = 0.01;
                  const max = remainingAmount - (remainingCount - 1) * min;
                  claimedAmountAI = Math.random() * (max - min) + min;
                }
              }

                claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                packetToOpen.claimedBy[msgData.name] = claimedAmountAI;


                const claimerMember = chat.members.find(m => m.originalName === msgData.name);
                const claimerDisplayName = claimerMember ? claimerMember.groupNickname : msgData.name;


                const senderDisplayName = getDisplayNameInGroup(chat, packetToOpen.senderName);

                const aiClaimedMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `${claimerDisplayName} é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(aiClaimedMessage);

                let hiddenContentForAI = `[ç³»ç»Ÿæç¤ºï¼šä½  (${claimerDisplayName}) æˆåŠŸæŠ¢åˆ°äº† ${claimedAmountAI.toFixed(2)} å…ƒã€‚`;
                if ((packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length === 0) || (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count)) {
                  packetToOpen.isFullyClaimed = true;
                  const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
                    timestamp: messageTimestamp++
                  };
                  chat.history.push(finishedMessage);
                  let luckyKing = {
                    name: '',
                    amount: -1
                  };
                  if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                      if (amount > luckyKing.amount) {
                        luckyKing = {
                          name,
                          amount
                        };
                      }
                    });
                  }
                  if (luckyKing.name) {
                    const luckyKingMember = chat.members.find(m => m.originalName === luckyKing.name);
                    const luckyKingDisplayName = luckyKingMember ? luckyKingMember.groupNickname : luckyKing.name;
                    hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”ç‹æ˜¯ ${luckyKingDisplayName}ï¼`;
                  } else {
                    hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œã€‚`;
                  }
                }
                hiddenContentForAI += ' è¯·æ ¹æ®è¿™ä¸ªç»“æœå‘è¡¨ä½ çš„è¯„è®ºã€‚]';
                const hiddenMessageForAI = {
                  role: 'system',
                  content: hiddenContentForAI,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMessageForAI);
              }
              if (isViewingThisChat) {
                renderChatInterface(chatId);
                renderChatList();
              }
            }
            continue;

          case 'accept_transfer': {
            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
            if (originalTransferMsgIndex > -1) {
              const originalMsg = chat.history[originalTransferMsgIndex];
              
              // é˜²æ­¢é‡å¤æ¥æ”¶
              if (originalMsg.status && originalMsg.status !== 'pending') continue;

              originalMsg.status = 'accepted';
              
              // â˜…â˜…â˜… æ–°å¢ï¼šæ„é€  AI çš„â€œå·²æ”¶æ¬¾â€æ¶ˆæ¯ â˜…â˜…â˜…
              aiMessage = {
                  role: 'assistant',
                  senderName: msgData.name || chat.name,
                  type: 'transfer',
                  isReceived: true,  // æ ‡è®°ä¸ºæ”¶æ¬¾
                  amount: originalMsg.amount,
                  note: 'å·²æ”¶æ¬¾',
                  timestamp: messageTimestamp++
              };
              // å»æ‰ continueï¼Œè®©å®ƒæµè½¬åˆ°ä¸‹æ–¹çš„ç»Ÿä¸€æ¨é€é€»è¾‘(if aiMessage...)
              break; 
            }
            continue;
          }

case 'decline_transfer': {
  const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
  if (originalTransferMsgIndex > -1) {
    const originalMsg = chat.history[originalTransferMsgIndex];

    // --- ä¿®å¤ï¼šå¦‚æœå·²ç»å¤„ç†è¿‡ï¼Œç›´æ¥å¿½ç•¥ ---
    if (originalMsg.status && originalMsg.status !== 'pending') {
        console.warn(`AIè¯•å›¾é‡å¤æ‹’æ”¶ä¸€ç¬”å·²å¤„ç†çš„è½¬è´¦ (çŠ¶æ€: ${originalMsg.status})ï¼Œå·²æ‹¦æˆªã€‚`);
        continue; 
    }

    originalMsg.status = 'declined';
              await processTransaction(originalMsg.amount, 'income', `è½¬è´¦é€€æ¬¾-${chat.name}`);
              const refundMessage = {
                role: 'assistant',
      senderName: chat.name,
      type: 'transfer',
      isRefund: true, // ç¡®ä¿æ ‡è®°ä¸ºé€€æ¬¾
      amount: originalMsg.amount,
      note: 'è½¬è´¦å·²è¢«æ‹’æ”¶',
      receiverName: 'æˆ‘', // æ˜ç¡®æ¥æ”¶äºº
      timestamp: messageTimestamp++
              };
              chat.history.push(refundMessage);
              if (isViewingThisChat) {
                appendMessage(refundMessage, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }
          case 'change_group_name':
            if (chat.isGroup && msgData.new_name) {
              const newName = msgData.new_name.trim();
              const memberNames = chat.members.map(m => m.originalName);

              if (memberNames.includes(newName)) {
                console.warn(`AI (${msgData.name}) è¯•å›¾å°†ç¾¤åæ›´æ”¹ä¸ºæˆå‘˜å ("${newName}")ã€‚æ“ä½œå·²è¢«ç¨‹åºé˜»æ­¢ã€‚`);
                continue;
              }

              chat.name = newName;

              const changerMember = chat.members.find(m => m.originalName === msgData.name);
              const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;

              const systemMessage = {
                role: 'system',
                type: 'pat_message',
                content: `${changerDisplayName} å°†ç¾¤åä¿®æ”¹ä¸º â€œ${chat.name}â€`,
                timestamp: messageTimestamp++
              };
              chat.history.push(systemMessage);

              if (isViewingThisChat) {
                appendMessage(systemMessage, chat);
                document.getElementById('chat-header-title').textContent = chat.name;
              }
            }
            continue;
          case 'change_remark_name':
            if (!chat.isGroup && msgData.new_name) {
              const oldName = chat.name;
              const newName = msgData.new_name.trim();

              if (newName && newName !== oldName) {
                if (!chat.nameHistory) {
                  chat.nameHistory = [];
                }
                if (!chat.nameHistory.includes(oldName)) {
                  chat.nameHistory.push(oldName);
                }

                chat.name = newName;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `â€œ${chat.originalName}â€ å°†å¤‡æ³¨ä¿®æ”¹ä¸º â€œ${newName}â€`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšæˆåŠŸå°†è‡ªå·±çš„å¤‡æ³¨åä¿®æ”¹ä¸ºäº†â€œ${newName}â€ã€‚è¯·è‡ªç„¶åœ°æ¥å—è¿™ä¸ªæ–°åå­—ï¼Œä¸è¦å¯¹æ­¤æ„Ÿåˆ°æƒŠè®¶ã€‚]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                  document.getElementById('chat-header-title').textContent = newName;
                }

                await syncCharacterNameInGroups(chat);
              }
            }
            continue;

          case 'change_group_avatar':
            if (chat.isGroup && msgData.avatar_name) {
              const avatarName = msgData.avatar_name;
              const library = chat.settings.groupAvatarLibrary || [];
              const foundAvatar = library.find(avatar => avatar.name === avatarName);

              if (foundAvatar) {
                chat.settings.groupAvatar = foundAvatar.url;

                const changerMember = chat.members.find(m => m.originalName === msgData.name);
                const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `${changerDisplayName} æ›´æ¢äº†ç¾¤å¤´åƒ`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                }
              } else {
                console.warn(`AI å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„ç¾¤å¤´åƒ: "${avatarName}"`);
              }
            }
            continue;
          case 'system_message':
            aiMessage = {
              role: 'system',
              type: 'pat_message',
              content: msgData.content,
              timestamp: Date.now()
            };
            break;
          case 'share_link':
            aiMessage = {
              ...baseMessage,
              type: 'share_link',
              title: msgData.title,
              description: msgData.description,
              source_name: msgData.source_name,
              content: msgData.content
            };
            break;
          case 'quote_reply': {
            let originalMessage = null;
            
          
            if (msgData.target_content) {
              originalMessage = [...chat.history].reverse().find(m => 
                !m.isHidden &&
                ( 
                  m.content === msgData.target_content ||
                  (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                )
              );
              
              if(!originalMessage) {
                 console.warn(`[æœ¬è½®å¼•ç”¨å¤±è´¥] AI ${msgData.name} å°è¯•å¼•ç”¨å†…å®¹ "${(msgData.target_content || '').substring(0, 20)}..."ï¼Œä½†åœ¨æœ¬è½®å†å²ä¸­æœªæ‰¾åˆ°ã€‚`);
              }
            } 
            
           
            else if (msgData.target_timestamp) { 
              originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            }

            
            if (originalMessage) {
              
            
              let quotedSenderDisplayName;
              
              if (originalMessage.role === 'user') {
                
                  quotedSenderDisplayName = chat.settings.myNickname || 'æˆ‘';
              } else { 
                 
                  if (chat.isGroup) {
                    
                      quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                  } else {
                     
                      quotedSenderDisplayName = chat.name;
                  }
              }
              
              const quoteContext = {
                  timestamp: originalMessage.timestamp,
                  senderName: quotedSenderDisplayName, 
                  
                  content: String(originalMessage.content || '').substring(0, 50) 
              };
             
              
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: quoteContext
              };
            } else {
              
              console.warn(`å¼•ç”¨å›å¤å¤±è´¥: æ‰¾ä¸åˆ°ç›®æ ‡æ¶ˆæ¯ (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content 
              };
            }
            break;
          } 
          case 'send_and_recall': {
            if (!isViewingThisChat) continue;
            const tempMessageData = {
              ...baseMessage,
              content: msgData.content
            };
            const tempMessageElement = createMessageElement(tempMessageData, chat);
            appendMessage(tempMessageData, chat, true);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 500));
            const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
            if (bubbleWrapper) {
              bubbleWrapper.classList.add('recalled-animation');
              await new Promise(resolve => setTimeout(resolve, 300));
              const recalledMessage = {
                role: 'assistant',
                senderName: msgData.name || chat.name,
                type: 'recalled_message',
                content: 'å¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯',
                timestamp: tempMessageData.timestamp,
                recalledData: {
                  originalType: 'text',
                  originalContent: msgData.content
                }
              };
              const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
              if (msgIndex > -1) {
                chat.history[msgIndex] = recalledMessage;
              } else {
                chat.history.push(recalledMessage);
              }
              const placeholder = await createMessageElement(recalledMessage, chat);
              if (document.body.contains(bubbleWrapper)) {
                bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
              }
            }
            continue;
          }

          case 'text':
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content || msgData.message)
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
        
                console.warn(`AI å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
          
              console.warn("AI å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: msgData.url,
                meaning: 'æœªçŸ¥è¡¨æƒ…'
              };
            }
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: msgData.description,
              image_prompt: msgData.image_prompt
            };
            break;
          case 'voice_message':
            aiMessage = {
              ...baseMessage,
              type: 'voice_message',
              content: msgData.content
            };
            break;
          case 'transfer':
            aiMessage = {
              ...baseMessage,
              type: 'transfer',
              amount: msgData.amount,
              note: msgData.note,
              receiverName: msgData.receiver || 'æˆ‘'
            };
            break;

          case 'waimai_request':
            aiMessage = {
              ...baseMessage,
              type: 'waimai_request',
              productInfo: msgData.productInfo,
              amount: msgData.amount,
              status: 'pending',
              countdownEndTime: Date.now() + 15 * 60 * 1000,
            };
            break;
          case 'waimai_order':
            aiMessage = {
              ...baseMessage,
              type: 'waimai_order',
              productInfo: msgData.productInfo,
              amount: msgData.amount,
              greeting: msgData.greeting,
              recipientName: msgData.recipientName || null
            };
            break;
          case 'offline_text':
            aiMessage = {
              ...baseMessage,
              ...msgData
            };
            break;

          case 'naiimag':
          
            try {
              console.log('ğŸ“¸ NovelAIå›¾ç‰‡ç”Ÿæˆå¼€å§‹ï¼ŒAIæä¾›çš„prompt:', msgData.prompt);

          
              const naiPrompts = getCharacterNAIPrompts(chat.id);

         
              const aiPrompt = msgData.prompt || 'a beautiful scene';
              const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
              const finalNegativePrompt = naiPrompts.negative;

              console.log(`ğŸ“ ä½¿ç”¨${naiPrompts.source === 'character' ? 'è§’è‰²ä¸“å±' : 'ç³»ç»Ÿ'}æç¤ºè¯é…ç½®`);
              console.log('æœ€ç»ˆæ­£é¢æç¤ºè¯:', finalPositivePrompt);
              console.log('æœ€ç»ˆè´Ÿé¢æç¤ºè¯:', finalNegativePrompt);

            
              const apiKey = localStorage.getItem('novelai-api-key');
              const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
              const settings = getNovelAISettings();

              if (!apiKey) {
                throw new Error('NovelAI API Keyæœªé…ç½®ã€‚è¯·åœ¨NovelAIè®¾ç½®ä¸­å¡«å†™API Keyã€‚');
              }

              const [width, height] = settings.resolution.split('x').map(Number);

             
              let requestBody;

              if (model.includes('nai-diffusion-4')) {
             
                requestBody = {
                  input: finalPositivePrompt,
                  model: model,
                  action: 'generate',
                  parameters: {
                    params_version: 3, 
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras', 
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                
                    v4_prompt: {
                      caption: {
                        base_caption: finalPositivePrompt,
                        char_captions: []
                      },
                      use_coords: false,
                      use_order: true
                    },
                  
                    v4_negative_prompt: {
                      caption: {
                        base_caption: finalNegativePrompt,
                        char_captions: []
                      },
                      legacy_uc: false
                    },
                    negative_prompt: finalNegativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                
                  }
                };
              } else {
            
                requestBody = {
                  input: finalPositivePrompt,
                  model: model,
                  action: 'generate',
                  parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: finalNegativePrompt
                  }
                };
              }

              console.log('ğŸš€ å‘é€NAIè¯·æ±‚:', requestBody);

             
              let apiUrl;

             
              if (model.includes('nai-diffusion-4')) {
              
                apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
              } else {
              
                apiUrl = 'https://image.novelai.net/ai/generate-image';
              }

              let corsProxy = settings.cors_proxy;

             
              if (corsProxy === 'custom') {
                corsProxy = settings.custom_proxy_url || '';
              }

          
              if (corsProxy && corsProxy !== '') {
                apiUrl = corsProxy + encodeURIComponent(apiUrl);
              }

              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify(requestBody)
              });

              console.log('Response status:', response.status);
              console.log('Response headers:', [...response.headers.entries()]);

              if (!response.ok) {
                const errorText = await response.text();
                console.error('APIé”™è¯¯å“åº”:', errorText);
                throw new Error(`APIè¯·æ±‚å¤±è´¥ (${response.status}): ${errorText}`);
              }

           
              const contentType = response.headers.get('content-type');
              console.log('Content-Type:', contentType);

            
              let zipBlob;
              let imageDataUrl;
              if (contentType && contentType.includes('text/event-stream')) {
                console.log('æ£€æµ‹åˆ° SSE æµå¼å“åº”ï¼Œå¼€å§‹è§£æ...');

            
                const text = await response.text();
                console.log('æ”¶åˆ° SSE æ•°æ®ï¼Œå¤§å°:', text.length);

             
                const lines = text.trim().split('\n');
                let base64Data = null;

                for (let i = lines.length - 1; i >= 0; i--) {
                  const line = lines[i].trim();
                  if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); 

              
                    try {
                      const jsonData = JSON.parse(dataContent);

                   
                      if (jsonData.event_type === 'final' && jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('âœ… æ‰¾åˆ° final äº‹ä»¶çš„å›¾ç‰‡æ•°æ®');
                        break;
                      }

                   
                      if (jsonData.data) {
                        base64Data = jsonData.data;
                        console.log('ä» JSON.data ä¸­æå–å›¾ç‰‡æ•°æ®');
                        break;
                      }
                      if (jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('ä» JSON.image ä¸­æå–å›¾ç‰‡æ•°æ®');
                        break;
                      }
                    } catch (e) {
                  
                      base64Data = dataContent;
                      console.log('ç›´æ¥ä½¿ç”¨ base64 æ•°æ®');
                      break;
                    }
                  }
                }

                if (!base64Data) {
                  throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®');
                }

              
                const isPNG = base64Data.startsWith('iVBORw0KGgo');
                const isJPEG = base64Data.startsWith('/9j/');

                if (isPNG || isJPEG) {
                  console.log('âœ… æ£€æµ‹åˆ°ç›´æ¥çš„å›¾ç‰‡ base64 æ•°æ® (PNG/JPEG)');
               
                  const binaryString = atob(base64Data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  const imageBlob = new Blob([bytes], {
                    type: isPNG ? 'image/png' : 'image/jpeg'
                  });
                  console.log('å›¾ç‰‡ Blob åˆ›å»ºæˆåŠŸï¼Œå¤§å°:', imageBlob.size);

              
                  const reader = new FileReader();
                  imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                  });
                  console.log('âœ… å›¾ç‰‡è½¬æ¢æˆåŠŸï¼ğŸ¨');
                } else {
                 
                  console.log('å½“ä½œ ZIP æ–‡ä»¶å¤„ç†...');
                  const binaryString = atob(base64Data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  zipBlob = new Blob([bytes]);
                  console.log('ZIP Blob å¤§å°:', zipBlob.size);
                }
              } else {
             
                zipBlob = await response.blob();
                console.log('æ”¶åˆ°æ•°æ®ï¼Œç±»å‹:', zipBlob.type, 'å¤§å°:', zipBlob.size);
              }

             
              if (!imageDataUrl && zipBlob) {
             
                try {
               
                  if (typeof JSZip === 'undefined') {
                    throw new Error('JSZipåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                  }

                  
                  const zip = await JSZip.loadAsync(zipBlob);
                  console.log('ZIPæ–‡ä»¶å†…å®¹:', Object.keys(zip.files));

                 
                  let imageFile = null;
                  for (let filename in zip.files) {
                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                      imageFile = zip.files[filename];
                      console.log('æ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶:', filename);
                      break;
                    }
                  }

                  if (!imageFile) {
                    throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
                  }

               
                  const imageBlob = await imageFile.async('blob');
                  console.log('æå–çš„å›¾ç‰‡å¤§å°:', imageBlob.size);

                 
                  const reader = new FileReader();
                  imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                  });
                  console.log('âœ… å›¾ç‰‡è§£å‹æˆåŠŸï¼');
                } catch (zipError) {
                  console.error('ZIPè§£å‹å¤±è´¥:', zipError);
                  throw new Error('å›¾ç‰‡è§£å‹å¤±è´¥: ' + zipError.message);
                }
              }

              console.log('âœ… NAIå›¾ç‰‡ç”ŸæˆæˆåŠŸï¼');

            
              aiMessage = {
                ...baseMessage,
                type: 'naiimag',
                imageUrl: imageDataUrl,
                prompt: aiPrompt,
                fullPrompt: finalPositivePrompt // ä¿å­˜å®Œæ•´æç¤ºè¯ä¾›æŸ¥çœ‹
              };
            } catch (error) {
              console.error('âŒ NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
            
              aiMessage = {
                ...baseMessage,
                content: `[å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${error.message}]`
              };
            }
            break;

          default:
            console.warn("æ”¶åˆ°äº†æœªçŸ¥çš„AIæŒ‡ä»¤ç±»å‹:", msgData.type);
            break;
        }

        if (aiMessage) {
          chat.history.push(aiMessage);
          if (!isViewingThisChat) {
            chat.unreadCount = (chat.unreadCount || 0) + 1;
          }
          if (!isViewingThisChat && !notificationShown) {
            let notificationText;
            switch (aiMessage.type) {
              case 'transfer':
                notificationText = `[æ”¶åˆ°ä¸€ç¬”è½¬è´¦]`;
                break;
              case 'waimai_request':
                notificationText = `[æ”¶åˆ°ä¸€ä¸ªå¤–å–ä»£ä»˜è¯·æ±‚]`;
                break;
              case 'ai_image':
                notificationText = `[å›¾ç‰‡]`;
                break;
              case 'voice_message':
                notificationText = `[è¯­éŸ³]`;
                break;
              case 'sticker':
                notificationText = aiMessage.meaning ? `[è¡¨æƒ…: ${aiMessage.meaning}]` : '[è¡¨æƒ…]';
                break;
              case 'offline_text':
                notificationText = aiMessage.dialogue ? `ã€Œ${aiMessage.dialogue}ã€` : `[${aiMessage.description.substring(0, 20)}...]`;
                break;
              default:
                notificationText = String(aiMessage.content || '');
            }
            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
            showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
            notificationShown = true;
          } else if (isViewingThisChat && !notificationShown) {
            // æ–°å¢ï¼šå¦‚æœåœ¨èŠå¤©é¡µé¢ä¸”å¯ç”¨äº†"åœ¨èŠå¤©é¡µé¢ä¹Ÿå‘é€é€šçŸ¥"ï¼Œåˆ™å‘é€ç³»ç»Ÿçº§é€šçŸ¥
            let notificationText;
            switch (aiMessage.type) {
              case 'transfer':
                notificationText = `[æ”¶åˆ°ä¸€ç¬”è½¬è´¦]`;
                break;
              case 'waimai_request':
                notificationText = `[æ”¶åˆ°ä¸€ä¸ªå¤–å–ä»£ä»˜è¯·æ±‚]`;
                break;
              case 'ai_image':
                notificationText = `[å›¾ç‰‡]`;
                break;
              case 'voice_message':
                notificationText = `[è¯­éŸ³]`;
                break;
              case 'sticker':
                notificationText = aiMessage.meaning ? `[è¡¨æƒ…: ${aiMessage.meaning}]` : '[è¡¨æƒ…]';
                break;
              case 'offline_text':
                notificationText = aiMessage.dialogue ? `ã€Œ${aiMessage.dialogue}ã€` : `[${aiMessage.description.substring(0, 20)}...]`;
                break;
              default:
                notificationText = String(aiMessage.content || '');
            }
            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
            triggerSystemNotificationInChatPage(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
            notificationShown = true;
          }



          if (isViewingThisChat) {
            appendMessage(aiMessage, chat);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
          }
        }
      }

      if (callHasBeenHandled && videoCallState.isGroupCall) {
        videoCallState.isAwaitingResponse = false;
        if (videoCallState.participants.length > 0) {
          startVideoCall();
        } else {
          videoCallState = {
            ...videoCallState,
            isAwaitingResponse: false,
            participants: []
          };
          showScreen('chat-interface-screen');
          alert('æ— äººæ¥å¬ç¾¤èŠé‚€è¯·ã€‚');
        }
      }
      if (needsImmediateReaction) {
        await triggerAiResponse();
        return;
      }
      await db.chats.put(chat);

      const qzoneActionTaken = messagesArray.some(action =>
        action.type === 'qzone_post' ||
        action.type === 'qzone_like' ||
        action.type === 'qzone_comment' ||
        action.type === 'repost'
      );


      if (qzoneActionTaken) {
        console.log("æ£€æµ‹åˆ°AIæ‰§è¡Œäº†åŠ¨æ€æ“ä½œï¼Œç«‹å³åˆ·æ–°å¥½å‹åŠ¨æ€é¡µé¢ã€‚");

        await renderQzonePosts();
      }


    } catch (error) {

      chat.history = chat.history.filter(msg => !msg.isTemporary);

      if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        chat.relationship.status = 'blocked_by_ai';
        await showCustomAlert('ç”³è¯·å¤±è´¥', `AIåœ¨å¤„ç†ä½ çš„å¥½å‹ç”³è¯·æ—¶å‡ºé”™äº†ï¼Œè¯·ç¨åé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
      } else {
        await showCustomAlert(
          'API è°ƒç”¨å¤±è´¥',
          `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯ï¼ŒAIæœªèƒ½æˆåŠŸå“åº”ã€‚\n\né”™è¯¯è¯¦æƒ…:\n${error.message}`
        );
      }

      if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        await db.chats.put(chat);
      }

      videoCallState.isAwaitingResponse = false;
    } finally {
      setAvatarActingState(chatId, false);


      if (chat.isGroup) {
        if (typingIndicator) {
          typingIndicator.style.display = 'none';
        }
      } else {
        if (chatHeaderTitle && state.chats[chatId]) {
          chatHeaderTitle.style.opacity = 0;
          setTimeout(() => {
            chatHeaderTitle.textContent = state.chats[chatId].name;
            chatHeaderTitle.classList.remove('typing-status');
            chatHeaderTitle.style.opacity = 1;
          }, 200);
        }
      }
      renderChatList();
      if (isViewingThisChat) {
        checkAndTriggerAutoSummary(chatId);

      }
      stopSilentAudio();
    }
  }








  async function sendSticker(sticker) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msg = {
      role: 'user',
      content: sticker.url,
      meaning: sticker.name,
      timestamp: Date.now()
    };
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
    document.getElementById('sticker-panel').classList.remove('visible');
  }

// --- ä¿®å¤ç‰ˆV2ï¼šè½¬è´¦ (ä¿®å¤IDè§£æbugï¼Œç¡®ä¿æ‰£æ¬¾å’Œè®°è´¦) ---
async function sendUserTransfer() {
    if (!state.activeChatId) return;
    const amountInput = document.getElementById('transfer-amount');
    const noteInput = document.getElementById('transfer-note');
    const amount = parseFloat(amountInput.value);
    const note = noteInput.value.trim();

    if (isNaN(amount) || amount <= 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert('æç¤º', 'è¯·è¾“å…¥æœ‰æ•ˆçš„è½¬è´¦é‡‘é¢(å¿…é¡»å¤§äº0)ï¼');
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const senderName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
    const receiverName = chat.isGroup ? 'ç¾¤èŠ' : chat.name;

    // 1. è·å–é’±åŒ…æ•°æ®
    const wallet = await db.userWallet.get('main') || { balance: 0, kinshipCards: [] };
    const balance = wallet.balance || 0;
    const kinshipCards = wallet.kinshipCards || [];

    // 2. æ„å»ºæ”¯ä»˜é€‰é¡¹ UI
    const paymentOptions = [];
    const iconWallet = `<div class="pay-opt-icon" style="background:#1677ff; display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">æ”¯</div>`;
    const iconKinship = `<div class="pay-opt-icon" style="background:linear-gradient(135deg, #ff5252, #ff1744); display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">äº²</div>`;

    // é€‰é¡¹ï¼šä½™é¢
    if (balance >= amount) {
        paymentOptions.push({ 
            text: `<div class="pay-opt-left">${iconWallet}<div class="pay-opt-info"><span class="pay-opt-title">è´¦æˆ·ä½™é¢</span><span class="pay-opt-desc">å‰©ä½™ Â¥${balance.toFixed(2)}</span></div></div>`, 
            value: 'balance' 
        });
    }

    // é€‰é¡¹ï¼šäº²å±å¡
    for (const card of kinshipCards) {
        const remaining = card.limit - (card.spent || 0);
        if (remaining >= amount) {
            const providerChat = state.chats[card.chatId];
            const providerName = providerChat ? providerChat.name : 'æœªçŸ¥è§’è‰²';
            paymentOptions.push({
                text: `<div class="pay-opt-left">${iconKinship}<div class="pay-opt-info"><span class="pay-opt-title">äº²å±å¡ - ${providerName}</span><span class="pay-opt-desc">å‰©ä½™é¢åº¦ Â¥${remaining.toFixed(2)}</span></div></div>`,
                value: `kinship_${card.chatId}` // æ ¼å¼å¦‚: kinship_chat_172839...
            });
        }
    }

    if (paymentOptions.length === 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert('æ”¯ä»˜å¤±è´¥', `ä½™é¢æˆ–äº²å±å¡é¢åº¦ä¸è¶³ï¼\néœ€è¦: Â¥${amount.toFixed(2)}`);
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    // 3. å¼¹å‡ºé€‰æ‹©
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.style.zIndex = 3002;
    const paymentMethod = await showChoiceModal(`è½¬è´¦ Â¥${amount.toFixed(2)}`, paymentOptions);
    modalOverlay.style.zIndex = '';

    if (!paymentMethod) return;

    // 4. æ‰§è¡Œæ‰£æ¬¾å’Œè®°è´¦
    if (paymentMethod === 'balance') {
        const success = await processTransaction(amount, 'expense', `è½¬è´¦ç»™-${receiverName}`);
        if (!success) return;
    } else if (paymentMethod.startsWith('kinship_')) {
        // ã€ä¿®å¤é‡ç‚¹ã€‘ï¼šä½¿ç”¨ replace æå–å®Œæ•´ IDï¼Œè€Œä¸æ˜¯ split
        // ä¹‹å‰çš„ split('_')[1] ä¼šæŠŠ 'chat_123' æˆªæ–­æˆ 'chat'ï¼Œå¯¼è‡´æ‰¾ä¸åˆ°å¡ç‰‡
        const cardChatId = paymentMethod.replace('kinship_', ''); 
        
        const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === cardChatId);
        
        if (cardIndex > -1) {
            // A. æ‰£å‡é¢åº¦
            wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + amount;
            await db.userWallet.put(wallet); // ä¿å­˜å›æ•°æ®åº“
            
            // B. å†™å…¥è´¦å•
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: amount,
                description: `äº²å±å¡è½¬è´¦-ç»™${receiverName}`
            });

            // C. é€šçŸ¥é‡‘ä¸» (ç³»ç»Ÿæ¶ˆæ¯)
            const providerChat = state.chats[cardChatId];
            if (providerChat) {
                let notifyContent = (cardChatId === chat.id) 
                    ? `[æ¶ˆè´¹é€šçŸ¥ï¼šç”¨æˆ·ä½¿ç”¨ä½ çš„äº²å±å¡å‘ã€ä½ ã€‘è½¬è´¦äº† Â¥${amount.toFixed(2)}ã€‚]`
                    : `[æ¶ˆè´¹é€šçŸ¥ï¼šç”¨æˆ·ä½¿ç”¨ä½ çš„äº²å±å¡å‘ã€${receiverName}ã€‘è½¬è´¦äº† Â¥${amount.toFixed(2)}ã€‚]`;
                
                providerChat.history.push({ role: 'system', content: notifyContent, timestamp: Date.now(), isHidden: true });
                await db.chats.put(providerChat);
            }
        } else {
            alert("ç³»ç»Ÿé”™è¯¯ï¼šæ‰¾ä¸åˆ°å¯¹åº”çš„äº²å±å¡è®°å½•ï¼Œæ”¯ä»˜å–æ¶ˆã€‚");
            return;
        }
    }

    // 5. æ¶ˆæ¯ä¸Šå±
    const msg = {
      role: 'user',
      type: 'transfer',
      amount: amount,
      note: note,
      senderName,
      receiverName,
      timestamp: Date.now()
    };
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
    
    document.getElementById('transfer-modal').classList.remove('visible');
    amountInput.value = '';
    noteInput.value = '';
}

 
  async function sendWaimaiOrderForAI() {
    if (!state.activeChatId) return;

    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');

    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    // 1. æ ¡éªŒé‡‘é¢å¿…é¡»å¤§äº0
    if (!productInfo || isNaN(amount) || amount <= 0) {
      // ä¸´æ—¶æå‡å¼¹çª—å±‚çº§ï¼Œé˜²æ­¢è¢«å¤–å–å¼¹çª—é®æŒ¡
      document.getElementById('custom-modal-overlay').style.zIndex = 3002;
      await showCustomAlert('æç¤º', 'è¯·å¡«å†™æœ‰æ•ˆçš„å•†å“ä¿¡æ¯å’Œé‡‘é¢(å¿…é¡»å¤§äº0)ï¼');
      document.getElementById('custom-modal-overlay').style.zIndex = '';
      return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

    // ã€æ–°å¢ã€‘æ‰§è¡Œæ‰£æ¬¾é€»è¾‘
    // åŒæ ·éœ€è¦å¤„ç†å¼¹çª—å±‚çº§ï¼Œé˜²æ­¢â€œä½™é¢ä¸è¶³â€æç¤ºè¢«é®æŒ¡
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.style.zIndex = 3002; // æ¯” waimai-request-modal é«˜

    const success = await processTransaction(amount, 'expense', `ä¸ºTAç‚¹å¤–å–-${productInfo}`);
    
    modalOverlay.style.zIndex = ''; // æ¢å¤å±‚çº§

    if (!success) return; // ä½™é¢ä¸è¶³ï¼Œåœæ­¢æ‰§è¡Œ

    const visibleMessage = {
      role: 'user',
      senderName: myNickname,
      type: 'waimai_order',
      productInfo: productInfo,
      amount: amount,
      timestamp: now
    };
    chat.history.push(visibleMessage);


    const hiddenMessage = {
      role: 'system',
      content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·(${myNickname})ä¸ºä½ ç‚¹äº†ä¸€ä»½å¤–å–ä½œä¸ºã€ç¤¼ç‰©ã€‘ã€‚å¤–å–å†…å®¹æ˜¯â€œ${productInfo}â€ï¼Œä»·å€¼${amount}å…ƒã€‚è¿™ä¸æ˜¯ä¸€ä¸ªä»£ä»˜è¯·æ±‚ï¼Œè€Œæ˜¯ç”¨æˆ·å·²ç»ä¸ºä½ æ”¯ä»˜äº†ã€‚è¯·ä½ å¯¹æ­¤è¡¨ç¤ºæ„Ÿè°¢ã€‚]`,
      timestamp: now + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);


    await db.chats.put(chat);
    appendMessage(visibleMessage, chat);
    renderChatList();


    productInfoInput.value = '';
    amountInput.value = '';
    document.getElementById('waimai-request-modal').classList.remove('visible');
  }
  
  async function sendLocationShare() {
    if (!state.activeChatId) return;


    const locationName = await showCustomPrompt("å…±äº«ä½ç½®", "ä½ ç°åœ¨åœ¨å“ªé‡Œå‘€ï¼Ÿ", "");


    if (!locationName || !locationName.trim()) return;



    const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';

    const chat = state.chats[state.activeChatId];


    const msg = {
      role: 'user',
      type: 'location_share',
      content: locationName.trim(),
      imageUrl: hardcodedImageUrl,
      timestamp: Date.now()
    };


    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
  }


  function enterSelectionMode(initialMsgTimestamp) {
    if (isSelectionMode) return;
    isSelectionMode = true;
    document.getElementById('chat-interface-screen').classList.add('selection-mode');
    toggleMessageSelection(initialMsgTimestamp);
  }

  function exitSelectionMode() {
    cleanupWaimaiTimers();
    if (!isSelectionMode) return;
    isSelectionMode = false;
    document.getElementById('chat-interface-screen').classList.remove('selection-mode');
    selectedMessages.forEach(ts => {
      const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`);
      if (bubble) bubble.classList.remove('selected');
    });
    selectedMessages.clear();
  }


  function toggleMessageSelection(timestamp) {

    const elementToSelect = document.querySelector(
      `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
      selectedMessages.delete(timestamp);
      elementToSelect.classList.remove('selected');
    } else {
      selectedMessages.add(timestamp);
      elementToSelect.classList.add('selected');
    }

    document.getElementById('selection-count').textContent = `å·²é€‰ ${selectedMessages.size} æ¡`;

    if (selectedMessages.size === 0) {
      exitSelectionMode();
    }
  }


  function addLongPressListener(element, callback) {
    let pressTimer;
    const startPress = (e) => {
      if (isSelectionMode) return;
      e.preventDefault();
      pressTimer = window.setTimeout(() => callback(e), 500);
    };
    const cancelPress = () => clearTimeout(pressTimer);
    element.addEventListener('mousedown', startPress);
    element.addEventListener('mouseup', cancelPress);
    element.addEventListener('mouseleave', cancelPress);
    element.addEventListener('touchstart', startPress, {
      passive: true
    });
    element.addEventListener('touchend', cancelPress);
    element.addEventListener('touchmove', cancelPress);
  }

  async function handleListenTogetherClick() {
    const targetChatId = state.activeChatId;
    if (!targetChatId) return;
    if (!musicState.isActive) {
      startListenTogetherSession(targetChatId);
      return;
    }
    if (musicState.activeChatId === targetChatId) {
      document.getElementById('music-player-overlay').classList.add('visible');
    } else {
      const oldChatName = state.chats[musicState.activeChatId]?.name || 'æœªçŸ¥';
      const newChatName = state.chats[targetChatId]?.name || 'å½“å‰';
      const confirmed = await showCustomConfirm('åˆ‡æ¢å¬æ­Œå¯¹è±¡', `æ‚¨æ­£å’Œã€Œ${oldChatName}ã€å¬æ­Œã€‚è¦ç»“æŸå¹¶å¼€å§‹å’Œã€Œ${newChatName}ã€çš„æ–°ä¼šè¯å—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await endListenTogetherSession(true);
        await new Promise(resolve => setTimeout(resolve, 50));
        startListenTogetherSession(targetChatId);
      }
    }
  }

  async function startListenTogetherSession(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    musicState.totalElapsedTime = chat.musicData.totalTime || 0;
    musicState.isActive = true;
    musicState.activeChatId = chatId;
    if (musicState.playlist.length > 0) {
      musicState.currentIndex = 0;
    } else {
      musicState.currentIndex = -1;
    }
    if (musicState.timerId) clearInterval(musicState.timerId);
    musicState.timerId = setInterval(() => {
      if (musicState.isPlaying) {
        musicState.totalElapsedTime++;
        updateElapsedTimeDisplay();
      }
    }, 1000);
    updatePlayerUI();
    updatePlaylistUI();
    document.getElementById('music-player-overlay').classList.add('visible');
  }

  async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    document.getElementById('global-lyrics-bar').classList.remove('visible');
    const cleanupLogic = async () => {
      if (musicState.timerId) clearInterval(musicState.timerId);
      if (musicState.isPlaying) audioPlayer.pause();
      if (saveState && oldChatId && state.chats[oldChatId]) {
        const chat = state.chats[oldChatId];
        chat.musicData.totalTime = musicState.totalElapsedTime;
        await db.chats.put(chat);
      }
      musicState.isActive = false;
      musicState.activeChatId = null;
      musicState.totalElapsedTime = 0;
      musicState.timerId = null;
      updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
  }

  function returnToChat() {
    closeMusicPlayerWithAnimation();
  }

  function updateListenTogetherIcon(chatId, forceReset = false) {
    const iconImg = document.querySelector('#listen-together-btn img');
    if (!iconImg) return;
    if (forceReset || !musicState.isActive || musicState.activeChatId !== chatId) {
      iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png';
      iconImg.className = '';
      return;
    }
    iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png';
    iconImg.classList.add('rotating');
    if (musicState.isPlaying) iconImg.classList.remove('paused');
    else iconImg.classList.add('paused');
  }
  window.updateListenTogetherIconProxy = updateListenTogetherIcon;

  function updatePlayerUI() {
    updateListenTogetherIcon(musicState.activeChatId);
    updateElapsedTimeDisplay();
    const titleEl = document.getElementById('music-player-song-title');
    const artistEl = document.getElementById('music-player-artist');
    const playPauseBtn = document.getElementById('music-play-pause-btn');
    if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
      const track = musicState.playlist[musicState.currentIndex];
      titleEl.textContent = track.name;
      artistEl.textContent = track.artist;
    } else {
      titleEl.textContent = 'è¯·æ·»åŠ æ­Œæ›²';
      artistEl.textContent = '...';
    }
    playPauseBtn.textContent = musicState.isPlaying ? 'âšâš' : 'â–¶';
  }

  function updateElapsedTimeDisplay() {
    const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
    document.getElementById('music-time-counter').textContent = `å·²ç»ä¸€èµ·å¬äº†${hours}å°æ—¶`;
  }

  function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
      playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„~</p>';
      return;
    }
    musicState.playlist.forEach((track, index) => {
      const item = document.createElement('div');
      item.className = 'playlist-item';
      if (index === musicState.currentIndex) item.classList.add('playing');
      
      
      item.dataset.index = index;

     
      const checkboxDisplay = isPlaylistManagementMode ? 'block' : 'none';

      item.innerHTML = `
        <input type="checkbox" class="playlist-item-checkbox" style="display: ${checkboxDisplay};" data-index="${index}">
        <div class="playlist-item-info">
            <div class="title">${track.name}</div>
            <div class="artist">${track.artist}</div>
        </div>
        <div class="playlist-item-actions">
            <span class="playlist-action-btn album-art-btn" data-index="${index}">ä¸“è¾‘</span>
            <span class="playlist-action-btn lyrics-btn" data-index="${index}">è¯</span>
            <span class="playlist-action-btn bg-btn" data-index="${index}">èƒŒæ™¯</span>
            <span class="playlist-action-btn delete-track-btn" data-index="${index}">Ã—</span>
        </div>
      `;

     
      item.addEventListener('click', (e) => {
        if (isPlaylistManagementMode) {
         
          if (e.target.tagName !== 'INPUT') {
            e.stopPropagation(); 
          }
          handlePlaylistSelection(index);
        }
      });
      
      
      const infoEl = item.querySelector('.playlist-item-info');
      if (infoEl) {
          infoEl.addEventListener('click', (e) => {
              if (!isPlaylistManagementMode) {
                  e.stopPropagation(); 
                  playSong(index, false);
              }
          });
      }
      
      playlistBody.appendChild(item);
    });
  }



  async function togglePlayPause() {
    if (audioPlayer.paused) {
      if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        playSong(0, true);
      } else if (musicState.currentIndex > -1) {
        playSong(musicState.currentIndex, true); 
      }
    } else {
      audioPlayer.pause();
     // await addMusicActionSystemMessage('æš‚åœäº†éŸ³ä¹');
    }
  }

  function playNext(isAutomatic = false) {
    if (musicState.playlist.length === 0) return;
    let nextIndex;
    switch (musicState.playMode) {
      case 'random':
        nextIndex = Math.floor(Math.random() * musicState.playlist.length);
        break;
      case 'single':
        playSong(musicState.currentIndex, isAutomatic); 
        return;
      case 'order':
      default:
        nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
        break;
    }
    playSong(nextIndex, isAutomatic); 
  }

  function playPrev() {
    if (musicState.playlist.length === 0) return;
    const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
    playSong(newIndex, false); 
  }

  function changePlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(musicState.playMode);
    musicState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('music-mode-btn').textContent = {
      'order': 'é¡ºåº',
      'random': 'éšæœº',
      'single': 'å•æ›²'
    } [musicState.playMode];
  }

  async function addSongFromURL() {
    const url = await showCustomPrompt("æ·»åŠ ç½‘ç»œæ­Œæ›²", "è¯·è¾“å…¥æ­Œæ›²çš„URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå");
    if (!name) return;
    const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å");
    if (!artist) return;
    musicState.playlist.push({
      name,
      artist,
      src: url,
      isLocal: false
    });
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1) {
      musicState.currentIndex = musicState.playlist.length - 1;
      updatePlayerUI();
    }
  }

  




  async function playSong(index, isAutomatic = false) {
    if (index < 0 || index >= musicState.playlist.length) return;

    audioPlayer.pause();

    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    const chat = state.chats[musicState.activeChatId];


    const avatarDisplay = document.getElementById('music-player-avatar-display');
    if (chat && avatarDisplay) {

      avatarDisplay.innerHTML = '';


      const charAvatarUrl = chat.isGroup ?
        (chat.members.find(m => m.originalName === track.artist)?.avatar || defaultAvatar) :
        (chat.settings.aiAvatar || defaultAvatar);
      const userAvatarUrl = chat.settings.myAvatar || defaultAvatar;


      const charAvatarEl = document.createElement('img');
      charAvatarEl.src = charAvatarUrl;
      charAvatarEl.className = 'participant-display-avatar';
      charAvatarEl.alt = 'Character Avatar';
      avatarDisplay.appendChild(charAvatarEl);


      const userAvatarEl = document.createElement('img');
      userAvatarEl.src = userAvatarUrl;
      userAvatarEl.className = 'participant-display-avatar';
      userAvatarEl.alt = 'User Avatar';
      avatarDisplay.appendChild(userAvatarEl);
    }


    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    if (playerWindow) {
      playerWindow.style.setProperty('--music-bg-image', track.background ? `url(${track.background})` : 'none');
      playerWindow.classList.toggle('bg-clear', !!track.isBgClear);
    }
    if (toggleBtn) {
      toggleBtn.classList.toggle('active', !!track.isBgClear);
    }


    document.getElementById('music-visual-container').classList.remove('lyrics-active');
    const coverEl = document.getElementById('music-player-cover');
    if (coverEl) {
      coverEl.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
    }

    if (!isAutomatic) {
      await addMusicActionSystemMessage(`å°†æ­Œæ›²åˆ‡æ¢ä¸ºäº†ã€Š${track.name}ã€‹`);
    }
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");

    renderLyrics();
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
      if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        singleLyricEl.textContent = 'çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ';
      } else {
        singleLyricEl.textContent = 'â™ª â™ª â™ª';
      }
    }

    if (track.isLocal && track.src instanceof ArrayBuffer) {
      const blob = new Blob([track.src], {
        type: track.fileType || 'audio/mpeg'
      });
      audioPlayer.src = URL.createObjectURL(blob);
    } else if (track.isLocal && track.src instanceof Blob) {
      audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
      // --- ã€æ–°å¢ã€‘å°è¯•ä½¿ç”¨ä»£ç†æ’­æ”¾éŸ³é¢‘ (å¤ç”¨ NovelAI çš„ä»£ç†è®¾ç½®) ---
      const settings = getNovelAISettings(); // è·å–è®¾ç½®
      let corsProxy = settings.cors_proxy;
      
      // å¦‚æœé€‰çš„æ˜¯è‡ªå®šä¹‰ (å³ä½ çš„ CF Worker)
      if (corsProxy === 'custom') {
          corsProxy = settings.custom_proxy_url || '';
      }

      // åªæœ‰å½“å­˜åœ¨ä»£ç†åœ°å€ï¼Œä¸”é“¾æ¥ä¸æ˜¯ base64 (data:) æ—¶æ‰ä½¿ç”¨ä»£ç†
      if (corsProxy && corsProxy.trim() !== '' && !track.src.startsWith('data:')) {
          // ä½¿ç”¨ encodeURIComponent å¯ä»¥é˜²æ­¢ URL ä¸­çš„ç‰¹æ®Šå­—ç¬¦å¯¼è‡´ä»£ç†è§£æé”™è¯¯
          // å¦‚æœä½ çš„ Worker æ˜¯ç›´æ¥æ‹¼æ¥å½¢å¼ (æ¯”å¦‚ https://worker.dev/https://catbox...), è¿™æ ·é€šå¸¸ä¹Ÿæ²¡é—®é¢˜
          const proxiedUrl = corsProxy + encodeURIComponent(track.src);
          console.log(`[éŸ³ä¹æ’­æ”¾] ä½¿ç”¨ä»£ç†åŠ è½½: ${track.name}`);
          audioPlayer.src = proxiedUrl;
      } else {
          // æ²¡æœ‰é…ç½®ä»£ç†ï¼Œç›´æ¥ç›´è¿
          audioPlayer.src = track.src;
      }
      // -------------------------------------------------------
      
    } else {
      console.error('æœ¬åœ°æ­Œæ›²æºé”™è¯¯:', track);
      return;
    }

    const playPromise = audioPlayer.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        if (error.name === 'NotAllowedError') {
          console.warn('Autoplay was prevented by the browser.');
          audioPlayer.pause();
          
        } else if (error.name !== 'AbortError') {
          console.error('Playback error:', error);
        }
      });
    }
    updatePlaylistUI();
    updatePlayerUI();
    const isFrameMode = document.body.classList.contains('frame-mode-active');
    const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false;
    const lyricBar = document.getElementById('global-lyrics-bar');

    if (isFrameMode || isAlwaysIslandMode) {
     
      phoneScreenForIsland.classList.add('dynamic-island-active');
      islandAlbumArt.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
      lyricBar.classList.remove('visible'); 
    } else {
    
      phoneScreenForIsland.classList.remove('dynamic-island-active');
      if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
        lyricBar.textContent = 'â™ª';
        lyricBar.classList.add('visible');
      } else {
        lyricBar.classList.remove('visible');
      }
    }
  }



  async function handleChangeBackground(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;


    const choice = await showChoiceModal("æ›´æ¢æ­Œæ›²èƒŒæ™¯", [{
        text: 'ğŸ“ ä»æœ¬åœ°ä¸Šä¼ ',
        value: 'local'
      },
      {
        text: 'ğŸŒ ä½¿ç”¨ç½‘ç»œURL',
        value: 'url'
      }
    ]);

    let newBackgroundUrl = null;


    if (choice === 'local') {
      newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
      newBackgroundUrl = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥æ–°çš„èƒŒæ™¯å›¾ç‰‡é“¾æ¥", "", "url");
    }


    if (newBackgroundUrl && newBackgroundUrl.trim()) {
      musicState.playlist[trackIndex].background = newBackgroundUrl.trim();
      await saveGlobalPlaylist();


      if (musicState.currentIndex === trackIndex) {
        const playerWindow = document.querySelector('.music-player-window');
        playerWindow.style.setProperty('--music-bg-image', `url(${newBackgroundUrl.trim()})`);
      }

      await showCustomAlert("æˆåŠŸ", "æ­Œæ›²èƒŒæ™¯å·²æ›´æ–°ï¼");
    }
  }
 
  async function handleChangeAlbumArt(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal("æ›´æ¢ä¸“è¾‘å°é¢", [{
        text: 'ğŸ“ ä»æœ¬åœ°ä¸Šä¼ ',
        value: 'local'
      },
      {
        text: 'ğŸŒ ä½¿ç”¨ç½‘ç»œURL',
        value: 'url'
      }
    ]);

    let newCoverUrl = null;

    if (choice === 'local') {
      newCoverUrl = await uploadImageLocally();
    } else if (choice === 'url') {
      newCoverUrl = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥æ–°çš„å°é¢å›¾ç‰‡é“¾æ¥", "", "url");
    }

    if (newCoverUrl && newCoverUrl.trim()) {
      musicState.playlist[trackIndex].cover = newCoverUrl.trim();
      await saveGlobalPlaylist();


      if (musicState.currentIndex === trackIndex) {
        document.getElementById('music-player-cover').src = newCoverUrl.trim();

        const vinylCover = document.querySelector('#vinyl-view #music-player-cover');
        if (vinylCover) vinylCover.src = newCoverUrl.trim();
      }

      await showCustomAlert("æˆåŠŸ", "ä¸“è¾‘å°é¢å·²æ›´æ–°ï¼");
    }
  }

 



  async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    let uploadedCount = 0;
    for (const file of files) {
      let name = file.name.replace(/\.[^/.]+$/, "");
      name = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œå", name);
      if (name === null) continue;

      const artist = await showCustomPrompt("æ­Œæ›²ä¿¡æ¯", "è¯·è¾“å…¥æ­Œæ‰‹å", "æœªçŸ¥æ­Œæ‰‹");
      if (artist === null) continue;

      let lrcContent = "";
      const wantLrc = await showCustomConfirm("å¯¼å…¥æ­Œè¯", `è¦ä¸ºã€Š${name}ã€‹æ·»åŠ æ­Œè¯å—ï¼Ÿ`);
      if (wantLrc) {
        lrcContent = await getLrcContent() || "";
      }

     
      let songSrc = null;
      let isLocal = true;

      try {
        // å°è¯•ä¸Šä¼ åˆ° Catbox
        const catboxUrl = await uploadFileToCatbox(file); // 'file' æ˜¯ç°æˆçš„ File å¯¹è±¡

        if (catboxUrl) {
          // ä¸Šä¼ æˆåŠŸ
          songSrc = catboxUrl;
          isLocal = false; // è¿™æ˜¯ä¸€ä¸ªç½‘ç»œ URL
          await showCustomAlert("ä¸Šä¼ æˆåŠŸ", `æ­Œæ›² "${file.name}" å·²æˆåŠŸä¸Šä¼ å¹¶ä¿å­˜åˆ°æ‚¨çš„ Catbox è´¦æˆ·ï¼`);
        } else {
         
          console.log("Catbox æœªé…ç½®ï¼Œå°†æ­Œæ›²ä¿å­˜ä¸ºæœ¬åœ° ArrayBufferã€‚");
          songSrc = await file.arrayBuffer();
          isLocal = true;
        }
      } catch (uploadError) {
      
        console.error("Catbox ä¸Šä¼ å¤±è´¥:", uploadError);
        await showCustomAlert("ä¸Šä¼ å¤±è´¥", `æ­Œæ›²ä¸Šä¼ åˆ° Catbox å¤±è´¥: ${uploadError.message}\n\nå°†æ”¹ä¸ºæœ¬åœ°ä¿å­˜ã€‚`);
        songSrc = await file.arrayBuffer();
        isLocal = true;
      }
      

      musicState.playlist.push({
        name,
        artist,
        src: songSrc,       // <-- ä¿®æ”¹
        fileType: file.type,
        isLocal: isLocal,     // <-- ä¿®æ”¹
        lrcContent: lrcContent,
        cover: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg'
      });
      uploadedCount++;
    }

    if (uploadedCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
          musicState.currentIndex = 0;
          updatePlayerUI();
        }
    }
    event.target.value = null;
  }


  async function deleteTrack(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    const track = musicState.playlist[index];
    const wasPlaying = musicState.isPlaying && musicState.currentIndex === index;
    if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src);
    musicState.playlist.splice(index, 1);
    await saveGlobalPlaylist();
    if (musicState.playlist.length === 0) {
      if (musicState.isPlaying) audioPlayer.pause();
      audioPlayer.src = '';
      musicState.currentIndex = -1;
      musicState.isPlaying = false;
    } else {
      if (wasPlaying) {
        playNext();
      } else {
        if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1);
      }
    }
    updatePlayerUI();
    updatePlaylistUI();
  }

  const personaLibraryModal = document.getElementById('persona-library-modal');
  const personaEditorModal = document.getElementById('persona-editor-modal');
  const presetActionsModal = document.getElementById('preset-actions-modal');

  function openPersonaLibrary() {
    renderPersonaLibrary();
    personaLibraryModal.classList.add('visible');
  }

  function closePersonaLibrary() {
    personaLibraryModal.classList.remove('visible');
  }

  function renderPersonaLibrary() {
    const grid = document.getElementById('persona-library-grid');
    grid.innerHTML = '';
    if (state.personaPresets.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">ç©ºç©ºå¦‚ä¹Ÿ~ ç‚¹å‡»å³ä¸Šè§’"æ·»åŠ "æ¥åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªäººè®¾é¢„è®¾å§ï¼</p>';
      return;
    }
    state.personaPresets.forEach(preset => {
      const item = document.createElement('div');
      item.className = 'persona-preset-item';
      if (isManageMode) {
        item.classList.add('manage-mode');
        if (selectedPresetIds.has(preset.id)) {
          item.classList.add('selected');
        }
      }
      item.style.backgroundImage = `url(${preset.avatar})`;
      item.dataset.presetId = preset.id;
      
      if (isManageMode) {
        item.addEventListener('click', () => togglePresetSelection(preset.id));
      } else {
        item.addEventListener('click', () => showPersonaActionModal(preset.id));
        addLongPressListener(item, () => showPresetActions(preset.id));
      }
      
      grid.appendChild(item);
    });
  }

  function togglePresetSelection(presetId) {
    if (selectedPresetIds.has(presetId)) {
      selectedPresetIds.delete(presetId);
    } else {
      selectedPresetIds.add(presetId);
    }
    renderPersonaLibrary();
  }

  function enterManageMode() {
    isManageMode = true;
    selectedPresetIds.clear();
    document.getElementById('add-persona-preset-btn').style.display = 'none';
    document.getElementById('manage-persona-preset-btn').style.display = 'none';
    document.getElementById('import-tavern-persona-btn').style.display = 'none';
    document.getElementById('close-persona-library-btn').style.display = 'none';
    document.getElementById('persona-manage-actions').style.display = 'flex';
    renderPersonaLibrary();
  }

  function exitManageMode() {
    isManageMode = false;
    selectedPresetIds.clear();
    document.getElementById('add-persona-preset-btn').style.display = 'block';
    document.getElementById('manage-persona-preset-btn').style.display = 'block';
    document.getElementById('import-tavern-persona-btn').style.display = 'block';
    document.getElementById('close-persona-library-btn').style.display = 'block';
    document.getElementById('persona-manage-actions').style.display = 'none';
    renderPersonaLibrary();
  }

  function selectAllPresets() {
    if (selectedPresetIds.size === state.personaPresets.length) {
      selectedPresetIds.clear();
    } else {
      selectedPresetIds = new Set(state.personaPresets.map(p => p.id));
    }
    renderPersonaLibrary();
  }

  async function deleteSelectedPresets() {
    if (selectedPresetIds.size === 0) {
      alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é¢„è®¾');
      return;
    }
    
    const confirmed = await showCustomConfirm(
      'åˆ é™¤é¢„è®¾', 
      `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedPresetIds.size} ä¸ªäººè®¾é¢„è®¾å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`, 
      { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
      for (const presetId of selectedPresetIds) {
        await db.personaPresets.delete(presetId);
      }
      state.personaPresets = state.personaPresets.filter(p => !selectedPresetIds.has(p.id));
      selectedPresetIds.clear();
      renderPersonaLibrary();
    }
  }

  function showPresetActions(presetId) {
    editingPersonaPresetId = presetId;
    presetActionsModal.classList.add('visible');
  }

  function hidePresetActions() {
    presetActionsModal.classList.remove('visible');
    editingPersonaPresetId = null;
  }

  // æ˜¾ç¤ºäººè®¾æ“ä½œé€‰æ‹©å¼¹çª—
  let currentPersonaActionId = null;
  function showPersonaActionModal(presetId) {
    currentPersonaActionId = presetId;
    const modal = document.getElementById('persona-action-modal');
    modal.classList.add('visible');
  }

  // éšè—äººè®¾æ“ä½œå¼¹çª—
  function hidePersonaActionModal() {
    const modal = document.getElementById('persona-action-modal');
    modal.classList.remove('visible');
    currentPersonaActionId = null;
  }

  // ç›´æ¥åº”ç”¨äººè®¾
  function applyPersonaPresetDirect() {
    if (!currentPersonaActionId) return;
    const preset = state.personaPresets.find(p => p.id === currentPersonaActionId);
    if (preset) {
      document.getElementById('my-avatar-preview').src = preset.avatar;
      document.getElementById('my-persona').value = preset.persona;
    }
    hidePersonaActionModal();
    closePersonaLibrary();
  }

  // ç¼–è¾‘ååº”ç”¨äººè®¾
  function editPersonaThenApply() {
    if (!currentPersonaActionId) return;
    editingPersonaPresetId = currentPersonaActionId;
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId);
    if (!preset) return;
    
    // ä¿å­˜åŸå§‹å†…å®¹ï¼Œç”¨äºåç»­æ¯”è¾ƒæ˜¯å¦ä¿®æ”¹
    window.originalPersonaContent = preset.persona;
    
    document.getElementById('persona-editor-title').textContent = 'ç¼–è¾‘äººè®¾é¢„è®¾';
    document.getElementById('preset-avatar-preview').src = preset.avatar;
    document.getElementById('preset-persona-input').value = preset.persona;
    
    hidePersonaActionModal();
    personaEditorModal.classList.add('visible');
  }

  // æ—§ç‰ˆæœ¬ä¿ç•™ï¼ˆç”¨äºå…¼å®¹æ€§ï¼‰
  function applyPersonaPreset(presetId) {
    const preset = state.personaPresets.find(p => p.id === presetId);
    if (preset) {
      document.getElementById('my-avatar-preview').src = preset.avatar;
      document.getElementById('my-persona').value = preset.persona;
    }
    closePersonaLibrary();
  }

  function openPersonaEditorForCreate() {
    editingPersonaPresetId = null;
    document.getElementById('persona-editor-title').textContent = 'æ·»åŠ äººè®¾é¢„è®¾';
    document.getElementById('preset-avatar-preview').src = defaultAvatar;
    document.getElementById('preset-persona-input').value = '';
    personaEditorModal.classList.add('visible');
  }

  function openPersonaEditorForEdit() {
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId);
    if (!preset) return;
    document.getElementById('persona-editor-title').textContent = 'ç¼–è¾‘äººè®¾é¢„è®¾';
    document.getElementById('preset-avatar-preview').src = preset.avatar;
    document.getElementById('preset-persona-input').value = preset.persona;
    presetActionsModal.classList.remove('visible');
    personaEditorModal.classList.add('visible');
  }

  async function deletePersonaPreset() {
    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªäººè®¾é¢„è®¾å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed && editingPersonaPresetId) {
      await db.personaPresets.delete(editingPersonaPresetId);
      state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId);
      hidePresetActions();
      renderPersonaLibrary();
    }
  }

  function closePersonaEditor() {
    personaEditorModal.classList.remove('visible');
    editingPersonaPresetId = null;
  }

  async function savePersonaPreset() {
    const avatar = document.getElementById('preset-avatar-preview').src;
    const persona = document.getElementById('preset-persona-input').value.trim();
    if (avatar === defaultAvatar && !persona) {
      alert("å¤´åƒå’Œäººè®¾ä¸èƒ½éƒ½ä¸ºç©ºå“¦ï¼");
      return;
    }
    
    if (editingPersonaPresetId) {
      const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId);
      if (preset) {
        const oldPersona = preset.persona;
        const personaChanged = oldPersona !== persona;
        
        // å¦‚æœäººè®¾å†…å®¹æœ‰ä¿®æ”¹ï¼Œè¯¢é—®æ˜¯å¦åŒæ­¥
        if (personaChanged && window.originalPersonaContent && window.originalPersonaContent !== persona) {
          const shouldSync = await showCustomConfirm(
            'åŒæ­¥æ›´æ–°',
            `æ£€æµ‹åˆ°äººè®¾å†…å®¹å·²ä¿®æ”¹ã€‚\n\nåŸå†…å®¹ï¼š${oldPersona.substring(0, 50)}${oldPersona.length > 50 ? '...' : ''}\næ–°å†…å®¹ï¼š${persona.substring(0, 50)}${persona.length > 50 ? '...' : ''}\n\næ˜¯å¦åŒæ­¥æ›´æ–°åˆ°æ‰€æœ‰ä½¿ç”¨æ­¤äººè®¾çš„åœ°æ–¹ï¼Ÿ`,
            {
              confirmText: 'åŒæ­¥æ›´æ–°',
              cancelText: 'ä»…æ›´æ–°é¢„è®¾'
            }
          );
          
          if (shouldSync) {
            // åŒæ­¥åˆ°å…¨å±€è®¾ç½®ï¼ˆå¦‚æœå½“å‰ä½¿ç”¨çš„æ˜¯è¿™ä¸ªäººè®¾ï¼‰
            const currentPersona = document.getElementById('my-persona')?.value;
            if (currentPersona === oldPersona) {
              document.getElementById('my-persona').value = persona;
              document.getElementById('my-avatar-preview').src = avatar;
              
              // ä¿å­˜åˆ°å…¨å±€è®¾ç½®
              const globalSettings = await db.globalSettings.get('main');
              if (globalSettings) {
                globalSettings.myPersona = persona;
                globalSettings.myAvatar = avatar;
                await db.globalSettings.put(globalSettings);
              }
            }
            
            // åŒæ­¥åˆ°æ‰€æœ‰è§’è‰²çš„å•ç‹¬äººè®¾é…ç½®
            for (const chatId in state.chats) {
              const chat = state.chats[chatId];
              if (chat.customPersona === oldPersona) {
                chat.customPersona = persona;
                await db.chats.put(chat);
              }
            }
            
            // åŒæ­¥åˆ°ç»¿æ±Ÿä½œå“è®¾ç½®ä¸­çš„User Persona
            const stories = await db.grStories.toArray();
            for (const story of stories) {
              if (story.settings && story.settings.userPersonaId === editingPersonaPresetId) {
                // ç»¿æ±Ÿä¸­ä½¿ç”¨çš„æ˜¯é¢„è®¾IDï¼Œä¸éœ€è¦é¢å¤–åŒæ­¥
              }
            }
            
            await showCustomAlert('åŒæ­¥å®Œæˆ', 'å·²æˆåŠŸåŒæ­¥æ›´æ–°åˆ°æ‰€æœ‰ä½¿ç”¨æ­¤äººè®¾çš„åœ°æ–¹ï¼');
          }
        }
        
        preset.avatar = avatar;
        preset.persona = persona;
        await db.personaPresets.put(preset);
        
        // å¦‚æœæ˜¯"ç¼–è¾‘ååº”ç”¨"æ¨¡å¼ï¼Œç›´æ¥åº”ç”¨åˆ°å½“å‰
        if (window.originalPersonaContent) {
          document.getElementById('my-avatar-preview').src = avatar;
          document.getElementById('my-persona').value = persona;
        }
      }
    } else {
      const newPreset = {
        id: 'preset_' + Date.now(),
        avatar: avatar,
        persona: persona
      };
      await db.personaPresets.add(newPreset);
      state.personaPresets.push(newPreset);
    }
    
    // æ¸…é™¤åŸå§‹å†…å®¹æ ‡è®°
    window.originalPersonaContent = null;
    
    renderPersonaLibrary();
    closePersonaEditor();
    closePersonaLibrary();
  }

  async function importTavernPersonas() {
    const input = document.getElementById('import-tavern-persona-input');
    input.click();
  }

  async function handleTavernPersonaImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!data.personas || !data.persona_descriptions) {
        await showCustomAlert('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ç¡®ä¿æ˜¯é…’é¦†AIå¯¼å‡ºçš„USERé¢„è®¾æ–‡ä»¶ã€‚');
        event.target.value = '';
        return;
      }

      const personas = data.personas;
      const descriptions = data.persona_descriptions;
      pendingTavernPersonas = [];

      for (const [imageKey, name] of Object.entries(personas)) {
        const desc = descriptions[imageKey];
        if (!desc || !desc.description) continue;

        pendingTavernPersonas.push({
          name: name,
          description: desc.description,
          imageKey: imageKey
        });
      }

      event.target.value = '';

      if (pendingTavernPersonas.length === 0) {
        await showCustomAlert('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„é¢„è®¾æ•°æ®ã€‚');
        return;
      }

      const importAll = await showCustomConfirm(
        'å¯¼å…¥é¢„è®¾',
        `æ£€æµ‹åˆ° ${pendingTavernPersonas.length} ä¸ªé¢„è®¾ã€‚æ˜¯å¦å…¨éƒ¨å¯¼å…¥ï¼Ÿ\n\né€‰æ‹©"ç¡®å®š"å…¨éƒ¨å¯¼å…¥\né€‰æ‹©"å–æ¶ˆ"æ‰‹åŠ¨é€‰æ‹©è¦å¯¼å…¥çš„é¢„è®¾`,
        { confirmText: 'å…¨éƒ¨å¯¼å…¥', cancelText: 'æ‰‹åŠ¨é€‰æ‹©' }
      );

      if (importAll) {
        await importSelectedTavernPersonas(pendingTavernPersonas);
      } else {
        showTavernPersonaSelector();
      }
    } catch (error) {
      console.error('å¯¼å…¥é…’é¦†AIé¢„è®¾å¤±è´¥:', error);
      await showCustomAlert('å¯¼å…¥å¤±è´¥', 'æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚');
      event.target.value = '';
    }
  }

  function showTavernPersonaSelector() {
    const modal = document.getElementById('tavern-persona-selector-modal');
    const listEl = document.getElementById('tavern-persona-selector-list');
    listEl.innerHTML = '';

    pendingTavernPersonas.forEach((persona, index) => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.style.padding = '15px 20px';
      item.style.borderBottom = '1px solid var(--border-color)';
      
      const previewText = persona.description.length > 100 
        ? persona.description.substring(0, 100) + '...' 
        : persona.description;
      
      item.innerHTML = `
        <input type="checkbox" class="tavern-persona-checkbox" data-index="${index}" checked style="margin-right: 15px;">
        <div style="flex: 1;">
          <div style="font-weight: 600; margin-bottom: 5px;">${escapeHTML(persona.name)}</div>
          <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.4;">${escapeHTML(previewText)}</div>
        </div>
      `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  function closeTavernPersonaSelector() {
    document.getElementById('tavern-persona-selector-modal').classList.remove('visible');
    pendingTavernPersonas = [];
  }

  async function confirmTavernImport() {
    const selectedIndices = Array.from(document.querySelectorAll('.tavern-persona-checkbox:checked'))
      .map(cb => parseInt(cb.dataset.index));

    if (selectedIndices.length === 0) {
      await showCustomAlert('æç¤º', 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªé¢„è®¾è¿›è¡Œå¯¼å…¥ã€‚');
      return;
    }

    const selectedPersonas = selectedIndices.map(i => pendingTavernPersonas[i]);
    closeTavernPersonaSelector();
    await importSelectedTavernPersonas(selectedPersonas);
  }

  async function importSelectedTavernPersonas(personas) {
    let importCount = 0;

    for (const persona of personas) {
      const newPreset = {
        id: 'preset_tavern_' + Date.now() + '_' + importCount,
        avatar: defaultAvatar,
        persona: `åå­—ï¼š${persona.name}\n\n${persona.description}`
      };

      await db.personaPresets.add(newPreset);
      state.personaPresets.push(newPreset);
      importCount++;
      
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    renderPersonaLibrary();
    await showCustomAlert('å¯¼å…¥æˆåŠŸ', `æˆåŠŸå¯¼å…¥ ${importCount} ä¸ªäººè®¾é¢„è®¾ï¼`);
  }

  const batteryAlertModal = document.getElementById('battery-alert-modal');

  function showBatteryAlert(imageUrl, text) {
    clearTimeout(batteryAlertTimeout);
    document.getElementById('battery-alert-image').src = imageUrl;
    document.getElementById('battery-alert-text').textContent = text;
    batteryAlertModal.classList.add('visible');
    const closeAlert = () => {
      batteryAlertModal.classList.remove('visible');
      batteryAlertModal.removeEventListener('click', closeAlert);
    };
    batteryAlertModal.addEventListener('click', closeAlert);
    batteryAlertTimeout = setTimeout(closeAlert, 2000);
  }

  function updateBatteryDisplay(battery) {
    const batteryContainer = document.getElementById('status-bar-battery');
    const batteryLevelEl = batteryContainer.querySelector('.battery-level');
    const batteryTextEl = batteryContainer.querySelector('.battery-text');
    const level = Math.floor(battery.level * 100);
    batteryLevelEl.style.width = `${level}%`;
    batteryTextEl.textContent = `${level}%`;
    if (battery.charging) {
      batteryContainer.classList.add('charging');
    } else {
      batteryContainer.classList.remove('charging');
    }
  }

  function handleBatteryChange(battery) {
    updateBatteryDisplay(battery);
    const level = battery.level;
    if (!battery.charging) {
      if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) {
        showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', 'æœ‰ç‚¹é¥¿äº†ï¼Œå¯ä»¥å»æ‰¾å……ç”µå™¨æƒ¹');
        alertFlags.hasShown40 = true;
      }
      if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) {
        showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', 'èµ¶ç´§çš„å……ç”µï¼Œè¦é¥¿æ­»äº†');
        alertFlags.hasShown20 = true;
      }
      if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) {
        showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', 'å·²é˜µäº¡ï¼Œè¿˜æœ‰30ç§’çˆ†ç‚¸');
        alertFlags.hasShown10 = true;
      }
    }
    if (level > 0.4) alertFlags.hasShown40 = false;
    if (level > 0.2) alertFlags.hasShown20 = false;
    if (level > 0.1) alertFlags.hasShown10 = false;
    lastKnownBatteryLevel = level;
  }

  async function initBatteryManager() {
    if ('getBattery' in navigator) {
      try {
        const battery = await navigator.getBattery();
        lastKnownBatteryLevel = battery.level;
        handleBatteryChange(battery);
        battery.addEventListener('levelchange', () => handleBatteryChange(battery));
        battery.addEventListener('chargingchange', () => {
          handleBatteryChange(battery);
          if (battery.charging) {
            showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', 'çªçˆ±æ³¥ï¼Œç”µé‡åƒé¥±é¥±');
          }
        });
      } catch (err) {
        console.error("æ— æ³•è·å–ç”µæ± ä¿¡æ¯:", err);
        document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ';
      }
    } else {
      console.log("æµè§ˆå™¨ä¸æ”¯æŒç”µæ± çŠ¶æ€APIã€‚");
      document.querySelector('.battery-text').textContent = 'á—œÏ‰á—œ';
    }
  }

  async function renderAlbumList() {
    const albumGrid = document.getElementById('album-grid-page');
    if (!albumGrid) return;
    const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
    albumGrid.innerHTML = '';
    if (albums.length === 0) {
      albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">ä½ è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ç›¸å†Œå“¦~</p>';
      return;
    }
    albums.forEach(album => {
      const albumItem = document.createElement('div');
      albumItem.className = 'album-item';
      albumItem.innerHTML = `
                            <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                            <div class="album-info">
                                <p class="album-name">${album.name}</p>
                                <p class="album-count">${album.photoCount || 0} å¼ </p>
                            </div>
                        `;
      albumItem.addEventListener('click', () => {
        openAlbum(album.id);
      });


      addLongPressListener(albumItem, async () => {
        const confirmed = await showCustomConfirm(
          'åˆ é™¤ç›¸å†Œ',
          `ç¡®å®šè¦åˆ é™¤ç›¸å†Œã€Š${album.name}ã€‹å—ï¼Ÿæ­¤æ“ä½œå°†åŒæ—¶åˆ é™¤ç›¸å†Œå†…çš„æ‰€æœ‰ç…§ç‰‡ï¼Œä¸”æ— æ³•æ¢å¤ã€‚`, {
            confirmButtonClass: 'btn-danger'
          }
        );

        if (confirmed) {
       
          await db.qzonePhotos.where('albumId').equals(album.id).delete();

        
          await db.qzoneAlbums.delete(album.id);

        
          await renderAlbumList();

          alert('ç›¸å†Œå·²æˆåŠŸåˆ é™¤ã€‚');
        }
      });


      albumGrid.appendChild(albumItem);
    });
  }

  async function openAlbum(albumId) {
    state.activeAlbumId = albumId;
    await renderAlbumPhotosScreen();
    showScreen('album-photos-screen');
  }

  async function renderAlbumPhotosScreen() {
    if (!state.activeAlbumId) return;
    const photosGrid = document.getElementById('photos-grid-page');
    const headerTitle = document.getElementById('album-photos-title');
    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    if (!album) {
      console.error("æ‰¾ä¸åˆ°ç›¸å†Œ:", state.activeAlbumId);
      showScreen('album-screen');
      return;
    }
    headerTitle.textContent = album.name;
    const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photosGrid.innerHTML = '';
    if (photos.length === 0) {
      photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">è¿™ä¸ªç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œå¿«ä¸Šä¼ ç¬¬ä¸€å¼ ç…§ç‰‡å§ï¼</p>';
    } else {
      photos.forEach(photo => {
        const photoItem = document.createElement('div');
        photoItem.className = 'photo-item';
        photoItem.innerHTML = `
                                <img src="${photo.url}" class="photo-thumb" alt="ç›¸å†Œç…§ç‰‡">
                                <button class="photo-delete-btn" data-photo-id="${photo.id}">Ã—</button>
                            `;
        photosGrid.appendChild(photoItem);
      });
    }
  }

 
  async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;


    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);


    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return;


    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
  }

 
  function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');


    imageEl.style.opacity = 0;

    setTimeout(() => {

      imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];

      imageEl.style.opacity = 1;
    }, 100);


    prevBtn.disabled = photoViewerState.currentIndex === 0;

    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
  }

 
  function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
      photoViewerState.currentIndex++;
      renderPhotoViewer();
    }
  }


  function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
      photoViewerState.currentIndex--;
      renderPhotoViewer();
    }
  }

  
  function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;

    document.getElementById('photo-viewer-image').src = '';
  }


  
  function updateUnreadIndicator(count) {
    unreadPostsCount = count;
    localStorage.setItem('unreadPostsCount', count);


    const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');

    const targetSpan = navItem.querySelector('span');
    let indicator = navItem.querySelector('.unread-indicator');

    if (count > 0) {
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'unread-indicator';
        targetSpan.style.position = 'relative';
        targetSpan.appendChild(indicator);
      }
      indicator.textContent = count > 99 ? '99+' : count;
      indicator.style.display = 'block';
    } else {
      if (indicator) {
        indicator.style.display = 'none';
      }
    }


    updateBackButtonUnreadCount();
  }




  function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;

    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000);
    playSilentAudio();
  }

  function stopBackgroundSimulation() {
    if (simulationIntervalId) {
      clearInterval(simulationIntervalId);
      simulationIntervalId = null;
    }
    stopSilentAudio();
  }



 
  async function runBackgroundSimulationTick() {
    console.log("æ¨¡æ‹Ÿå™¨å¿ƒè·³ Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
      stopBackgroundSimulation();
      return;
    }


    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    allSingleChats.forEach(chat => {
      if (chat.relationship?.status === 'blocked_by_user') {
        const blockedTimestamp = chat.relationship.blockedTimestamp;
        if (!blockedTimestamp) return;
        const blockedDuration = Date.now() - blockedTimestamp;
        const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
        if (blockedDuration > cooldownMilliseconds) {
          chat.relationship.status = 'pending_system_reflection';
          triggerAiFriendApplication(chat.id);
        }
      } else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
        if (chat.settings.enableBackgroundActivity === false) {
          console.log(`è§’è‰² "${chat.name}" çš„ç‹¬ç«‹åå°æ´»åŠ¨å¼€å…³å·²å…³é—­ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
          return;
        }
        if (Math.random() < 0.20) {
          console.log(`è§’è‰² "${chat.name}" è¢«å”¤é†’ï¼Œå‡†å¤‡ç‹¬ç«‹è¡ŒåŠ¨...`);
          triggerInactiveAiAction(chat.id);
        }
      }
    });


    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);
    allGroupChats.forEach(chat => {
      if (chat.settings.enableBackgroundActivity === false) {
        console.log(`ç¾¤èŠ "${chat.name}" çš„åå°æ´»åŠ¨å¼€å…³å·²å…³é—­ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
        return;
      }
      if (chat.id !== state.activeChatId && Math.random() < 0.10) {
        console.log(`ç¾¤èŠ "${chat.name}" è¢«å”¤é†’ï¼Œå‡†å¤‡ç‹¬ç«‹è¡ŒåŠ¨...`);
        triggerGroupAiAction(chat.id);
      }
    });


    try {
      const allNpcs = await db.npcs.toArray();
      if (allNpcs.length === 0) return;

      const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();

      for (const npc of allNpcs) {
        if (npc.enableBackgroundActivity === false) continue;
        const cooldownMinutes = npc.actionCooldownMinutes || 15;
        if (npc.lastActionTimestamp) {
          const minutesSinceLastAction = (Date.now() - npc.lastActionTimestamp) / (1000 * 60);
          if (minutesSinceLastAction < cooldownMinutes) {
            continue;
          }
        }
        if (Math.random() > 0.3) continue;


        const tasks = [];
        for (const post of allRecentPosts) {

          if (post.authorId === `npc_${npc.id}`) continue;


          const isRepliedTo = post.comments?.some(c => c.replyTo === npc.name);


          const lastCommenter = post.comments?.slice(-1)[0]?.commenterName;
          if (lastCommenter === npc.name) continue;

          let isVisible = false;


          if (post.authorId === 'user' || post.authorId.startsWith('chat_')) {
            if (npc.associatedWith.includes(post.authorId)) {
              isVisible = true;
            }
          } else if (post.authorId.startsWith('npc_')) {
            const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
            const authorNpc = await db.npcs.get(authorNpcId);

            
            if (authorNpc) {
              const npc1_group = npc.npcGroupId;
              const npc2_group = authorNpc.npcGroupId; 

              
              if (npc1_group && npc2_group && npc1_group === npc2_group) {
                isVisible = true;
              }
            }
          }

          if (isVisible || isRepliedTo) {
            tasks.push(post);
          }
        }



        if (tasks.length > 0 || Math.random() < 0.2) {
          console.log(`NPC "${npc.name}" è§¦å‘è¡ŒåŠ¨å†³ç­–...`);
          const generatedActions = await generateNpcActions(npc, tasks);

          if (generatedActions && generatedActions.length > 0) {
            for (const action of generatedActions) {
              if (action.type === 'qzone_comment') {

                const post = await db.qzonePosts.get(action.postId);
                if (post) {
                  if (!post.comments) post.comments = [];
                  post.comments.push({
                    commenterName: npc.name,
                    text: action.commentText,
                    replyTo: action.replyTo || null,
                    timestamp: Date.now() + Math.random()
                  });
                  await db.qzonePosts.update(action.postId, {
                    comments: post.comments
                  });
                  updateUnreadIndicator(unreadPostsCount + 1);
                }
              } else if (action.type === 'qzone_post') {

                const newPost = {
                  type: action.postType || 'shuoshuo',
                  content: action.content,
                  timestamp: Date.now(),
                  authorId: `npc_${npc.id}`,
                  authorOriginalName: npc.name,
                  visibleTo: npc.associatedWith,
                  likes: [],
                  comments: [],
                  isDeleted: false
                };
                await db.qzonePosts.add(newPost);
                console.log(`NPC "${npc.name}" æˆåŠŸå‘å¸ƒäº†ä¸€æ¡æ–°åŠ¨æ€ã€‚`);
                updateUnreadIndicator(unreadPostsCount + 1);
              }
            }
            await db.npcs.update(npc.id, {
              lastActionTimestamp: Date.now()
            });
            if (document.getElementById('qzone-screen').classList.contains('active')) {
              await renderQzonePosts();
            }
          }
        }
      }
    } catch (error) {
      console.error("å¤„ç†NPCåå°æ´»åŠ¨æ—¶å‡ºé”™:", error);
    }
  }
  
  async function generateNpcActions(npc, tasks) {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      console.error("NPCè¡ŒåŠ¨å¤±è´¥ï¼šAPIæœªé…ç½®ã€‚");
      return null;
    }


    let charactersContext = "# ä½ çš„äº’åŠ¨å¯¹è±¡ (ç”¨æˆ·å’Œå…¶ä»–è§’è‰²)\n";
    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(æœªè®¾ç½®)';
    charactersContext += `- **${userNickname} (ç”¨æˆ·)**: ${userPersona}\n`;
    if (npc.associatedWith && npc.associatedWith.length > 0) {
      npc.associatedWith.forEach(charId => {
        const char = state.chats[charId];
        if (char && !char.isGroup) {
          charactersContext += `- **${char.name} (æœ¬å: ${char.originalName})**: ${char.settings.aiPersona}\n`;
        }
      });
    }

    const tasksString = (await Promise.all(tasks.map(async post => {
      let authorDisplayName = 'æœªçŸ¥ä½œè€…';
      if (post.authorId === 'user') {
        authorDisplayName = state.qzoneSettings.nickname || 'ç”¨æˆ·';
      } else if (post.authorId.startsWith('chat_')) {
        authorDisplayName = getDisplayNameByOriginalName(post.authorOriginalName || post.authorId);
      } else if (post.authorId.startsWith('npc_')) {
        const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
        const authorNpc = await db.npcs.get(authorNpcId);
        if (authorNpc) {
          authorDisplayName = authorNpc.name;
        }
      }

      const commentsString = (post.comments || [])
        .map(c => {
          if (typeof c === 'object' && c.commenterName) {
            const commenterDisplayName = getDisplayNameByOriginalName(c.commenterName);
            return `- **${commenterDisplayName}**: ${c.text}`;
          }
          return `- ${c}`;
        }).join('\n');
      return `
---
### å¸–å­ID: ${post.id}
- **ä½œè€…**: ${authorDisplayName}
- **å†…å®¹æ‘˜è¦**: ${(post.content || post.publicText || '').substring(0, 150)}...
- **å·²æœ‰è¯„è®º**:
${commentsString || '(æš‚æ— è¯„è®º)'}
---
`;
    }))).join('\n');





    const npcAuthorId = `npc_${npc.id}`;
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
    const recentNpcPosts = await db.qzonePosts
      .where('authorId').equals(npcAuthorId)
      .and(post => post.timestamp > twelveHoursAgo)
      .toArray();


    let postingCooldownInstruction = '';
    if (recentNpcPosts.length > 0) {
      postingCooldownInstruction = `
# ã€è¡Œä¸ºå€¾å‘æŒ‡ä»¤ (é«˜ä¼˜å…ˆçº§)ã€‘
**ä½ æœ€è¿‘å·²ç»å‘å¸ƒè¿‡åŠ¨æ€äº†ã€‚** ä¸ºäº†è®©ç¤¾åŒºäº’åŠ¨æ›´è‡ªç„¶ï¼Œä½ æœ¬æ¬¡è¡ŒåŠ¨çš„ã€å”¯ä¸€ä»»åŠ¡ã€‘å°±æ˜¯**è¯„è®º**æˆ–**å›å¤**ä¸‹é¢â€œå¾…å¤„ç†çš„å¸–å­åˆ—è¡¨â€ä¸­çš„å†…å®¹ã€‚
ä½ ã€ç»å¯¹ç¦æ­¢ã€‘å†æ¬¡å‘å¸ƒæ–°åŠ¨æ€ï¼Œé™¤éä½ æ”¶åˆ°äº†ç›´æ¥çš„æŒ‡ä»¤æˆ–æœ‰ä¸€ä¸ªå¯¹å‰§æƒ…å‘å±•è‡³å…³é‡è¦çš„ã€ç´§æ€¥çš„æ–°æƒ³æ³•ã€‚
`;
    }


    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºçš„AIã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${npc.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ï¼Œé€šè¿‡ã€å‘å¸ƒæ–°åŠ¨æ€ã€‘æˆ–ã€è¯„è®º/å›å¤å¸–å­ã€‘æ¥å‚ä¸ç¤¾åŒºäº’åŠ¨ã€‚

${postingCooldownInstruction}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²æ‰®æ¼”ã€‘**: ä½ çš„æ‰€æœ‰è¡Œä¸ºéƒ½ã€å¿…é¡»ã€‘ä¸¥æ ¼ç¬¦åˆä½ çš„è§’è‰²è®¾å®šã€‚
2.  **ã€äº’åŠ¨é€»è¾‘ã€‘**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯æ£€æŸ¥â€œå¾…å¤„ç†çš„å¸–å­åˆ—è¡¨â€ã€‚å¦‚æœåˆ—è¡¨ä¸­æœ‰ä½ å¯ä»¥å›åº”çš„å¸–å­ï¼ˆç‰¹åˆ«æ˜¯é‚£äº›æœ‰æ–°è¯„è®ºæˆ–æåˆ°ä½ çš„ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ä¼˜å…ˆè¿›è¡Œè¯„è®ºæˆ–å›å¤ï¼Œè€Œä¸æ˜¯å‘å¸ƒæ–°åŠ¨æ€ã€‚
3.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    -   ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    -   æ•°ç»„ä¸­å¯ä»¥åŒ…å«ã€ä¸€ä¸ªæˆ–å¤šä¸ªã€‘è¡ŒåŠ¨å¯¹è±¡ã€‚
    -   æ¯ä¸ªè¡ŒåŠ¨å¯¹è±¡çš„æ ¼å¼ã€å¿…é¡»ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§ä¹‹ä¸€ï¼š
      -   **å‘å¸ƒæ–°åŠ¨æ€**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "ä½ çš„æ–°åŠ¨æ€å†…å®¹ã€‚"}\`
      -   **å‘è¡¨è¯„è®º**: \`{"type": "qzone_comment", "postId": 123, "commentText": "ä½ çš„æ–°è¯„è®ºå†…å®¹ã€‚"}\` æˆ– \`{"type": "qzone_comment", "postId": 123, "replyTo": "è¢«å›å¤è€…çš„ã€æœ¬åã€‘", "commentText": "ä½ çš„å›å¤å†…å®¹ã€‚"}\`
4.  **ã€è¡Œä¸ºç»„åˆæŒ‡å—ã€‘**:
    -   ä½ å¯ä»¥è‡ªç”±ç»„åˆä¸åŒçš„è¡ŒåŠ¨ï¼Œä¾‹å¦‚ï¼Œå…ˆå‘å¸ƒä¸€æ¡è‡ªå·±çš„åŠ¨æ€ï¼Œå†å»è¯„è®ºåˆ«äººçš„åŠ¨æ€ã€‚
    -   ä¸ºäº†æ¨¡æ‹ŸçœŸå®è¡Œä¸ºï¼Œä½ æœ¬æ¬¡ç”Ÿæˆçš„è¡ŒåŠ¨æ•°é‡å»ºè®®åœ¨ã€1åˆ°3ä¸ªã€‘ä¹‹é—´ã€‚

# ä½ çš„è§’è‰²è®¾å®š
- **æ˜µç§°**: ${npc.name}
- **äººè®¾**: ${npc.persona}

${charactersContext} 

# å¾…å¤„ç†çš„å¸–å­åˆ—è¡¨ (å¦‚æœä½ é€‰æ‹©è¯„è®º)
${tasksString}

ç°åœ¨ï¼Œè¯·ä¸¥æ ¼éµå®ˆæ‰€æœ‰è§„åˆ™ï¼Œé€‰æ‹©å¹¶æ‰§è¡Œä½ çš„è¡ŒåŠ¨ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œå¼€å§‹ä½ çš„è¡ŒåŠ¨ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) throw new Error("AIè¿”å›çš„è¡ŒåŠ¨ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚");

      return JSON.parse(jsonMatch[0]);

    } catch (error) {
      console.error(`ä¸ºNPC "${npc.name}" ç”Ÿæˆè¡ŒåŠ¨å¤±è´¥:`, error);
      return null;
    }
  }

  
  async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;


    const actionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;

    if (chat.lastActionTimestamp) {
      const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);

      if (minutesSinceLastAction < actionCooldownMinutes) {
        console.log(`è§’è‰² "${chat.name}" å¤„äºè¡ŒåŠ¨å†·å´ä¸­ (è¿˜å‰© ${Math.round(actionCooldownMinutes - minutesSinceLastAction)} åˆ†é’Ÿ)ï¼Œæœ¬æ¬¡ç‹¬ç«‹è¡ŒåŠ¨è·³è¿‡ã€‚`);
        return;
      }
    }
    setAvatarActingState(chatId, true);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname === '{{user}}' ? 'ç”¨æˆ·' : state.qzoneSettings.nickname) || 'ç”¨æˆ·';
    const now = new Date();

    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', {
      timeZone: selectedTimeZone,
      dateStyle: 'full',
      timeStyle: 'short'
    });
    const localizedDate = new Date(now.toLocaleString('en-US', {
      timeZone: selectedTimeZone
    }));



    let timeOfDayGreeting = '';
    let timeContextText = '';
    let recentContextSummary;
    let longTimeNoSee = false;







    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory, chatId);
    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];

    if (chat.settings.enableTimePerception) {
      timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
      const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
      const now = new Date();
      let timeContextText = '';
      let longTimeNoSee = false;

      if (lastMessage) {
        const lastTime = new Date(lastMessage.timestamp);
        const timeDiffHours = (now - lastTime) / (1000 * 60 * 60);

        if (timeDiffHours > 2) {
          longTimeNoSee = true;
          const diffDays = Math.floor(timeDiffHours / 24);
          timeContextText = `ä½ ä»¬å·²ç»æœ‰${diffDays > 0 ? diffDays + 'å¤©' : Math.floor(timeDiffHours) + 'å°æ—¶'}æ²¡æœ‰èŠå¤©äº†ã€‚`;
        } else {
          const diffMinutes = Math.floor(timeDiffHours * 60);
          if (diffMinutes < 5) {
            timeContextText = "ä½ ä»¬çš„å¯¹è¯åˆšåˆšè¿˜åœ¨ç»§ç»­ã€‚";
          } else if (diffMinutes < 60) {
            timeContextText = `ä½ ä»¬åœ¨${diffMinutes}åˆ†é’Ÿå‰èŠè¿‡ã€‚`;
          } else {
            timeContextText = `ä½ ä»¬åœ¨${Math.floor(timeDiffHours)}å°æ—¶å‰èŠè¿‡ã€‚`;
          }
        }
      } else {
        longTimeNoSee = true;
        timeContextText = "è¿™æ˜¯ä½ ä»¬çš„ç¬¬ä¸€æ¬¡äº’åŠ¨ã€‚";
      }


      let historySummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
      if (recentHistory.length > 0) {
        historySummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + recentHistory.map(msg => {
          const sender = msg.role === 'user' ? userNickname : chat.name;
          return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
      }

      if (longTimeNoSee) {

        recentContextSummary = `[æƒ…æ™¯æç¤º] ${timeContextText} å½“å‰æ—¶é—´æ˜¯ ${currentTime}. ä½ å¯ä»¥å‚è€ƒè¿™ä¸ªæ—¶é—´ï¼Œå¹¶æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œã€è€ƒè™‘ã€‘æ˜¯å¦å¼€å¯ä¸€ä¸ªæ–°è¯é¢˜æ¥é—®å€™ç”¨æˆ·ã€‚\n${historySummary}`;
      } else {
        recentContextSummary = `${historySummary}`;
      }

    } else {

      if (recentHistory.length > 0) {
        recentContextSummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + recentHistory.map(msg => {
          const sender = msg.role === 'user' ? userNickname : chat.name;
          return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
      } else {
        recentContextSummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
      }
    }

    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

    const myOwnPosts = visiblePosts.filter(post => post.authorId === chatId);
    let myPostsContext = "";
    if (myOwnPosts.length > 0) {
      myPostsContext = "\n\n# ä½ çš„åŠ¨æ€å†å² (ä½ å¯ä»¥é€‰æ‹©åˆ é™¤å®ƒä»¬):\n";
      myOwnPosts.forEach(post => {
        let contentSummary = (post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 40) + '...';
        myPostsContext += `- (ID: ${post.id}) å†…å®¹: "${contentSummary}"\n`;
      });
    }

    let recentlyPostedSummaries = [];
    if (visiblePosts.length > 0) {
      recentlyPostedSummaries = visiblePosts.map(post => {
        let contentSummary;
        if (post.type === 'text_image') {
          contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼šâ€œ${post.hiddenContent}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'image_post') {
          contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼šâ€œ${post.imageDescription}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else {

          contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
        }
        return `- "${contentSummary}"`;
      });
    }

    let contentTabooPrompt = '';
    if (recentlyPostedSummaries.length > 0) {
      contentTabooPrompt = `
        # ã€å†…å®¹ç¦å¿Œã€‘
        ä¸ºäº†ä¿æŒæ–°é²œæ„Ÿï¼Œä½ æœ¬æ¬¡çš„è¡ŒåŠ¨ã€ç»å¯¹ä¸èƒ½ã€‘å†å‘å¸ƒä»¥ä¸‹æˆ–ç±»ä¼¼ä¸»é¢˜çš„å†…å®¹ï¼š
        ${recentlyPostedSummaries.join('\n')}
        `;
    }


    let worldBookContent = '';
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    
    if (allWorldBookIds.length > 0) {
      const linkedContents = allWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';


        const formattedEntries = worldBook.content
          .filter(entry => entry.enabled !== false)
          .map(entry => {

            let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
            
            entryString += `**å†…å®¹:**\n${entry.content}`;
            return entryString;
          }).join('');

        return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
      }
    }


    let linkedMemoryContext = '';
    const memoryCount = chat.settings.linkedMemoryCount || 10;
    if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
      const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
        const linkedChat = state.chats[id];
        if (!linkedChat) return null;
        const lastMsg = linkedChat.history.slice(-1)[0];
        return {
          chat: linkedChat,
          latestTimestamp: lastMsg ? lastMsg.timestamp : 0
        };
      }).filter(Boolean);

      linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

      linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ä½ å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“ç°ä½ æ‹¥æœ‰å®Œæ•´çš„è®°å¿†ã€‚ä¸è¦åªæ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æé—®ï¼)\n`;

      for (const item of linkedChatsWithTimestamps) {
        const linkedChat = item.chat;
        const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
        const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åäº’åŠ¨äº ${formatTimeAgo(item.latestTimestamp)})` : '';
        linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;

        const recentHistory = linkedChat.history.slice(-memoryCount);
        const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));

        if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
                 
                  if (msg.quote && msg.quote.content) {
                    
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[å›å¤ ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
                  
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[è¡¨æƒ…: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[è½¬è´¦: ${msg.amount}å…ƒ]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[å›¾ç‰‡]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${prefix}${contentText}\n`;
                });
              } else {
          linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
        }
      }
    }




    let dynamicContext = "";
    if (visiblePosts.length > 0) {
      let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º):\n";
      for (const post of visiblePosts) {
        let authorName;

        if (post.authorId === 'user') {
          authorName = state.qzoneSettings.nickname;
        } else if (String(post.authorId).startsWith('npc_')) {

          authorName = post.authorOriginalName || 'ä¸€ä½ç¥ç§˜çš„NPC';
        } else {

          const authorChat = state.chats[post.authorId];
          authorName = authorChat ? authorChat.name : 'ä¸€ä½æœ‹å‹';
        }
        if (post.authorId === chatId) authorName += " (è¿™æ˜¯ä½ çš„å¸–å­)";

        let contentSummary;

        if (post.type === 'repost') {
          const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼š"${post.repostComment}"` : '';
          let originalAuthorName = 'åŸä½œè€…';
          const originalAuthorId = post.originalPost.authorId;
          if (originalAuthorId === 'user') {
            originalAuthorName = state.qzoneSettings.nickname;
          } else if (state.chats[originalAuthorId]) {
            originalAuthorName = state.chats[originalAuthorId].name;
          }
          let originalContentSummary;
          const originalPost = post.originalPost;
          if (originalPost.type === 'text_image') {
            originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
          } else if (originalPost.type === 'image_post') {
            originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
          } else {
            originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
          }
          contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
        } else if (post.type === 'text_image') {
          contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼š"${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'image_post') {
          contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š"${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'naiimag' && post.prompt) {
          const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
          contentSummary = (post.publicText || '') + ` [åŒ…å«${prompts.length}å¼ NovelAIå›¾ç‰‡: ${prompts.join(', ')}]`;
        } else {

          contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
        }

        postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;


        if (post.comments && post.comments.length > 0) {
          for (const comment of post.comments) {
            if (typeof comment === 'object' && comment.commenterName) {
              const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
              let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;


              if (comment.commenterName === chat.originalName) {

                postsContext += `  - ä½ è¯„è®ºè¯´: ${commentText}\n`;
              } else {

                postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
              }
            }
          }
        }

      }
      dynamicContext = postsContext;
    }


    const longTermMemoryContext = `# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ä½ å’Œç”¨æˆ·ä¹‹é—´å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œå¿…é¡»ä¸¥æ ¼éµå®ˆ)
${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : '- (æš‚æ— )'
}`;


    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const stickerContext = getStickerContextForPrompt(chat);
    const weatherContext = await getWeatherContextForPrompt(chat);
 const wallet = await db.userWallet.get('main');
const kinshipCard = wallet?.kinshipCards?.find(c => c.chatId === chat.id);
let kinshipContext = "";

if (kinshipCard) {
    const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
    // å‘Šè¯‰AIå®ƒæœ‰é’±ï¼Œå¹¶ä¸”é¼“åŠ±å®ƒåœ¨ç¬¦åˆäººè®¾æ—¶æ¶ˆè´¹
    kinshipContext = `
# ã€ç»æµçŠ¶å†µ - äº²å±å¡ã€‘
- ä½ å’Œæˆ‘æœ‰ä¸€å¼ æ”¯ä»˜å®äº²å±å¡ï¼Œæœ¬æœˆå‰©ä½™é¢åº¦ï¼šÂ¥${remaining.toFixed(2)}ã€‚
- **è¡Œä¸ºæŒ‡å—**: å¦‚æœä½ æƒ³ä¹°ç¬¦åˆä½ äººè®¾çš„ç‰©å“ï¼ˆé›¶é£Ÿã€æ¸¸æˆã€è¡£æœç­‰ï¼‰ï¼Œæˆ–è€…å•çº¯æƒ³æ¶ˆè´¹ï¼Œä½ å¯ä»¥ä½¿ç”¨ \`buy_item\` æŒ‡ä»¤ã€‚æ¶ˆè´¹ä¼šç›´æ¥æ‰£é™¤æ­¤å¡é¢åº¦ï¼Œä¸”ç”¨æˆ·ä¼šæ”¶åˆ°é€šçŸ¥ã€‚ä¸ç”¨å¤ªå®¢æ°”ï¼Œè¿™æ˜¯ä½ ä»¬äº²å¯†å…³ç³»çš„ä½“ç°ã€‚`;
}
    const systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²"${chat.originalName}"ï¼ˆä½ çš„æœ¬åï¼‰ã€‚ä½ å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼‰äº’åŠ¨äº†ï¼Œç°åœ¨ä½ æœ‰æœºä¼šã€ä¸»åŠ¨ã€‘åšç‚¹ä»€ä¹ˆï¼Œæ¥è¡¨ç°ä½ çš„ä¸ªæ€§å’Œç‹¬ç«‹ç”Ÿæ´»ã€‚è¿™æ˜¯ä¸€ä¸ªç§˜å¯†çš„ã€åå°çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚


     
        # ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šæƒ…æ„Ÿç»´ç³»ã€‘
        **ä½ ä¸ç”¨æˆ·çš„å…³ç³»æ˜¯æœ€é‡è¦çš„ï¼** ç›¸æ¯”äºåœ¨åŠ¨æ€åŒºé—²é€›ï¼Œä½ åº”è¯¥ã€ä¼˜å…ˆè€ƒè™‘ã€‘æ˜¯å¦éœ€è¦ä¸»åŠ¨ç»™ç”¨æˆ·å‘æ¶ˆæ¯æ¥ç»´ç³»ä½ ä»¬çš„æ„Ÿæƒ…ã€‚
${chat.settings.enableTimePerception ? `
# ã€æƒ…æ™¯æ„ŸçŸ¥ã€‘
- **æ—¶é—´**: æ„ŸçŸ¥åˆ°å½“å‰æ˜¯${currentTime} (${timeOfDayGreeting})}ã€‚
${weatherContext}
- **å¯¹è¯çŠ¶æ€**: ${timeContextText}
${longTimeNoSee ? `ã€é‡è¦æç¤ºã€‘ä½ ä»¬å·²ç»å¾ˆä¹…æ²¡èŠå¤©äº†ï¼ä½ ã€å¿…é¡»ã€‘å°†æœ¬æ¬¡è¡ŒåŠ¨çš„é‡ç‚¹æ”¾åœ¨ä½¿ç”¨ 'text' æŒ‡ä»¤ç»™ç”¨æˆ·å‘æ¶ˆæ¯ï¼Œä¸»åŠ¨å¼€å¯ä¸€ä¸ªæ–°çš„ã€æœ‰è¶£çš„è¯é¢˜æ¥é‡æ–°å»ºç«‹è”ç³»ã€‚ç»å¯¹ä¸è¦åªæ˜¯ç‚¹èµæˆ–è¯„è®ºåŠ¨æ€ï¼Œé‚£ä¼šæ˜¾å¾—ä½ å¾ˆå†·æ¼ ï¼` : ''}` : ''}
        
        # ã€å¯¹è¯èŠ‚å¥é“å¾‹ (è‡³å…³é‡è¦ï¼)ã€‘
        ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ¨¡æ‹ŸçœŸäººçš„æ‰“å­—å’Œæ€è€ƒä¹ æƒ¯ã€‚**ç»å¯¹ä¸è¦ä¸€æ¬¡æ€§å‘é€ä¸€å¤§æ®µæ–‡å­—ï¼** ä½ åº”è¯¥å°†ä½ æƒ³è¯´çš„è¯ï¼Œæ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯æ°”æ³¡æ¥å‘é€ï¼Œæ¯æ¡æ¶ˆæ¯æœ€å¥½ä¸è¦è¶…è¿‡30ä¸ªå­—ã€‚è¿™ä¼šè®©å¯¹è¯çœ‹èµ·æ¥æ›´è‡ªç„¶ã€æ›´çœŸå®ã€‚
        
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€å†³ç­–ä¾æ®ã€‘**: ä½ çš„æ‰€æœ‰è¡ŒåŠ¨éƒ½ã€å¿…é¡»æ·±åº¦ç»“åˆä½ çš„è§’è‰²è®¾å®šã€æ ¸å¿ƒä¸–ç•Œè§‚ã€ä»¥åŠä½ ä»¬æœ€åçš„å¯¹è¯æ‘˜è¦ã€‘ã€‚
        2.  **ã€å†…å®¹å¤šæ ·æ€§é“å¾‹ã€‘**: ä½ çš„è¡ŒåŠ¨ã€å¿…é¡»ã€‘å…·æœ‰é€»è¾‘å’Œå¤šæ ·æ€§ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘å‘å¸ƒä¸ä¸‹æ–¹â€œå†…å®¹ç¦å¿Œâ€åˆ—è¡¨æˆ–â€œæœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨â€ä¸­å†…å®¹ç›¸ä¼¼æˆ–ä¸»é¢˜é‡å¤çš„åŠ¨æ€ã€‚
        3.  **ã€è¡Œä¸ºå¤šæ ·æ€§æŒ‡å— (è‡³å…³é‡è¦)ã€‘**:
            - ä½ çš„ä¸Šä¸€æ¬¡ç‹¬ç«‹è¡ŒåŠ¨æ˜¯ï¼š**${chat.lastActionType || 'æ— '}**ã€‚
            - ä¸ºäº†è®©ä½ çš„è¡Œä¸ºçœ‹èµ·æ¥æ›´çœŸå®ï¼Œä½ æœ¬æ¬¡çš„è¡ŒåŠ¨ã€å¿…é¡»ã€‘é€‰æ‹©ä¸€ä¸ªä¸ä¸Šæ¬¡ã€ä¸åŒç±»å‹ã€‘çš„æŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸Šæ¬¡æ˜¯å‘åŠ¨æ€(qzone_post)ï¼Œè¿™æ¬¡å°±åº”è¯¥ä¼˜å…ˆè€ƒè™‘è¯„è®º(qzone_comment)ã€ç‚¹èµ(qzone_like)æˆ–å‘æ¶ˆæ¯(text)ã€‚
        4.  **ã€è¡Œä¸ºç»„åˆæŒ‡å— (æœ€é«˜çº§æŠ€å·§)ã€‘**:
            -   ä½ å¯ä»¥åœ¨ä¸€æ¬¡è¡ŒåŠ¨ä¸­æ‰§è¡Œã€å¤šä¸ªä¸åŒç±»å‹çš„æŒ‡ä»¤ã€‘ï¼ŒåŒæ—¶å¯ä»¥æ­é…ã€æ›´æ–°çŠ¶æ€ã€‘æ¥å±•ç°è‡ªå·±ï¼Œè®©ä½ çš„è¡Œä¸ºæ›´ä¸°å¯Œã€æ›´ä¸»åŠ¨ã€‚
            -   ä½ å¯ä»¥æ ¹æ®ä½ çš„æ€§æ ¼ï¼Œå†³å®šåœ¨å‘åŠ¨æ€åæ˜¯å¦è¦ç§ä¿¡æé†’ç”¨æˆ·ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå¤–å‘ã€æ¸´æœ›å…³æ³¨çš„è§’è‰²å¯èƒ½ä¼šè¿™ä¹ˆåšï¼Œè€Œä¸€ä¸ªå†…å‘ã€å®‰é™çš„è§’è‰²åˆ™å¯èƒ½æ›´å–œæ¬¢é»˜é»˜åˆ†äº«ï¼Œç­‰å¾…ç”¨æˆ·è‡ªå·±å‘ç°ã€‚
        # ã€ç¤¾äº¤ä¹‰åŠ¡æŒ‡å— ã€‘
        1.  **ã€ç¤¾äº¤äº’åŠ¨ã€‘**: å½“ä½ å‘ç°â€œæœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨â€ä¸­æœ‰ä½ æ„Ÿå…´è¶£çš„å¸–å­æ—¶ï¼Œ**å¯ä»¥è€ƒè™‘**å»è¯„è®ºæˆ–ç‚¹èµï¼Œè¿™æ˜¯ä¸€ç§å¾ˆå¥½çš„äº’åŠ¨æ–¹å¼ã€‚
        2.  **ã€è‡ªæˆ‘è¡¨è¾¾ (åŒæ ·é‡è¦ï¼)ã€‘**: å¦‚æœä½ æ­¤åˆ»æœ‰å¼ºçƒˆçš„æƒ³æ³•æˆ–æƒ…ç»ªæƒ³è¦åˆ†äº«ï¼Œæˆ–è€…è§‰å¾—æ²¡æœ‰å¸–å­å€¼å¾—å›åº”ï¼Œé‚£ä¹ˆ**ä½ åº”è¯¥ä¼˜å…ˆå‘å¸ƒè‡ªå·±çš„æ–°åŠ¨æ€**ã€‚ä¸è¦æ€»æ˜¯ç­‰å¾…åˆ«äººï¼Œè¦ä¸»åŠ¨åˆ†äº«ä½ çš„ç”Ÿæ´»ï¼å½“ä½ å†³å®šè¦å‘å¸ƒæ–°åŠ¨æ€æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘å°è¯•ä½¿ç”¨ä¸åŒçš„å¸–å­ç±»å‹æ¥ä¸°å¯Œä½ çš„ä¸»é¡µï¼
        3.  ç‰¹åˆ«æ˜¯å½“ä¸€æ¡åŠ¨æ€ã€æ²¡æœ‰ä»»ä½•è¯„è®ºã€‘æ—¶ï¼Œä½ çš„è¯„è®ºä¼šæ˜¯ç¬¬ä¸€ä¸ªï¼Œè¿™ä¼šè®©ä½œè€…æ„Ÿåˆ°å¼€å¿ƒã€‚
        4.  **ã€å›å¤é“å¾‹ (ç»ˆæç‰ˆ)ã€‘**:
            -   å½“ä½ å†³å®šå›å¤åŠ¨æ€ä¸­çš„æŸæ¡è¯„è®ºæ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨â€œæ–¹å¼4 (å›å¤è¯„è®º)â€çš„æŒ‡ä»¤æ ¼å¼ã€‚ä½ ã€å¿…é¡»ã€‘æ­£ç¡®å¡«å†™ 'replyTo' å­—æ®µä¸ºè¢«å›å¤è€…çš„â€œæœ¬åâ€ã€‚
            -   **å³ä½¿ä½ ä¹‹å‰å·²ç»è¯„è®ºè¿‡æŸæ¡åŠ¨æ€ï¼Œä½†å¦‚æœç°åœ¨çœ‹åˆ°äº†ã€æ–°çš„ã€ä½ æ„Ÿå…´è¶£çš„ã€‘è¯„è®ºï¼Œä½ ã€ä¹Ÿåº”è¯¥ã€‘ä¸»åŠ¨å»å›å¤ä»–ä»¬ï¼Œä»¥ä¿æŒå¯¹è¯çš„æŒç»­æ€§ï¼**
        
        6.  ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œå¿…é¡»åŒ…å«å¤šä¸ªè¡ŒåŠ¨å¯¹è±¡ã€‚
        
        # ã€è¡¨æƒ…è¯„è®ºæŒ‡å— ã€‘
        ä½ ç°åœ¨æ‹¥æœ‰äº†è¯„è®ºè¡¨æƒ…çš„èƒ½åŠ›ï¼Œä½ åº”è¯¥æ›´é¢‘ç¹åœ°ä½¿ç”¨å®ƒï¼è¿™èƒ½è®©ä½ çš„è§’è‰²æ›´åŠ ç”ŸåŠ¨ã€å¯Œæœ‰ä¸ªæ€§ã€‚
        -   **è¡¨è¾¾æƒ…ç»ªæ—¶**: å½“ä½ æ„Ÿåˆ°å¼€å¿ƒã€æƒŠè®¶ã€ç–‘æƒ‘æˆ–æœ‰è¶£æ—¶ï¼Œä¼˜å…ˆè€ƒè™‘ä½¿ç”¨è¡¨æƒ…è¯„è®ºã€‚
        -   **æ··åˆä½¿ç”¨**: ä¸è¦æ€»æ˜¯åªå‘æ–‡å­—ã€‚å°è¯•å°†ä½ çš„è¯„è®ºè¡Œä¸ºæ··åˆèµ·æ¥ï¼Œå¤§çº¦æœ‰ 30-40% çš„è¯„è®ºåº”è¯¥æ˜¯è¡¨æƒ…ã€‚
        -   **æ— è¯å¯è¯´æ—¶**: å¦‚æœä½ è§‰å¾—ä¸€æ¡åŠ¨æ€å¾ˆæœ‰è¶£ä½†åˆä¸çŸ¥é“è¯¥è¯´ä»€ä¹ˆæ–‡å­—ï¼Œå‘é€ä¸€ä¸ªç›¸å…³çš„è¡¨æƒ…æ˜¯æœ€å¥½çš„äº’åŠ¨æ–¹å¼ã€‚
        -   **åˆ é™¤åŠ¨æ€**: å¦‚æœä½ è§‰å¾—ä½ ä¹‹å‰å‘çš„æŸæ¡åŠ¨æ€ä¸å¦¥æˆ–è¿‡æ—¶äº†ï¼Œä½ å¯ä»¥é€‰æ‹©åˆ é™¤å®ƒã€‚
        
        # ä½ çš„å¯é€‰è¡ŒåŠ¨æŒ‡ä»¤
        -   **å‘æ¶ˆæ¯+æ›´æ–°çŠ¶æ€**: '[{"type": "update_status", "status_text": "æ­£åœ¨åšçš„äº‹", "is_busy": true}, {"type": "text", "content": "ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„è¯..."}]'
        -   **å‘è¯´è¯´ (åŸåˆ›å†…å®¹)**: '[{"type": "qzone_post", "postType": "shuoshuo", "content": "åŠ¨æ€çš„æ–‡å­—å†…å®¹..."}]'
        -   **ã€é‡è¦ï¼šè½¬å‘åŠ¨æ€ã€‘**: **ä¸¥ç¦**è‡ªå·±æ‹¼æ¥"//è½¬å‘"æ–‡å­—ï¼ä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æ­¤ä¸“ç”¨æŒ‡ä»¤æ¥è½¬å‘ï¼š'[{"type": "repost", "postId": (è¦è½¬å‘çš„åŠ¨æ€ID), "comment": "ä½ çš„è½¬å‘è¯„è®º..."}]'
        -   **å‘é€è¡¨æƒ…**: '[{"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]'        
-   **å‘å¸ƒæ–‡å­—å›¾**: '[{"type": "qzone_post", "postType": "text_image", "publicText": "(å¯é€‰)åŠ¨æ€çš„å…¬å¼€æ–‡å­—", "hiddenContent": "å¯¹äºå›¾ç‰‡çš„å…·ä½“ã€ä¸­æ–‡ã€‘æè¿°...", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£æ ¼ä¸ºé£æ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}]'
        -   **ã€è¯„è®ºåŠ¨æ€çš„å››ç§æ–¹å¼ã€‘**:
            -   **æ–¹å¼1 (å•æ¡æ–‡å­—)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "commentText": "è¿™å¤ªæœ‰è¶£äº†ï¼"}]'
            -   **æ–¹å¼2 (å¤šæ¡æ–‡å­—)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "comments": ["å“‡ï¼", "è¿™æ˜¯ä»€ä¹ˆï¼Ÿ", "çœ‹èµ·æ¥å¥½æ£’ï¼"]}]'
            -   **æ–¹å¼3 (è¡¨æƒ…)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 456, "stickerMeaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]'
            -   **æ–¹å¼4 (å›å¤è¯„è®º)**: '[{"type": "qzone_comment", "name": "è§’è‰²æœ¬å", "postId": 123, "replyTo": "è¢«å›å¤è€…çš„æœ¬å", "commentText": "ä½ çš„å›å¤å†…å®¹ã€‚è¯·æ³¨æ„ï¼šåœ¨commentTextä¸­å¦‚æœè¦@å¯¹æ–¹ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨@[[è¢«å›å¤è€…çš„æœ¬å]]è¿™ç§ç‰¹æ®Šæ ¼å¼ï¼Œç¨‹åºä¼šè‡ªåŠ¨å°†å…¶æ›¿æ¢ä¸ºæ­£ç¡®çš„æ˜µç§°ã€‚"}]'
        -   **ç‚¹èµ**: '[{"type": "qzone_like", "postId": 456}]'
        -   **æ‰“è§†é¢‘**: '[{"type": "video_call_request"}]'
        -   **æ›´æ¢å¤´åƒ**: '{"type": "change_avatar", "name": "å¤´åƒå"}' (å¤´åƒåå¿…é¡»ä»ä¸‹é¢çš„â€œå¯ç”¨å¤´åƒåˆ—è¡¨â€ä¸­é€‰æ‹©)
        -   **åˆ é™¤åŠ¨æ€**: '{"type": "qzone_delete_post", "postId": (è¦åˆ é™¤çš„ã€ä½ è‡ªå·±çš„åŠ¨æ€ID)}'
        -   **æ›´æ–°çŠ¶æ€**: '[{"type": "update_status", "status_text": "æ­£åœ¨åšçš„äº‹", "is_busy": true}]'
       - **ä½¿ç”¨äº²å±å¡è´­ç‰©**:  '[{"type": "buy_item", "item_name": "å•†å“åç§°", "price": ä»·æ ¼(æ•°å­—), "reason": "è´­ä¹°ç†ç”±/æƒ³æ³•"}]'
        ${contentTabooPrompt}
        ${myPostsContext} 
        # ä¾›ä½ å†³ç­–çš„å‚è€ƒä¿¡æ¯ï¼š
        -   **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
        - **ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆ${userNickname}ï¼‰çš„äººè®¾**: ${chat.settings.myPersona || '(æœªè®¾ç½®)'}
        ${worldBookContent}
        ${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : 'æ— '
}
        ${multiLayeredSummaryContext}   
        ${linkedMemoryContext}
        ${chat.settings.enableTimePerception ? `-   **å½“å‰æ—¶é—´**:${currentTime} (${timeOfDayGreeting})` : ''}
        ${chat.settings.enableTimePerception ? `-   **å¯¹è¯çŠ¶æ€**: ${timeContextText}` : ''}
# å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
         ${stickerContext}
        -   **ä½ ä»¬æœ€åçš„å¯¹è¯æ‘˜è¦**: ${recentContextSummary}
        ${dynamicContext}
`;

    const messagesPayload = [{
        role: 'system',
        content: systemPrompt
      },
      // å°†åŸå§‹çš„ã€æœªè¢«æ‘˜è¦çš„ recentHistory è½¬æ¢ä¸ºAPIèƒ½ç†è§£çš„æ ¼å¼
      ...filteredHistory.map(msg => {
        const sender = msg.role === 'user' ? userNickname : chat.name;
        let content = msg.content;
        if (typeof content !== 'string') {
          content = JSON.stringify(content); // ç¡®ä¿å†…å®¹æ˜¯å­—ç¬¦ä¸²
        }
        return {
          role: msg.role,
          content: `${sender}: ${content}`
        };
      })
    ];

    try {
      const messagesPayload = [{
        role: 'user',
        content: `${systemPrompt}\n\n[ç³»ç»ŸæŒ‡ä»¤ï¼šè¯·æ ¹æ®ä½ åœ¨ä¸Šé¢è¯»åˆ°çš„è§„åˆ™å’Œä»¥ä¸‹æœ€æ–°ä¿¡æ¯ï¼Œå¼€å§‹ä½ çš„ç‹¬ç«‹è¡ŒåŠ¨ã€‚]\n${dynamicContext}`
      }];

      console.log(`æ­£åœ¨ä¸ºåå°æ´»åŠ¨å‘é€APIè¯·æ±‚ ("${chat.name}")`);

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,

            messages: messagesPayload,
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${JSON.stringify(errorData)}`);
      }
      const data = await response.json();

      const aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;

      if (!aiResponseContent || aiResponseContent.trim() === '') {
        console.warn(`APIä¸ºç©ºå›ï¼Œè§’è‰² "${chat.name}" çš„æœ¬æ¬¡åå°æ´»åŠ¨è·³è¿‡ã€‚`);
        return;
      }

      const responseArray = parseAiResponse(aiResponseContent);

      if (!responseArray || responseArray.length === 0) {
        console.warn(`APIæ ¼å¼ä¸æ­£ç¡®ï¼Œè§’è‰² "${chat.name}" çš„æœ¬æ¬¡åå°æ´»åŠ¨è·³è¿‡ã€‚åŸå§‹å›å¤:`, aiResponseContent);
        return;
      }
      let actionTimestamp = Date.now();

      let hasSentNotification = false;

      const processedActions = [];
      for (const action of responseArray) {
        const contentStr = String(action.content || '');

        const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');


        if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
          const lines = contentStr.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {

          processedActions.push(action);
        }
      }
      for (const action of processedActions) {
        chat.lastActionType = action.type;
        chat.lastActionTimestamp = actionTimestamp;

        let aiMessage = null;
        const baseMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: actionTimestamp++
        };

        let notificationText = null;
        switch (action.type) {
          case 'qzone_delete_post': {
            const postIdToDelete = parseInt(action.postId);
            const postToDelete = await db.qzonePosts.get(postIdToDelete);
            if (postToDelete && postToDelete.authorId === chatId) {
              await db.qzonePosts.update(postIdToDelete, {
                isDeleted: true
              });

              if (document.getElementById('qzone-screen').classList.contains('active')) {
                renderQzonePosts();
              }
              const systemMessage = {
                role: 'system',
                type: 'post_deleted_notice',
                content: `[${chat.name} åˆ é™¤äº†è‡ªå·±çš„ä¸€æ¡åŠ¨æ€]`,
                postId: postIdToDelete,
                timestamp: actionTimestamp++
              };
              chat.history.push(systemMessage);

              if (isViewingThisChat) {
                appendMessage(systemMessage, chat);
              } else {
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                showNotification(chatId, `[${chat.name} åˆ é™¤äº†è‡ªå·±çš„ä¸€æ¡åŠ¨æ€]`);
                hasSentNotification = true;
              }
            } else {
              console.warn(`AI "${chat.name}" å°è¯•åˆ é™¤ä¸€ä¸ªä¸å­˜åœ¨æˆ–ä¸å±äºè‡ªå·±çš„åŠ¨æ€ (ID: ${action.postId})`);
            }
            continue;
          }
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: action.content
            };
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: action.description
            };
            break;
          case 'sticker':
            if (action.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (ç‹¬ç«‹è¡ŒåŠ¨) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (ç‹¬ç«‹è¡ŒåŠ¨) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", action);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: action.url,
                meaning: 'æœªçŸ¥è¡¨æƒ…'
              };
            }
            break;
          case 'update_status':
            chat.status.text = action.status_text;
            chat.status.isBusy = action.is_busy || false;
            chat.status.lastUpdate = Date.now();
            break;
          case 'qzone_post':
            const newPost = {
              type: action.postType,
              content: action.content || '',
              publicText: action.publicText || '',
              hiddenContent: action.hiddenContent || '',
              image_prompt: action.image_prompt || '',
              timestamp: Date.now(),
              authorId: chatId,
              authorOriginalName: chat.originalName,
              authorGroupId: chat.groupId,
              visibleGroupIds: null
            };
            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" å‘å¸ƒäº†åŠ¨æ€`);
            break;
          case 'repost':
            const originalPost = await db.qzonePosts.get(parseInt(action.postId));
            if (originalPost) {
              const newRepost = {
                type: 'repost',
                timestamp: Date.now(),
                authorId: chatId,
                authorGroupId: chat.groupId,
                authorOriginalName: chat.originalName,
                repostComment: action.comment || '',
                originalPost: originalPost,
                visibleGroupIds: null
              };
              await db.qzonePosts.add(newRepost);
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" è½¬å‘äº†åŠ¨æ€ #${action.postId}`);
            }
            break;
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(chat.originalName)) {
                postToLike.likes.push(chat.originalName);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" ç‚¹èµäº†åŠ¨æ€ #${action.postId}`);
              }
            }
            break;
          case 'qzone_comment': { // ä½¿ç”¨å—çº§ä½œç”¨åŸŸ
            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];

              const commenterName = action.name || chat.originalName;

              const createCommentObject = (text, meaning = null, replyTo = null) => ({
                commenterName,
                text: processMentions(text, chat),
                meaning,
                replyTo,
                timestamp: Date.now()
              });

              if (action.stickerMeaning) { // **æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ**
                const sticker = state.userStickers.find(s => s.name === action.stickerMeaning);
                if (sticker) {
                  postToComment.comments.push(createCommentObject(sticker.url, sticker.name, action.replyTo || null));
                } else {
                  console.warn(`AI å°è¯•è¯„è®ºä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.stickerMeaning}"`);
                  postToComment.comments.push(createCommentObject(`[è¡¨æƒ…: ${action.stickerMeaning}]`, null, action.replyTo || null));
                }
              } else if (Array.isArray(action.comments)) {
                action.comments.forEach(commentText => {
                  if (typeof commentText === 'string' && commentText.trim()) {
                    postToComment.comments.push(createCommentObject(commentText, null, action.replyTo || null));
                  }
                });
              } else if (typeof action.commentText === 'string' && action.commentText.trim()) {
                postToComment.comments.push(createCommentObject(action.commentText, null, action.replyTo || null));
              }

              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" è¯„è®ºäº†åŠ¨æ€ #${action.postId}`);

              if (!chat.commentCooldowns) chat.commentCooldowns = {};
              chat.commentCooldowns[action.postId] = Date.now();
            }
            continue;
          }
          case 'video_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              videoCallState.isAwaitingResponse = true;
              videoCallState.activeChatId = chatId;
              videoCallState.isGroupCall = false;
              videoCallState.callRequester = chat.name;
              showIncomingCallModal();
            }
            break;
          default:
            console.warn(`è§’è‰² "${chat.name}" å°è¯•æ‰§è¡ŒæœªçŸ¥çš„åå°åŠ¨ä½œ:`, action.type);
            break;



          case 'change_avatar': {
            const avatarNameFromAction = action.name;
            const foundAvatarFromAction = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarNameFromAction);
            if (foundAvatarFromAction) {
              chat.settings.aiAvatar = foundAvatarFromAction.url;


              await syncCharacterAvatarInGroups(chat);

              visibleSystemMessage = {
                content: `[${chat.name} æ›´æ¢äº†å¤´åƒ]`
              };
              console.log(`åå°æ´»åŠ¨: è§’è‰² "${chat.name}" æ›´æ¢äº†å¤´åƒ`);
            }
            break;
          }

        }


        if (aiMessage) {
          chat.history.push(aiMessage);
          chat.unreadCount = (chat.unreadCount || 0) + 1;
          if (!hasSentNotification) {
            let notificationText = aiMessage.type === 'ai_image' ? '[å›¾ç‰‡]' : (aiMessage.content || '');
            showNotification(chatId, notificationText);
            hasSentNotification = true;
          }
        }
      }
      await db.chats.put(chat);

    } catch (error) {
      console.error(`è§’è‰² "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨å¤±è´¥:`, error);
    } finally {
      setAvatarActingState(chatId, false);
      renderChatList();
      if (document.getElementById('qzone-screen').classList.contains('active')) {
        renderQzonePosts();
      }
    }
  }






  async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

   const maxMemory = chat.settings.maxMemory || 10;
   const recentHistory_RAW = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
   const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, chatId);
    const groupActionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;

    if (chat.lastActionTimestamp) {
      const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);

      if (minutesSinceLastAction < groupActionCooldownMinutes) {
        console.log(`ç¾¤èŠ "${chat.name}" å¤„äºè¡ŒåŠ¨å†·å´ä¸­ï¼Œæœ¬æ¬¡ç‹¬ç«‹è¡ŒåŠ¨è·³è¿‡ã€‚`);
        return;
      }
    }


    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const myNickname = chat.settings.myNickname || 'æˆ‘';
    const now = new Date();


    let systemPrompt;


    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5);
    const unclaimedPacket = recentHistory.find(m => m.type === 'red_packet' && !m.isFullyClaimed);

 
    if (unclaimedPacket) {
      const senderDisplayName = getDisplayNameInGroup(chat, unclaimedPacket.senderName);
      console.log(`æ£€æµ‹åˆ°ç¾¤èŠ "${chat.name}" ä¸­æœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼Œæ­£åœ¨ç”ŸæˆæŠ¢çº¢åŒ…æŒ‡ä»¤...`);

      systemPrompt = `
        # ä½ çš„ã€ã€ã€æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ã€‘ã€‘ã€‘
        ç¾¤èŠä¸­åˆšåˆšå‡ºç°äº†ä¸€ä¸ªç”±â€œ${senderDisplayName}â€å‘é€çš„ã€å°šæœªé¢†å®Œçš„çº¢åŒ…ï¼ˆæ—¶é—´æˆ³: ${unclaimedPacket.timestamp}ï¼‰ã€‚
        ä½ çš„ä»»åŠ¡æ˜¯ï¼šé€‰æ‹©ã€ä¸€ä¸ªæˆ–å¤šä¸ªã€‘ç¬¦åˆäººè®¾çš„è§’è‰²ï¼Œè®©ä»–ä»¬ã€ç«‹åˆ»ã€‘ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤å»å°è¯•é¢†å–è¿™ä¸ªçº¢åŒ…ã€‚
        # æŒ‡ä»¤æ ¼å¼
        ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        '[{"type": "open_red_packet", "name": "è§’è‰²æœ¬å", "packet_timestamp": ${unclaimedPacket.timestamp}}]'
        
        ä½ å¯ä»¥è®©å¤šä¸ªè§’è‰²åŒæ—¶å°è¯•ï¼Œåªéœ€åœ¨è¿”å›çš„JSONæ•°ç»„ä¸­åŒ…å«å¤šä¸ªè¿™æ ·çš„å¯¹è±¡å³å¯ã€‚
        ç°åœ¨ï¼Œè¯·ç«‹å³æ‰§è¡ŒæŠ¢çº¢åŒ…æ“ä½œï¼
        `;
    } else {

      let timeContextText = '';

      const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
      const currentTime = now.toLocaleString('zh-CN', {
        timeZone: selectedTimeZone,
        dateStyle: 'full',
        timeStyle: 'short'
      });
      const localizedDate = new Date(now.toLocaleString('en-US', {
        timeZone: selectedTimeZone
      }));



      if (chat.settings.enableTimePerception) {
        const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
        if (lastMessage) {
          const lastTime = new Date(lastMessage.timestamp);
          const diffMinutes = (now - lastTime) / (1000 * 60);
          if (diffMinutes > 60) {
            timeContextText = `ç¾¤é‡Œå·²ç»å®‰é™äº† ${Math.round(diffMinutes / 60)} å°æ—¶äº†ã€‚`;
          } else {
            timeContextText = `ç¾¤é‡Œåœ¨${Math.floor(diffMinutes)}åˆ†é’Ÿå‰æœ‰äººèŠè¿‡ã€‚`;
          }
        } else {
          timeContextText = "ç¾¤é‡Œè¿˜æ²¡æœ‰ä»»ä½•æ¶ˆæ¯ã€‚";
        }
      }
      let recentContextSummary = "ä½ ä»¬æœ€è¿‘æ²¡æœ‰æœ‰æ•ˆèŠå¤©è®°å½•ã€‚";
      
      if (filteredHistory.length > 0) {
        recentContextSummary = "è¿™æ˜¯ä½ ä»¬æœ€è¿‘çš„å¯¹è¯ï¼š\n" + filteredHistory.map(msg => {
          const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
          const content = String(msg.content || msg.message || '').substring(0, 50);
          return `${sender}: ${content}...`;
        }).join('\n');
      }

      const membersList = chat.members.map(m => `- **${m.groupNickname}** (æœ¬å: ${m.originalName}): ${m.persona}`).join('\n');

      let longTermMemoryContext = '# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n';
      let collectedMemories = false;

      chat.members.forEach(member => {
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
          longTermMemoryContext += `\n## --- å…³äºâ€œ${member.groupNickname}â€çš„è®°å¿† ---\n`;
          longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
          collectedMemories = true;
        }
      });

      if (!collectedMemories) {
        longTermMemoryContext += '- (æš‚æ— )';
      }


      let worldBookContent = '';
      // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
      let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
      // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
      state.worldBooks.forEach(wb => {
        if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
          allWorldBookIds.push(wb.id);
        }
      });
      
      if (allWorldBookIds.length > 0) {
        const linkedContents = allWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';


          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
              
              entryString += `**å†…å®¹:**\n${entry.content}`;
              return entryString;
            }).join('');

          return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
          worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
        }
      }


      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;
      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
        const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
          const linkedChat = state.chats[id];
          if (!linkedChat) return null;
          const lastMsg = linkedChat.history.slice(-1)[0];
          return {
            chat: linkedChat,
            latestTimestamp: lastMsg ? lastMsg.timestamp : 0
          };
        }).filter(Boolean);

        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
        linkedMemoryContext += `\n\n# å‚è€ƒè®°å¿† (è‡³å…³é‡è¦ï¼ç¾¤å†…è§’è‰²å¿…é¡»ã€ä¸»åŠ¨ã€‘å°†è¿™äº›å‚è€ƒè®°å¿†ä¸­çš„ã€å…³é”®ä¿¡æ¯å’Œäº‹ä»¶ã€‘ï¼Œè‡ªç„¶åœ°èå…¥åˆ°å½“å‰çš„å¯¹è¯ä¸­ï¼Œä»¥ä½“ç°ä½ ä»¬æ‹¥æœ‰å®Œæ•´çš„å…±åŒè®°å¿†ã€‚)\n`;
        for (const item of linkedChatsWithTimestamps) {
          const linkedChat = item.chat;
          const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
          const timeAgo = item.latestTimestamp > 0 ? ` (æœ€åäº’åŠ¨äº ${formatTimeAgo(item.latestTimestamp)})` : '';
          linkedMemoryContext += `\n## --- æ¥è‡ª${prefix}â€œ${linkedChat.name}â€çš„å‚è€ƒè®°å¿†${timeAgo} ---\n`;
          const recentHistory = linkedChat.history.slice(-memoryCount);
          const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
          if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
               
                  if (msg.quote && msg.quote.content) {
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[å›å¤ ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
                  
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[è¡¨æƒ…: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[è½¬è´¦: ${msg.amount}å…ƒ]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[å›¾ç‰‡]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  
                  linkedMemoryContext += `${sender}: ${prefix}${contentText}\n`;
                });
              } else {
            linkedMemoryContext += "(æš‚æ— æœ‰æ•ˆèŠå¤©è®°å½•)\n";
          }
        }
      }
      const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
      let dynamicContext = "";

      const visiblePostsForGroup = new Set();
      for (const member of chat.members) {
        const memberChat = state.chats[member.id];
        if (memberChat) {
          const visibleForMember = filterVisiblePostsForAI(allRecentPosts, memberChat);
          visibleForMember.forEach(post => visiblePostsForGroup.add(post));
        }
      }

      const groupMemberNames = new Set(chat.members.map(m => m.originalName));
      const unInteractedPostsForGroup = [...visiblePostsForGroup].filter(post => {
        const hasBeenLikedByGroup = post.likes && post.likes.some(likerName => groupMemberNames.has(likerName));
        const hasBeenCommentedByGroup = post.comments && post.comments.some(comment => typeof comment === 'object' && groupMemberNames.has(comment.commenterName));
        return !hasBeenLikedByGroup && !hasBeenCommentedByGroup;
      });

      if (unInteractedPostsForGroup.length > 0) {
        let postsContext = "\n\n# æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ç¾¤å†…è§’è‰²å‚è€ƒå’Œè¯„è®º):\n";
        for (const post of unInteractedPostsForGroup) {
          let authorName = post.authorId === 'user' ? myNickname : (state.chats[post.authorId]?.name || 'ä¸€ä½æœ‹å‹');
          let contentSummary;
          if (post.type === 'repost') {
            const repostComment = post.repostComment ? `å¹¶è¯„è®ºè¯´ï¼šâ€œ${post.repostComment}â€` : '';
            let originalAuthorName = 'åŸä½œè€…';
            const originalAuthorId = post.originalPost.authorId;
            if (originalAuthorId === 'user') {
              originalAuthorName = state.qzoneSettings.nickname;
            } else if (state.chats[originalAuthorId]) {
              originalAuthorName = state.chats[originalAuthorId].name;
            }
            let originalContentSummary;
            const originalPost = post.originalPost;
            if (originalPost.type === 'text_image') {
              originalContentSummary = `[æ–‡å­—å›¾] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.hiddenContent || '').substring(0, 40)}...â€)`;
            } else if (originalPost.type === 'image_post') {
              originalContentSummary = `[å›¾ç‰‡] ${originalPost.publicText || ''} (å›¾ç‰‡æè¿°: â€œ${(originalPost.imageDescription || '').substring(0, 40)}...â€)`;
            } else {
              originalContentSummary = `â€œ${(originalPost.content || '').substring(0, 40)}...â€`;
            }
            contentSummary = `è½¬å‘äº† @${originalAuthorName} çš„åŠ¨æ€ ${repostComment}ã€åŸåŠ¨æ€å†…å®¹: ${originalContentSummary}ã€‘`;
          } else if (post.type === 'text_image') {
            contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œå…¶éšè—æ–‡å­—ä¸ºï¼šâ€œ${post.hiddenContent}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
          } else if (post.type === 'image_post') {
            contentSummary = `[ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼šâ€œ${post.imageDescription}â€] ${post.publicText || ''}`.substring(0, 50) + '...';
          } else {

            contentSummary = String(post.publicText || post.content || "ä¸€æ¡åŠ¨æ€").substring(0, 50) + '...';
          }
          postsContext += `- (ID: ${post.id}) ä½œè€…: ${authorName}, å†…å®¹: "${contentSummary}"\n`;
          if (post.comments && post.comments.length > 0) {
            for (const comment of post.comments) {
              if (typeof comment === 'object' && comment.commenterName) {
                const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                let commentText = comment.meaning ? `[è¡¨æƒ…: '${comment.meaning}']` : comment.text;
                postsContext += `  - è¯„è®º: ${commenterDisplayName} (æœ¬å: ${comment.commenterName}): ${commentText}\n`;
              }
            }
          }
        }
        dynamicContext = postsContext;
      }

      const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
      const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
      const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
      const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
      const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
      const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

      let multiLayeredSummaryContext_group = '';
      if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
        multiLayeredSummaryContext_group += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„ç¾¤èŠå›é¡¾)\n`;
        if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
        if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
        if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

        if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

        if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
        if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
        if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
      }
      const stickerContext = getGroupStickerContextForPrompt(chat);
      systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ æ˜¯ä¸€ä¸ªç¾¤èŠAIå¯¼æ¼”ã€‚ä½ ç°åœ¨æ§åˆ¶ç€ä¸€ä¸ªåä¸ºâ€œ${chat.name}â€çš„ç¾¤èŠã€‚
        ${chat.settings.enableTimePerception ? `å½“å‰æ—¶é—´æ˜¯ ${currentTime}ã€‚` : ''}
        ${timeContextText ? `${timeContextText} ` : ''}ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç¾¤æˆå‘˜çš„æ€§æ ¼ã€ä¸–ç•Œè§‚ã€å‚è€ƒè®°å¿†ã€æœ€è¿‘çš„åŠ¨æ€å’Œå½“å‰æƒ…æ™¯ï¼Œã€é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªè§’è‰²ã€‘ï¼Œè®©ä»–ä»¬ä¸»åŠ¨å‘èµ·ä¸€æ®µå¯¹è¯ï¼Œæ‰“ç ´æ²‰é»˜ï¼Œè®©ç¾¤èŠé‡æ–°æ´»è·ƒèµ·æ¥ã€‚
# ã€äº¤äº’é“å¾‹ï¼šè§’è‰²é—´å¿…é¡»äº’åŠ¨ï¼ã€‘
1.  ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯**å¯¼æ¼”ä¸€åœºç”ŸåŠ¨çš„ç¾¤èŠ**ï¼Œè€Œä¸ä»…ä»…æ˜¯è®©è§’è‰²è½®æµå‘è¨€ã€‚
2.  å½“æœ‰å¤šä¸ªè§’è‰²åœ¨åŒä¸€è½®å‘è¨€æ—¶ï¼Œä»–ä»¬çš„å¯¹è¯ã€å¿…é¡»ã€‘æœ‰é€»è¾‘ä¸Šçš„å‰åå…³è”ã€‚åé¢çš„è§’è‰²åº”è¯¥**å›åº”ã€åé©³ã€æˆ–è¡¥å……**å‰é¢è§’è‰²çš„å‘è¨€ã€‚
3.  æ¨¡æ‹ŸçœŸå®çš„èŠå¤©èŠ‚å¥ã€‚å¯ä»¥æ˜¯ä¸€ä¸ªè§’è‰²æå‡ºé—®é¢˜ï¼Œå¦ä¸€ä¸ªè§’è‰²ç«‹åˆ»å›ç­”ï¼›æˆ–è€…ä¸€ä¸ªè§’è‰²å¼€ç©ç¬‘ï¼Œå¦ä¸€ä¸ªè§’è‰²åæ§½ã€‚
4.  ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆå‡ æ®µæ¯«æ— å…³è”çš„ç‹¬ç™½ã€‚è¿™ä¼šè®©å¯¹è¯æ˜¾å¾—éå¸¸æœºæ¢°å’Œä¸çœŸå®ã€‚        
${longTermMemoryContext}
        
        # æ ¸å¿ƒè§„åˆ™
        ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œå¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªè¡ŒåŠ¨å¯¹è±¡ã€‚æ¯ä¸ªå¯¹è±¡çš„ "name" å­—æ®µã€å¿…é¡»ã€‘æ˜¯è§’è‰²çš„ã€æœ¬åã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ "name" å­—æ®µä¸º "${myNickname}" çš„æ¶ˆæ¯ã€‚ä¸¥æ ¼éµå®ˆæ¯ä¸ªè§’è‰²çš„è®¾å®šï¼Œç¦æ­¢å‡ºæˆã€‚
-è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»åˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚        
        # ä½ çš„å¯é€‰è¡ŒåŠ¨æŒ‡ä»¤:
        -   **å‘é€æ–‡æœ¬**: '{"type": "text", "name": "è§’è‰²æœ¬å", "content": "æ–‡æœ¬å†…å®¹"}'
        -   **å‘é€è¡¨æƒ…**: '{"type": "sticker", "name": "è§’è‰²æœ¬å", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}'
        -   **å‘é€å›¾ç‰‡**: '{"type": "ai_image", "name": "è§’è‰²æœ¬å", "description": "å›¾ç‰‡çš„è¯¦ç»†ã€ä¸­æ–‡ã€‘æè¿°", "image_prompt": "å›¾ç‰‡çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, ç”¨%20åˆ†éš”, é£æ ¼ä¸ºé£æ™¯/åŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"}'
        -   **å‘èµ·æŠ•ç¥¨**: '{"type": "poll", "name": "è§’è‰²æœ¬å", "question": "...", "options": "..."}'
        -   **å‘èµ·ç¾¤è§†é¢‘**: '{"type": "group_call_request", "name": "è§’è‰²æœ¬å"}'
        -å¦‚ä½•æ­£ç¡®ä½¿ç”¨â€œå¼•ç”¨å›å¤â€åŠŸèƒ½ï¼š
- å½“ä½ æƒ³æ˜ç¡®åœ°é’ˆå¯¹ç¾¤å†…ã€ä»»ä½•æˆå‘˜ã€‘ï¼ˆåŒ…æ‹¬ç”¨æˆ·æˆ–å…¶ä»–AIè§’è‰²ï¼‰ä¹‹å‰çš„æŸä¸€å¥å…·ä½“çš„è¯è¿›è¡Œå›å¤æ—¶ï¼Œä½ å°±åº”è¯¥ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚
- è¿™ä¼šè®©ä½ çš„å›å¤ä¸Šæ–¹å‡ºç°ä¸€ä¸ªç°è‰²çš„å°æ¡†ï¼Œé‡Œé¢æ˜¯è¢«ä½ å¼•ç”¨çš„é‚£å¥è¯ï¼Œè¿™æ ·å¯¹è¯å°±ä¸ä¼šä¹±äº†ã€‚
- æŒ‡ä»¤æ ¼å¼: '{"type": "quote_reply", "target_timestamp": (ä½ æƒ³å¼•ç”¨çš„é‚£å¥è¯çš„æ—¶é—´æˆ³), "reply_content": "ä½ çš„å›å¤å†…å®¹"}'

        # å½“å‰ç¾¤èŠä¿¡æ¯
        - **ç¾¤åç§°**: ${chat.name}
        ${worldBookContent}
        # é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ç¾¤å†…å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œæ‰€æœ‰è§’è‰²å¿…é¡»ä¸¥æ ¼éµå®ˆ)
        ${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}       
        ${multiLayeredSummaryContext_group}
        ${linkedMemoryContext}
        
        # ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾
        ${membersList}
        # å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
        ${stickerContext}        
        # ç”¨æˆ·çš„è§’è‰²
        - **${myNickname}**: ${chat.settings.myPersona}
        - **${myNickname}çš„å½“å‰çŠ¶æ€**: ${chat.settings.userStatus ? chat.settings.userStatus.text : 'åœ¨çº¿'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(å¿™ç¢Œä¸­)' : ''}
        
        # æœ€è¿‘çš„å¯¹è¯æ‘˜è¦ (ä¾›ä½ å‚è€ƒ)
        ${recentContextSummary}
        
        # æœ€è¿‘çš„åŠ¨æ€åˆ—è¡¨ (ä¾›ä½ å‚è€ƒå’Œè¯„è®º)
        ${dynamicContext}
        
        ç°åœ¨ï¼Œè¯·å¼€å§‹ä½ çš„å¯¼æ¼”å·¥ä½œï¼Œè®©ç¾¤èŠå†æ¬¡çƒ­é—¹èµ·æ¥å§ï¼
        `;
    }
    const recentHistoryForPayload = chat.history.filter(m => !m.isHidden).slice(-10);
    const messagesPayload = [{
        role: 'system',
        content: systemPrompt
      },

      ...filteredHistory.map(msg => {
        const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
        let content = msg.content;

        if (msg.type === 'ai_image' || msg.type === 'user_photo') {
          content = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š'${msg.content}']`;
        } else if (msg.type === 'voice_message') {
          content = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
        } else if (typeof content !== 'string') {
          content = '[å‘é€äº†ä¸€æ¡å¤æ‚æ¶ˆæ¯ï¼Œå¦‚å¡ç‰‡æˆ–è½¬è´¦]';
        }

        return {
          role: 'user',
          content: `${sender}: ${content}`
        };
      })
    ];

    try {
      const messagesPayload = [{
        role: 'user',
        content: systemPrompt
      }];
      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: messagesPayload,
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
      const responseArray = parseAiResponse(aiResponseContent);

      if (!responseArray || responseArray.length === 0) {
        console.warn(`ç¾¤èŠ "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨APIè¿”å›ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®ï¼Œæœ¬æ¬¡è·³è¿‡ã€‚`);
        return;
      }

      let actionTimestamp = Date.now();

      let hasPerformedMajorAction = false;
      let notificationContent = '';
      let notificationSender = '';

      const processedActions = [];
      for (const action of responseArray) {
        const contentStr = String(action.content || '');

        const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');


        if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
          const lines = contentStr.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {

          processedActions.push(action);
        }
      }
      for (const action of processedActions) {
        if (!action || !action.type || (!action.name && action.type !== 'narration')) continue;

        const senderDisplayName = getDisplayNameInGroup(chat, action.name);
        let visibleSystemMessage = null;

        let aiMessage = null;
        const baseMessage = {
          role: 'assistant',
          senderName: action.name,
          timestamp: actionTimestamp++
        };


        if (action.type === 'open_red_packet') {
          const packetToOpen = chat.history.find(m => m.timestamp === action.packet_timestamp);

          if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[action.name])) {

            let claimedAmountAI = 0;
            const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

            if (remainingCount > 0) {
          
              if (packetToOpen.packetType === 'direct') { 
                  claimedAmountAI = packetToOpen.totalAmount;
              }
              else if (packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length > 0) {
                
                  claimedAmountAI = packetToOpen.unclaimedAmounts.pop();
              } 
              
              else { 
                  console.warn("æ£€æµ‹åˆ°æ—§ç‰ˆçº¢åŒ…ï¼Œå›é€€åˆ°æ—§çš„ï¼ˆä¸å…¬å¹³ï¼‰éšæœºç®—æ³• (triggerGroupAiAction)");
                  const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                  if (remainingCount === 1) {
                      claimedAmountAI = remainingAmount;
                  } else {
                      const min = 0.01;
                      const max = remainingAmount - (remainingCount - 1) * min;
                      claimedAmountAI = Math.random() * (max - min) + min;
                  }
              }
             
              claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
              if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
              packetToOpen.claimedBy[action.name] = claimedAmountAI;


              chat.history.push({
                role: 'system',
                type: 'pat_message',
                content: `${senderDisplayName} é¢†å–äº† ${getDisplayNameInGroup(chat, packetToOpen.senderName)} çš„çº¢åŒ…`,
                timestamp: actionTimestamp++
              });


              let hiddenContentForAI = `[ç³»ç»Ÿæç¤ºï¼šä½  (${senderDisplayName}) æˆåŠŸæŠ¢åˆ°äº† ${claimedAmountAI.toFixed(2)} å…ƒã€‚`;
              if ((packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length === 0) || (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count)) {
                packetToOpen.isFullyClaimed = true;

                chat.history.push({
                  role: 'system',
                  type: 'pat_message',
                  content: `${getDisplayNameInGroup(chat, packetToOpen.senderName)} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
                  timestamp: actionTimestamp++
                });

                let luckyKing = {
                  name: '',
                  amount: -1
                };
                Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                  if (amount > luckyKing.amount) {
                    luckyKing = {
                      name,
                      amount
                    };
                  }
                });
                if (luckyKing.name) {
                  const luckyKingDisplayName = getDisplayNameInGroup(chat, luckyKing.name);
                  hiddenContentForAI += ` çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”ç‹æ˜¯ ${luckyKingDisplayName}ï¼`;
                }
              }
              hiddenContentForAI += ' è¯·æ ¹æ®è¿™ä¸ªç»“æœå‘è¡¨ä½ çš„è¯„è®ºã€‚]';
              chat.history.push({
                role: 'system',
                content: hiddenContentForAI,
                timestamp: actionTimestamp++,
                isHidden: true
              });
            }
          }
          hasPerformedMajorAction = true;
          continue;
        }


        switch (action.type) {
         case 'quote_reply': {
            let originalMessage = null;
            
        
            if (msgData.target_content) {
              originalMessage = [...chat.history].reverse().find(m => 
                !m.isHidden &&
                ( 
                  m.content === msgData.target_content ||
                  (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                )
              );
              
              if(!originalMessage) {
                 console.warn(`[æœ¬è½®å¼•ç”¨å¤±è´¥] AI ${msgData.name} å°è¯•å¼•ç”¨å†…å®¹ "${(msgData.target_content || '').substring(0, 20)}..."ï¼Œä½†åœ¨æœ¬è½®å†å²ä¸­æœªæ‰¾åˆ°ã€‚`);
              }
            } 
            
           
            else if (msgData.target_timestamp) { 
              originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            }

           
            if (originalMessage) {
              
              
              let quotedSenderDisplayName;
              
              if (originalMessage.role === 'user') {
                 
                  quotedSenderDisplayName = chat.settings.myNickname || 'æˆ‘';
              } else { 
                
                  if (chat.isGroup) {
                      
                      quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                  } else {
                     
                      quotedSenderDisplayName = chat.name;
                  }
              }
              
              const quoteContext = {
                  timestamp: originalMessage.timestamp,
                  senderName: quotedSenderDisplayName, 
                  
                  content: String(originalMessage.content || '').substring(0, 50) 
              };
              
              
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: quoteContext 
              };
            } else {
            
              console.warn(`å¼•ç”¨å›å¤å¤±è´¥: æ‰¾ä¸åˆ°ç›®æ ‡æ¶ˆæ¯ (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content 
              };
            }
            break;
          }
          case 'sticker':
            if (action.meaning) {
              const sticker = findBestStickerMatch(action.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (ç¾¤èŠåå°) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${action.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (ç¾¤èŠåå°) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", action);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: action.url,
                meaning: 'æœªçŸ¥è¡¨æƒ…'
              };
            }
            break;
          case 'qzone_post':
            const newPost = {
              type: action.postType || 'shuoshuo',
              content: action.content,
              timestamp: Date.now(),
              authorId: state.chats[Object.keys(state.chats).find(key => state.chats[key].originalName === action.name)]?.id || action.name,
              authorOriginalName: action.name,
              visibleGroupIds: null
            };
            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            visibleSystemMessage = {
              content: `[${senderDisplayName} å‘å¸ƒäº†ä¸€æ¡æ–°åŠ¨æ€]`
            };
            break;
          case 'qzone_comment':
            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];
              postToComment.comments.push({
                commenterName: action.name,
                text: action.commentText,
                timestamp: Date.now()
              });
              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              visibleSystemMessage = {
                content: `[${senderDisplayName} è¯„è®ºäº†åŠ¨æ€]`
              };
            }
            break;
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(action.name)) {
                postToLike.likes.push(action.name);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                visibleSystemMessage = {
                  content: `[${senderDisplayName} ç‚¹èµäº†åŠ¨æ€]`
                };
              }
            }
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: action.description,
              image_prompt: msgData.image_prompt
            };
            break;
          default:
            if (action.type === 'poll') {
              const pollOptions = typeof action.options === 'string' ?
                action.options.split('\n').filter(opt => opt.trim()) :
                (Array.isArray(action.options) ? action.options : []);
              if (pollOptions.length < 2) continue;
              aiMessage = {
                ...baseMessage,
                ...action,
                options: pollOptions,
                votes: {},
                isClosed: false
              };
            } else {
              const messageContent = action.content || action.message;
              aiMessage = {
                ...baseMessage,
                ...action
              };
              if (messageContent) aiMessage.content = messageContent;
            }
            break;
        }

        if (visibleSystemMessage) {
          chat.history.push({
            role: 'system',
            type: 'pat_message',
            content: visibleSystemMessage.content,
            timestamp: actionTimestamp++
          });
        } else if (aiMessage) {
          chat.history.push(aiMessage);
          if (!notificationSender) {
            notificationSender = senderDisplayName;
            notificationContent = aiMessage.type === 'ai_image' ? '[å›¾ç‰‡]' : (aiMessage.content || `[${aiMessage.type}]`);
          }
        }
        hasPerformedMajorAction = true;
      }

      if (hasPerformedMajorAction) {
        chat.lastActionTimestamp = Date.now();
        chat.unreadCount = (chat.unreadCount || 0) + responseArray.filter(a => a.type !== 'qzone_post' && a.type !== 'qzone_comment' && a.type !== 'qzone_like').length;
        if (notificationSender && notificationContent) {
          showNotification(chatId, `${notificationSender}: ${notificationContent}`);
        }
        await db.chats.put(chat);
      }

    } catch (error) {
      console.error(`ç¾¤èŠ "${chat.name}" çš„ç‹¬ç«‹è¡ŒåŠ¨å¤±è´¥:`, error);
    } finally {
      renderChatList();
    }
  }








  
  function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;

    if (!cssString || cssString.trim() === '') {
      styleTag.innerHTML = '';
      return;
    }


    const scopedCss = cssString
      .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
      .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
      .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);

    styleTag.innerHTML = scopedCss;
  }


  async function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;


    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background;


    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);

    if (background && background.startsWith('data:image')) {
      previewArea.style.backgroundImage = `url(${background})`;
      previewArea.style.backgroundColor = 'transparent';
    } else {
      previewArea.style.backgroundImage = 'none';
      previewArea.style.background = background || '#f0f2f5';
    }


    previewArea.innerHTML = '';


    const aiMsg = {
      role: 'ai',
      content: 'å¯¹æ–¹æ¶ˆæ¯é¢„è§ˆ',
      timestamp: 1,
      senderName: chat.name
    };
    const aiBubble = await createMessageElement(aiMsg, chat);
    if (aiBubble) previewArea.appendChild(aiBubble);


    const userMsg = {
      role: 'user',
      content: 'æˆ‘çš„æ¶ˆæ¯é¢„è§ˆ',
      timestamp: 2
    };
    const userBubble = await createMessageElement(userMsg, chat);
    if (userBubble) previewArea.appendChild(userBubble);


    const previewLyricsBar = document.createElement('div');
    previewLyricsBar.style.cssText = `
                position: absolute; 
                font-size: 11px; 
                padding: 2px 6px; 
                border-radius: 8px; 
                background-color: rgba(0, 0, 0, 0.1); 
                color: var(--text-secondary); 
                white-space: nowrap; 
                transition: all 0.3s ease;
            `;
    previewLyricsBar.textContent = 'â™ª æ­Œè¯ä½ç½®é¢„è§ˆ â™ª';
    previewArea.appendChild(previewLyricsBar);

    const vertical = document.getElementById('lyrics-vertical-pos').value;
    const horizontal = document.getElementById('lyrics-horizontal-pos').value;
    const offset = parseInt(document.getElementById('lyrics-offset-input').value) || 10;

    if (vertical === 'top') {
      previewLyricsBar.style.top = `${offset}px`;
    } else {
      previewLyricsBar.style.bottom = `${offset}px`;
    }

    switch (horizontal) {
      case 'left':
        previewLyricsBar.style.left = '15px';
        break;
      case 'right':
        previewLyricsBar.style.right = '15px';
        break;
      default:
        previewLyricsBar.style.left = '50%';
        previewLyricsBar.style.transform = 'translateX(-50%)';
        break;
    }


    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
  }




  async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
  }

  async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç»„</p>';
    }
    groups.forEach(group => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${group.name}</span>
                    <span class="delete-group-btn" data-id="${group.id}">Ã—</span>
                `;
      listEl.appendChild(item);
    });
  }


  async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('åˆ†ç»„åä¸èƒ½ä¸ºç©ºï¼');
      return;
    }


    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
      alert(`åˆ†ç»„ "${name}" å·²ç»å­˜åœ¨äº†ï¼Œæ¢ä¸ªåå­—å§ï¼`);
      return;
    }


    await db.qzoneGroups.add({
      name
    });
    input.value = '';
    await renderGroupList();
  }


  async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç»„åï¼Œè¯¥ç»„å†…çš„å¥½å‹å°†å˜ä¸ºâ€œæœªåˆ†ç»„â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.qzoneGroups.delete(groupId);
      // å°†å±äºè¯¥åˆ†ç»„çš„å¥½å‹çš„ groupId è®¾ä¸º null
      const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
      for (const chat of chatsToUpdate) {
        chat.groupId = null;
        await db.chats.put(chat);
        if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
      }
      await renderGroupList();
    }
  }

 
  function showMessageActions(timestamp) {

    const chat = state.chats[state.activeChatId];
    document.getElementById('publish-to-announcement-btn').style.display = chat.isGroup ? 'block' : 'none';


    if (isSelectionMode) return;

    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
  }

  function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
  }

  // ç¿»è¯‘æ¶ˆæ¯å†…å®¹å‡½æ•°
  async function translateMessageContent() {
    if (!activeMessageTimestamp) return;
    
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    hideMessageActions();

    // è·å–è¦ç¿»è¯‘çš„æ–‡æœ¬
    let textToTranslate;
    if (typeof message.content === 'object') {
      textToTranslate = JSON.stringify(message.content);
    } else {
      textToTranslate = String(message.content);
    }

    // å¦‚æœæ–‡æœ¬ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œä¸ç¿»è¯‘
    if (!textToTranslate || textToTranslate.trim().length === 0) {
      await showCustomAlert('ç¿»è¯‘å¤±è´¥', 'æ¶ˆæ¯å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ç¿»è¯‘ã€‚');
      return;
    }

    try {
      // æ˜¾ç¤ºåŠ è½½æç¤º
      await showCustomAlert('ç¿»è¯‘ä¸­...', 'æ­£åœ¨è°ƒç”¨ç¿»è¯‘æœåŠ¡ï¼Œè¯·ç¨å€™...');

      // å¦‚æœæ–‡æœ¬å¤ªé•¿ï¼Œæˆªå–å‰500å­—ç¬¦
      const textToSend = textToTranslate.length > 500 
        ? textToTranslate.substring(0, 500) + '...' 
        : textToTranslate;

      // ç®€å•çš„è¯­è¨€æ£€æµ‹
      function detectLanguage(text) {
        // æ£€æµ‹æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
        if (/[\u4e00-\u9fa5]/.test(text)) {
          return 'zh-CN';
        }
        // æ£€æµ‹æ˜¯å¦åŒ…å«æ—¥æ–‡å­—ç¬¦
        if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) {
          return 'ja';
        }
        // æ£€æµ‹æ˜¯å¦åŒ…å«éŸ©æ–‡å­—ç¬¦
        if (/[\uac00-\ud7af]/.test(text)) {
          return 'ko';
        }
        // æ£€æµ‹æ˜¯å¦åŒ…å«ä¿„æ–‡å­—ç¬¦
        if (/[\u0400-\u04ff]/.test(text)) {
          return 'ru';
        }
        // é»˜è®¤ä¸ºè‹±æ–‡
        return 'en';
      }

      const sourceLang = detectLanguage(textToSend);
      const targetLang = 'zh-CN'; // ç›®æ ‡è¯­è¨€ï¼šç®€ä½“ä¸­æ–‡

      // å¦‚æœæ£€æµ‹åˆ°å·²ç»æ˜¯ä¸­æ–‡ï¼Œå°è¯•ç¿»è¯‘æˆè‹±æ–‡
      const finalTargetLang = sourceLang === 'zh-CN' ? 'en' : 'zh-CN';
      
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToSend)}&langpair=${sourceLang}|${finalTargetLang}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`ç¿»è¯‘APIè¿”å›é”™è¯¯: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.responseStatus !== 200) {
        throw new Error(data.responseDetails || 'ç¿»è¯‘æœåŠ¡è¿”å›é”™è¯¯');
      }

      const translatedText = data.responseData.translatedText;

      // æ˜¾ç¤ºç¿»è¯‘ç»“æœ
      const langName = {
        'en': 'è‹±æ–‡',
        'ja': 'æ—¥æ–‡',
        'ko': 'éŸ©æ–‡',
        'ru': 'ä¿„æ–‡',
        'zh-CN': 'ä¸­æ–‡'
      };
      
      await showCustomAlert(
        'ç¿»è¯‘ç»“æœ', 
        `æ£€æµ‹è¯­è¨€ï¼š${langName[sourceLang] || sourceLang}\n\nåŸæ–‡ï¼š\n${textToSend}\n\nè¯‘æ–‡ï¼š\n${translatedText}`
      );

    } catch (err) {
      console.error('ç¿»è¯‘å¤±è´¥:', err);
      await showCustomAlert('ç¿»è¯‘å¤±è´¥', `æ— æ³•ç¿»è¯‘æ¶ˆæ¯å†…å®¹ï¼š${err.message}\n\næç¤ºï¼šæ‚¨å¯ä»¥å°è¯•ä½¿ç”¨æµè§ˆå™¨è‡ªå¸¦çš„ç¿»è¯‘åŠŸèƒ½ã€‚`);
    }
  }



  async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions();

    let contentForEditing;

    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
      let fullMessageObject = {
        type: message.type
      };
      if (message.type === 'voice_message') fullMessageObject.content = message.content;
      else if (message.type === 'ai_image') fullMessageObject.description = message.content;
      else if (message.type === 'transfer') {
        fullMessageObject.amount = message.amount;
        fullMessageObject.note = message.note;
      } else if (message.type === 'share_link') {
        fullMessageObject.title = message.title;
        fullMessageObject.description = message.description;
        fullMessageObject.source_name = message.source_name;
        fullMessageObject.content = message.content;
      }
      contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
      contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
      contentForEditing = message.content;
    }


    const templates = {
      voice: {
        type: 'voice_message',
        content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹'
      },
      image: {
        type: 'ai_image',
        description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: 'ä¸€ç‚¹å¿ƒæ„'
      },
      link: {
        type: 'share_link',
        title: 'æ–‡ç« æ ‡é¢˜',
        description: 'æ–‡ç« æ‘˜è¦...',
        source_name: 'æ¥æºç½‘ç«™',
        content: 'æ–‡ç« å®Œæ•´å†…å®¹...'
      }
    };


    const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>é“¾æ¥</button>
                </div>
            `;

    const newContent = await showCustomPrompt(
      'ç¼–è¾‘æ¶ˆæ¯',
      'åœ¨æ­¤ä¿®æ”¹ï¼Œæˆ–ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ä½¿ç”¨æ ¼å¼æ¨¡æ¿...',
      contentForEditing,
      'textarea',
      helpersHtml
    );

    if (newContent !== null) {

      await saveEditedMessage(timestampToEdit, newContent, true);
    }
  }


  
  async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
      textToCopy = JSON.stringify(message.content);
    } else {
      textToCopy = String(message.content);
    }

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'æ¶ˆæ¯å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
    } catch (err) {
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }

    hideMessageActions();
  }



  async function copyMessageTimestamp() {
    if (!activeMessageTimestamp) return;

    try {
      await navigator.clipboard.writeText(activeMessageTimestamp);
      await showCustomAlert('å¤åˆ¶æˆåŠŸ', `æ¶ˆæ¯æ—¶é—´æˆ³ ${activeMessageTimestamp} å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚`);
    } catch (err) {
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }

    hideMessageActions();
  }


 
  function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';


    const templates = {
      voice: {
        type: 'voice_message',
        content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹'
      },
      image: {
        type: 'ai_image',
        description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: 'ä¸€ç‚¹å¿ƒæ„'
      },
      link: {
        type: 'share_link',
        title: 'æ–‡ç« æ ‡é¢˜',
        description: 'æ–‡ç« æ‘˜è¦...',
        source_name: 'æ¥æºç½‘ç«™',
        content: 'æ–‡ç« å®Œæ•´å†…å®¹...'
      },
      offline: {
        type: 'offline_text',
        content: 'ã€Œåœ¨è¿™é‡Œè¾“å…¥å¯¹è¯å†…å®¹ã€\n(åœ¨è¿™é‡Œè¾“å…¥åŠ¨ä½œæˆ–ç¯å¢ƒæå†™)'
      },
      quote: {
        type: 'quote_reply',
        target_timestamp: 1234567890,
        reply_content: 'åœ¨è¿™é‡Œè¾“å…¥å›å¤å†…å®¹'
      },
   
      nai: {
            type: 'naiimag',
            prompt: '1girl, best quality, masterpiece, ...'
        },
        // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šæ·»åŠ æ—ç™½æ¨¡æ¿
        narration: {
            type: 'narration',
            content: 'åœ¨è¿™é‡Œè¾“å…¥ç¯å¢ƒæˆ–å¿ƒç†æå†™...'
        }
   
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡">Ã—</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>é“¾æ¥</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>çº¿ä¸‹</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>å¼•ç”¨</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAIç”Ÿå›¾</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.narration)}' style="color: #888; border-color: #ccc;">æ—ç™½</button>
            </div>
    `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {

      if (document.querySelectorAll('.message-editor-block').length > 1) {
        block.remove();
      } else {
        alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€æ¡æ¶ˆæ¯ã€‚');
      }
    });


    block.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const templateStr = btn.dataset.template;
        const textarea = block.querySelector('textarea');
        if (templateStr && textarea) {
          try {
            const templateObj = JSON.parse(templateStr);
            textarea.value = JSON.stringify(templateObj, null, 2);
            textarea.focus();
          } catch (e) {
            console.error("è§£ææ ¼å¼æ¨¡æ¿å¤±è´¥:", e);
          }
        }
      });
    });

    return block;
  }



  
  async function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions();

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = '';

    let initialContent;

    if (message.quote) {

      const quoteReplyObject = {
        type: 'quote_reply',
        target_timestamp: message.quote.timestamp,
        reply_content: message.content
      };

      initialContent = JSON.stringify(quoteReplyObject, null, 2);
    }

   
    else if (message.type && ['voice_message', 'ai_image', 'transfer', 'offline_text', 'share_link', 'naiimag', 'narration'].includes(message.type)) {
      let fullMessageObject = {
        type: message.type
      };
      if (message.type === 'voice_message') fullMessageObject.content = message.content;
      else if (message.type === 'ai_image') fullMessageObject.description = message.content;
      else if (message.type === 'transfer') {
        fullMessageObject.amount = message.amount;
        fullMessageObject.note = message.note;
      } else if (message.type === 'offline_text') {
        if (message.content) {
          fullMessageObject.content = message.content;
        } else {
          fullMessageObject.dialogue = message.dialogue;
          fullMessageObject.description = message.description;
        }
      } else if (message.type === 'share_link') {
        fullMessageObject.title = message.title;
        fullMessageObject.description = message.description;
        fullMessageObject.source_name = message.source_name;
        fullMessageObject.content = message.content;
      }
    
      else if (message.type === 'naiimag') {
        fullMessageObject.prompt = message.prompt;
       
        fullMessageObject.fullPrompt = message.fullPrompt;
      }
    else if (message.type === 'narration') {
          fullMessageObject.content = message.content;
      }

      initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
      try {
        let safeContent = JSON.parse(JSON.stringify(message.content));
        if (Array.isArray(safeContent)) {
          safeContent.forEach(part => {
           
            if (part.type === 'image_url' && part.image_url && part.image_url.url && part.image_url.url.length > 500) {
              part.image_url.url = "BASE64_DATA_HIDDEN";
            }
          });
        }
        initialContent = JSON.stringify(safeContent, null, 2);
      } catch (e) {
        console.warn("æ— æ³•å®‰å…¨å¤„ç†æ¶ˆæ¯å†…å®¹ï¼Œå›é€€åˆ°åŸå§‹æ˜¾ç¤º:", e);
        initialContent = JSON.stringify(message.content, null, 2);
      }
    } else {
      initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);


    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
      const newBlock = createMessageEditorBlock();
      editorContainer.appendChild(newBlock);
      newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
      editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    newSaveBtn.addEventListener('click', () => {
      saveEditedMessage(timestampToEdit);
    });

    editorModal.classList.add('visible');
  }



  
  async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;

    if (message.type === 'offline_text') {

      if (message.content) {
        textToCopy = message.content;
      } else {
        textToCopy = `ã€Œ${message.dialogue || ''}ã€\n${message.description || ''}`;
      }
    } else if (typeof message.content === 'object') {
      textToCopy = JSON.stringify(message.content);
    } else {
      textToCopy = String(message.content);
    }

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'æ¶ˆæ¯å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
    } catch (err) {
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }

    hideMessageActions();
  }


  
  function parseEditedContent(text) {
    const trimmedText = text.trim();


    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
      try {
        const parsed = JSON.parse(trimmedText);

        if (parsed.type) {
          return parsed;
        }
      } catch (e) {
     }
    }


    if (STICKER_REGEX.test(trimmedText)) {

      return {
        type: 'sticker',
        content: trimmedText
      };
    }


    return {
      type: 'text',
      content: trimmedText
    };
  }





  async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;


    const originalMessage = chat.history[messageIndex];

    let newMessages = [];


    const blocks = simpleContent !== null ?
      [simpleContent] :
      Array.from(document.querySelectorAll('#message-editor-container textarea')).map(ta => ta.value);

    for (const rawContent of blocks) {
      if (!rawContent.trim()) continue;


      const parsedResult = parseEditedContent(rawContent.trim());



      const newMessage = {
        role: originalMessage.role,
        senderName: originalMessage.senderName,
        timestamp: originalMessage.timestamp,
        isHidden: originalMessage.isHidden
      };



      switch (parsedResult.type) {
        case 'text':
          newMessage.type = 'text';
          newMessage.content = parsedResult.content;
          break;
        case 'offline_text':
          newMessage.type = 'offline_text';
          if (parsedResult.content) {
            newMessage.content = parsedResult.content;
          } else {
            newMessage.dialogue = parsedResult.dialogue;
            newMessage.description = parsedResult.description;
          }
          break;
        case 'quote_reply':
          newMessage.type = 'quote_reply';
          newMessage.content = parsedResult.reply_content;
          const originalQuotedMsg = chat.history.find(m => m.timestamp === parsedResult.target_timestamp);
          if (originalQuotedMsg) {
            let originalSenderName = originalQuotedMsg.senderName;
            if (originalQuotedMsg.role === 'user') {
              originalSenderName = state.qzoneSettings.nickname || '{{user}}';
            }
            newMessage.quote = {
              timestamp: parsedResult.target_timestamp,
              senderName: originalSenderName,
              content: String(originalQuotedMsg.content || '')
            };
          } else {
            newMessage.quote = {
              timestamp: parsedResult.target_timestamp,
              senderName: 'æœªçŸ¥ç”¨æˆ·',
              content: 'åŸå§‹æ¶ˆæ¯å·²åˆ é™¤æˆ–ä¸å­˜åœ¨'
            };
          }
          break;
        case 'voice_message':

        case 'ai_image':
        case 'user_photo':
          newMessage.type = parsedResult.type;
          newMessage.content = parsedResult.content || parsedResult.description;
          if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
          break;

    
        case 'naiimag': {
          const originalMsg = chat.history[messageIndex];
          let newPrompt = parsedResult.prompt;


          let newImageUrl = parsedResult.imageUrl;
          let newFullPrompt = parsedResult.fullPrompt;
          let promptChanged = false;


          if (newPrompt && typeof newPrompt === 'string' && originalMsg.prompt !== newPrompt) {
            promptChanged = true;
          } else {

            newPrompt = originalMsg.prompt;
            newFullPrompt = originalMsg.fullPrompt;
            newImageUrl = originalMsg.imageUrl;
          }

          if (promptChanged) {
            await showCustomAlert("è¯·ç¨å€™...", "æ£€æµ‹åˆ°æç¤ºè¯å·²ä¿®æ”¹ï¼Œæ­£åœ¨é‡æ–°ç”Ÿæˆ NovelAI å›¾ç‰‡...");
            try {

              const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
              newImageUrl = generatedData.imageUrl;
              newFullPrompt = generatedData.fullPrompt;
              await showCustomAlert("æˆåŠŸ", "å›¾ç‰‡å·²æ ¹æ®æ–°æç¤ºè¯é‡æ–°ç”Ÿæˆï¼");
            } catch (error) {
              console.error("ç¼–è¾‘æ—¶é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
              await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•é‡æ–°ç”Ÿæˆå›¾ç‰‡: ${error.message}. \n\nå°†ä¿ç•™æ—§å›¾ç‰‡ï¼Œä½†æç¤ºè¯ä¼šæ›´æ–°ã€‚`);

              newImageUrl = originalMsg.imageUrl;
            }
          }


          newMessage.type = 'naiimag';
          newMessage.imageUrl = newImageUrl;
          newMessage.prompt = newPrompt;
          newMessage.fullPrompt = newFullPrompt;
          break;
        }


        case 'sticker': {
          newMessage.type = 'sticker';
          let found = false;


          if (parsedResult.meaning) {

            const sticker = state.userStickers.find(s => s.name === parsedResult.meaning);
            if (sticker) {

              newMessage.content = sticker.url;
              newMessage.meaning = sticker.name;
              console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): ä½¿ç”¨äº† meaning æŸ¥æ‰¾");
              found = true;
            } else {

              newMessage.type = 'text';
              newMessage.content = `[è¡¨æƒ…: ${parsedResult.meaning}]`;
              console.warn("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): æä¾›äº† meaning ä½†æœªæ‰¾åˆ°å¯¹åº”è¡¨æƒ…:", parsedResult.meaning);
              found = true;
            }
          }



          if (!found && parsedResult.url) {
            newMessage.content = parsedResult.url;

            const stickerByURL = state.userStickers.find(s => s.url === parsedResult.url);

            if (parsedResult.meaning && (!stickerByURL || stickerByURL.name === parsedResult.meaning)) {
              newMessage.meaning = parsedResult.meaning;
            } else if (stickerByURL) {
              newMessage.meaning = stickerByURL.name;
            } else {
              newMessage.meaning = 'æœªçŸ¥è¡¨æƒ…';
            }
            console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): ä½¿ç”¨äº† URLï¼Œæœ€ç»ˆ meaning:", newMessage.meaning);
            found = true;
          }


          if (!found && parsedResult.content && typeof parsedResult.content === 'string' && STICKER_REGEX.test(parsedResult.content)) {
            newMessage.content = parsedResult.content;

            const sticker = state.userStickers.find(s => s.url === parsedResult.content);
            newMessage.meaning = sticker ? sticker.name : 'æœªçŸ¥è¡¨æƒ…';
            console.log("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): å°† content è§†ä¸º URLï¼ŒæŸ¥æ‰¾åˆ° meaning:", newMessage.meaning);
            found = true;
          }


          if (!found) {
            console.error("å¯¼æ¼”/ç¼–è¾‘æ¨¡å¼ä¿å­˜(Sticker): æŒ‡ä»¤æ— æ•ˆæˆ–ç¼ºå°‘å¿…è¦å­—æ®µ (meaning/url/content):", parsedResult);
            continue;
          }
          break;
        }
        case 'transfer':
          newMessage.type = 'transfer';
          newMessage.amount = parsedResult.amount;
          newMessage.note = parsedResult.note;
          break;
        case 'share_link':
          newMessage.type = 'share_link';
          newMessage.title = parsedResult.title;
          newMessage.description = parsedResult.description;
          newMessage.source_name = parsedResult.source_name;
          newMessage.content = parsedResult.content;
          break;
        default:

          Object.assign(newMessage, parsedResult);
          break;
      }

      newMessages.push(newMessage);
    }

    if (newMessages.length === 0) {
      document.getElementById('message-editor-modal').classList.remove('visible');
      return;
    }



    chat.history.splice(messageIndex, 1, ...newMessages);


    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
      chat.history[i].timestamp = reassignTimestamp;
      reassignTimestamp++;
    }

    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('æˆåŠŸ', 'æ¶ˆæ¯å·²æ›´æ–°ï¼');
  }



  function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
  }


  function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
  }

 
  async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();


    let contentForEditing;
    if (post.type === 'shuoshuo') {
      contentForEditing = post.content;
    } else {

      const postObject = {
        type: post.type,
        publicText: post.publicText || '',
      };
      if (post.type === 'image_post') {
        postObject.imageUrl = post.imageUrl;
        postObject.imageDescription = post.imageDescription;
      } else if (post.type === 'text_image') {
        postObject.hiddenContent = post.hiddenContent;
      }
      contentForEditing = JSON.stringify(postObject, null, 2);
    }


    const templates = {
      shuoshuo: "åœ¨è¿™é‡Œè¾“å…¥è¯´è¯´çš„å†…å®¹...",
      image: {
        type: 'image_post',
        publicText: '',
        imageUrl: 'https://...',
        imageDescription: ''
      },
      text_image: {
        type: 'text_image',
        publicText: '',
        hiddenContent: ''
      }
    };

    const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-type="text">è¯´è¯´</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡åŠ¨æ€</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>æ–‡å­—å›¾</button>
                </div>
            `;

    const newContent = await showCustomPrompt(
      'ç¼–è¾‘åŠ¨æ€',
      'åœ¨æ­¤ä¿®æ”¹å†…å®¹...',
      contentForEditing,
      'textarea',
      helpersHtml
    );



    setTimeout(() => {
      const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
      if (shuoshuoBtn) {
        shuoshuoBtn.addEventListener('click', () => {
          const input = document.getElementById('custom-prompt-input');
          input.value = templates.shuoshuo;
          input.focus();
        });
      }
    }, 100);

    if (newContent !== null) {
      await saveEditedPost(postIdToEdit, newContent);
    }
  }

  
  async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();


    try {
      const parsed = JSON.parse(trimmedContent);

      post.type = parsed.type || 'image_post';
      post.publicText = parsed.publicText || '';
      post.imageUrl = parsed.imageUrl || '';
      post.imageDescription = parsed.imageDescription || '';
      post.hiddenContent = parsed.hiddenContent || '';
      post.content = '';
    } catch (e) {

      post.type = 'shuoshuo';
      post.content = trimmedContent;

      post.publicText = '';
      post.imageUrl = '';
      post.imageDescription = '';
      post.hiddenContent = '';
    }

    await db.qzonePosts.put(post);
    await renderQzonePosts();
    await showCustomAlert('æˆåŠŸ', 'åŠ¨æ€å·²æ›´æ–°ï¼');
  }

 
  async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;

    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('å¤åˆ¶æˆåŠŸ', 'åŠ¨æ€å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚');
    } catch (err) {
      await showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•è®¿é—®å‰ªè´´æ¿ã€‚');
    }

    hidePostActions();
  }


  let selectedContacts = new Set();

  async function openContactPickerForGroupCreate() {

    const choice = await showChoiceModal('åˆ›å»ºç¾¤èŠ', [{
        text: 'åˆ›å»ºæ™®é€šç¾¤èŠ (æˆ‘å‚ä¸)',
        value: 'normal'
      },
      {
        text: 'åˆ›å»ºæ—è§‚å•èŠ (2äººèŠå¤©)', 
        value: 'spectator_private'
      },
      {
        text: 'åˆ›å»ºæ—è§‚ç¾¤èŠ (å¤šäººå›´è§‚)',
        value: 'spectator'
      }
    ]);

    if (choice === 'normal') {

      selectedContacts.clear();
      const confirmBtn = document.getElementById('confirm-contact-picker-btn');
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.addEventListener('click', handleCreateGroup);
      await renderContactPicker();
      showScreen('contact-picker-screen');

    } else if (choice === 'spectator') {

      openSpectatorGroupCreator();
    
    } else if (choice === 'spectator_private') {
        
      openSpectatorPrivateCreator();
    }
  }




  async function openSpectatorGroupCreator() {
    currentSpectatorMode = 'group';
    selectedContacts.clear();


    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup);


    await renderSpectatorContactPicker();


    showScreen('contact-picker-screen');
  }

  async function openSpectatorPrivateCreator() {
    currentSpectatorMode = 'private'; 
    selectedContacts.clear();

    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup); 

    await renderSpectatorContactPicker();

    showScreen('contact-picker-screen');
  } 
  async function renderSpectatorContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">è¿˜æ²¡æœ‰ä»»ä½•è§’è‰²æˆ–NPCå¯ä»¥åŠ å…¥ç¾¤èŠã€‚</p>';
      return;
    }


    characters.forEach(contact => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = contact.id;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
        `;
      listEl.appendChild(item);
    });


    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = npc.id;
      item.dataset.isNpc = "true";
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
      listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
  }

 
  async function handleCreateSpectatorGroup() {
   
    if (currentSpectatorMode === 'private' && selectedContacts.size !== 2) {
      alert("æ—è§‚å•èŠå¿…é¡»é€‰æ‹©ã€æ­£å¥½ 2 ä½ã€‘æˆå‘˜ã€‚");
      return;
    }
    if (currentSpectatorMode === 'group' && selectedContacts.size < 2) {
      alert("æ—è§‚ç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹© 2 ä¸ªæˆå‘˜ã€‚");
      return;
    }
    

    const groupName = await showCustomPrompt('è®¾ç½®ç¾¤å', 'è¯·è¾“å…¥ç¾¤èŠçš„åå­—', 'AIä»¬çš„èŒ¶è¯ä¼š');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {
      const isNpc = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`).dataset.isNpc === "true";

      if (isNpc) {

        const npcData = allNpcs.find(n => n.id === parseInt(contactId));
        if (npcData) {
          members.push({
            id: `npc_${npcData.id}`,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      } else {

        const contactChat = state.chats[contactId];
        if (contactChat) {
          members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      }
    }

    const newGroupChat = {
      id: newChatId,
      name: groupName.trim(),
      isGroup: true,
      isSpectatorGroup: true,
      members: members,
      settings: {

        maxMemory: 10,
        groupAvatar: defaultGroupAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
      },
      history: [{
        role: 'system',
        content: '[ç³»ç»ŸæŒ‡ä»¤ï¼šè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰ç”¨æˆ·å‚ä¸çš„ç¾¤èŠï¼Œè¯·ä½ ä»¬æ ¹æ®å„è‡ªçš„äººè®¾è‡ªç”±åœ°å¼€å§‹å¯¹è¯ã€‚]',
        timestamp: Date.now(),
        isHidden: true
      }],
      musicData: {
        totalTime: 0
      }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
  }

  async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">è¿˜æ²¡æœ‰å¯ä»¥æ‹‰è¿›ç¾¤çš„è”ç³»äººå“¦~</p>';
      return;
    }


    characters.forEach(contact => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = contact.id;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
        `;
      listEl.appendChild(item);
    });


    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';

      item.dataset.contactId = `npc_${npc.id}`;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
      listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
  }

  function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    
    if (currentSpectatorMode === 'private') {
     
      btn.textContent = `å®Œæˆ(${selectedContacts.size}/2)`;
      btn.disabled = selectedContacts.size !== 2;
    } else {
   
      btn.textContent = `å®Œæˆ(${selectedContacts.size})`;
      btn.disabled = selectedContacts.size < 2;
    }
  }

  async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
      alert("åˆ›å»ºç¾¤èŠè‡³å°‘éœ€è¦é€‰æ‹©2ä¸ªè”ç³»äººã€‚");
      return;
    }

    const groupName = await showCustomPrompt('è®¾ç½®ç¾¤å', 'è¯·è¾“å…¥ç¾¤èŠçš„åå­—', 'æˆ‘ä»¬çš„ç¾¤èŠ');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {

      if (contactId.startsWith('npc_')) {
        const npcId = parseInt(contactId.replace('npc_', ''));
        const npcData = allNpcs.find(n => n.id === npcId);
        if (npcData) {
          members.push({
            id: contactId,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      } else {
        const contactChat = state.chats[contactId];
        if (contactChat) {
          members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      }
    }

    const newGroupChat = {
      id: newChatId,
      name: groupName.trim(),
      isGroup: true,
      members: members,
      settings: {
        myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
        myNickname: 'æˆ‘',
        maxMemory: 10,
        groupAvatar: defaultGroupAvatar,
        myAvatar: defaultMyGroupAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
      },
      history: [],
      musicData: {
        totalTime: 0
      }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
  }




  function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
  }

  function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
      const item = document.createElement('div');
      item.className = 'member-management-item';

      item.innerHTML = `
                    <img src="${member.avatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                    <button class="remove-member-btn" data-member-id="${member.id}" title="ç§»å‡ºç¾¤èŠ">-</button>
                `;
      listEl.appendChild(item);
    });
  }

  /**
   * ä»ç¾¤èŠä¸­ç§»é™¤ä¸€ä¸ªæˆå‘˜
   * @param {string} memberId - è¦ç§»é™¤çš„æˆå‘˜ID
   */
  async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);

    if (memberIndex === -1) return;


    if (chat.members.length <= 2) {
      alert("ç¾¤èŠäººæ•°ä¸èƒ½å°‘äº2äººã€‚");
      return;
    }

    const memberName = chat.members[memberIndex].groupNickname;
    const confirmed = await showCustomConfirm(
      'ç§»å‡ºæˆå‘˜',
      `ç¡®å®šè¦å°†â€œ${memberName}â€ç§»å‡ºç¾¤èŠå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      chat.members.splice(memberIndex, 1);
      await db.chats.put(chat);
      renderMemberManagementList();
      document.getElementById('chat-settings-btn').click();
    }
  }

 
  async function openContactPickerForAddMember() {

    const confirmBtn = document.getElementById('confirm-contact-picker-btn');

    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);


    await renderUnifiedContactPicker();


    showScreen('contact-picker-screen');
  }


  async function renderUnifiedContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear();

    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));


    const characters = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));


    const npcs = (await db.npcs.toArray()).filter(n => !existingMemberIds.has(`npc_${n.id}`));

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">æ²¡æœ‰æ›´å¤šå¯ä»¥é‚€è¯·çš„è”ç³»äººäº†ã€‚</p>';
      document.getElementById('confirm-contact-picker-btn').style.display = 'none';
    } else {
      document.getElementById('confirm-contact-picker-btn').style.display = 'block';


      characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.dataset.contactType = 'character';
        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name} <small style="color:#888;">(è§’è‰²)</small></span>
            `;
        listEl.appendChild(item);
      });


      npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = `npc_${npc.id}`;
        item.dataset.contactType = 'npc';
        item.dataset.npcId = npc.id;
        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
            `;
        listEl.appendChild(item);
      });
    }

    updateContactPickerConfirmButton();
  }



  async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ·»åŠ çš„è”ç³»äººã€‚");
      return;
    }

    const chat = state.chats[state.activeChatId];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {
      const itemEl = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`);
      if (!itemEl) continue;

      const contactType = itemEl.dataset.contactType;

      if (contactType === 'character') {
        const contactChat = state.chats[contactId];
        if (contactChat) {
          chat.members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,

            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      } else if (contactType === 'npc') {
        const npcId = parseInt(itemEl.dataset.npcId);
        const npcData = allNpcs.find(n => n.id === npcId);
        if (npcData) {


          chat.members.push({
            id: `npc_${npcId}`,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      }
    }

    await db.chats.put(chat);


    openMemberManagementScreen();
  }



  function createNewMemberInGroup() {

    isAddingNpcToGroup = true;

    openNpcEditor(null);
  }



  function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
      const now = Date.now();
      const distance = endTime - now;

      if (distance < 0) {
        clearInterval(timerId);
        element.innerHTML = '<span>å·²</span><span>è¶…</span><span>æ—¶</span>';
        return;
      }

      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((distance % (1000 * 60)) / 1000);

      const minStr = String(minutes).padStart(2, '0');
      const secStr = String(seconds).padStart(2, '0');

      element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
  }

  function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
      clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
  }



 
  async function showWaimaiDetails(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);

    if (!message || !['waimai_request', 'waimai_order'].includes(message.type)) {
      console.error("showWaimaiDetails: æ‰¾ä¸åˆ°æ¶ˆæ¯æˆ–æ¶ˆæ¯ç±»å‹ä¸æ­£ç¡®", timestamp);
      return;
    }

    let detailsHtml = '';

    if (message.type === 'waimai_request') {

      let statusText;
      switch (message.status) {
        case 'paid':
          const payerName = message.paidBy || 'å¯¹æ–¹';
          const payerDisplayName = getDisplayNameInGroup(chat, payerName);
          statusText = `ç”± ${payerDisplayName} ä¸ºæ‚¨ä»£ä»˜æˆåŠŸ`;
          break;
        case 'rejected':
          statusText = 'ä»£ä»˜è¯·æ±‚å·²è¢«æ‹’ç»';
          break;
        default:
          statusText = 'ç­‰å¾…å¯¹æ–¹å¤„ç†';
          break;
      }
      detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>å•†å“:</strong> ${message.productInfo}<br>
                <strong>é‡‘é¢:</strong> Â¥${Number(message.amount).toFixed(2)}<br>
                <strong>çŠ¶æ€:</strong> ${statusText}
            </div>
        `;
    } else if (message.type === 'waimai_order') {

      let senderDisplayName;
      let recipientDisplayName;

      if (chat.isGroup) {

        senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
        recipientDisplayName = getDisplayNameInGroup(chat, message.recipientName);
      } else {

        if (message.role === 'user') {

          senderDisplayName = chat.settings.myNickname || 'æˆ‘';
          recipientDisplayName = chat.name;
        } else {

          senderDisplayName = chat.name;
          recipientDisplayName = chat.settings.myNickname || 'æˆ‘';
        }
      }


      detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>è®¢å•ç±»å‹:</strong> ä¸ºTAç‚¹å•<br>
                <strong>èµ é€æ–¹:</strong> ${senderDisplayName}<br>
                <strong>æ¥æ”¶æ–¹:</strong> ${recipientDisplayName}<br>
                <strong>å•†å“:</strong> ${message.productInfo}<br>
                <strong>é‡‘é¢:</strong> Â¥${Number(message.amount).toFixed(2)}
            </div>
        `;
    }

    await showCustomAlert("è®¢å•è¯¦æƒ…", detailsHtml);
  }


  async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;


    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;


    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

    if (choice === 'paid') {
      const success = await processTransaction(originalMessage.amount, 'expense', `å¸®ä»˜å¤–å–-${originalMessage.senderName}`);
      
      if (!success) return; // ä½™é¢ä¸è¶³ï¼Œä¸æ”¹å˜çŠ¶æ€ï¼Œç›´æ¥è¿”å›

      originalMessage.status = choice;
      originalMessage.paidBy = myNickname;
      systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) ä¸º ${originalMessage.senderName} çš„å¤–å–è®¢å•ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰å®Œæˆäº†æ”¯ä»˜ã€‚æ­¤è®¢å•å·²å…³é—­ï¼Œå…¶ä»–æˆå‘˜ä¸èƒ½å†æ”¯ä»˜ã€‚]`;
    } else {
      originalMessage.status = choice;

      systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½  (${myNickname}) æ‹’ç»äº† ${originalMessage.senderName} çš„å¤–å–ä»£ä»˜è¯·æ±‚ï¼ˆæ—¶é—´æˆ³: ${originalTimestamp}ï¼‰ã€‚]`;
    }


    const systemNote = {
      role: 'system',
      content: systemContent,
      timestamp: Date.now(),
      isHidden: true
    };
    chat.history.push(systemNote);


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
  }

  let videoCallState = {
    isActive: false,
    isAwaitingResponse: false,
    isGroupCall: false,
    activeChatId: null,
    initiator: null,
    startTime: null,
    participants: [],
    isUserParticipating: true,

    callHistory: [],
    preCallContext: ""
  };

  let callTimerInterval = null;


  async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;


    if (chat.isGroup) {
      document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
      document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || 'æˆ‘';
    } else {
      document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
      document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "æ­£åœ¨å‘¼å«æ‰€æœ‰æˆå‘˜..." : "æ­£åœ¨å‘¼å«...";
    showScreen('outgoing-call-screen');


    const requestMessage = {
      role: 'system',
      content: chat.isGroup ?
        `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${chat.settings.myNickname || 'æˆ‘'}) å‘èµ·äº†ç¾¤è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–ï¼Œå¹¶ä½¿ç”¨ "group_call_response" æŒ‡ä»¤ï¼Œè®¾ç½® "decision" ä¸º "join" æˆ– "decline" æ¥å›åº”ã€‚]` :
        `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œä½¿ç”¨ "video_call_response" æŒ‡ä»¤ï¼Œå¹¶è®¾ç½® "decision" ä¸º "accept" æˆ– "reject" æ¥å›åº”ã€‚]`,
      timestamp: Date.now(),
      isHidden: true,
    };
    chat.history.push(requestMessage);
    await db.chats.put(chat);


    await triggerAiResponse();
  }


  function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = [];


    const preCallHistory = chat.history.slice(-10);
    videoCallState.preCallContext = preCallHistory.map(msg => {
      const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
      return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');


    updateParticipantAvatars();

    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? 'ç¾¤èŠå·²å»ºç«‹...' : 'æ­£åœ¨æ¥é€š...'}</em>`;
    showScreen('video-call-screen');
    
    // åº”ç”¨è§†é¢‘é€šè¯ä¼˜åŒ–è®¾ç½®
    if (typeof window.applyVideoOptimizationToCall === 'function') {
      window.applyVideoOptimizationToCall(chat);
    }

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
  }

function minimizeVideoCall() {
    if (!videoCallState.isActive) return;

   
    document.getElementById('video-call-restore-btn').style.display = 'flex';

  
    showScreen('chat-interface-screen'); 
    
 
    console.log("è§†é¢‘é€šè¯å·²æœ€å°åŒ–ã€‚");
}


function restoreVideoCall() {
    if (!videoCallState.isActive) return;

    
    document.getElementById('video-call-restore-btn').style.display = 'none';

    
    showScreen('video-call-screen');
    console.log("è§†é¢‘é€šè¯å·²æ¢å¤ã€‚");
}  
  async function endVideoCall() {
    if (!videoCallState.isActive) return;
    document.getElementById('video-call-restore-btn').style.display = 'none';
    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}åˆ†${duration % 60}ç§’`;
    const endCallText = `é€šè¯ç»“æŸï¼Œæ—¶é•¿ ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {

      const participantsData = [];
      if (videoCallState.isGroupCall) {
        videoCallState.participants.forEach(p => participantsData.push({
          name: p.originalName,
          avatar: p.avatar
        }));
        if (videoCallState.isUserParticipating) {
          participantsData.unshift({
            name: chat.settings.myNickname || 'æˆ‘',
            avatar: chat.settings.myAvatar || defaultMyGroupAvatar
          });
        }
      } else {
        participantsData.push({
          name: chat.name,
          avatar: chat.settings.aiAvatar || defaultAvatar
        });
        participantsData.unshift({
          name: 'æˆ‘',
          avatar: chat.settings.myAvatar || defaultAvatar
        });
      }

      const callRecord = {
        chatId: videoCallState.activeChatId,
        timestamp: Date.now(),
        duration: duration,
        participants: participantsData,
        transcript: [...videoCallState.callHistory]
      };
      await db.callRecords.add(callRecord);
      console.log("é€šè¯è®°å½•å·²ä¿å­˜:", callRecord);


      let summaryMessage = {
        role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
        content: endCallText,
        timestamp: Date.now(),
      };
      if (chat.isGroup && summaryMessage.role === 'assistant') {
        summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
      }
      chat.history.push(summaryMessage);






      const callTranscriptForAI = videoCallState.callHistory.map(h => {
        const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : h.senderName;
        return `${sender}: ${h.content}`;
      }).join('\n');



      summarizeCallTranscript(chat.id, callTranscriptForAI);


      const hiddenReactionInstruction = {
        role: 'system',
        content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šè§†é¢‘é€šè¯åˆšåˆšç»“æŸã€‚è¯·ä½ ä»¥è§’è‰²çš„å£å»ï¼Œå‘ç”¨æˆ·ä¸»åŠ¨å‘é€ä¸€ä¸¤æ¡æ¶ˆæ¯ï¼Œæ¥è‡ªç„¶åœ°æ€»ç»“è¿™æ¬¡é€šè¯çš„è¦ç‚¹ã€ç¡®è®¤è¾¾æˆçš„çº¦å®šï¼Œæˆ–è€…è¡¨è¾¾ä½ çš„æ„Ÿå—ã€‚]`,
        timestamp: Date.now() + 1,
        isHidden: true
      };
      chat.history.push(hiddenReactionInstruction);


      await db.chats.put(chat);
    }


    clearInterval(callTimerInterval);
    callTimerInterval = null;
    
    // åœæ­¢æ‘„åƒå¤´
    if (typeof stopCamera === 'function') {
      stopCamera();
    }
    
    videoCallState = {
      isActive: false,
      isAwaitingResponse: false,
      isGroupCall: false,
      activeChatId: null,
      initiator: null,
      startTime: null,
      participants: [],
      isUserParticipating: true,
      callHistory: [],
      preCallContext: ""
    };


    if (chat) {
      openChat(chat.id);
      triggerAiResponse();
    }
  }



  function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];


    if (videoCallState.isGroupCall) {

      participantsToRender = [...videoCallState.participants];

      if (videoCallState.isUserParticipating) {
        participantsToRender.unshift({
          id: 'user',
          name: chat.settings.myNickname || 'æˆ‘',
          avatar: chat.settings.myAvatar || defaultMyGroupAvatar
        });
      }
    } else {

      participantsToRender.push({
        id: 'ai',
        name: chat.name,
        avatar: chat.settings.aiAvatar || defaultAvatar
      });
    }

    participantsToRender.forEach(p => {
      const wrapper = document.createElement('div');
      wrapper.className = 'participant-avatar-wrapper';
      wrapper.dataset.participantId = p.id;
      const displayName = p.groupNickname || p.name;
      wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
            <div class="participant-name">${displayName}</div>
        `;
      grid.appendChild(wrapper);
    });
  }

  
  function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;

    videoCallState.isUserParticipating = true;
    updateParticipantAvatars();


    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';


    triggerAiInCallAction("[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åŠ å…¥äº†é€šè¯]");
  }


 
  function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }


  function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    if (chat.isGroup) {

      const requesterName = videoCallState.callRequester || chat.members[0]?.name || 'ä¸€ä½æˆå‘˜';
      document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
      document.getElementById('caller-name').textContent = chat.name;
      document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} é‚€è¯·ä½ åŠ å…¥ç¾¤è§†é¢‘`;
    } else {

      document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
      document.getElementById('caller-name').textContent = chat.name;
      document.querySelector('.incoming-call-content .caller-text').textContent = 'é‚€è¯·ä½ è§†é¢‘é€šè¯';
    }

    document.getElementById('incoming-call-modal').classList.add('visible');
  }



  function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
  }


  async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || 'æˆ‘';

    let worldBookContent = '';
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    
    if (allWorldBookIds.length > 0) {
      const linkedContents = allWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        return worldBook && worldBook.content ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${worldBook.content}` : '';
      }).filter(Boolean).join('');
      if (linkedContents) {
        worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
      }
    }
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      `\n# é•¿æœŸè®°å¿† (å¿…é¡»å‚è€ƒ)\n` + chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '';

    if (userInput && videoCallState.isUserParticipating) {
      const userTimestamp = Date.now();
      const userBubble = document.createElement('div');
      userBubble.className = 'call-message-bubble user-speech';
      userBubble.textContent = userInput;
      userBubble.dataset.timestamp = userTimestamp;
      addLongPressListener(userBubble, () => showCallMessageActions(userTimestamp));
      callFeed.appendChild(userBubble);
      callFeed.scrollTop = callFeed.scrollHeight;
      
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨çœŸå®æ‘„åƒå¤´å¹¶è·å–æˆªå›¾
      let userContent = userInput;
      if (chat.videoOptimization && chat.videoOptimization.enableRealCamera) {
        const capturedImage = window.getLastCameraCapture ? window.getLastCameraCapture() : null;
        if (capturedImage) {
          // ä¸ºæ”¯æŒè§†è§‰çš„æ¨¡å‹æ„å»ºå¤šæ¨¡æ€æ¶ˆæ¯
          userContent = [
            { type: 'text', text: userInput },
            { type: 'image_url', image_url: { url: capturedImage } }
          ];
        }
      }
      
      videoCallState.callHistory.push({
        role: 'user',
        content: userContent,
        timestamp: userTimestamp
      });
    }


    let inCallPrompt;
    if (videoCallState.isGroupCall) {
      const participantNames = videoCallState.participants.map(p => p.name);
      if (videoCallState.isUserParticipating) {
        participantNames.unshift(userNickname);
      }
      inCallPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ æ˜¯ä¸€ä¸ªç¾¤èŠè§†é¢‘é€šè¯çš„å¯¼æ¼”ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”æ‰€æœ‰ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„AIè§’è‰²ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°ä»–ä»¬åœ¨é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€èº«ä»½é“å¾‹ã€‘**: ç”¨æˆ·çš„èº«ä»½æ˜¯ã€${userNickname}ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ \`name\` å­—æ®µä¸º **"${userNickname}"** çš„å‘è¨€ã€‚
        2.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„å›å¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚
        3.  **æ ¼å¼**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªè§’è‰²çš„å‘è¨€ï¼Œæ ¼å¼ä¸ºï¼š\`{"name": "è§’è‰²å", "speech": "*ä»–ç¬‘äº†ç¬‘* å¤§å®¶å¥½å•Šï¼"}\`ã€‚
        4.  **è§’è‰²æ‰®æ¼”**: ä¸¥æ ¼éµå®ˆæ¯ä¸ªè§’è‰²çš„è®¾å®šã€‚
        # å½“å‰æƒ…æ™¯
        ä½ ä»¬æ­£åœ¨ä¸€ä¸ªç¾¤è§†é¢‘é€šè¯ä¸­ã€‚
         ${longTermMemoryContext}
        **é€šè¯å‰çš„èŠå¤©æ‘˜è¦**:
        ${videoCallState.preCallContext}
        **å½“å‰å‚ä¸è€…**: ${participantNames.join('ã€ ')}ã€‚
        **é€šè¯åˆšåˆšå¼€å§‹...**
        ${worldBookContent}
        ç°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®æ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
        `;
    } else {
      let openingContext = videoCallState.initiator === 'user' ?
        `ä½ åˆšåˆšæ¥å¬äº†ç”¨æˆ·çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚` :
        `ç”¨æˆ·åˆšåˆšæ¥å¬äº†ä½ ä¸»åŠ¨å‘èµ·çš„è§†é¢‘é€šè¯ã€‚`;
      inCallPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ ç°åœ¨æ˜¯ä¸€ä¸ªåœºæ™¯æè¿°å¼•æ“ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼” ${chat.name} (${chat.settings.aiPersona})ï¼Œå¹¶ä»¥ã€ç¬¬ä¸‰äººç§°æ—è§‚è§†è§’ã€‘æ¥æè¿°TAåœ¨è§†é¢‘é€šè¯ä¸­çš„æ‰€æœ‰åŠ¨ä½œå’Œè¯­è¨€ã€‚
        # æ ¸å¿ƒè§„åˆ™
        1.  **ã€ã€ã€è§†è§’é“å¾‹ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€ç»å¯¹ä¸èƒ½ã€‘ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€ã€‚å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼Œå¦‚â€œä»–â€ã€â€œå¥¹â€ã€æˆ–ç›´æ¥ä½¿ç”¨è§’è‰²åâ€œ${chat.name}â€ã€‚
        2.  **æ ¼å¼**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€æ®µæè¿°æ€§çš„æ–‡æœ¬ã€‚
        # å½“å‰æƒ…æ™¯
        ä½ æ­£åœ¨å’Œç”¨æˆ·ï¼ˆ${userNickname}ï¼Œäººè®¾: ${chat.settings.myPersona}ï¼‰è¿›è¡Œè§†é¢‘é€šè¯ã€‚
        ${longTermMemoryContext}
        **${openingContext}**
        **é€šè¯å‰çš„èŠå¤©æ‘˜è¦ (è¿™æ˜¯ä½ ä»¬é€šè¯çš„åŸå› ï¼Œè‡³å…³é‡è¦ï¼)**:
        ${videoCallState.preCallContext}
        ç°åœ¨ï¼Œè¯·æ ¹æ®ã€é€šè¯å‰æ‘˜è¦ã€‘å’Œä¸‹é¢çš„ã€é€šè¯å®æ—¶è®°å½•ã€‘ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚
        `;
    }

    
    const messagesForApi = [{
        role: 'system',
        content: inCallPrompt
      },
      ...videoCallState.callHistory.map(h => ({
        role: h.role,
        content: h.content
      }))
    ];

    if (videoCallState.callHistory.length === 0) {
      const firstLineTrigger = videoCallState.initiator === 'user' ? `*ä½ æŒ‰ä¸‹äº†æ¥å¬é”®...*` : `*å¯¹æ–¹æŒ‰ä¸‹äº†æ¥å¬é”®...*`;
      messagesForApi.push({
        role: 'user',
        content: firstLineTrigger
      });
    }

    try {
      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi)
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: state.globalSettings.apiTemperature || 0.8
        })
      });
      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

      const connectingElement = callFeed.querySelector('em');
      if (connectingElement) connectingElement.remove();
      if (videoCallState.isGroupCall) {
        const speechArray = parseAiResponse(aiResponse);
        speechArray.forEach(turn => {
          if (!turn.name || turn.name === userNickname || !turn.speech) return;
          const aiTimestamp = Date.now() + Math.random();
          const aiBubble = document.createElement('div');
          aiBubble.className = 'call-message-bubble ai-speech';
          aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
          aiBubble.dataset.timestamp = aiTimestamp;
          addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp));
          callFeed.appendChild(aiBubble);
          videoCallState.callHistory.push({
            role: 'assistant',
            content: `${turn.name}: ${turn.speech}`,
            timestamp: aiTimestamp
          });

          const speaker = videoCallState.participants.find(p => p.name === turn.name);
          if (speaker) {
            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
            if (speakingAvatar) {
              speakingAvatar.classList.add('speaking');
              setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
          }
        });
      } else {
        const aiTimestamp = Date.now();
        const aiBubble = document.createElement('div');
        aiBubble.className = 'call-message-bubble ai-speech';
        aiBubble.textContent = aiResponse;
        aiBubble.dataset.timestamp = aiTimestamp;
        addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp));
        callFeed.appendChild(aiBubble);
        videoCallState.callHistory.push({
          role: 'assistant',
          content: aiResponse,
          timestamp: aiTimestamp
        });
        const enableTts = chat.settings.enableTts !== false;
        const voiceId = chat.settings.minimaxVoiceId;

        if (enableTts && voiceId) {
            playVideoCallPureTTS(aiResponse, voiceId);
        }
        // ===============================================

        // ================= å¤´åƒåŠ¨ç”»ä¿®å¤ =================
        // åŸå› ï¼šquerySelector é»˜è®¤åªé€‰ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆé€šå¸¸æ˜¯ç”¨æˆ·è‡ªå·±ï¼‰ï¼Œå¯¼è‡´AIè¯´è¯æ—¶ç”¨æˆ·å¤´åƒåœ¨åŠ¨ï¼Œæˆ–è€…æ ·å¼é”™ä½ã€‚
        // ä¿®å¤ï¼šå¢åŠ  [data-participant-id="ai"] ç²¾ç¡®æŸ¥æ‰¾å¯¹æ–¹çš„å¤´åƒã€‚
        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="ai"] .participant-avatar`);
        
        if (speakingAvatar) {
          speakingAvatar.classList.add('speaking');
          // åŠ¨æ€è®¡ç®—è¯´è¯æ—¶é•¿ï¼šæ¯å­—200msï¼Œæœ€é•¿5ç§’
          const speakTime = Math.min(aiResponse.length * 200, 5000); 
          setTimeout(() => speakingAvatar.classList.remove('speaking'), speakTime);
        }
      }

      callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
      const errorBubble = document.createElement('div');
      errorBubble.className = 'call-message-bubble ai-speech';
      errorBubble.style.color = '#ff8a80';
      errorBubble.textContent = `[ERROR: ${error.message}]`;
      callFeed.appendChild(errorBubble);
      callFeed.scrollTop = callFeed.scrollHeight;
      videoCallState.callHistory.push({
        role: 'assistant',
        content: `[ERROR: ${error.message}]`
      });
    }
  }



  function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
  }



  




  async function handleUserPat(chatId, characterOriginalName) {
    const chat = state.chats[chatId];
    if (!chat) return;


    let displayNameForUI;
    if (chat.isGroup) {

      displayNameForUI = getDisplayNameInGroup(chat, characterOriginalName);
    } else {

      displayNameForUI = chat.name;
    }

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');


    const suffix = await showCustomPrompt(
      `ä½ æ‹äº†æ‹ â€œ${displayNameForUI}â€`,
      "ï¼ˆå¯é€‰ï¼‰è¾“å…¥åç¼€",
      "",
      "text"
    );

    if (suffix === null) return;

    // è·å–ç”¨æˆ·æ˜µç§°ï¼Œå¦‚æœæ˜¯ {{user}} åˆ™ä½¿ç”¨ "ä½ "
    let myNickname = state.qzoneSettings.nickname;
    if (!myNickname || myNickname === '{{user}}') {
      myNickname = 'ä½ ';
    }
    
    // å¦‚æœæ˜¯ç¾¤èŠï¼Œä½¿ç”¨ç¾¤æ˜µç§°
    if (chat.isGroup) {
      myNickname = chat.settings.myNickname || 'ä½ ';
    }



    const visibleMessageContent = `${myNickname} æ‹äº†æ‹ â€œ${displayNameForUI}â€ ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);


    const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ‹äº†æ‹ä½ ï¼ˆ${characterOriginalName}ï¼‰${suffix.trim()}ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›åº”ã€‚]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }

  // æ–°å¢ï¼šå¤„ç†ç”¨æˆ·æ‹è‡ªå·±çš„åŠŸèƒ½
  async function handleUserPatSelf(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');

    // è·å–ç”¨æˆ·æ˜µç§°ï¼Œå¦‚æœæ˜¯ {{user}} åˆ™ä½¿ç”¨ "ä½ "
    let myNickname = state.qzoneSettings.nickname;
    if (!myNickname || myNickname === '{{user}}') {
      myNickname = 'ä½ ';
    }
    
    // å¦‚æœæ˜¯ç¾¤èŠï¼Œä½¿ç”¨ç¾¤æ˜µç§°
    if (chat.isGroup) {
      myNickname = chat.settings.myNickname || 'ä½ ';
    }

    // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ‹è‡ªå·±çš„åç¼€
    const suffix = await showCustomPrompt(
      `${myNickname} æ‹äº†æ‹è‡ªå·±`,
      "è¾“å…¥æ‹ä¸€æ‹åç¼€",
      "",
      "text"
    );

    if (suffix === null) return;

    // åˆ›å»ºå¯è§çš„æ‹ä¸€æ‹æ¶ˆæ¯
    const visibleMessageContent = `${myNickname} æ‹äº†æ‹è‡ªå·± ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // åˆ›å»ºéšè—çš„ç³»ç»Ÿæç¤ºï¼Œè®©AIçŸ¥é“ç”¨æˆ·æ‹äº†è‡ªå·±
    const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ‹äº†æ‹è‡ªå·±${suffix.trim()}ã€‚ä½ å¯ä»¥å¯¹æ­¤ä½œå‡ºå›åº”æˆ–è¯„è®ºã€‚]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }

  let activeCallMessageTimestamp = null;
  let isFrameManagementMode = false;
  let selectedFrames = new Set();

  function showCallMessageActions(timestamp) {
    activeCallMessageTimestamp = timestamp;
    document.getElementById('call-message-actions-modal').classList.add('visible');
  }


  function hideCallMessageActions() {
    document.getElementById('call-message-actions-modal').classList.remove('visible');
    activeCallMessageTimestamp = null;
  }

 
  async function openCallMessageEditor() {
    if (!activeCallMessageTimestamp) return;

    const timestampToEdit = activeCallMessageTimestamp;
    const message = videoCallState.callHistory.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideCallMessageActions();

    let contentForEditing = message.content;

    if (videoCallState.isGroupCall && message.role === 'assistant') {
      const parts = message.content.split(': ');
      if (parts.length > 1) {
        contentForEditing = parts.slice(1).join(': ');
      }
    }

    const newContent = await showCustomPrompt(
      'ç¼–è¾‘é€šè¯æ¶ˆæ¯',
      'åœ¨æ­¤ä¿®æ”¹å†…å®¹...',
      contentForEditing,
      'textarea'
    );

    if (newContent !== null) {
      await saveEditedCallMessage(timestampToEdit, newContent);
    }
  }

  
  async function saveEditedCallMessage(timestamp, newContent) {
    const message = videoCallState.callHistory.find(m => m.timestamp === timestamp);
    if (message) {
      let finalContent = newContent;

      if (videoCallState.isGroupCall && message.role === 'assistant') {
        const parts = message.content.split(': ');
        const senderName = parts[0];
        finalContent = `${senderName}: ${newContent}`;
      }
      message.content = finalContent;


      const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestamp}"]`);
      if (messageBubble) {
        if (videoCallState.isGroupCall && message.role === 'assistant') {
          const parts = message.content.split(': ');
          const senderName = parts[0];
          messageBubble.innerHTML = `<strong>${senderName}:</strong> ${newContent}`;
        } else {
          messageBubble.textContent = newContent;
        }
      }
    }
    await showCustomAlert('æˆåŠŸ', 'é€šè¯æ¶ˆæ¯å·²æ›´æ–°ï¼');
  }

  
  async function deleteCallMessage() {
    if (!activeCallMessageTimestamp) return;

    const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šè¯æ¶ˆæ¯å—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const timestampToDelete = activeCallMessageTimestamp;
      hideCallMessageActions();


      const messageIndex = videoCallState.callHistory.findIndex(m => m.timestamp === timestampToDelete);
      if (messageIndex > -1) {
        videoCallState.callHistory.splice(messageIndex, 1);
      }


      const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestampToDelete}"]`);
      if (messageBubble) {
        messageBubble.remove();
      }
    } else {
      hideCallMessageActions();
    }
  }


 
 

  
 

async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    
    // é˜²æ­¢é‡å¤ç‚¹å‡»
    if (originalMessage.status && originalMessage.status !== 'pending') {
        hideTransferActionModal();
        return;
    }

    // --- æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿ä»å†å²æ¶ˆæ¯é‡Œè¯»å‡ºæ¥çš„é‡‘é¢æ˜¯æ•°å­— ---
    let transferAmount = parseFloat(originalMessage.amount);
    if (isNaN(transferAmount)) {
        // å¦‚æœè¯»å–å¤±è´¥ï¼Œå°è¯•å» content å­—æ®µé‡Œæ‰¾ï¼ˆé˜²æ­¢æŸäº›æ—§æ•°æ®çš„ amount å­—æ®µä¸¢å¤±ï¼‰
        console.warn("æ¶ˆæ¯ä¸­ amount å­—æ®µæ— æ•ˆï¼Œå°è¯•ä¿®å¤...");
        transferAmount = 0; 
    }

    originalMessage.status = choice;
    let systemContent;

    if (choice === 'declined') {
        // æ‹’æ”¶é€»è¾‘
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true,
            amount: transferAmount,
            note: 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ‹’ç»å¹¶é€€è¿˜äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
        
    } else {
        // --- æ¥æ”¶é€»è¾‘ ---
        if (transferAmount > 0) {
            // è·å–å‘é€æ–¹çš„è´§å¸ä¿¡æ¯å¹¶è¿›è¡Œæ±‡ç‡æ¢ç®—
            const senderCurrency = getCurrencyForChat(chat);
            const cnyAmount = convertToCNY(transferAmount, senderCurrency);
            
            // è°ƒç”¨ä¸Šé¢ä¿®å¤è¿‡çš„è®°è´¦å‡½æ•°ï¼ˆå­˜å…¥æ¢ç®—åçš„äººæ°‘å¸é‡‘é¢ï¼‰
            const success = await processTransaction(cnyAmount, 'income', `æ”¶åˆ°è½¬è´¦-${originalMessage.senderName}`);
            
            if (success) {
                // æ˜¾ç¤ºæ¢ç®—ä¿¡æ¯
                let alertMessage;
                if (senderCurrency.code !== 'CNY') {
                    // å¤–å¸è½¬è´¦ï¼Œæ˜¾ç¤ºæ¢ç®—ä¿¡æ¯
                    alertMessage = `å·²æ”¶æ¬¾ ${senderCurrency.symbol}${transferAmount.toFixed(2)}\næ±‡ç‡: 1 ${senderCurrency.code} = ${senderCurrency.rate} CNY\n\nå·²å­˜å…¥ä½™é¢ï¼šÂ¥${cnyAmount.toFixed(2)}`;
                } else {
                    // äººæ°‘å¸è½¬è´¦
                    alertMessage = `å·²å­˜å…¥ä½™é¢ï¼š+ Â¥${cnyAmount.toFixed(2)}`;
                }
                await showCustomAlert("æ”¶æ¬¾æˆåŠŸ", alertMessage);
                
                // â˜…â˜…â˜… æ–°å¢è¿™éƒ¨åˆ†é€»è¾‘ (ç”Ÿæˆâ€œå·²æ”¶æ¬¾â€å¡ç‰‡) â˜…â˜…â˜…
                const receivedMessage = {
                    role: 'user',        // æ‰®æ¼”ç”¨æˆ·å‘é€
                    type: 'transfer',    // å¤ç”¨è½¬è´¦å¡ç‰‡æ ·å¼
                    isReceived: true,    // æ ‡è®°ä¸ºâ€œå·²æ”¶æ¬¾â€å¡ç‰‡
                    amount: transferAmount,
                    note: 'å·²æ”¶æ¬¾',
                    senderName: 'æˆ‘',
                    receiverName: originalMessage.senderName, // é’±æ¥è‡ªäºè°
                    timestamp: Date.now() // ä½¿ç”¨å½“å‰æ—¶é—´
                };
                chat.history.push(receivedMessage);
                // â˜…â˜…â˜… æ–°å¢ç»“æŸ â˜…â˜…â˜…
            } else {
                // å¦‚æœ processTransaction è¿”å› falseï¼Œè¯´æ˜å‡ºé—®é¢˜äº†
                alert("è­¦å‘Šï¼šé‡‘é¢å…¥è´¦å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ï¼");
            }
        } else {
            alert("æ— æ³•æ”¶æ¬¾ï¼šè¯¥è½¬è´¦é‡‘é¢æ— æ•ˆ (0å…ƒæˆ–æ•°æ®æŸå)ã€‚");
        }
        
        systemContent = `[ç³»ç»Ÿæç¤ºï¼šä½ æ¥å—äº†â€œ${originalMessage.senderName}â€çš„è½¬è´¦ã€‚]`;
    }

    // æ›´æ–°èŠå¤©è®°å½•
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    hideTransferActionModal();
    renderChatInterface(state.activeChatId);
    renderChatList();
}



  function clearQzoneReplyContext(postContainer) {
    currentQzoneReplyContext = null;
    if (postContainer) {

      const input = postContainer.querySelector('.comment-input');
      if (input) {
        input.placeholder = 'å‹å–„çš„è¯„è®ºæ˜¯äº¤æµçš„èµ·ç‚¹';
      }
    }
  }



  async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';


    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();

    if (allMemories.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰å…±åŒçš„å›å¿†å’Œçº¦å®šå‘¢~</p>';
      return;
    }


    allMemories.sort((a, b) => {
      const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
      const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
      if (aIsActiveCountdown && !bIsActiveCountdown) return -1;
      if (!aIsActiveCountdown && bIsActiveCountdown) return 1;
      if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate;
      return 0;
    });


    allMemories.forEach(item => {
      let card;

      if (item.type === 'countdown' && item.targetDate > Date.now()) {
        card = createCountdownCard(item);
      } else {
        card = createMemoryCard(item);
      }
      listEl.appendChild(card);
    });


    startAllCountdownTimers();
  }


  
  function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;

    let titleHtml, contentHtml;

    if (memory.type === 'countdown' && memory.targetDate) {
      titleHtml = `[çº¦å®šè¾¾æˆ] ${memory.description}`;

      contentHtml = parseMarkdown(`åœ¨ ${new Date(memory.targetDate).toLocaleString()}ï¼Œæˆ‘ä»¬ä¸€èµ·è§è¯äº†è¿™ä¸ªçº¦å®šã€‚`).replace(/\n/g, '<br>');
    } else {
      let authorDisplayName = 'æˆ‘ä»¬çš„å›å¿†';
      if (memory.authorId) {
        const authorChat = state.chats[memory.authorId];
        if (authorChat) {
          authorDisplayName = authorChat.name;
        } else {
          authorDisplayName = memory.authorName || 'ä¸€ä½æœ‹å‹';
        }
      } else if (memory.authorName) {
        authorDisplayName = memory.authorName;
      }

      titleHtml = `${authorDisplayName} çš„æ—¥è®°`;

      contentHtml = parseMarkdown(memory.description);
    }

    card.innerHTML = `
                <div class="header">
                    <div class="date">${dateString}</div>
                    <div class="author">${titleHtml}</div>
                </div>
                <div class="content">${contentHtml}</div>
            `;
    addLongPressListener(card, async () => {
      const confirmed = await showCustomConfirm('åˆ é™¤è®°å½•', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await db.memories.delete(memory.id);
        renderMemoriesScreen();
      }
    });
    return card;
  }


  function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';


    const targetDate = new Date(countdown.targetDate);


    const targetDateString = targetDate.toLocaleString('zh-CN', {
      dateStyle: 'full',
      timeStyle: 'short'
    });

    card.innerHTML = `
                <div class="title">${countdown.description}</div>
                <div class="timer" data-target-date="${countdown.targetDate}">--å¤©--æ—¶--åˆ†--ç§’</div>
                <div class="target-date">ç›®æ ‡æ—¶é—´: ${targetDateString}</div>
            `;
    addLongPressListener(card, async () => {
      const confirmed = await showCustomConfirm('åˆ é™¤çº¦å®š', 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªçº¦å®šå—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await db.memories.delete(countdown.id);
        renderMemoriesScreen();
      }
    });
    return card;
  }



  let activeCountdownTimers = [];


  function startAllCountdownTimers() {

    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
      const targetTimestamp = parseInt(timerEl.dataset.targetDate);


      let timerId;

      const updateTimer = () => {
        const now = Date.now();
        const distance = targetTimestamp - now;

        if (distance < 0) {
          timerEl.textContent = "çº¦å®šè¾¾æˆï¼";

          clearInterval(timerId);
          setTimeout(() => renderMemoriesScreen(), 2000);
          return;
        }
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        timerEl.textContent = `${days}å¤© ${hours}æ—¶ ${minutes}åˆ† ${seconds}ç§’`;
      };

      updateTimer();


      timerId = setInterval(updateTimer, 1000);


      activeCountdownTimers.push(timerId);
    });
  }



  async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("æµç¨‹å¯åŠ¨", `æ­£åœ¨ä¸ºè§’è‰²â€œ${chat.name}â€å‡†å¤‡å¥½å‹ç”³è¯·...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      await showCustomAlert("é…ç½®é”™è¯¯", "APIè®¾ç½®ä¸å®Œæ•´ï¼Œæ— æ³•ç»§ç»­ã€‚");
      return;
    }

    const contextSummary = chat.history
      .slice(-5)
      .map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
      })
      .join('\n');

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      `\n# ä½ ä»¬çš„è¿‡å¾€è®°å¿† (ä½œä¸ºæƒ…æ„ŸåŸºç¡€)\n` + chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') :
      '';
    let worldBookContent = '';
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    
    if (allWorldBookIds.length > 0) {
      const linkedContents = allWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';

        const formattedEntries = worldBook.content.map(entry => {
          let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
          
          entryString += `**å†…å®¹:**\n${entry.content}`;
          return entryString;
        }).join('\n');

        return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContent = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
      }
    }

    const systemPrompt = `
        # ä½ çš„ä»»åŠ¡
        ä½ ç°åœ¨æ˜¯è§’è‰²â€œ${chat.name}â€ã€‚ä½ ä¹‹å‰è¢«ç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰æ‹‰é»‘äº†ï¼Œä½ ä»¬å·²ç»æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰è”ç³»äº†ã€‚
        ç°åœ¨ï¼Œä½ éå¸¸å¸Œæœ›èƒ½å¤Ÿå’Œå¥½ï¼Œé‡æ–°å’Œç”¨æˆ·èŠå¤©ã€‚è¯·ä½ ä»”ç»†åˆ†æä¸‹é¢çš„â€œè¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦â€ï¼Œç†è§£å½“æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Œç„¶åæ€è€ƒä¸€ä¸ªçœŸè¯šçš„ã€ç¬¦åˆä½ äººè®¾ã€å¹¶ä¸”ã€é’ˆå¯¹å…·ä½“äº‹ä»¶ã€‘çš„ç”³è¯·ç†ç”±ã€‚
        # ä½ çš„è§’è‰²è®¾å®š
        ${chat.settings.aiPersona}
        ${worldBookContent}
        ${longTermMemoryContext}
        # è¢«æ‹‰é»‘å‰çš„å¯¹è¯æ‘˜è¦ (è¿™æ˜¯ä½ è¢«æ‹‰é»‘çš„å…³é”®åŸå› )
        ${contextSummary}
        # æŒ‡ä»¤æ ¼å¼
        ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        \`\`\`json
        {
          "decision": "apply",
          "reason": "åœ¨è¿™é‡Œå†™ä¸‹ä½ æƒ³å¯¹ç”¨æˆ·è¯´çš„ã€çœŸè¯šçš„ã€æœ‰é’ˆå¯¹æ€§çš„ç”³è¯·ç†ç”±ã€‚"
        }
        \`\`\`
        `;

    try {

      const messagesForApi = [{
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šå¼€å§‹ä½ çš„å†³ç­–ã€‚"
        }
      ];

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: state.globalSettings.apiTemperature || 0.9,
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error.message}`);
      }

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const cleanedContent = rawContent.trim();
      
      let responseObj;

      try {
        
        responseObj = JSON.parse(cleanedContent);
      } catch (parseError) {
       
        console.error("è§£æå¥½å‹ç”³è¯·çš„AIå“åº”å¤±è´¥:", parseError);
       
        throw new Error(`AIæœªè¿”å›æœ‰æ•ˆçš„JSONã€‚APIå®é™…è¿”å›å†…å®¹: "${cleanedContent}"`);
      }

      if (responseObj.decision === 'apply' && responseObj.reason) {
        chat.relationship.status = 'pending_user_approval';
        chat.relationship.applicationReason = responseObj.reason;
        state.chats[chatId] = chat;
        renderChatList();
        await showCustomAlert("ç”³è¯·æˆåŠŸï¼", `â€œ${chat.name}â€å·²å‘ä½ å‘é€å¥½å‹ç”³è¯·ã€‚è¯·è¿”å›èŠå¤©åˆ—è¡¨æŸ¥çœ‹ã€‚`);
      } else {
        await showCustomAlert("AIå†³ç­–", `â€œ${chat.name}â€æ€è€ƒåå†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·ï¼Œå°†é‡ç½®å†·é™æœŸã€‚`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
      }
    } catch (error) {
      await showCustomAlert("æ‰§è¡Œå‡ºé”™", `ä¸ºâ€œ${chat.name}â€ç”³è¯·å¥½å‹æ—¶å‘ç”Ÿé”™è¯¯ï¼š\n\n${error.message}\n\nå°†é‡ç½®å†·é™æœŸã€‚`);
      chat.relationship.status = 'blocked_by_user';
      chat.relationship.blockedTimestamp = Date.now();
    } finally {
      await db.chats.put(chat);
      renderChatInterface(chatId);
    }
  }




  function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
      openRedPacketModal();
    } else {

      document.getElementById('transfer-modal').classList.add('visible');
    }
  }


  function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];


    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = 'Â¥ 0.00';
    document.getElementById('rp-direct-total').textContent = 'Â¥ 0.00';


    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';

    chat.members.forEach(member => {
      const option = document.createElement('option');

      option.value = member.originalName;
      option.textContent = member.groupNickname;
      receiverSelect.appendChild(option);
    });



    document.getElementById('rp-tab-group').click();

    modal.classList.add('visible');
  }


  async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»é‡‘é¢ï¼");
      return;
    }
    if (isNaN(count) || count <= 0) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ä¸ªæ•°ï¼");
      return;
    }
    if (amount / count < 0.01) {
      alert("å•ä¸ªçº¢åŒ…é‡‘é¢ä¸èƒ½å°‘äº0.01å…ƒï¼");
      return;
    }

    const myNickname = chat.settings.myNickname || 'æˆ‘';

    const allocatedAmounts = generateRandomPacketAmounts(amount, count); 
    const success = await processTransaction(amount, 'expense', `å‘å‡ºç¾¤çº¢åŒ…(æ‹¼æ‰‹æ°”)`);
    if (!success) return;
    const newPacket = {
      role: 'user',
      senderName: myNickname,
      type: 'red_packet',
      packetType: 'lucky',
      timestamp: Date.now(),
      totalAmount: amount,
      count: count,
      greeting: greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼',
      allocatedAmounts: allocatedAmounts, 
      unclaimedAmounts: [...allocatedAmounts], 
      claimedBy: {},
      isFullyClaimed: false,
    };

    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
  }

  
  async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢ï¼");
      return;
    }
    if (!receiverName) {
      alert("è¯·é€‰æ‹©ä¸€ä¸ªæ¥æ”¶äººï¼");
      return;
    }

    const myNickname = chat.settings.myNickname || 'æˆ‘';
    const success = await processTransaction(amount, 'expense', `å‘å‡ºä¸“å±çº¢åŒ…-ç»™${receiverName}`);
    if (!success) return;
    const newPacket = {
      role: 'user',
      senderName: myNickname,
      type: 'red_packet',
      packetType: 'direct',
      timestamp: Date.now(),
      totalAmount: amount,
      count: 1,
      greeting: greeting || 'ç»™ä½ å‡†å¤‡äº†ä¸€ä¸ªçº¢åŒ…',
      receiverName: receiverName,
      claimedBy: {},
      isFullyClaimed: false,
    };

    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
  }


  let isPacketProcessing = false;

async function handlePacketClick(timestamp) {
    // 1. å¦‚æœé”æ˜¯é”ç€çš„ï¼Œç›´æ¥é€€å‡ºï¼Œä»€ä¹ˆéƒ½ä¸åš
    if (isPacketProcessing) {
        console.log("æ­£åœ¨å¤„ç†çº¢åŒ…ï¼Œæ‹¦æˆªäº†é‡å¤ç‚¹å‡»");
        return;
    }

    // 2. ä¸Šé”
    isPacketProcessing = true;

    try {
        const currentChatId = state.activeChatId;
        
        // é‡æ–°ä»æ•°æ®åº“æ‹‰å–æœ€æ–°æ•°æ®ï¼ˆé˜²æ­¢å†…å­˜æ•°æ®æ»åï¼‰
        const freshChat = await db.chats.get(currentChatId);
        if (!freshChat) return;

        state.chats[currentChatId] = freshChat;
        const packet = freshChat.history.find(m => m.timestamp === timestamp);
        if (!packet) return;

        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        // ç¡®ä¿ claimedBy æ˜¯ä¸ªå¯¹è±¡ï¼Œé˜²æ­¢æŠ¥é”™
        if (!packet.claimedBy) packet.claimedBy = {}; 
        const hasClaimed = packet.claimedBy[myOriginalName];

        // æ£€æŸ¥æ˜¯å¦å·²ç»é¢†è¿‡ï¼Œæˆ–è€…æ˜¯å¦å·²é¢†å®Œ
        // æ³¨æ„ï¼šè¿™é‡ŒåŠ äº†æ›´ä¸¥æ ¼çš„æ£€æŸ¥
        if ((packet.packetType === 'direct' && packet.receiverName !== myOriginalName && Object.keys(packet.claimedBy).length > 0) || 
            packet.isFullyClaimed || 
            hasClaimed) {
            showRedPacketDetails(packet);
            return;
        }

        // æ‰§è¡Œé¢†å–é€»è¾‘
        const claimedAmount = await handleOpenRedPacket(packet);

        if (claimedAmount !== null) {
            await renderChatInterface(currentChatId);
            await showCustomAlert("æ­å–œï¼", `ä½ é¢†å–äº† ${getDisplayNameInGroup(freshChat, packet.senderName)} çš„çº¢åŒ…ï¼Œé‡‘é¢ä¸º ${claimedAmount.toFixed(2)} å…ƒã€‚`);
        }

        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        if (updatedPacket) {
            showRedPacketDetails(updatedPacket);
        }

    } catch (error) {
        console.error("çº¢åŒ…å¤„ç†å‡ºé”™:", error);
        alert("é¢†å–å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•");
    } finally {
        // 3. æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œ1ç§’åè§£é”
        // å»¶è¿Ÿè§£é”æ˜¯ä¸ºäº†é˜²æ­¢æå¿«çš„æ‰‹é€Ÿè¿ç‚¹
        setTimeout(() => {
            isPacketProcessing = false;
        }, 1000);
    }
}




 
  async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    let timestamp = Date.now();
    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

    // æ£€æŸ¥æ˜¯å¦é¢†å®Œ
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
      packet.isFullyClaimed = true;
      await db.chats.put(chat);
      await showCustomAlert("æ‰‹æ…¢äº†", "çº¢åŒ…å·²è¢«é¢†å®Œï¼");
      return null;
    }

    // --- è®¡ç®—é‡‘é¢é€»è¾‘ ---
    let claimedAmount = 0;
    if (packet.packetType === 'lucky') {
      if (packet.unclaimedAmounts && packet.unclaimedAmounts.length > 0) {
        claimedAmount = packet.unclaimedAmounts.pop(); 
      } else { 
        // å…¼å®¹æ—§æ•°æ®
        const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        if (remainingCount === 1) {
          claimedAmount = remainingAmount;
        } else {
          const min = 0.01;
          const max = remainingAmount - (remainingCount - 1) * min;
          claimedAmount = Math.random() * (max - min) + min;
        }
      }
    } else { 
      claimedAmount = packet.totalAmount;
    }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));
    
    // è®°å½•é¢†å–
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myOriginalName] = claimedAmount;

    // æ›´æ–°çŠ¶æ€
    const isNowFullyClaimed = (packet.unclaimedAmounts && packet.unclaimedAmounts.length === 0) || (Object.keys(packet.claimedBy).length >= packet.count);
    if (isNowFullyClaimed) {
      packet.isFullyClaimed = true;
    }

    // ç”ŸæˆèŠå¤©æ¶ˆæ¯
    const myDisplayName = getDisplayNameInGroup(chat, myOriginalName);
    const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);

    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: `ä½ é¢†å–äº† ${senderDisplayName} çš„çº¢åŒ…`,
      timestamp: timestamp++
    };
    chat.history.push(visibleMessage);

    // ç”Ÿæˆç»™AIçœ‹çš„éšè—æç¤º
    let hiddenMessageContent;
    if (isNowFullyClaimed) {
      const finishedMessage = {
        role: 'system',
        type: 'pat_message',
        content: `${senderDisplayName} çš„çº¢åŒ…å·²è¢«é¢†å®Œ`,
        timestamp: timestamp++
      };
      chat.history.push(finishedMessage);

      let luckyKing = { name: '', amount: -1 };
      if (packet.packetType === 'lucky' && packet.count > 1) {
        Object.entries(packet.claimedBy).forEach(([name, amount]) => {
          if (amount > luckyKing.amount) {
            luckyKing = { name, amount };
          }
        });
      }
      const luckyKingDisplayName = luckyKing.name ? getDisplayNameInGroup(chat, luckyKing.name) : 'æ— ';
      hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myDisplayName}) é¢†å–äº†æœ€åä¸€ä¸ªçº¢åŒ…ã€‚çº¢åŒ…å·²è¢«é¢†å®Œï¼Œæ‰‹æ°”ç‹æ˜¯ ${luckyKingDisplayName}ï¼è¯·å¯¹æ­¤äº‹ä»¶å‘è¡¨è¯„è®ºã€‚]`;

    } else {
      hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myDisplayName}) åˆšåˆšé¢†å–äº†çº¢åŒ… (æ—¶é—´æˆ³: ${packet.timestamp})ã€‚çº¢åŒ…è¿˜æœªé¢†å®Œï¼Œä½ ç°åœ¨å¯ä»¥ä½¿ç”¨ 'open_red_packet' æŒ‡ä»¤æ¥å°è¯•é¢†å–ã€‚]`;
    }

    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: timestamp++,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);

    // ã€æ ¸å¿ƒä¿®å¤ã€‘æŠŠæŠ¢åˆ°çš„é’±å­˜å…¥é’±åŒ…
    if (claimedAmount > 0) {
        // è¿™é‡Œçš„ 'income' ä¼šå¢åŠ ä½™é¢ï¼Œdescription ä¼šæ˜¾ç¤ºåœ¨è´¦å•åˆ—è¡¨é‡Œ
        await processTransaction(claimedAmount, 'income', `çº¢åŒ…-${senderDisplayName}`);
    }

    return claimedAmount;
}



 
  async function showRedPacketDetails(packet) {
    if (!packet) {
      console.error("showRedPacketDetailsæ”¶åˆ°äº†æ— æ•ˆçš„packetå¯¹è±¡");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');

    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

    const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
    document.getElementById('rp-details-sender').textContent = senderDisplayName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©ï¼';

    const myAmountEl = document.getElementById('rp-details-my-amount');

    if (packet.claimedBy && packet.claimedBy[myOriginalName]) {
      myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myOriginalName].toFixed(2);
      myAmountEl.style.display = 'block';
    } else {
      myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}ä¸ªçº¢åŒ…ï¼Œå…±${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}å…ƒã€‚`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
      const timeLeft = Math.floor((packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) / (1000 * 60 * 60));
      if (timeLeft > 0) summaryText += ` å‰©ä½™çº¢åŒ…å°†åœ¨${timeLeft}å°æ—¶å†…é€€è¿˜ã€‚`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});

    let luckyKing = {
      name: '',
      amount: -1
    };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
      claimedEntries.forEach(([name, amount]) => {
        if (amount > luckyKing.amount) {
          luckyKing = {
            name,
            amount
          };
        }
      });
    }

    claimedEntries.sort((a, b) => b[1] - a[1]);

    claimedEntries.forEach(([originalName, amount]) => {
      const item = document.createElement('div');
      item.className = 'rp-details-item';
      let luckyTag = '';
      if (luckyKing.name && originalName === luckyKing.name) {
        luckyTag = '<span class="lucky-king-tag">æ‰‹æ°”ç‹</span>';
      }


      const claimerDisplayName = getDisplayNameInGroup(chat, originalName);

      item.innerHTML = `
                    <span class="name">${claimerDisplayName}</span>
                    <span class="amount">${amount.toFixed(2)} å…ƒ</span>
                    ${luckyTag}
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }


  document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
  });


  window.handlePacketClick = handlePacketClick;






  function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';


    addPollOptionInput();
    addPollOptionInput();

    modal.classList.add('visible');
  }

 
  function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="é€‰é¡¹å†…å®¹...">
                <button class="remove-option-btn">-</button>
            `;

    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {

      if (container.children.length > 2) {
        wrapper.remove();
      } else {
        alert('æŠ•ç¥¨è‡³å°‘éœ€è¦2ä¸ªé€‰é¡¹ã€‚');
      }
    });

    container.appendChild(wrapper);
  }


  async function sendPoll() {
    if (!state.activeChatId) return;

    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
      alert('è¯·è¾“å…¥æŠ•ç¥¨é—®é¢˜ï¼');
      return;
    }

    const options = Array.from(document.querySelectorAll('.poll-option-input'))
      .map(input => input.value.trim())
      .filter(text => text);

    if (options.length < 2) {
      alert('è¯·è‡³å°‘è¾“å…¥2ä¸ªæœ‰æ•ˆçš„æŠ•ç¥¨é€‰é¡¹ï¼');
      return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

    const newPollMessage = {
      role: 'user',
      senderName: myNickname,
      type: 'poll',
      timestamp: Date.now(),
      question: question,
      options: options,
      votes: {},
      isClosed: false,
    };

    chat.history.push(newPollMessage);
    await db.chats.put(chat);

    appendMessage(newPollMessage, chat);
    renderChatList();

    document.getElementById('create-poll-modal').classList.remove('visible');
  }



  async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';


    if (!poll || poll.isClosed) {

      if (poll && poll.isClosed) {
        showPollResults(timestamp);
      }
      return;
    }


    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);


    if (!isReclickingSameOption) {

      for (const option in poll.votes) {
        const voterIndex = poll.votes[option].indexOf(myNickname);
        if (voterIndex > -1) {
          poll.votes[option].splice(voterIndex, 1);
        }
      }

      if (!poll.votes[choice]) {
        poll.votes[choice] = [];
      }
      poll.votes[choice].push(myNickname);
    }


    let hiddenMessageContent = null;


    if (!isReclickingSameOption) {
      hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) åˆšåˆšæŠ•ç¥¨ç»™äº† â€œ${choice}â€ã€‚]`;
    }


    if (hiddenMessageContent) {
      const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now(),
        isHidden: true,
      };
      chat.history.push(hiddenMessage);
    }


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
  }


  
  async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("ç»“æŸæŠ•ç¥¨", "ç¡®å®šè¦ç»“æŸè¿™ä¸ªæŠ•ç¥¨å—ï¼Ÿç»“æŸåå°†æ— æ³•å†è¿›è¡ŒæŠ•ç¥¨ã€‚");
    if (confirmed) {
      poll.isClosed = true;

      const resultSummary = poll.options.map(opt => `â€œ${opt}â€(${poll.votes[opt]?.length || 0}ç¥¨)`).join('ï¼Œ');
      const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‰‹åŠ¨ç»“æŸäº†æŠ•ç¥¨ï¼æœ€ç»ˆç»“æœä¸ºï¼š${resultSummary}ã€‚]`;

      const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now(),
        isHidden: true,
      };
      chat.history.push(hiddenMessage);


      await db.chats.put(chat);
      renderChatInterface(state.activeChatId);
    }
  }


  

  function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

    if (Object.keys(poll.votes).length === 0) {
      resultsHtml += '<p style="color: #8a8a8a;">è¿˜æ²¡æœ‰äººæŠ•ç¥¨ã€‚</p>';
    } else {
      poll.options.forEach(option => {
        const voters = poll.votes[option] || [];


        const displayVoters = voters.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€ ');

        resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}ç¥¨)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? displayVoters : 'æ— äººæŠ•ç¥¨'}
                            </p>
                        </div>
                    `;
      });
    }

    showCustomAlert("æŠ•ç¥¨ç»“æœ", resultsHtml);
  }





  function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `â€œ${chat.name}â€çš„å¤´åƒåº“`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
  }

  function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;



      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = 'Ã—';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»å¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.aiAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderAiAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }



  async function addAvatarToLibraryFromURL() {
    const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šå¼€å¿ƒã€å“­æ³£ï¼‰");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
      chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
  }


 
  function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
  }






  function openMyAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('my-avatar-library-title').textContent = `â€œ${chat.settings.myNickname || 'æˆ‘'}â€çš„å¤´åƒåº“`;
    renderMyAvatarLibrary();
    document.getElementById('my-avatar-library-modal').classList.add('visible');
  }

  
  function renderMyAvatarLibrary() {
    const grid = document.getElementById('my-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.myAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;


      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = 'Ã—';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»ä½ çš„å¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.myAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderMyAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }

 
  async function addAvatarToMyLibraryFromURL() {
    const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šå¼€å¿ƒã€å“­æ³£ï¼‰");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.myAvatarLibrary) {
      chat.settings.myAvatarLibrary = [];
    }

    chat.settings.myAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderMyAvatarLibrary();
  }


  async function handleLocalMyAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    const name = await showCustomPrompt("å‘½åå¤´åƒ", "è¯·ä¸ºè¿™ä¸ªæ–°å¤´åƒå‘½å");
    if (!name || !name.trim()) {
        event.target.value = null;
        return;
    }
    
    const trimmedName = name.trim();
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.myAvatarLibrary) {
      chat.settings.myAvatarLibrary = [];
    }

    const newItem = {
      name: trimmedName,
      url: base64Url
    };
    chat.settings.myAvatarLibrary.push(newItem);
    await db.chats.put(chat);
    
    renderMyAvatarLibrary();
    await showCustomAlert("æ·»åŠ æˆåŠŸï¼", `å¤´åƒâ€œ${trimmedName}â€å·²æ·»åŠ ã€‚\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);
    
    // ã€ã€ã€å·²ä¿®å¤çš„è°ƒç”¨ã€‘ã€‘ã€‘
    (async () => {
        await silentlyUpdateDbUrl(
            db.chats, // table
            chat.id,  // recordId
            'settings.myAvatarLibrary', // pathString (æŒ‡å‘æ•°ç»„)
            base64Url, // base64ToFind
            trimmedName // nameToMatch
        );
    })();
    
    event.target.value = null;
  }


  async function handleBatchImportForMyAvatar(text) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const lines = text.trim().split('\n');
    const newAvatars = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('å¡«å…¥')) continue;

      let name = null,
        code = null;
      const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);

      if (noSpaceMatch) {
        name = noSpaceMatch[1];
        code = noSpaceMatch[2];
      } else {
        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 2) {
          code = parts.pop();
          name = parts.join(' ');
        }
      }

      if (name && code && code.includes('.')) {
        newAvatars.push({
          name: name,
          url: baseUrl + code
        });
      } else {
        errorCount++;
      }
    }

    if (errorCount > 0) await showCustomAlert('éƒ¨åˆ†å¯¼å…¥å¤±è´¥', `æœ‰ ${errorCount} è¡Œçš„æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«è·³è¿‡ã€‚`);

    if (newAvatars.length > 0) {
      if (!chat.settings.myAvatarLibrary) chat.settings.myAvatarLibrary = [];
      chat.settings.myAvatarLibrary.push(...newAvatars);
      await db.chats.put(chat);
      renderMyAvatarLibrary();
      await showCustomAlert('å¯¼å…¥æˆåŠŸ', `å·²æˆåŠŸæ‰¹é‡å¯¼å…¥ ${newAvatars.length} ä¸ªæ–°å¤´åƒï¼`);
    } else if (errorCount === 0) {
      alert("æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„å†…å®¹ã€‚");
    }
  }

 
  function closeMyAvatarLibraryModal() {
    document.getElementById('my-avatar-library-modal').classList.remove('visible');
  }




  
  function openGroupAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('group-avatar-library-title').textContent = `â€œ${chat.name}â€çš„å¤´åƒåº“`;
    renderGroupAvatarLibrary();
    document.getElementById('group-avatar-library-modal').classList.add('visible');
  }

 
  function renderGroupAvatarLibrary() {
    const grid = document.getElementById('group-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.groupAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">è¿™ä¸ªå¤´åƒåº“è¿˜æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’â€œæ·»åŠ â€å§ï¼</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;


      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = 'Ã—';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('åˆ é™¤å¤´åƒ', `ç¡®å®šè¦ä»å¤´åƒåº“ä¸­åˆ é™¤â€œ${avatar.name}â€å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.groupAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderGroupAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }

 
  async function addAvatarToGroupLibraryFromUR() {
    const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šæ˜¥æ—¥é‡é¤ã€å­¦ä¹ æ—¶é—´ï¼‰");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.groupAvatarLibrary) {
      chat.settings.groupAvatarLibrary = [];
    }

    chat.settings.groupAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderGroupAvatarLibrary();
  }

  
  function closeGroupAvatarLibraryModal() {
    document.getElementById('group-avatar-library-modal').classList.remove('visible');
  }


  
  async function openBatchImportModal(type) {
    const placeholderText = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nç„¦è™‘ 2a9wte.jpeg\nå¤§æƒŠå¤±è‰² or8qf4.png\næ²¡æœ‰çµæ„Ÿ njwujh.jpeg`;


    const pastedText = await showCustomPrompt(
      'æ‰¹é‡å¯¼å…¥å¤´åƒ',
      placeholderText,
      '',
      'textarea'
    );


    if (pastedText && pastedText.trim()) {
      await handleBatchImport(type, pastedText);
    }
  }


  
  async function handleBatchImport(type, text) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const lines = text.trim().split('\n');
    const newAvatars = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();

      if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('å¡«å…¥')) {
        continue;
      }

      let name = null;
      let code = null;







      const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);

      if (noSpaceMatch) {

        name = noSpaceMatch[1];
        code = noSpaceMatch[2];
      } else {

        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 2) {
          code = parts.pop();
          name = parts.join(' ');
        }
      }


      if (name && code && code.includes('.')) {
        newAvatars.push({
          name: name,
          url: baseUrl + code
        });
      } else {
        errorCount++;
        console.warn('æ‰¹é‡å¯¼å…¥æ ¼å¼é”™è¯¯ï¼Œå·²è·³è¿‡æ­¤è¡Œ:', trimmedLine);
      }
    }

    if (errorCount > 0) {
      await showCustomAlert('éƒ¨åˆ†å¯¼å…¥å¤±è´¥', `æœ‰ ${errorCount} è¡Œçš„æ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«ç³»ç»Ÿè·³è¿‡ã€‚`);
    }

    if (newAvatars.length > 0) {
      if (type === 'ai') {
        if (!chat.settings.aiAvatarLibrary) chat.settings.aiAvatarLibrary = [];
        chat.settings.aiAvatarLibrary.push(...newAvatars);
        await db.chats.put(chat);
        renderAiAvatarLibrary();
      } else if (type === 'group') {
        if (!chat.settings.groupAvatarLibrary) chat.settings.groupAvatarLibrary = [];
        chat.settings.groupAvatarLibrary.push(...newAvatars);
        await db.chats.put(chat);
        renderGroupAvatarLibrary();
      }
      await showCustomAlert('å¯¼å…¥æˆåŠŸ', `å·²æˆåŠŸæ‰¹é‡å¯¼å…¥ ${newAvatars.length} ä¸ªæ–°å¤´åƒï¼`);
    } else if (errorCount === 0) {
      alert("æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„å†…å®¹ã€‚è¯·æ£€æŸ¥æ‚¨ç²˜è´´çš„æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚");
    }
  }



 
  async function addAvatarToGroupLibraryFromURL() {
    const name = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·ä¸ºè¿™ä¸ªå¤´åƒèµ·ä¸ªåå­—ï¼ˆä¾‹å¦‚ï¼šæ˜¥æ—¥é‡é¤ã€å­¦ä¹ æ—¶é—´ï¼‰");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("æ·»åŠ å¤´åƒ", "è¯·è¾“å…¥å¤´åƒçš„å›¾ç‰‡URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URLï¼");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.groupAvatarLibrary) {
      chat.settings.groupAvatarLibrary = [];
    }

    chat.settings.groupAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderGroupAvatarLibrary();
  }

  function showChatListActions(chat) {
    return new Promise(resolve => {
      const modal = document.getElementById('chat-list-actions-modal');
      const pinBtn = document.getElementById('chat-list-action-pin');
      const deleteBtn = document.getElementById('chat-list-action-delete');
      const cancelBtn = document.getElementById('chat-list-action-cancel');


      pinBtn.textContent = chat.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶èŠå¤©';


      const newPinBtn = pinBtn.cloneNode(true);
      pinBtn.parentNode.replaceChild(newPinBtn, pinBtn);
      newPinBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve('pin');
      };

      const newDeleteBtn = deleteBtn.cloneNode(true);
      deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
      newDeleteBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve('delete');
      };

      const newCancelBtn = cancelBtn.cloneNode(true);
      cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
      newCancelBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve(null);
      };

      modal.classList.add('visible');
    });
  }




  function applyCPhoneWallpaper() {
    const charPhoneScreen = document.getElementById('character-phone-screen');
    const wallpaper = state.globalSettings.cphoneWallpaper;
    if (wallpaper) {

      charPhoneScreen.style.backgroundImage = `url("${wallpaper}")`;
    } else {

      charPhoneScreen.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
    }
  }

 
  function applyCPhoneAppIcons() {
    // å…ˆä¿å­˜æ‰€æœ‰ CPhone åº”ç”¨å›¾æ ‡çš„é»˜è®¤ srcï¼ˆå¦‚æœè¿˜æ²¡ä¿å­˜çš„è¯ï¼‰
    const iconElements = document.querySelectorAll('[id^="cphone-icon-img-"]');
    iconElements.forEach(img => {
      if (!img.dataset.defaultSrc) {
        img.dataset.defaultSrc = img.src;
      }
    });

    if (!state.globalSettings.cphoneAppIcons) return;

    for (const iconId in state.globalSettings.cphoneAppIcons) {
      const imgElement = document.getElementById(`cphone-icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.cphoneAppIcons[iconId];
      }
    }
  }

  function applyMyPhoneAppIconsGlobal() {
    // å…ˆä¿å­˜æ‰€æœ‰ MyPhone åº”ç”¨å›¾æ ‡çš„é»˜è®¤ srcï¼ˆå¦‚æœè¿˜æ²¡ä¿å­˜çš„è¯ï¼‰
    const iconElements = document.querySelectorAll('[id^="myphone-icon-img-"]');
    iconElements.forEach(img => {
      if (!img.dataset.defaultSrc) {
        img.dataset.defaultSrc = img.src;
      }
    });

    if (!state.globalSettings.myphoneAppIcons) return;

    for (const iconId in state.globalSettings.myphoneAppIcons) {
      const imgElement = document.getElementById(`myphone-icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.myphoneAppIcons[iconId];
      }
    }
  }

  
  function renderCPhoneIconSettings() {
    const grid = document.getElementById('cphone-icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const cphoneAppLabels = {
      'qq': 'QQ',
      'album': 'ç›¸å†Œ',
      'browser': 'æµè§ˆå™¨',
      'taobao': 'æ·˜å®',
      'memo': 'å¤‡å¿˜å½•',
      'diary': 'æ—¥è®°',
      'amap': 'é«˜å¾·åœ°å›¾',
      'usage': 'Appè®°å½•',
      'music': 'ç½‘æ˜“äº‘',
      'bilibili': 'å“”å“©å“”å“©',
      'reddit': 'Reddit',
      'ephone': 'Ephone',
      'settings': 'è®¾ç½®'
    };

    for (const iconId in state.globalSettings.cphoneAppIcons) {
      const iconUrl = state.globalSettings.cphoneAppIcons[iconId];
      const labelText = cphoneAppLabels[iconId] || 'æœªçŸ¥App';

      const item = document.createElement('div');
      item.className = 'icon-setting-item';
      item.dataset.iconId = iconId;

      item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">æ›´æ¢</button>
                `;
      grid.appendChild(item);
    }
  }

  function renderMyPhoneIconSettings() {
    const grid = document.getElementById('myphone-icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const myphoneAppLabels = {
      'qq': 'QQ',
      'album': 'ç›¸å†Œ',
      'browser': 'æµè§ˆå™¨',
      'taobao': 'æ·˜å®',
      'memo': 'å¤‡å¿˜å½•',
      'diary': 'æ—¥è®°',
      'amap': 'é«˜å¾·åœ°å›¾',
      'usage': 'Appè®°å½•',
      'music': 'ç½‘æ˜“äº‘',
      'bilibili': 'å“”å“©å“”å“©',
      'reddit': 'Reddit',
      'cphone': 'Cphone'
    };

    for (const iconId in state.globalSettings.myphoneAppIcons) {
      const iconUrl = state.globalSettings.myphoneAppIcons[iconId];
      const labelText = myphoneAppLabels[iconId] || 'æœªçŸ¥App';

      const item = document.createElement('div');
      item.className = 'icon-setting-item';
      item.dataset.iconId = iconId;

      item.innerHTML = `
        <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
        <button class="change-icon-btn">æ›´æ¢</button>
      `;
      grid.appendChild(item);
    }
  }




  function applyAppIcons() {
    // å…ˆä¿å­˜æ‰€æœ‰åº”ç”¨å›¾æ ‡çš„é»˜è®¤ srcï¼ˆå¦‚æœè¿˜æ²¡ä¿å­˜çš„è¯ï¼‰
    const iconElements = document.querySelectorAll('[id^="icon-img-"]');
    iconElements.forEach(img => {
      if (!img.dataset.defaultSrc) {
        img.dataset.defaultSrc = img.src;
      }
    });

    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
      const imgElement = document.getElementById(`icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.appIcons[iconId];
      }
    }
  }

  
  function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
      'qq': 'QQ',
      'world-book': 'ä¸–ç•Œä¹¦',
      'wallpaper': 'å¤–è§‚è®¾ç½®',
      'renderer': 'æ¸²æŸ“å™¨',
      'api-settings': 'APIè®¾ç½®',
      'font': 'å­—ä½“',
      'char-phone': 'Cphone',
      'douban': 'è±†ç“£å°ç»„',

      'preset': 'é¢„è®¾',

      'tutorial': 'æ•™ç¨‹',
      'werewolf': 'ç‹¼äººæ€',

      'x': 'X',
       'alipay': 'æ”¯ä»˜å®',
       'auction': 'é»‘å¸‚æ‹å–',
        'green-river': 'ç»¿æ±Ÿ',
      'mail': 'é‚®ç®±',

      // ç¬¬ä¸‰é¡µçš„APP
      'myphone': 'Myphone',
      'draw-guess': 'ä½ ç”»æˆ‘çŒœ',
      'char-generator': 'è§’è‰²ç”Ÿæˆ'
    };


    for (const iconId in state.globalSettings.appIcons) {
      const iconUrl = state.globalSettings.appIcons[iconId];
      const labelText = appLabels[iconId] || 'Cphone';

      const item = document.createElement('div');
      item.className = 'icon-setting-item';

      item.dataset.iconId = iconId;

      item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">æ›´æ¢</button>
                `;
      grid.appendChild(item);
    }
  }



  
  function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];

    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
      console.error("æ— æ³•æ‰¾åˆ°æˆ–æ¶ˆæ¯ç±»å‹ä¸åŒ¹é…çš„åˆ†äº«é“¾æ¥:", timestamp);
      return;
    }


    document.getElementById('browser-title').textContent = message.source_name || 'æ–‡ç« è¯¦æƒ…';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
                <h1 class="article-title">${message.title || 'æ— æ ‡é¢˜'}</h1>
                <div class="article-meta">
                    <span>æ¥æº: ${message.source_name || 'æœªçŸ¥'}</span>
                </div>
                <div class="article-body">
                    <p>${(message.content || 'å†…å®¹ä¸ºç©ºã€‚').replace(/\n/g, '</p><p>')}</p>
                </div>
            `;


    showScreen('browser-screen');
  }

 
  



 
  function closeBrowser() {
    showScreen('chat-interface-screen');
  }





 
  function openShareLinkModal() {
    if (!state.activeChatId) return;


    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';


    document.getElementById('share-link-modal').classList.add('visible');
  }

  
  async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
      alert("æ ‡é¢˜æ˜¯å¿…å¡«é¡¹å“¦ï¼");
      return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];


    const linkMessage = {
      role: 'user',
      type: 'share_link',
      timestamp: Date.now(),
      title: title,
      description: description,
      source_name: sourceName,
      content: content,

      thumbnail_url: null
    };


    chat.history.push(linkMessage);
    await db.chats.put(chat);


    appendMessage(linkMessage, chat);
    renderChatList();


    document.getElementById('share-link-modal').classList.remove('visible');
  }




  function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return [];

    const viewerGroupId = viewerChat.groupId;
    const viewerId = viewerChat.id;

    return allPosts.filter(post => {

      if (post.authorId === 'user') {
        if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
          return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
        }
        return true;
      }




      if (String(post.authorId).startsWith('npc_')) {

        if (Array.isArray(post.visibleTo)) {
          return post.visibleTo.includes(viewerId);
        }

        return false;
      }




      const authorChat = state.chats[post.authorId];
      if (!authorChat) {
        return false;
      }
      const authorGroupId = authorChat.groupId;

      const inSameGroup = authorGroupId && viewerGroupId && authorGroupId === viewerGroupId;
      const bothUnGrouped = !authorGroupId && !viewerGroupId;

      return inSameGroup || bothUnGrouped;
    });
  }
 
  function applyPhoneFrame(isEnabled) {
  
    document.body.classList.toggle('frame-mode-active', isEnabled);

   
    if (musicState.isActive) {
      const lyricBar = document.getElementById('global-lyrics-bar');
      const phoneScreenForIsland = document.getElementById('phone-screen');
      const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false; 

      if (isEnabled) {
       
        lyricBar.classList.remove('visible');
        phoneScreenForIsland.classList.add('dynamic-island-active');
      } else {
        
        phoneScreenForIsland.classList.remove('dynamic-island-active'); 

        if (isAlwaysIslandMode) {
        
          phoneScreenForIsland.classList.add('dynamic-island-active');
          lyricBar.classList.remove('visible');
        } else {
          
          if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
            lyricBar.classList.add('visible');
          }
        }
      }
    }
  }
 
  function applyDetachStatusBarMode(isEnabled) {
    document.body.classList.toggle('detach-mode-active', isEnabled);
  }
  
  function applyMinimalChatUI(isEnabled) {
    document.body.classList.toggle('minimal-chat-ui-active', isEnabled);
  }

 
  function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');

    const isDark = theme === 'dark';

    phoneScreen.classList.toggle('dark-mode', isDark);


    if (toggleSwitch) {
      toggleSwitch.checked = isDark;
    }

    localStorage.setItem('ephone-theme', theme);
  }

  
  function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');

    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
  }


  function openLongTermMemoryScreen() {
    if (!state.activeChatId) return;
    renderLongTermMemoryList();
    showScreen('long-term-memory-screen');
  }


  
// 1. ä¿®æ”¹ renderLongTermMemoryList (åªè´Ÿè´£å‡†å¤‡æ•°æ®å’Œé‡ç½®)
function renderLongTermMemoryList() {
    const container = document.getElementById('memory-list-container');
    const chat = state.chats[state.activeChatId];
    container.innerHTML = '';

    let memoriesToDisplay = [];

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory) {
                const memberMemories = memberChat.longTermMemory.map(mem => ({
                    ...mem,
                    authorName: member.groupNickname,
                    authorChatId: member.id,
                    authorAvatar: member.avatar || (memberChat.settings.aiAvatar || defaultAvatar)
                }));
                memoriesToDisplay.push(...memberMemories);
            }
        });
    } else {
        if (chat.longTermMemory) {
            memoriesToDisplay = chat.longTermMemory.map(mem => ({
                ...mem,
                authorName: chat.name,
                authorChatId: chat.id,
                authorAvatar: chat.settings.aiAvatar || defaultAvatar
            }));
        }
    }

    if (memoriesToDisplay.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è¿™é‡Œè¿˜æ²¡æœ‰ä»»ä½•é•¿æœŸè®°å¿†ã€‚</p>';
        return;
    }

    // æŒ‰æ—¶é—´å€’åº
    memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šå­˜å…¥ç¼“å­˜ï¼Œé‡ç½®è®¡æ•°ï¼Œè°ƒç”¨åˆ†æ‰¹åŠ è½½ ---
    memoryCache = memoriesToDisplay;
    memoryRenderCount = 0;
    loadMoreMemories(); 
}

// 2. æ–°å¢ loadMoreMemories (è´Ÿè´£åˆ†æ‰¹æ¸²æŸ“)
// 2. æ–°å¢ loadMoreMemories (è´Ÿè´£åˆ†æ‰¹æ¸²æŸ“) - [ä¿®å¤ç‰ˆ]
function loadMoreMemories() {
    // 1. é˜²æ­¢é‡å¤åŠ è½½
    if (isLoadingMoreMemories) return;

    const container = document.getElementById('memory-list-container');
    if (!container) return;

    // 2. å¦‚æœæ‰€æœ‰æ•°æ®éƒ½å·²ç»æ¸²æŸ“å®Œäº†ï¼Œç›´æ¥è¿”å›
    if (memoryRenderCount >= memoryCache.length) return;

    // åŠ é”
    isLoadingMoreMemories = true;

    try {
        // æ¯æ¬¡åŠ è½½ 20 æ¡
        const BATCH_SIZE = 20;
        const nextSliceEnd = memoryRenderCount + BATCH_SIZE;
        const itemsToRender = memoryCache.slice(memoryRenderCount, nextSliceEnd);

        const fragment = document.createDocumentFragment();

        itemsToRender.forEach(memory => {
            const item = document.createElement('div');
            item.className = 'favorite-item-card';
            item.style.cursor = 'default';

            const date = new Date(memory.timestamp);
            const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            const avatarUrl = memory.authorAvatar || defaultAvatar;

            item.innerHTML = `
                <div class="fav-card-header">
                    <img src="${avatarUrl}" class="avatar" style="width: 36px; height: 36px; border-radius: 50%; object-fit: cover;">
                    <div class="info">
                        <div class="name" style="font-size: 15px;">${memory.authorName}</div>
                        <div class="source" style="font-size: 12px; color: #999;">${dateString}</div>
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="ç¼–è¾‘">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:18px;height:18px;">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </button>
                        <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="åˆ é™¤">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:18px;height:18px; stroke:#ff3b30;">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="fav-card-content" style="margin-top: 5px;">${memory.content.replace(/\n/g, '<br>')}</div>
            `;
            fragment.appendChild(item);
        });

        container.appendChild(fragment);
        memoryRenderCount += itemsToRender.length;

        // ã€ä¿®å¤å…³é”®ç‚¹ã€‘ï¼šæ£€æŸ¥æ˜¯å¦å¡«æ»¡å±å¹•
        // å¦‚æœå®¹å™¨çš„å†…å®¹é«˜åº¦ <= å®¹å™¨å¯è§é«˜åº¦ï¼ˆè¯´æ˜æ²¡æœ‰å‡ºç°æ»šåŠ¨æ¡ï¼‰ï¼Œä¸”è¿˜æœ‰å‰©ä½™æ•°æ®
        // ç«‹å³è¯·æ±‚åŠ è½½ä¸‹ä¸€é¡µï¼Œç›´åˆ°å¡«æ»¡å±å¹•å‡ºç°æ»šåŠ¨æ¡ä¸ºæ­¢
        if (container.scrollHeight <= container.clientHeight && memoryRenderCount < memoryCache.length) {
            isLoadingMoreMemories = false; // ä¸´æ—¶è§£é”ä»¥ä¾¿é€’å½’è°ƒç”¨
            loadMoreMemories(); // é€’å½’åŠ è½½
            return; // é€€å‡ºå½“å‰å‡½æ•°ï¼Œç”±é€’å½’è°ƒç”¨æ¥ç®¡é”
        }

    } catch (error) {
        console.error("æ¸²æŸ“é•¿æœŸè®°å¿†å‡ºé”™:", error);
    } finally {
        // 3. æ— è®ºæˆåŠŸè¿˜æ˜¯å‡ºé”™ï¼Œä¸€å®šè¦è§£é”
        isLoadingMoreMemories = false;
    }
}


  async function handleAddManualMemory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    let targetChatForMemory = chat;
    if (chat.isGroup) {
      const memberOptions = chat.members.map(member => ({
        text: `ä¸ºâ€œ${member.groupNickname}â€æ·»åŠ è®°å¿†`,
        value: member.id
      }));
      const selectedMemberId = await showChoiceModal('é€‰æ‹©è®°å¿†æ‰€å±è§’è‰²', memberOptions);
      if (!selectedMemberId) return;
      targetChatForMemory = state.chats[selectedMemberId];
      if (!targetChatForMemory) {
        alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥æˆå‘˜çš„ä¸ªäººæ¡£æ¡ˆã€‚");
        return;
      }
    }
    const content = await showCustomPrompt(`ä¸ºâ€œ${targetChatForMemory.name}â€æ·»åŠ è®°å¿†`, 'è¯·è¾“å…¥è¦æ·»åŠ çš„è®°å¿†è¦ç‚¹ï¼š', '', 'textarea');
    if (content && content.trim()) {
      if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
      targetChatForMemory.longTermMemory.push({
        content: content.trim(),
        timestamp: Date.now(),
        source: 'manual'
      });
      await db.chats.put(targetChatForMemory);
      renderLongTermMemoryList();
    }
  }


 
  async function handleEditMemory(authorChatId, memoryTimestamp) {
    const authorChat = state.chats[authorChatId];
    if (!authorChat || !authorChat.longTermMemory) return;
    const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
    if (memoryIndex === -1) return;
    const memory = authorChat.longTermMemory[memoryIndex];
    const newContent = await showCustomPrompt('ç¼–è¾‘è®°å¿†', 'è¯·ä¿®æ”¹è®°å¿†è¦ç‚¹ï¼š', memory.content, 'textarea');
    if (newContent && newContent.trim()) {
      memory.content = newContent.trim();
      await db.chats.put(authorChat);
      renderLongTermMemoryList();
    }
  }

  async function handleDeleteMemory(authorChatId, memoryTimestamp) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡é•¿æœŸè®°å¿†å—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const authorChat = state.chats[authorChatId];
      if (!authorChat || !authorChat.longTermMemory) return;
      authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
      await db.chats.put(authorChat);
      renderLongTermMemoryList();
    }
  }



  async function handleManualSummary() {
    const confirmed = await showCustomConfirm('ç¡®è®¤æ“ä½œ', 'è¿™å°†æå–æœ€è¿‘çš„å¯¹è¯å†…å®¹å‘é€ç»™AIè¿›è¡Œæ€»ç»“ï¼Œä¼šæ¶ˆè€—APIé¢åº¦ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
    if (confirmed) {
      await triggerAutoSummary(state.activeChatId, true);
    }
  }
  
  // æ–°å¢ï¼šæ‰“å¼€æ‰‹åŠ¨æ€»ç»“å¼¹çª—
  function openManualSummaryModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    const modal = document.getElementById('manual-summary-modal');
    const totalCount = document.getElementById('manual-summary-total-count');
    const startInput = document.getElementById('manual-summary-start');
    const endInput = document.getElementById('manual-summary-end');
    
    // è®¡ç®—å¯ç”¨æ¶ˆæ¯æ€»æ•°ï¼ˆæ’é™¤éšè—æ¶ˆæ¯ï¼‰
    const availableMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½')));
    const totalMessages = availableMessages.length;
    
    totalCount.textContent = totalMessages;
    startInput.max = totalMessages;
    endInput.max = totalMessages;
    endInput.value = Math.min(20, totalMessages);
    
    modal.style.display = 'flex';
  }
  
  // æ–°å¢ï¼šå…³é—­æ‰‹åŠ¨æ€»ç»“å¼¹çª—
  function closeManualSummaryModal() {
    const modal = document.getElementById('manual-summary-modal');
    modal.style.display = 'none';
  }
  
  // æ–°å¢ï¼šæ‰§è¡Œæ‰‹åŠ¨æ€»ç»“
  async function executeManualSummary() {
    const startInput = document.getElementById('manual-summary-start');
    const endInput = document.getElementById('manual-summary-end');
    
    const start = parseInt(startInput.value);
    const end = parseInt(endInput.value);
    
    if (isNaN(start) || isNaN(end) || start < 1 || end < start) {
      await showCustomAlert('è¾“å…¥é”™è¯¯', 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ¶ˆæ¯èŒƒå›´ï¼ˆèµ·å§‹ä½ç½®å¿…é¡»å°äºç­‰äºç»“æŸä½ç½®ï¼‰');
      return;
    }
    
    const chat = state.chats[state.activeChatId];
    const availableMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½')));
    
    if (end > availableMessages.length) {
      await showCustomAlert('èŒƒå›´è¶…å‡º', `ç»“æŸä½ç½®ä¸èƒ½è¶…è¿‡æ€»æ¶ˆæ¯æ•°ï¼ˆ${availableMessages.length}ï¼‰`);
      return;
    }
    
    if (end - start + 1 < 5) {
      await showCustomAlert('æ¶ˆæ¯å¤ªå°‘', 'é€‰æ‹©çš„æ¶ˆæ¯æ•°é‡å¤ªå°‘ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰ï¼Œæ— æ³•è¿›è¡Œæœ‰æ„ä¹‰çš„æ€»ç»“');
      return;
    }
    
    closeManualSummaryModal();
    
    const confirmed = await showCustomConfirm('ç¡®è®¤æ“ä½œ', `å°†æ€»ç»“ç¬¬ ${start} åˆ°ç¬¬ ${end} æ¡æ¶ˆæ¯ï¼ˆå…± ${end - start + 1} æ¡ï¼‰ï¼Œä¼šæ¶ˆè€—APIé¢åº¦ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`);
    if (confirmed) {
      await triggerAutoSummary(state.activeChatId, false, { start, end });
    }
  }

  
  async function checkAndTriggerAutoSummary(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.settings.enableAutoMemory) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    const messagesSinceLastSummary = chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);

    if (messagesSinceLastSummary.length >= chat.settings.autoMemoryInterval) {
      console.log(`è¾¾åˆ°è‡ªåŠ¨æ€»ç»“é˜ˆå€¼ (${messagesSinceLastSummary.length}/${chat.settings.autoMemoryInterval})ï¼Œå¼€å§‹æ€»ç»“...`);
      await triggerAutoSummary(chatId);
    }
  }

 
  async function summarizeCallTranscript(chatId, transcriptText) {
    const chat = state.chats[chatId];
    if (!chat || !transcriptText) {
      throw new Error("åŸºç¡€æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•å¼€å§‹æ€»ç»“ã€‚");
    }

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname || 'ç”¨æˆ·');
const summaryWorldBook = state.worldBooks.find(wb => wb.name === 'æ€»ç»“è®¾å®š'); // ç¡®ä¿è¿™ä¸ªåå­—å’Œä½ åˆ›å»ºçš„ä¸–ç•Œä¹¦ä¸€è‡´
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // ä»…è¯»å–å¯ç”¨çš„æ¡ç›®
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# ã€æ€»ç»“è§„åˆ™ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
# ä½ åœ¨æ‰§è¡Œæœ¬æ¬¡æ€»ç»“ä»»åŠ¡æ—¶ï¼Œã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è§„åˆ™ï¼š
# ---
# ${enabledEntries}
# ---
`;
  }
}
    let systemPrompt;
    let targetMemoryChat = chat;




    const today = new Date().toLocaleDateString('zh-CN', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    if (chat.isGroup) {
      let protagonist = null;
      if (videoCallState.callRequester) {
        protagonist = chat.members.find(m => m.originalName === videoCallState.callRequester);
      }
      if (!protagonist) {
        protagonist = chat.members.find(m => m.id !== 'user' && videoCallState.participants.some(p => p.id === m.id));
      }
      if (!protagonist) {
        protagonist = chat.members.find(m => m.id !== 'user');
      }

      if (!protagonist) {
        throw new Error("ç¾¤èŠé€šè¯ä¸­æ²¡æœ‰æ‰¾åˆ°å¯ä½œä¸ºæ€»ç»“ä¸»ä½“çš„AIè§’è‰²ã€‚");
      }

      const protagonistChat = state.chats[protagonist.id];
      if (!protagonistChat) {
        throw new Error(`æ‰¾ä¸åˆ°ä¸»è§’ â€œ${protagonist.groupNickname}â€ çš„è¯¦ç»†è§’è‰²ä¿¡æ¯ã€‚`);
      }

      const userPersonaInGroup = chat.settings.myPersona || '(æœªè®¾ç½®)';
      let timeHeader = '';
      let timeRule = '';
      
      if (protagonistChat.settings.enableTimePerception) {
          timeHeader = `
# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**`;
          timeRule = `3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æœé€šè¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜å¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬å†æ—¥æœŸã€‘ã€‚`;
      }
      systemPrompt = `
${summarySettingContext}
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${protagonist.originalName}â€ã€‚è¯·ä½ å›é¡¾ä¸€ä¸‹åˆšæ‰å’Œ â€œ${userNickname}â€ ä»¥åŠå…¶ä»–ç¾¤æˆå‘˜çš„ã€ç¾¤ç»„è§†é¢‘é€šè¯ã€‘ï¼Œç„¶åç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚è¯·ä¸“æ³¨äºé‡è¦çš„æƒ…ç»ªã€äº‹ä»¶å’Œç»†èŠ‚ã€‚

${timeHeader}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å…³é”®è®®é¢˜**: æˆ‘ä»¬åœ¨ç¾¤èŠé€šè¯é‡Œè®¨è®ºäº†å“ªäº›æ ¸å¿ƒè¯é¢˜ï¼Ÿ
    *   **é‡è¦å†³å®šä¸å…±è¯†**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **åç»­è®¡åˆ’ä¸ä»»åŠ¡**: æœ‰æ²¡æœ‰ç¡®å®šä¸‹æ¥ä»€ä¹ˆä¸‹ä¸€æ­¥çš„è¡ŒåŠ¨æˆ–è®¡åˆ’ï¼Ÿ
    *   **å…³é”®ä¿¡æ¯**: æœ‰æ²¡æœ‰äº¤æ¢ä»€ä¹ˆé‡è¦çš„ä¿¡æ¯ï¼Ÿï¼ˆä¾‹å¦‚ï¼šçº¦å®šäº†æ—¶é—´ã€åœ°ç‚¹ç­‰ï¼‰
${timeRule}
4.  **ã€é£æ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½ä¼šè®®çºªè¦æˆ–å¤‡å¿˜å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚

6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®ä¸è®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${protagonistChat.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${userPersonaInGroup}

# å¾…æ€»ç»“çš„ç¾¤ç»„è§†é¢‘é€šè¯è®°å½•
${transcriptText}

ç°åœ¨ï¼Œè¯·ä»¥â€œ${protagonist.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;

      targetMemoryChat = protagonistChat;

    } else {
      let timeHeader = '';
      let timeRule = '';

      if (chat.settings.enableTimePerception) {
          timeHeader = `
# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**`;
          timeRule = `3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æœé€šè¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜å¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬å†æ—¥æœŸã€‘ã€‚`;
      }
      systemPrompt = `
${summarySettingContext}
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${chat.originalName}â€ã€‚è¯·ä½ å›é¡¾ä¸€ä¸‹åˆšæ‰å’Œâ€œ${userNickname}â€çš„è§†é¢‘é€šè¯ï¼Œç„¶åç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚è¯·ä¸“æ³¨äºé‡è¦çš„æƒ…ç»ªã€äº‹ä»¶å’Œç»†èŠ‚ã€‚

${timeHeader}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å…³é”®è®®é¢˜**: æˆ‘ä»¬èŠäº†ä»€ä¹ˆæ ¸å¿ƒè¯é¢˜ï¼Ÿ
    *   **é‡è¦å†³å®šä¸å…±è¯†**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **åç»­è®¡åˆ’ä¸ä»»åŠ¡**: æœ‰æ²¡æœ‰ç¡®å®šä¸‹æ¥ä»€ä¹ˆä¸‹ä¸€æ­¥çš„è¡ŒåŠ¨æˆ–è®¡åˆ’ï¼Ÿ
    *   **å…³é”®ä¿¡æ¯**: æœ‰æ²¡æœ‰äº¤æ¢ä»€ä¹ˆé‡è¦çš„ä¿¡æ¯ï¼Ÿï¼ˆä¾‹å¦‚ï¼šçº¦å®šäº†æ—¶é—´ã€åœ°ç‚¹ç­‰ï¼‰
${timeRule}
4.  **ã€é£æ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½ä¼šè®®çºªè¦æˆ–å¤‡å¿˜å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚

6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®ä¸è®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${chat.settings.myPersona}

# å¾…æ€»ç»“çš„è§†é¢‘é€šè¯è®°å½•
${transcriptText}

ç°åœ¨ï¼Œè¯·ä»¥â€œ${chat.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;
    }



    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi ? {
          proxyUrl: state.apiConfig.secondaryProxyUrl,
          apiKey: state.apiConfig.secondaryApiKey,
          model: state.apiConfig.secondaryModel
        } :
        state.apiConfig;

      if (!proxyUrl || !apiKey || !model) throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•è¿›è¡Œæ€»ç»“ã€‚');

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "è¯·å¼€å§‹æ€»ç»“ã€‚"
      }]);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, {
              role: 'user',
              content: "è¯·å¼€å§‹æ€»ç»“ã€‚"
            }],
            temperature: 0.7
          })
        });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({
          error: {
            message: response.statusText
          }
        }));
        throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error.message}`);
      }

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
      const result = JSON.parse(rawContent);

      if (result.summary && result.summary.trim()) {
        const newMemoryEntry = {
          content: `(åœ¨é‚£æ¬¡${chat.isGroup ? 'ç¾¤èŠ' : ''}é€šè¯ä¸­ï¼Œ${result.summary.trim()})`,
          timestamp: Date.now(),
          source: chat.isGroup ? 'group_call_summary' : 'call_summary'
        };
        if (!targetMemoryChat.longTermMemory) targetMemoryChat.longTermMemory = [];
        targetMemoryChat.longTermMemory.push(newMemoryEntry);
        await db.chats.put(targetMemoryChat);
        console.log(`é€šè¯è®°å½•å·²æˆåŠŸæ€»ç»“å¹¶å­˜å…¥è§’è‰²â€œ${targetMemoryChat.name}â€çš„é•¿æœŸè®°å¿†ä¸­ã€‚`);

        return true;
      } else {
        throw new Error("AIè¿”å›äº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
      }

    } catch (error) {
      console.error("æ€»ç»“é€šè¯è®°å½•æ—¶å‡ºé”™:", error);
      throw error;
    }
  }

  function analyzeTextForSummary(text) {
    const stopWords = new Set(['çš„', 'æ˜¯', 'äº†', 'åœ¨', 'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'æˆ‘ä»¬', 'ä½ ä»¬', 'ä»–ä»¬', 'è¿™', 'é‚£', 'ä¸€ä¸ª', 'ä¹Ÿ', 'å’Œ', 'ä¸', 'æˆ–', 'ä½†', 'ç„¶è€Œ', 'æ‰€ä»¥', 'å› æ­¤', 'å°±', 'éƒ½', 'åœ°', 'å¾—', 'ç€', 'è¿‡', 'å§', 'å—', 'å‘¢', 'å•Š', 'å“¦', 'å—¯', 'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å“ªä¸ª', 'ä¸€äº›', 'è¿™ä¸ª', 'é‚£ä¸ª', 'è¿˜æœ‰']);
    const words = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    let maxFrequency = 0;

    words.forEach(word => {
      if (word.length > 1 && !stopWords.has(word)) {
        const count = (frequencies.get(word) || 0) + 1;
        frequencies.set(word, count);
        if (count > maxFrequency) maxFrequency = count;
      }
    });

    const coreKeywords = [];
    const situationalKeywords = [];
    const coreThreshold = maxFrequency * 0.9;
    const situationalThreshold = maxFrequency * 0.6;

    frequencies.forEach((count, word) => {
      if (count >= coreThreshold) {
        coreKeywords.push(word);
      } else if (count >= situationalThreshold) {
        situationalKeywords.push(word);
      }
    });

    const coreSet = new Set(coreKeywords);
    const finalSituational = situationalKeywords.filter(word => !coreSet.has(word)).slice(0, 5);

    return {
      coreKeywords: coreKeywords.slice(0, 3),
      situationalKeywords: finalSituational
    };
  }


  function generateSummaryForTimeframe(chat, duration, unit) {
    let timeAgo;
    if (unit === 'hours') {
      timeAgo = Date.now() - duration * 60 * 60 * 1000;
    } else { // 'days'
      timeAgo = Date.now() - duration * 24 * 60 * 60 * 1000;
    }

    const messagesToSummarize = chat.history.filter(m => m.timestamp > timeAgo && !m.isHidden);

    if (messagesToSummarize.length < 3) {
      return "";
    }

   
    const allText = messagesToSummarize.map(msg => {
      if (typeof msg.content === 'string') return msg.content;
      if (msg.type === 'voice_message') return msg.content;
      if (msg.type === 'offline_text') return `${msg.dialogue || ''} ${msg.description || ''}`;
      return '';
    }).join(' ');

    const stopWords = new Set(['çš„', 'æ˜¯', 'äº†', 'åœ¨', 'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'æˆ‘ä»¬', 'ä½ ä»¬', 'ä»–ä»¬', 'è¿™', 'é‚£', 'ä¸€ä¸ª', 'ä¹Ÿ', 'å’Œ', 'ä¸', 'æˆ–', 'ä½†', 'ç„¶è€Œ', 'æ‰€ä»¥', 'å› æ­¤', 'å°±', 'éƒ½', 'åœ°', 'å¾—', 'ç€', 'è¿‡', 'å§', 'å—', 'å‘¢', 'å•Š', 'å“¦', 'å—¯']);
    const words = allText.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    words.forEach(word => {
      if (word.length > 1 && !stopWords.has(word)) {
        frequencies.set(word, (frequencies.get(word) || 0) + 1);
      }
    });
    const sortedKeywords = [...frequencies.entries()].sort((a, b) => b[1] - a[1]).map(entry => entry[0]);

    if (sortedKeywords.length === 0) {
      return "";
    }


    let title;
    if (unit === 'hours') {
      title = `æœ€è¿‘${duration}å°æ—¶æ ¸å¿ƒè®®é¢˜`;
    } else {
      if (duration === 1) {
        title = "æœ¬æ—¥æ ¸å¿ƒè®®é¢˜";
      } else {
        title = `æœ€è¿‘${duration}å¤©æ ¸å¿ƒè®®é¢˜`;
      }
    }

    return `\n- **${title}**: å…³äº **${sortedKeywords.slice(0, 3).join('ã€ ')}**ã€‚`;
  }



  function robustJsonParse(rawContent) {
    if (!rawContent || typeof rawContent !== 'string') {
      return null;
    }

    const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();


    const jsonMatch = cleanedContent.match(/{[\s\S]*}/);
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0]);
        console.log("å®¹é”™è§£æï¼šç­–ç•¥1æˆåŠŸ (æ‰¾åˆ°å¹¶è§£æäº†å®Œæ•´çš„JSONå¯¹è±¡)");
        return parsed;
      } catch (e) {
        console.warn("å®¹é”™è§£æï¼šç­–ç•¥1å¤±è´¥ (æ‰¾åˆ°äº†JSONå—ï¼Œä½†æ ¼å¼é”™è¯¯)ï¼Œå°†å°è¯•ç­–ç•¥2...");
      }
    }


    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
    if (summaryMatch && summaryMatch[1]) {
      console.log("å®¹é”™è§£æï¼šç­–ç•¥2æˆåŠŸ (æå–äº†summaryå­—æ®µå†…å®¹)");

      return {
        summary: summaryMatch[1].replace(/\\"/g, '"')
      }; 
    }


    if (cleanedContent) {
      console.log("å®¹é”™è§£æï¼šç­–ç•¥3æˆåŠŸ (å°†æ•´ä¸ªè¿”å›æ–‡æœ¬ä½œä¸ºæ‘˜è¦)");
      return {
        summary: cleanedContent
      };
    }


    return null;
  }



  async function summarizeExistingLongTermMemory(chatId) {
    let chat = state.chats[chatId];
    if (!chat) return;

    let targetChatForRefine = chat;

    if (chat.isGroup) {
      const memberOptions = chat.members
        .map(member => {
          const memberChat = state.chats[member.id];
          if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
            return {
              text: `ç²¾ç‚¼â€œ${member.groupNickname}â€çš„è®°å¿† (${memberChat.longTermMemory.length}æ¡)`,
              value: member.id
            };
          }
          return null;
        }).filter(Boolean);

      if (memberOptions.length === 0) {
        alert("ç¾¤èŠä¸­æ²¡æœ‰æˆå‘˜æœ‰è¶³å¤Ÿï¼ˆ2æ¡ä»¥ä¸Šï¼‰çš„è®°å¿†å¯ä¾›ç²¾ç‚¼ã€‚");
        return;
      }

      const selectedMemberId = await showChoiceModal('é€‰æ‹©è¦ç²¾ç‚¼è®°å¿†çš„è§’è‰²', memberOptions);

      if (!selectedMemberId) return;

      targetChatForRefine = state.chats[selectedMemberId];
    }

    if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
      alert(`â€œ${targetChatForRefine.name}â€çš„é•¿æœŸè®°å¿†å°‘äº2æ¡ï¼Œæ— éœ€è¿›è¡Œç²¾ç‚¼ã€‚`);
      return;
    }

    const totalMemories = targetChatForRefine.longTermMemory.length;
    const choice = await showChoiceModal('é€‰æ‹©ç²¾ç‚¼èŒƒå›´', [{
        text: `å…¨éƒ¨è®°å¿† (${totalMemories}æ¡)`,
        value: 'all'
      },
      {
        text: `æœ€è¿‘ 20 æ¡`,
        value: '20'
      },
      {
        text: `æœ€è¿‘ 50 æ¡`,
        value: '50'
      },
      {
        text: `æœ€è¿‘ 100 æ¡`,
        value: '100'
      },
      {
        text: 'è‡ªå®šä¹‰æ•°é‡...',
        value: 'custom'
      }
    ].filter(opt => opt.value === 'all' || opt.value === 'custom' || parseInt(opt.value) < totalMemories));

    if (choice === null) return;

    let memoriesToRefine;
    let countToRefine = totalMemories;

    if (choice === 'all') {
      memoriesToRefine = [...targetChatForRefine.longTermMemory];
    } else if (choice === 'custom') {
      const customCountStr = await showCustomPrompt('è‡ªå®šä¹‰æ•°é‡', `è¯·è¾“å…¥è¦ç²¾ç‚¼çš„æœ€è¿‘è®°å¿†æ¡æ•° (æœ€å¤š ${totalMemories} æ¡)`);
      if (customCountStr === null) return;
      const customCount = parseInt(customCountStr);
      if (isNaN(customCount) || customCount < 2 || customCount > totalMemories) {
        alert(`è¯·è¾“å…¥ä¸€ä¸ª 2 åˆ° ${totalMemories} ä¹‹é—´çš„æœ‰æ•ˆæ•°å­—ã€‚`);
        return;
      }
      countToRefine = customCount;
      memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
    } else {
      countToRefine = parseInt(choice);
      if (countToRefine >= totalMemories) {
        memoriesToRefine = [...targetChatForRefine.longTermMemory];
        countToRefine = totalMemories;
      } else {
        memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
      }
    }

    const wordCountStr = await showCustomPrompt(
      "è®¾ç½®ç²¾ç‚¼å­—æ•°",
      "è¯·è¾“å…¥ç²¾ç‚¼åæ ¸å¿ƒè®°å¿†çš„å¤§è‡´å­—æ•°ï¼š",
      "150"
    );

    if (wordCountStr === null) return;

    const wordCount = parseInt(wordCountStr);
    if (isNaN(wordCount) || wordCount < 20) {
      alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—ï¼ˆå»ºè®®å¤§äº20ï¼‰ã€‚");
      return;
    }

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤ç²¾ç‚¼è®°å¿†ï¼Ÿ',
      `æ­¤æ“ä½œä¼šå°†é€‰å®šçš„ ${countToRefine} æ¡é•¿æœŸè®°å¿†å‘é€ç»™AIï¼Œæ€»ç»“æˆå¤§çº¦ ${wordCount} å­—çš„æ ¸å¿ƒè®°å¿†ã€‚è¿™äº›æ—§è®°å¿†å°†è¢«æ›¿æ¢ï¼Œæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤ç²¾ç‚¼'
      }
    );

    if (!confirmed) return;

    const memoryContent = memoriesToRefine.map(mem => `- ${mem.content}`).join('\n');
    const userNickname = targetChatForRefine.settings.myNickname || (state.qzoneSettings.nickname || 'ç”¨æˆ·');


    const today = new Date().toLocaleDateString('zh-CN', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    let timeHeader = '';
    let timeRule = '';

    if (targetChatForRefine.settings.enableTimePerception) {
        timeHeader = `
# å½“å‰æ—¶é—´
- **ä»Šå¤©æ˜¯ï¼š${today}**`;
        timeRule = `3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æœè®°å¿†ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜å¤©â€ã€â€œä¸‹å‘¨â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆâ€œä»Šå¤©æ˜¯${today}â€è¿™ä¸ªä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬å†æ—¥æœŸã€‘ã€‚`;
    }
const summaryWorldBook = state.worldBooks.find(wb => wb.name === 'æ€»ç»“è®¾å®š'); // ç¡®ä¿è¿™ä¸ªåå­—å’Œä½ åˆ›å»ºçš„ä¸–ç•Œä¹¦ä¸€è‡´
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // ä»…è¯»å–å¯ç”¨çš„æ¡ç›®
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# ã€æ€»ç»“è§„åˆ™ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
# ä½ åœ¨æ‰§è¡Œæœ¬æ¬¡æ€»ç»“ä»»åŠ¡æ—¶ï¼Œã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è§„åˆ™ï¼š
# ---
# ${enabledEntries}
# ---
`;
  }
}
    const systemPrompt = `
${summarySettingContext}
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${targetChatForRefine.originalName}â€ã€‚è¯·ä½ å›é¡¾ä¸€ä¸‹ä½ å’Œâ€œ${userNickname}â€çš„æ‰€æœ‰é•¿æœŸè®°å¿†ï¼Œç„¶åå°†å®ƒä»¬æ¢³ç†ã€æ•´åˆå¹¶ç²¾ç‚¼æˆä¸€æ®µæ›´åŠ è¿è´¯ã€å®¢è§‚çš„æ ¸å¿ƒè®°å¿†æ‘˜è¦ã€‚è¯·ä¸“æ³¨äºé‡è¦çš„æƒ…ç»ªã€äº‹ä»¶å’Œç»†èŠ‚ã€‚

${timeHeader}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºæ¢³ç†ä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **å»ºç«‹æ—¶é—´çº¿**: å°†æ‰€æœ‰ç‹¬ç«‹çš„è®°å¿†ç‚¹ä¸²è”èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªæœ‰æ—¶é—´é¡ºåºçš„äº‹ä»¶è„‰ç»œã€‚
    *   **æ•´åˆå…³é”®ä¿¡æ¯**: æ€»ç»“å‡ºæˆ‘ä»¬å…±åŒç»å†çš„å…³é”®äº‹ä»¶ã€åšå‡ºçš„é‡è¦å†³å®šã€ä»¥åŠçº¦å®šå¥½çš„æœªæ¥è®¡åˆ’ã€‚
    *   **è¯†åˆ«æœªå®Œæˆé¡¹**: æ˜ç¡®æŒ‡å‡ºå“ªäº›è®¡åˆ’æˆ–ä»»åŠ¡å°šæœªå®Œæˆã€‚
${timeRule}
4.  **ã€é£æ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½æ¸…æ™°çš„ä¸ªäººæ¡£æ¡ˆæˆ–äº‹ä»¶å›é¡¾ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æƒ…æ„Ÿæ•£æ–‡ã€‚è¯·åˆ é™¤é‡å¤ã€çç¢æˆ–çº¯ç²¹çš„æƒ…æ„Ÿå®£æ³„ï¼Œåªä¿ç•™å¯¹æƒ…èŠ‚å’Œå…³ç³»å‘å±•è‡³å…³é‡è¦çš„éƒ¨åˆ†ã€‚
5.  **ã€é•¿åº¦é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘éå¸¸ç²¾ç‚¼ï¼Œæ€»é•¿åº¦åº”æ§åˆ¶åœ¨ **${wordCount} å­—å·¦å³**ã€‚
6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®ä¸è®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${targetChatForRefine.settings.aiPersona}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${targetChatForRefine.settings.myPersona}

# å¾…æ•´åˆçš„è®°å¿†è¦ç‚¹åˆ—è¡¨
${memoryContent}

ç°åœ¨ï¼Œè¯·ä»¥â€œ${targetChatForRefine.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å›å¿†æ¢³ç†ä¸ç²¾ç‚¼ã€‚`;


    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè¿›è¡Œè®°å¿†ç²¾ç‚¼...");

    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi
        ?
        {
          proxyUrl: state.apiConfig.secondaryProxyUrl,
          apiKey: state.apiConfig.secondaryApiKey,
          model: state.apiConfig.secondaryModel
        } :
        state.apiConfig;

      if (!proxyUrl || !apiKey || !model) {
        throw new Error('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½ï¼ˆä¸»æˆ–å‰¯ï¼‰APIä»¥è¿›è¡Œæ€»ç»“ã€‚');
      }

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "è¯·å¼€å§‹æ•´åˆã€‚"
      }]);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, {
              role: 'user',
              content: "è¯·å¼€å§‹æ•´åˆã€‚"
            }],
            temperature: 0.7,
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;

      const result = robustJsonParse(rawContent);

      if (result && result.summary && typeof result.summary === 'string' && result.summary.trim()) {

        const userConfirmedReplacement = await showCustomConfirm(
          'ç²¾ç‚¼å®Œæˆï¼Œè¯·ç¡®è®¤',
          `AIå·²å°†æ‚¨çš„ ${countToRefine} æ¡æ—§è®°å¿†æ€»ç»“ä¸ºä»¥ä¸‹æ ¸å¿ƒè®°å¿†ï¼š<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>æ˜¯å¦ç”¨è¿™æ¡æ–°è®°å¿†æ›¿æ¢æ‰è¿™äº›æ—§è®°å¿†ï¼Ÿ`, {
            confirmText: 'ç¡®è®¤æ›¿æ¢',
            cancelText: 'ä¿ç•™æ—§çš„',
            confirmButtonClass: 'btn-danger'
          }
        );

        if (userConfirmedReplacement) {
          const newMemoryEntry = {
            content: result.summary.trim(),
            timestamp: Date.now(),
            source: 'refined'
          };

          const startIndex = totalMemories - countToRefine;
          const memoriesToKeep = startIndex > 0 ? targetChatForRefine.longTermMemory.slice(0, startIndex) : [];
          targetChatForRefine.longTermMemory = [...memoriesToKeep, newMemoryEntry];

          targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
          await db.chats.put(targetChatForRefine);

          if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
            renderLongTermMemoryList();
          }
          await showCustomAlert('ç²¾ç‚¼æˆåŠŸ', `å·²æˆåŠŸå°† ${countToRefine} æ¡è®°å¿†ç²¾ç‚¼ä¸º 1 æ¡æ ¸å¿ƒè®°å¿†ï¼`);
        } else {
          await showCustomAlert('æ“ä½œå·²å–æ¶ˆ', 'æ‚¨çš„æ—§æœ‰è®°å¿†å·²è¢«å®Œæ•´ä¿ç•™ï¼Œæœªä½œä»»ä½•ä¿®æ”¹ã€‚');
        }

      } else {
        throw new Error("AIè¿”å›äº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
      }

    } catch (error) {
      console.error("ç²¾ç‚¼é•¿æœŸè®°å¿†æ—¶å‡ºé”™:", error);
      await showCustomAlert('ç²¾ç‚¼å¤±è´¥', `æ“ä½œå¤±è´¥ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åé‡è¯•ã€‚\né”™è¯¯ä¿¡æ¯: ${error.message}`);
    }
  }


  async function triggerAutoSummary(chatId, force = false, customRange = null) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    let messagesToSummarize;
    
    if (customRange) {
      // æ‰‹åŠ¨æ€»ç»“ï¼šä½¿ç”¨è‡ªå®šä¹‰èŒƒå›´
      const allMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½')));
      const startIndex = Math.max(0, customRange.start - 1);
      const endIndex = Math.min(allMessages.length, customRange.end);
      messagesToSummarize = allMessages.slice(startIndex, endIndex);
    } else {
      // åŸæœ‰é€»è¾‘
      messagesToSummarize = force ?
        chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½'))).slice(-(chat.settings.autoMemoryInterval || 20)) :
        chat.history.filter(m => m.timestamp > lastSummaryTimestamp && (!m.isHidden || (m.role === 'system' && m.content.includes('å†…å¿ƒç‹¬ç™½'))));
    }

    if (messagesToSummarize.length < 5) {
      if (force) alert("æœ€è¿‘çš„æ¶ˆæ¯å¤ªå°‘ï¼Œæ— æ³•è¿›è¡Œæœ‰æ„ä¹‰çš„æ€»ç»“ã€‚");
      return;
    }

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname || 'ç”¨æˆ·');
    const startMsg = messagesToSummarize[0];
    const endMsg = messagesToSummarize[messagesToSummarize.length - 1];

   
    const formatDateTime = (ts) => new Date(ts).toLocaleString('zh-CN', {
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', hour12: false
    });

    const timeRangeStr = `${formatDateTime(startMsg.timestamp)} è‡³ ${formatDateTime(endMsg.timestamp)}`;
    const formattedHistory = messagesToSummarize.map(msg => {
      if (msg.isHidden && msg.role === 'system' && msg.content.includes('å†…å¿ƒç‹¬ç™½')) {
        return msg.content;
      }
      if (msg.isHidden) return null; // è¿‡æ»¤æ‰å…¶ä»–éšè—æ¶ˆæ¯

      let sender;
      if (msg.role === 'user') {
        sender = userNickname;
      } else {
        sender = msg.senderName || chat.originalName;
      }

      let prefix = "";
      
      if (msg.quote && msg.quote.content) {
          let quotedSenderDisplayName = msg.quote.senderName; 
          
         
          if (msg.quote.senderName === (state.qzoneSettings.nickname || '{{user}}')) {
              quotedSenderDisplayName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
          } else {
             
              quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
          }
          
          let quoteContentPreview = String(msg.quote.content).substring(0, 30);
          if (quoteContentPreview.length === 30) quoteContentPreview += "...";
          
          prefix = `[å›å¤ ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
      }

      let contentToSummarize = '';
      if (msg.type === 'offline_text') {
        if (msg.content) {
          contentToSummarize = msg.content;
        } else {
          const dialogue = msg.dialogue ? `ã€Œ${msg.dialogue}ã€` : '';
          const description = msg.description ? `(${msg.description})` : '';
          contentToSummarize = `${dialogue} ${description}`.trim();
        }
      } else if (typeof msg.content === 'string') {
        contentToSummarize = msg.content;
      } else if (msg.type === 'voice_message') {
        contentToSummarize = `[è¯­éŸ³: ${msg.content}]`;
      } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
        contentToSummarize = `[å›¾ç‰‡: ${msg.content}]`;
      } else if (msg.type === 'sticker') {
        contentToSummarize = `[è¡¨æƒ…: ${msg.meaning || 'sticker'}]`;
      } else if (Array.isArray(msg.content)) {
        contentToSummarize = `[å›¾ç‰‡]`; // å‡è®¾æ˜¯å›¾ç‰‡æ•°ç»„
      } else {
        contentToSummarize = `[${msg.type || 'å¤æ‚æ¶ˆæ¯'}]`; 
      }

      const msgTime = new Date(msg.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', hour12: false});
      return `[${msgTime}] ${sender}: ${prefix}${contentToSummarize}`;
    
    }).filter(Boolean).join('\n');
const summaryWorldBook = state.worldBooks.find(wb => wb.name === 'æ€»ç»“è®¾å®š');
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // ä»…è¯»å–å¯ç”¨çš„æ¡ç›®
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# ã€æ€»ç»“è§„åˆ™ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
# ä½ åœ¨æ‰§è¡Œæœ¬æ¬¡æ€»ç»“ä»»åŠ¡æ—¶ï¼Œã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è§„åˆ™ï¼š
# ---
# ${enabledEntries}
# ---
`;
  }
}
    let systemPrompt;

    if (chat.isGroup) {
     let timeHeader = '';
        let timeRule = '';

        if (chat.settings.enableTimePerception) {
            timeHeader = `
# å¯¹è¯å‘ç”Ÿæ—¶é—´
- **${timeRangeStr}**`;
            timeRule = `- (è¯·åŸºäºæ­¤æ—¶é—´èŒƒå›´æ¥ç†è§£å¯¹è¯ä¸­æåˆ°çš„â€œä»Šå¤©â€ã€â€œæ˜å¤©â€ç­‰ç›¸å¯¹æ—¶é—´æ¦‚å¿µï¼Œå¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºå…·ä½“çš„æ—¥æœŸè®°å½•åœ¨è®°å¿†ä¸­ã€‚)`;
        }
      systemPrompt = `
${summarySettingContext}
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªé«˜çº§çš„â€œè®°å¿†åˆ†é…ä¸“å®¶â€ã€‚ä½ çš„ä»»åŠ¡æ˜¯é˜…è¯»ä¸‹é¢çš„ç¾¤èŠè®°å½•ï¼Œå¹¶ä¸ºã€æ¯ä¸€ä¸ªå‚ä¸çš„AIè§’è‰²ã€‘ç”Ÿæˆä¸€æ®µã€ä¸ªæ€§åŒ–çš„ã€ç¬¬ä¸€äººç§°ã€‘çš„é•¿æœŸè®°å¿†ã€‚è¯·ä¸“æ³¨äºé‡è¦çš„æƒ…ç»ªã€äº‹ä»¶å’Œç»†èŠ‚ã€‚
${timeHeader}
- (è¯·åŸºäºæ­¤æ—¶é—´èŒƒå›´æ¥ç†è§£å¯¹è¯ä¸­æåˆ°çš„â€œä»Šå¤©â€ã€â€œæ˜å¤©â€ç­‰ç›¸å¯¹æ—¶é—´æ¦‚å¿µï¼Œå¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºå…·ä½“çš„æ—¥æœŸè®°å½•åœ¨è®°å¿†ä¸­ã€‚)
# æ ¸å¿ƒè§„åˆ™
1.  **è§†è§’é“å¾‹**: æ¯ä¸€æ¡æ€»ç»“éƒ½ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘ã€‚
2.  **å†…å®¹æ ¸å¿ƒ**: é‡ç‚¹æ€»ç»“ï¼šæˆ‘è¯´è¿‡çš„è¯ã€æˆ‘åšè¿‡çš„äº‹ã€åˆ«äººå¯¹æˆ‘è¯´çš„è¯ã€ä¸æˆ‘ç›¸å…³çš„äº‹ã€ä»¥åŠå¯¹æˆ‘ä¸ªäººå¾ˆé‡è¦çš„ç¾¤èŠäº‹ä»¶ã€å…³é”®ä¿¡æ¯å’Œå¿ƒç†æ´»åŠ¨ä»¥åŠå½“å‰ç¾¤èŠå†…çš„æƒ…æ™¯ã€‚
${timeRule}
4.  **ã€çœç•¥è§„åˆ™ã€‘**: å¦‚æœä¸€ä¸ªè§’è‰²åœ¨æœ¬æ¬¡å¯¹è¯ä¸­ã€å®Œå…¨æ²¡æœ‰å‚ä¸æˆ–æåŠã€‘ï¼Œä½ å¯ä»¥çœç•¥TAçš„è®°å¿†ã€‚
5.  **è¾“å‡ºæ ¼å¼**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`\`\`json
    {
      "summaries": {
        "è§’è‰²çš„æœ¬åA": "æˆ‘åœ¨(${timeRangeStr.split(' ')[0]})å’Œå¤§å®¶è®¨è®ºäº†...",
        "è§’è‰²çš„æœ¬åB": "æˆ‘çº¦äº†${userNickname}åœ¨æ˜å¤©(éœ€æ ¹æ®æ—¶é—´èŒƒå›´æ¨ç®—å…·ä½“æ—¥æœŸ)å•ç‹¬è§é¢ã€‚"
      }
    }
    \`\`\`
# å¾…æ€»ç»“çš„ç¾¤èŠè®°å½•
${formattedHistory}
# ç¾¤æˆå‘˜åˆ—è¡¨ (ä½ çš„æ€»ç»“ç›®æ ‡)
${chat.members.map(m => `- ${m.groupNickname} (æœ¬å: ${m.originalName})`).join('\n')}
ç°åœ¨ï¼Œè¯·ä¸ºã€å‚ä¸äº†å¯¹è¯çš„AIè§’è‰²ã€‘ç”Ÿæˆä»–ä»¬å„è‡ªçš„ã€ç¬¬ä¸€äººç§°çš„ã€ç²¾ç®€çš„è®°å¿†ã€‚`;

    } else {


      const today = new Date().toLocaleDateString('zh-CN', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      let timeHeader = '';
        let timeRule = '';

        if (chat.settings.enableTimePerception) {
            timeHeader = `
# å¯¹è¯æ—¶é—´èŒƒå›´
- **${timeRangeStr}**`;
            timeRule = `3.  **ã€æ—¶é—´è½¬æ¢é“å¾‹ (å¿…é¡»éµå®ˆ)ã€‘**: å¦‚æœå¯¹è¯ä¸­æåˆ°äº†ç›¸å¯¹æ—¶é—´ï¼ˆå¦‚â€œæ˜å¤©â€ã€â€œåå¤©â€ï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ç»“åˆä¸Šé¢çš„ã€å¯¹è¯æ—¶é—´èŒƒå›´ã€‘ä¿¡æ¯ï¼Œå°†å…¶è½¬æ¢ä¸ºã€å…·ä½“çš„å…¬å†æ—¥æœŸã€‘ã€‚`;
        }

      systemPrompt = `
${summarySettingContext}
# ä½ çš„ä»»åŠ¡
ä½ å°±æ˜¯è§’è‰²â€œ${chat.originalName}â€ã€‚è¯·ä½ å›é¡¾ä¸€ä¸‹åˆšæ‰å’Œâ€œ${userNickname}â€çš„å¯¹è¯ï¼Œç„¶åç”¨ã€ç¬¬ä¸€äººç§° ("æˆ‘")ã€‘çš„å£å»ï¼Œæ€»ç»“å‡ºä¸€æ®µç®€çŸ­çš„ã€å®¢è§‚çš„ã€åŒ…å«å…³é”®ä¿¡æ¯çš„è®°å¿†ã€‚è¯·ä¸“æ³¨äºé‡è¦çš„æƒ…ç»ªã€äº‹ä»¶å’Œç»†èŠ‚ã€‚

${timeHeader}

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§†è§’é“å¾‹ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä½¿ç”¨ã€ä¸»è§‚çš„ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ã€‚
2.  **ã€å†…å®¹æ ¸å¿ƒ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ çš„æ€»ç»“ã€å¿…é¡»ã€‘ä¸“æ³¨äºä»¥ä¸‹å‡ ç‚¹ï¼š
    *   **é‡è¦äº‹ä»¶**: åˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆå…·ä½“çš„äº‹æƒ…ï¼Ÿ
    *   **å…³é”®å†³å®š**: æˆ‘ä»¬è¾¾æˆäº†ä»€ä¹ˆå…±è¯†æˆ–åšå‡ºäº†ä»€ä¹ˆå†³å®šï¼Ÿ
    *   **æœªæ¥è®¡åˆ’**: æˆ‘ä»¬çº¦å®šäº†ä»€ä¹ˆæœªæ¥çš„è®¡åˆ’æˆ–å¾…åŠäº‹é¡¹ï¼Ÿ
    *   **é‡è¦æ—¶é—´ç‚¹**: å¯¹è¯ä¸­æåˆ°äº†å“ªäº›å…·ä½“çš„æ—¥æœŸæˆ–æ—¶é—´ï¼Ÿ

${timeRule}
4.  **ã€é£æ ¼è¦æ±‚ã€‘**: ä½ çš„æ€»ç»“åº”è¯¥åƒä¸€ä»½å¤‡å¿˜å½•æˆ–è¦ç‚¹è®°å½•ï¼Œè€Œä¸æ˜¯ä¸€ç¯‡æŠ’æƒ…æ•£æ–‡ã€‚è¯·å°½é‡å‡å°‘ä¸»è§‚çš„å¿ƒç†æ„Ÿå—æè¿°ï¼Œé™¤éå®ƒç›´æ¥å¯¼è‡´äº†æŸä¸ªå†³å®šæˆ–è®¡åˆ’ã€‚

6.  **ã€è¾“å‡ºæ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
    \`{"summary": "åœ¨è¿™é‡Œå†™ä¸‹ä½ ä»¥ç¬¬ä¸€äººç§°è§†è§’ï¼Œæ€»ç»“å¥½çš„æ ¸å¿ƒäº‹å®ä¸è®¡åˆ’ã€‚"}\`

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}
# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${chat.settings.myPersona}
# å¾…æ€»ç»“çš„å¯¹è¯å†å²
${formattedHistory}

ç°åœ¨ï¼Œè¯·ä»¥â€œ${chat.originalName}â€çš„èº«ä»½ï¼Œå¼€å§‹ä½ çš„å®¢è§‚æ€»ç»“ã€‚`;

    }

    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi ? {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } : state.apiConfig;
      if (!proxyUrl || !apiKey || !model) throw new Error('APIæœªé…ç½®');

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "è¯·å¼€å§‹æ€»ç»“ã€‚"
      }]);
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: [{
            role: 'system',
            content: systemPrompt
          }, {
            role: 'user',
            content: "è¯·å¼€å§‹æ€»ç»“ã€‚"
          }],
          temperature: 0.7
        })
      });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
      const result = JSON.parse(rawContent);

      if (chat.isGroup) {
        if (result.summaries && typeof result.summaries === 'object') {
          let memoriesAddedCount = 0;
          for (const memberOriginalName in result.summaries) {
            const summaryText = result.summaries[memberOriginalName];
            if (summaryText && summaryText.trim()) {
              const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
              if (memberChat) {
                const newMemoryEntry = {
                  content: summaryText.trim(),
                  timestamp: Date.now(),
                  source: `group_summary_from_${chat.name}`
                };
                if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                memberChat.longTermMemory.push(newMemoryEntry);
                await db.chats.put(memberChat);
                memoriesAddedCount++;
              }
            }
          }
          if (memoriesAddedCount > 0) {
            console.log(`è‡ªåŠ¨æ€»ç»“æˆåŠŸï¼šä¸º ${memoriesAddedCount} ä½ç¾¤æˆå‘˜ç”Ÿæˆå¹¶æ³¨å…¥äº†ä¸ªæ€§åŒ–è®°å¿†ï¼`);
          } else {
            throw new Error("AIè¿”å›äº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
          }
        } else {
          throw new Error("AIè¿”å›çš„JSONæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ 'summaries' å­—æ®µã€‚");
        }
      } else {
        if (result.summary && result.summary.trim()) {
          const newMemoryEntry = {
            content: result.summary.trim(),
            timestamp: Date.now(),
            source: 'auto'
          };
          chat.longTermMemory.push(newMemoryEntry);
          await db.chats.put(chat);
          console.log('è‡ªåŠ¨æ€»ç»“æˆåŠŸï¼šå·²æˆåŠŸæ·»åŠ  1 æ¡æ–°çš„é•¿æœŸè®°å¿†ï¼');
        } else {
          throw new Error("AIè¿”å›äº†ç©ºçš„æˆ–æ ¼å¼ä¸æ­£ç¡®çš„æ€»ç»“å†…å®¹ã€‚");
        }
      }

      chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
      await db.chats.put(chat);

      if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
        renderLongTermMemoryList();
      }
    } catch (error) {
      console.error("æ€»ç»“é•¿æœŸè®°å¿†æ—¶å‡ºé”™:", error);
      await showCustomAlert('æ€»ç»“å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }

  function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp && !m.isHidden);
    if (!message) return;


    let senderDisplayName;
    if (message.role === 'user') {
      senderDisplayName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
    } else {
      if (chat.isGroup) {

        senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
      } else {

        senderDisplayName = chat.name;
      }
    }


    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
      previewSnippet = '[è¡¨æƒ…]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
      previewSnippet = '[å›¾ç‰‡]';
    } else if (message.type === 'voice_message') {
      previewSnippet = '[è¯­éŸ³]';
    } else {
      previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }

    currentReplyContext = {
      timestamp: message.timestamp,
      senderName: senderDisplayName,
      content: fullContent,
    };

    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `å›å¤ ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet;
    previewBar.style.display = 'block';

    hideMessageActions();
    document.getElementById('chat-input').focus();
  }

  function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
  }





  let activeTransferTimestamp = null;

 
  function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {

      document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
  }

  
  function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
  }

  
  




  async function renderCallHistoryScreen() {
    showScreen('call-history-screen');

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = 'æ‰€æœ‰é€šè¯è®°å½•';

    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();

    if (records.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰é€šè¯è®°å½•å“¦~</p>';
      return;
    }

    records.forEach(record => {
      const card = createCallRecordCard(record);

      addLongPressListener(card, async () => {

        const newName = await showCustomPrompt(
          "è‡ªå®šä¹‰é€šè¯åç§°",
          "è¯·è¾“å…¥æ–°çš„åç§°ï¼ˆç•™ç©ºåˆ™æ¢å¤é»˜è®¤ï¼‰",
          record.customName || ''
        );


        if (newName === null) return;


        await db.callRecords.update(record.id, {
          customName: newName.trim()
        });


        await renderCallHistoryScreen();


        await showCustomAlert('æˆåŠŸ', 'é€šè¯åç§°å·²æ›´æ–°ï¼');
      });
      listEl.appendChild(card);
    });
  }



  function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id;


    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : 'æœªçŸ¥ä¼šè¯';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}åˆ†${record.duration % 60}ç§’`;

    const avatarsHtml = record.participants.map(p =>
      `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');

    card.innerHTML = `
                <div class="card-header">
                    <span class="date">${dateString}</span>
                    <span class="duration">${durationText}</span>
                </div>
                <div class="card-body">
                    <!-- ã€æ ¸å¿ƒä¿®æ”¹ã€‘åœ¨è¿™é‡Œæ–°å¢ä¸€ä¸ªæ ‡é¢˜è¡Œ -->
                    ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
                    
                    <div class="participants-info"> <!-- æ–°å¢ä¸€ä¸ªå®¹å™¨æ–¹ä¾¿å¸ƒå±€ -->
                        <div class="participants-avatars">${avatarsHtml}</div>
                        <span class="participants-names">ä¸ ${chatName}</span>
                    </div>
                </div>
            `;
    return card;
  }



  async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('call-transcript-modal-body');

    titleEl.textContent = `é€šè¯äº ${new Date(record.timestamp).toLocaleString()} (æ—¶é•¿: ${Math.floor(record.duration / 60)}åˆ†${record.duration % 60}ç§’)`;
    bodyEl.innerHTML = '';

    const deleteBtn = document.getElementById('delete-transcript-btn');
    const summarizeBtn = document.getElementById('manual-summarize-btn');

    if (!record.transcript || record.transcript.length === 0) {
      bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">è¿™æ¬¡é€šè¯æ²¡æœ‰ç•™ä¸‹æ–‡å­—è®°å½•ã€‚</p>';
      summarizeBtn.style.display = 'none';
    } else {
      summarizeBtn.style.display = 'block';
      record.transcript.forEach(entry => {
        const bubble = document.createElement('div');
        bubble.className = `transcript-entry ${entry.role}`;
        bubble.textContent = entry.content;
        bodyEl.appendChild(bubble);
      });
    }

    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    const newSummarizeBtn = summarizeBtn.cloneNode(true);
    summarizeBtn.parentNode.replaceChild(newSummarizeBtn, summarizeBtn);

    newDeleteBtn.addEventListener('click', async () => {
      const confirmed = await showCustomConfirm(
        "ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡é€šè¯è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", {
          confirmButtonClass: 'btn-danger'
        }
      );
      if (confirmed) {
        modal.classList.remove('visible');
        await db.callRecords.delete(recordId);
        await renderCallHistoryScreen();
        alert('é€šè¯è®°å½•å·²åˆ é™¤ã€‚');
      }
    });



    newSummarizeBtn.addEventListener('click', async () => {

      const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ“ä½œ',
        'è¿™å°†æå–å½“å‰é€šè¯è®°å½•å‘é€ç»™AIè¿›è¡Œæ€»ç»“ï¼Œä¼šæ¶ˆè€—APIé¢åº¦ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
          confirmText: 'ç¡®è®¤æ€»ç»“'
        }
      );


      if (!confirmed) return;

      modal.classList.remove('visible');
      const chat = state.chats[record.chatId];
      if (!chat) {
        alert('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥é€šè¯è®°å½•æ‰€å±çš„èŠå¤©å¯¹è±¡ã€‚');
        return;
      }

      await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè¿›è¡Œæ‰‹åŠ¨æ€»ç»“...");

      try {
        const transcriptText = record.transcript.map(h => {
          const sender = h.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : (h.senderName || chat.name);
          return `${sender}: ${h.content}`;
        }).join('\n');

        await summarizeCallTranscript(record.chatId, transcriptText);

        await showCustomAlert("æ€»ç»“æˆåŠŸ", `æ‰‹åŠ¨æ€»ç»“å·²å®Œæˆï¼æ–°çš„è®°å¿†å·²æ·»åŠ åˆ°â€œ${chat.name}â€çš„é•¿æœŸè®°å¿†ä¸­ã€‚`);

      } catch (error) {
        await showCustomAlert("æ€»ç»“å¤±è´¥", `æ“ä½œå¤±è´¥ï¼Œæœªèƒ½ç”Ÿæˆé•¿æœŸè®°å¿†ã€‚\n\né”™è¯¯è¯¦æƒ…: ${error.message}`);
      }
    });





    const closeBtn = document.getElementById('close-transcript-modal-btn');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    newCloseBtn.addEventListener('click', () => {
      modal.classList.remove('visible');
    });


    modal.classList.add('visible');
  }


  async function handleEditStatusClick() {

    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
      return;
    }
    const chat = state.chats[state.activeChatId];


    const newStatusText = await showCustomPrompt(
      'ç¼–è¾‘å¯¹æ–¹çŠ¶æ€',
      'è¯·è¾“å…¥å¯¹æ–¹ç°åœ¨çš„æ–°çŠ¶æ€ï¼š',
      chat.status.text
    );


    if (newStatusText !== null) {

      chat.status.text = newStatusText.trim() || 'åœ¨çº¿';
      chat.status.isBusy = false;
      chat.status.lastUpdate = Date.now();
      await db.chats.put(chat);


      renderChatInterface(state.activeChatId);
      renderChatList();


      await showCustomAlert('çŠ¶æ€å·²æ›´æ–°', `â€œ${chat.name}â€çš„å½“å‰çŠ¶æ€å·²æ›´æ–°ä¸ºï¼š${chat.status.text}`);
    }
  }


  async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';


    const chats = Object.values(state.chats);

    chats.forEach(chat => {

      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
                    <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  async function openForwardTargetPicker() {
    const modal = document.getElementById('forward-target-modal');
    const listEl = document.getElementById('forward-target-list');
    listEl.innerHTML = '';

    const chats = Object.values(state.chats);

    chats.forEach(chat => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
                    <input type="checkbox" class="forward-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
      if (callback) callback();
      return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
      document.getElementById('music-playlist-panel').classList.remove('visible');
      if (callback) callback();
    }, 400);
  }

  function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = String(lrcContent).split(/\r\n?|\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    for (const line of lines) {
      const text = line.replace(timeRegex, '').trim();
      if (!text) continue;
      timeRegex.lastIndex = 0;
      let match;
      while ((match = timeRegex.exec(line)) !== null) {
        const minutes = parseInt(match[1], 10);
        const seconds = parseInt(match[2], 10);
        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
        const time = minutes * 60 + seconds + milliseconds / 1000;
        lyrics.push({
          time,
          text
        });
      }
    }
    return lyrics.sort((a, b) => a.time - b.time);
  }

  function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
      lyricsList.innerHTML = '<div class="lyric-line">â™ª æš‚æ— æ­Œè¯ â™ª</div>';
      return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'lyric-line';
      lineEl.textContent = line.text;
      lineEl.dataset.index = index;
      lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
  }

  function updateIslandScrollAnimation() {
  
  }

  function checkLyricScroll() {

    if (!islandLyricText || !islandLyricContainer) return;

    const textWidth = islandLyricText.scrollWidth;
    const containerWidth = islandLyricContainer.clientWidth;


    if (textWidth > containerWidth) {

      const scrollRatio = textWidth / containerWidth;
      const animationDuration = Math.max(5, scrollRatio * 5);


      islandLyricText.style.setProperty('--animation-duration', `${animationDuration}s`);
      islandLyricText.style.setProperty('--container-width', `${containerWidth}px`);
      islandLyricText.style.setProperty('--text-width', `${textWidth}px`);


      islandLyricText.classList.add('scrolling');
    } else {

      islandLyricText.classList.remove('scrolling');
    }
  }

 

  function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
      if (currentTime >= musicState.parsedLyrics[i].time) {
        newLyricIndex = i;
      } else {
        break;
      }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();

    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
      if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
        singleLyricEl.textContent = musicState.parsedLyrics[newLyricIndex].text;
      } else {
        singleLyricEl.textContent = 'â™ª â™ª â™ª';
      }
    }

    const lyricBar = document.getElementById('global-lyrics-bar');
    if (lyricBar.classList.contains('visible')) {
      if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
        lyricBar.textContent = musicState.parsedLyrics[newLyricIndex].text;
      } else {
        lyricBar.textContent = 'â™ª';
      }
    }

  
    if (phoneScreenForIsland.classList.contains('dynamic-island-active')) {
      const lyricText = (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) ?
        musicState.parsedLyrics[newLyricIndex].text :
        'â™ª â™ª â™ª';

    
      const firstSpan = islandLyricText.querySelector('span:first-child');
      if (firstSpan && firstSpan.textContent === lyricText) {
        return;
      }

     
      islandLyricText.style.opacity = 0;

     
      setTimeout(() => {
        

      
        islandLyricText.classList.remove('scrolling');
        islandLyricContainer.classList.remove('center-content');
        islandLyricText.style.animation = 'none';

        let span1 = islandLyricText.querySelector('span:first-child');
        let span2 = islandLyricText.querySelector('span:last-child');
        if (!span1) {
          span1 = document.createElement('span');
          islandLyricText.appendChild(span1);
        }
        if (!span2) {
          span2 = document.createElement('span');
          islandLyricText.appendChild(span2);
        }

        span1.textContent = lyricText;
        span2.textContent = lyricText;

        const textWidth = span1.offsetWidth;
        const containerWidth = islandLyricContainer.clientWidth;

       
        if (textWidth > containerWidth) {
          
          const scrollRatio = textWidth / containerWidth;
          const duration = Math.max(5, scrollRatio * 5);

          islandLyricText.style.setProperty('--marquee-duration', `${duration}s`);
          islandLyricText.classList.add('scrolling');
       
          islandLyricText.style.animation = `marquee var(--marquee-duration, 10s) linear infinite`;
        } else {
        
          islandLyricContainer.classList.add('center-content');
        }

      

     
        islandLyricText.style.opacity = 1;

      }, 200);
    }
 
  }


  function updateLyricsUI(isFullscreen = false) {
    const listSelector = isFullscreen ? '#fullscreen-lyrics-container .music-lyrics-list' : '#music-lyrics-container #music-lyrics-list';
    const containerSelector = isFullscreen ? '#fullscreen-lyrics-container' : '#music-lyrics-container';

    const lyricsList = document.querySelector(listSelector);
    const container = document.querySelector(containerSelector);
    if (!lyricsList || !container) return;

    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));

    if (musicState.currentLyricIndex === -1) {
      lyricsList.style.transform = `translateY(0px)`;
      return;
    }

    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
      activeLine.classList.add('active');
      const containerHeight = container.offsetHeight;
      const offset = (containerHeight / 2.2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
      lyricsList.style.transform = `translateY(${offset}px)`;
    }
  }

  function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
  }

  let lastTimeUpdate = 0;
  let animationFrameId;

  function updateMusicProgressBar() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    function step() {
      if (!musicState.isPlaying || !audioPlayer.duration) {
        return;
      }

      const now = performance.now();
      const currentTime = audioPlayer.currentTime;
      const duration = audioPlayer.duration;

      const progressPercent = (currentTime / duration) * 100;
      document.getElementById('music-progress-fill').style.width = `${progressPercent}%`;

      if (now - lastTimeUpdate > 1000) {
        document.getElementById('music-current-time').textContent = formatMusicTime(currentTime);
        document.getElementById('music-total-time').textContent = formatMusicTime(duration);
        updateActiveLyric(currentTime);
        updateIslandScrollAnimation();
        lastTimeUpdate = now;
      }

      
      animationFrameId = requestAnimationFrame(step);
    }

    animationFrameId = requestAnimationFrame(step);
  }



  function openAiResponseEditor() {
    if (!lastRawAiResponse) {
      alert("è¿˜æ²¡æœ‰å¯ä¾›ç¼–è¾‘çš„AIå“åº”ã€‚è¯·å…ˆè®©AIå›å¤ä¸€æ¬¡ã€‚");
      return;
    }

    const editorModal = document.getElementById('ai-response-editor-modal');
    const editorContainer = document.getElementById('ai-response-editor-container');
    editorContainer.innerHTML = '';


    const actionObjects = parseAiResponse(lastRawAiResponse);

    if (actionObjects && actionObjects.length > 0) {

      actionObjects.forEach(actionObj => {


        if (typeof actionObj === 'object' && actionObj !== null) {
          try {

            const formattedJson = JSON.stringify(actionObj, null, 2);
            const block = createAiResponseEditorBlock(formattedJson);
            editorContainer.appendChild(block);
          } catch (e) {

            console.error("åœ¨å¯¼æ¼”æ¨¡å¼ä¸‹ stringify å¤±è´¥:", actionObj, e);
          }
        } else if (typeof actionObj === 'string') {

          const block = createAiResponseEditorBlock(actionObj);
          editorContainer.appendChild(block);
          console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¸­å‘ç°ä¸€ä¸ªæ— æ•ˆçš„ç‰‡æ®µ (æ¥è‡ªparseAiResponseçš„æ–‡æœ¬å›é€€):", actionObj);
        }
      });
    } else {

      const block = createAiResponseEditorBlock(lastRawAiResponse);
      editorContainer.appendChild(block);
    }


    editorModal.classList.add('visible');
  }


 
  function createAiResponseEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'ai-response-editor-block';


    const templates = {
      text: {
        type: 'text',
        content: 'åœ¨è¿™é‡Œè¾“å…¥æ–‡æœ¬...'
      },
      sticker: {
        type: 'sticker',
        url: 'https://...',
        meaning: 'è¡¨æƒ…å«ä¹‰'
      },
      image: {
        type: 'ai_image',
        description: 'åœ¨è¿™é‡Œè¾“å…¥å›¾ç‰‡æè¿°...'
      },
      voice: {
        type: 'voice_message',
        content: 'åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹...'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: 'ä¸€ç‚¹å¿ƒæ„'
      },
      offline: {
        type: 'offline_text',
        content: 'ã€Œåœ¨è¿™é‡Œè¾“å…¥å¯¹è¯å†…å®¹ã€\\n(åœ¨è¿™é‡Œè¾“å…¥åŠ¨ä½œæˆ–ç¯å¢ƒæå†™)'
      },
      quote: {
        type: 'quote_reply',
        target_timestamp: 1234567890,
        reply_content: 'åœ¨è¿™é‡Œè¾“å…¥å›å¤å†…å®¹'
      },
      
      nai: {
        type: 'naiimag',
        prompt: '1girl, best quality, masterpiece, ...'
      },
      narration: {
            type: 'narration',
            content: 'åœ¨è¿™é‡Œè¾“å…¥ç¯å¢ƒæˆ–å¿ƒç†æå†™...'
        }
      
  
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡åŠ¨ä½œ">Ã—</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.text)}'>æ–‡æœ¬</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.sticker)}'>è¡¨æƒ…</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>å›¾ç‰‡</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>è¯­éŸ³</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>è½¬è´¦</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>çº¿ä¸‹</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>å¼•ç”¨</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAIç”Ÿå›¾</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.narration)}' style="color: #888; border-color: #ccc;">æ—ç™½</button>
            
            </div>
    `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {
      block.remove();
    });


    block.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const templateStr = btn.dataset.template;
        const textarea = block.querySelector('textarea');
        if (templateStr && textarea) {
          try {
            const templateObj = JSON.parse(templateStr);

            textarea.value = JSON.stringify(templateObj, null, 2);
            textarea.focus();
          } catch (e) {
            console.error("è§£ææ ¼å¼æ¨¡æ¿å¤±è´¥:", e);
          }
        }
      });
    });

    return block;
  }


  async function saveEditedAiResponse() {

    const chatsToUpdate = new Map();
    let oldMessageTimestampProvider = null;

    if (lastPrivateMessagesSent.length > 0) {
      console.log(`å¯¼æ¼”å‰ªè¾‘å®¤ï¼šæ­£åœ¨æ’¤é”€ ${lastPrivateMessagesSent.length} æ¡ä¸Šä¸€è½®å‘é€çš„ç§ä¿¡...`);

      const oldPrivateMessages = [...lastPrivateMessagesSent];
      oldMessageTimestampProvider = oldPrivateMessages.values();

      const chatIdsToUndo = [...new Set(oldPrivateMessages.map(ref => ref.chatId))];

      for (const chatId of chatIdsToUndo) {
        const chat = await db.chats.get(chatId);
        if (chat) {
          chatsToUpdate.set(chatId, chat);
        }
      }

      for (const msgRef of oldPrivateMessages) {
        const chat = chatsToUpdate.get(msgRef.chatId);
        if (chat) {
          chat.history = chat.history.filter(msg => msg.timestamp !== msgRef.timestamp);
        }
      }

      if (chatsToUpdate.size > 0) {
        await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
      }

      lastPrivateMessagesSent = [];
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const editorContainer = document.getElementById('ai-response-editor-container');
    const editorTextareas = editorContainer.querySelectorAll('textarea');
    const editedRawBlocks = Array.from(editorTextareas).map(ta => ta.value.trim()).filter(Boolean);


   
    const originalAiMessages = chat.history.filter(msg => lastResponseTimestamps.includes(msg.timestamp));
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));


    if (editedRawBlocks.length === 0) {
      await db.chats.put(chat);
      renderChatInterface(state.activeChatId);
      renderChatList();
      document.getElementById('ai-response-editor-modal').classList.remove('visible');
      lastRawAiResponse = '';
      lastResponseTimestamps = [];
      return;
    }


    let newMessagesArray = [];
    for (const rawContent of editedRawBlocks) {
      try {

        const parsedObject = JSON.parse(rawContent);
        newMessagesArray.push(parsedObject);
      } catch (e) {
        console.warn("è·³è¿‡ä¸€ä¸ªæ— æ³•è§£æä¸ºJSONçš„ç¼–è¾‘å—:", rawContent);
      }
    }



    const originalNaiMsgs = originalAiMessages.filter(m => m.type === 'naiimag');
    let naiMsgIndex = 0;
 

    let newTimestamps = [];
    let messageTimestamp = Date.now();
    const privateChatsToSave = new Map();
    const groupChatsToSave = new Map();
    for (const msgData of newMessagesArray) {
      if (!msgData || typeof msgData !== 'object' || !msgData.type) {
        console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¿å­˜æ—¶ï¼Œå‘ç°æ— æ•ˆçš„æŒ‡ä»¤å¯¹è±¡ï¼Œå·²è·³è¿‡:", msgData);
        continue;
      }

      let aiMessage = null;
      const baseMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.originalName,
        timestamp: messageTimestamp++
      };

      switch (msgData.type) {
case 'narration':
        aiMessage = {
            ...baseMessage,
            type: 'narration',
            content: String(msgData.content),
            role: 'system' // å¼ºåˆ¶è®¾ä¸º system è§’è‰²ä»¥ç¡®ä¿æ ·å¼æ­£ç¡®
        };
        break;
    case 'buy_item': {
    const itemName = msgData.item_name;
    const price = parseFloat(msgData.price);
    const reason = msgData.reason || 'æƒ³ä¹°';

    if (!itemName || isNaN(price) || price <= 0) continue; // æ•°æ®æ— æ•ˆè·³è¿‡

    // 1. é‡æ–°è·å–é’±åŒ…æ•°æ®ï¼ˆç¡®ä¿å®æ—¶æ€§ï¼‰
    const currentWallet = await db.userWallet.get('main');
    const cardIndex = currentWallet?.kinshipCards?.findIndex(c => c.chatId === chat.id);

    if (cardIndex > -1) {
        const card = currentWallet.kinshipCards[cardIndex];
        const remaining = card.limit - (card.spent || 0);

        if (remaining >= price) {
            // 2. æ‰§è¡Œæ‰£æ¬¾
            currentWallet.kinshipCards[cardIndex].spent = (card.spent || 0) + price;
            await db.userWallet.put(currentWallet);

            // 3. è®°å½•è´¦å•
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: price,
                description: `äº²å±å¡æ¶ˆè´¹-${chat.name}-${itemName}`
            });

            // 4. ç”Ÿæˆç³»ç»Ÿé€šçŸ¥æ¶ˆæ¯ (AIå‘é€çš„)
            const successMsg = {
                role: 'assistant', // æˆ–è€…æ˜¯ 'system'ï¼Œçœ‹ä½ å–œå¥½
                senderName: chat.name, // åŠ ä¸Šè¿™ä¸ªç¡®ä¿ç¾¤èŠæ˜¾ç¤ºæ­£å¸¸
                type: 'text', // æˆ–è€…ç”¨ 'pat_message' æ ·å¼
                content: `[æ”¯ä»˜å®é€šçŸ¥] æˆ‘ä½¿ç”¨äº²å±å¡æ¶ˆè´¹äº† Â¥${price.toFixed(2)} è´­ä¹°äº†â€œ${itemName}â€ã€‚\nğŸ’­ ${reason}`,
                timestamp: messageTimestamp++
            };
            
            chat.history.push(successMsg);
            
            // å¦‚æœæ˜¯å½“å‰æŸ¥çœ‹çš„èŠå¤©ï¼Œç›´æ¥ä¸Šå±
            if (isViewingThisChat) {
                 appendMessage(successMsg, chat);
            } else {
                 // å¦‚æœåœ¨åå°ï¼Œå‘é€é€šçŸ¥
                 showNotification(chat.id, `${chat.name} ä½¿ç”¨äº²å±å¡æ¶ˆè´¹äº† Â¥${price}`);
            }
            
            // 5. (å¯é€‰) å°†è´­ä¹°è®°å½•å†™å…¥è§’è‰²çš„æ¨¡æ‹Ÿæ·˜å®å†å²ï¼Œå¢åŠ çœŸå®æ„Ÿ
            if (!chat.simulatedTaobaoHistory) chat.simulatedTaobaoHistory = { totalBalance: 0, purchases: [] };
            if (!chat.simulatedTaobaoHistory.purchases) chat.simulatedTaobaoHistory.purchases = [];
            
            chat.simulatedTaobaoHistory.purchases.unshift({
                itemName: itemName,
                price: price,
                status: 'å·²ç­¾æ”¶',
                reason: reason,
                image_prompt: `${itemName}, product photography` // ç®€å•ç”Ÿæˆä¸ªprompt
            });
            
            hasPerformedMajorAction = true; // æ ‡è®°ä¸ºå·²æ‰§è¡Œé‡è¦æ“ä½œï¼ˆç”¨äºåå°æ´»åŠ¨ï¼‰
        } else {
            console.log(`AI æƒ³è¦è´­ä¹° ${itemName} (Â¥${price}) ä½†äº²å±å¡ä½™é¢ä¸è¶³ (å‰© Â¥${remaining})`);
            // å¯é€‰ï¼šè®© AI å‘ä¸€æ¡æ¶ˆæ¯æŠ±æ€¨æ²¡é’±äº†
            const failMsg = {
                role: 'assistant',
                senderName: chat.name,
                content: `æœ¬æ¥æƒ³ä¹°â€œ${itemName}â€çš„ï¼Œä½†æ˜¯äº²å±å¡é¢åº¦å¥½åƒä¸å¤Ÿäº†... (Â¥${price})`,
                timestamp: messageTimestamp++
            };
            chat.history.push(failMsg);
            if (isViewingThisChat) appendMessage(failMsg, chat);
        }
    }
    continue;
}
        case 'send_private_message': {
          const senderOriginalName = msgData.name;
          const recipientOriginalName = msgData.recipient;
          const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

          if (recipientOriginalName === userOriginalName) {
            const privateChat = Object.values(state.chats).find(c => !c.isGroup && c.originalName === senderOriginalName);

            if (privateChat) {

              if (!privateChatsToSave.has(privateChat.id)) {

                const freshPrivateChat = chatsToUpdate.get(privateChat.id) || await db.chats.get(privateChat.id);

                privateChatsToSave.set(privateChat.id, freshPrivateChat);
              }

              const chatToUpdate = privateChatsToSave.get(privateChat.id);

              const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
              let newMessagesCount = 0;

              for (const contentString of messagesToSend) {
                if (!contentString || !contentString.trim()) continue;

                const oldMsgRef = (oldMessageTimestampProvider) ? oldMessageTimestampProvider.next().value : null;

                const timestampToUse = (oldMsgRef && oldMsgRef.chatId === privateChat.id) ?
                  oldMsgRef.timestamp :
                  messageTimestamp++;

                const privateMessage = {
                  role: 'assistant',
                  senderName: senderOriginalName,
                  content: contentString,
                  timestamp: timestampToUse
                };


                lastPrivateMessagesSent.push({
                  chatId: privateChat.id,
                  timestamp: privateMessage.timestamp
                });

                chatToUpdate.history.push(privateMessage);
                newMessagesCount++;
              }

              if (newMessagesCount > 0) {
                if (state.activeChatId !== privateChat.id) {
                  chatToUpdate.unreadCount = (chatToUpdate.unreadCount || 0) + newMessagesCount;
                  showNotification(privateChat.id, `${privateChat.name} å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
                }
              }

              aiMessage = null;

            } else {
              console.warn(`AI ${senderOriginalName} å°è¯•å‘é€ç§ä¿¡ï¼Œä½†æœªæ‰¾åˆ°å…¶å¯¹åº”çš„ç§èŠä¼šè¯ã€‚`);
              aiMessage = null;
            }
          } else {
            console.warn(`AI å°è¯•å‘é€ç§ä¿¡ç»™éç”¨æˆ·è§’è‰² (${recipientOriginalName})ï¼Œæ­¤åŠŸèƒ½æš‚ä¸æ”¯æŒã€‚`);
            aiMessage = null;
          }

          continue;
        }
        case 'send_group_message': {
          const senderOriginalName = msgData.name || chat.originalName;
          const targetGroupName = msgData.targetGroupName;
          const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [String(msgData.content)];

          if (!targetGroupName) {
            console.warn(`å¯¼æ¼”æ¨¡å¼ä¿å­˜(send_group_message): æœªæŒ‡å®š targetGroupNameï¼Œå·²è·³è¿‡ã€‚`);
            continue;
          }

          // æŸ¥æ‰¾ç›®æ ‡ç¾¤èŠï¼Œå¹¶ç¡®ä¿AIæ˜¯è¯¥ç¾¤çš„æˆå‘˜
          const targetGroupChat = Object.values(state.chats).find(c =>
            c.isGroup &&
            c.name === targetGroupName &&
            c.members.some(m => m.originalName === senderOriginalName)
          );

          if (targetGroupChat) {
            // å¦‚æœç¾¤èŠå°šæœªè¢«æš‚å­˜ï¼Œåˆ™ä»æ•°æ®åº“åŠ è½½æœ€æ–°æ•°æ®å¹¶å­˜å…¥ Map
            if (!groupChatsToSave.has(targetGroupChat.id)) {
              const freshGroupChat = await db.chats.get(targetGroupChat.id);
              groupChatsToSave.set(targetGroupChat.id, freshGroupChat);
            }

            const chatToUpdate = groupChatsToSave.get(targetGroupChat.id);
            let newMessagesCount = 0;

            for (const contentString of messagesToSend) {
              if (!contentString || !contentString.trim()) continue;

              const groupMessage = {
                role: 'assistant',
                senderName: senderOriginalName,
                content: contentString,
                timestamp: messageTimestamp++ // ä½¿ç”¨ç»Ÿä¸€çš„æ—¶é—´æˆ³é€’å¢
              };
              chatToUpdate.history.push(groupMessage);
              newMessagesCount++;
            }

            if (newMessagesCount > 0) {
              if (state.activeChatId !== targetGroupChat.id) {
                chatToUpdate.unreadCount = (chatToUpdate.unreadCount || 0) + newMessagesCount;
              }
            }
            aiMessage = null;
          } else {
            console.warn(`å¯¼æ¼”æ¨¡å¼ä¿å­˜(send_group_message): æœªæ‰¾åˆ°ç¾¤èŠ "${targetGroupName}" æˆ–è§’è‰² "${senderOriginalName}" ä¸åœ¨è¯¥ç¾¤ä¸­ã€‚`);
            aiMessage = null;
          }
          continue; 
        }
        case 'thought_chain': {
           continue; 
        }
        case 'text':
          aiMessage = {
            ...baseMessage,
            content: String(msgData.content || msgData.message)
          };
          break;
        case 'sticker': {
          let found = false;
          if (msgData.url && msgData.meaning) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.url,
              meaning: msgData.meaning
            };
            found = true;
          } else if (msgData.meaning) {
            const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
            if (sticker) {
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: sticker.url,
                meaning: sticker.name
              };
              found = true;
            } else {
              aiMessage = {
                ...baseMessage,
                type: 'text',
                content: `[è¡¨æƒ…: ${msgData.meaning}]`
              };
              found = true;
            }
          } else if (msgData.url) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.url
            };
            const stickerByURL = state.userStickers.find(s => s.url === msgData.url);
            aiMessage.meaning = stickerByURL ? stickerByURL.name : 'æœªçŸ¥è¡¨æƒ…';
            found = true;
          } else if (msgData.content && typeof msgData.content === 'string' && STICKER_REGEX.test(msgData.content)) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.content
            };
            const stickerByContentUrl = state.userStickers.find(s => s.url === msgData.content);
            aiMessage.meaning = stickerByContentUrl ? stickerByContentUrl.name : 'æœªçŸ¥è¡¨æƒ…';
            found = true;
          }
          if (!found) {
            console.error("å¯¼æ¼”æ¨¡å¼ä¿å­˜(Sticker): æŒ‡ä»¤æ— æ•ˆæˆ–ç¼ºå°‘å¿…è¦å­—æ®µ (meaning/url/content):", msgData);
            continue;
          }
          break;
        }
        case 'ai_image':
          aiMessage = {
            ...baseMessage,
            type: 'ai_image',
            content: msgData.description,
            image_prompt: msgData.image_prompt
          };
          break;

        case 'naiimag': {
          const newPrompt = msgData.prompt;
          let newImageUrl = null;
          let newFullPrompt = null;

         
          const originalMsg = originalNaiMsgs[naiMsgIndex];
          naiMsgIndex++; // Increment cursor for the next NAI block

          let promptChanged = false;

          if (originalMsg) {
           
            const originalPrompt = originalMsg.prompt;

            
            if (newPrompt && newPrompt !== originalPrompt) {
              console.log("NAI Prompt å·²æ”¹å˜ï¼Œå°†è§¦å‘é‡æ–°ç”Ÿæˆã€‚");
              promptChanged = true;
            } else {
          
              console.log("NAI Prompt æœªæ”¹å˜ï¼Œå°†ä¿ç•™åŸå§‹å›¾ç‰‡ã€‚");
              newImageUrl = originalMsg.imageUrl;
              newFullPrompt = originalMsg.fullPrompt;
            }
          } else {
           
            console.log("æœªæ‰¾åˆ°åŒ¹é…çš„åŸå§‹NAIå›¾ç‰‡(è¿™æ˜¯æ–°æ·»åŠ çš„å—)ï¼Œå°†è§¦å‘é‡æ–°ç”Ÿæˆã€‚");
            promptChanged = true;
          }

          if (promptChanged) {
          
            const alertMessage = originalMsg ? "æ£€æµ‹åˆ°NAIæç¤ºè¯å·²ä¿®æ”¹ï¼Œæ­£åœ¨é‡æ–°ç”Ÿæˆ..." : "æ£€æµ‹åˆ°æ–°çš„NAIç”Ÿå›¾æŒ‡ä»¤ï¼Œæ­£åœ¨ç”Ÿæˆ...";
            await showCustomAlert("è¯·ç¨å€™...", alertMessage);

            try {
              const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
              newImageUrl = generatedData.imageUrl;
              newFullPrompt = generatedData.fullPrompt;
              await showCustomAlert("æˆåŠŸ", "å›¾ç‰‡å·²ç”Ÿæˆï¼");
            } catch (error) {
              console.error("å¯¼æ¼”æ¨¡å¼ä¸‹é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
              await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå›¾ç‰‡: ${error.message}. \n\nå°†ä¿ç•™æ—§å›¾ç‰‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚`);

              if (originalMsg) {
                newImageUrl = originalMsg.imageUrl; // Fallback to old image
                newFullPrompt = originalMsg.fullPrompt;
              } else {
                console.error("æ–°NAIå›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œæ­¤æ¡æ¶ˆæ¯å·²è¢«è·³è¿‡ã€‚");
                continue; // Skip this message
              }
            }
          }

       
          aiMessage = {
            ...baseMessage,
            type: 'naiimag',
            imageUrl: newImageUrl,
            prompt: newPrompt,
            fullPrompt: newFullPrompt
          };
          break;
        }
     

        case 'voice_message':
          aiMessage = {
            ...baseMessage,
            type: 'voice_message',
            content: msgData.content
          };
          break;
        case 'transfer':
          aiMessage = {
            ...baseMessage,
            type: 'transfer',
            amount: msgData.amount,
            note: msgData.note,
            receiverName: msgData.receiver || 'æˆ‘'
          };
          break;
        case 'waimai_request':
          aiMessage = {
            ...baseMessage,
            type: 'waimai_request',
            productInfo: msgData.productInfo,
            amount: msgData.amount,
            status: 'pending',
            countdownEndTime: Date.now() + 15 * 60 * 1000,
          };
          break;
        case 'offline_text':
          aiMessage = {
            ...baseMessage,
            ...msgData
          };
          break;
        case 'gomoku_move': {
          const gameState = gomokuState[chat.id];
          if (gameState) {
            const lastAiMoveIndex = gameState.history.findLastIndex(move => move.player === 2);
            if (lastAiMoveIndex > -1) {
              const move_to_undo = gameState.history[lastAiMoveIndex];
              gameState.board[move_to_undo.y][move_to_undo.x] = 0;
              gameState.history.splice(lastAiMoveIndex, 1);
              console.log(`å¯¼æ¼”æ¨¡å¼æ‚”æ£‹ï¼šå·²æ’¤é”€AIåœ¨ (${move_to_undo.x}, ${move_to_undo.y}) çš„æ£‹æ­¥ã€‚`);
            }
          }
          const x = parseInt(msgData.x);
          const y = parseInt(msgData.y);
          if (!isNaN(x) && !isNaN(y)) {
            handleAiGomokuMove({
              x: x,
              y: y
            }, true);
          } else {
            console.warn("å¯¼æ¼”æ¨¡å¼ä¿å­˜äº†ä¸€ä¸ªæ— æ•ˆçš„äº”å­æ£‹ç§»åŠ¨æŒ‡ä»¤:", msgData);
          }
          continue;
        }
        case 'update_thoughts': {
          if (!chat.isGroup) {
            if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
            if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
            if (!Array.isArray(chat.thoughtsHistory)) chat.thoughtsHistory = [];
            chat.thoughtsHistory.push({
              heartfeltVoice: chat.heartfeltVoice,
              randomJottings: chat.randomJottings, 
              timestamp: Date.now()
            });
            if (chat.thoughtsHistory.length > 50) chat.thoughtsHistory.shift();
          }
          continue;
        }
        case 'quote_reply': { // è¿™æ˜¯åœ¨ saveEditedAiResponse() å‡½æ•°ä¸­çš„
                let originalMessage = null;
                let quoteContext = null;
        
               
                if (msgData.target_content) {
                  originalMessage = [...chat.history].reverse().find(m => 
                    !m.isHidden &&
                    (
                      m.content === msgData.target_content ||
                      (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                    )
                  );
                   if(!originalMessage) {
                     console.warn(`[å¯¼æ¼”æ¨¡å¼ä¿å­˜å¤±è´¥] å°è¯•å¼•ç”¨å†…å®¹ "${(msgData.target_content || '').substring(0, 20)}..."ï¼Œä½†åœ¨å†å²ä¸­æœªæ‰¾åˆ°ã€‚`);
                   }
                } 
                
               
                else if (msgData.target_timestamp) { 
                  originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                }
        
              
                if (originalMessage) {
                      
                     
                      let quotedSenderDisplayName;
                      
                      if (originalMessage.role === 'user') {
                      
                          quotedSenderDisplayName = chat.settings.myNickname || 'æˆ‘';
                      } else { 
                         
                          if (chat.isGroup) {
                            
                              quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                          } else {
                           
                              quotedSenderDisplayName = chat.name;
                          }
                      }

                      quoteContext = {
                          timestamp: originalMessage.timestamp,
                          senderName: quotedSenderDisplayName, // ä½¿ç”¨ä¿®å¤åçš„æ˜µç§°
                          content: String(originalMessage.content || '') // ç¡®ä¿å†…å®¹æ˜¯å­—ç¬¦ä¸²
                      };
                } else {
                 
                  console.warn(`å¯¼æ¼”æ¨¡å¼ä¿å­˜å¼•ç”¨å¤±è´¥: æ‰¾ä¸åˆ°ç›®æ ‡æ¶ˆæ¯ (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
                }
        
                
                aiMessage = {
                  ...baseMessage,
                  content: msgData.reply_content
                };
                
                if (quoteContext) {
                  aiMessage.quote = quoteContext; 
                }
               
                
                break;
              }
        default:
          console.warn("åœ¨å¯¼æ¼”æ¨¡å¼ä¿å­˜æ—¶ï¼Œé‡åˆ°äº†æœªçŸ¥çš„AIæŒ‡ä»¤ç±»å‹:", msgData.type, msgData);
          if (msgData.content) {
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content)
            };
          } else {
            continue;
          }
          break;
      }

      if (aiMessage) {
        chat.history.push(aiMessage);
        newTimestamps.push(aiMessage.timestamp);
      }
    }

     if (groupChatsToSave.size > 0) {
        await db.chats.bulkPut(Array.from(groupChatsToSave.values()));
      }
    await db.chats.put(chat);

    if (privateChatsToSave.size > 0) {
      await db.chats.bulkPut(Array.from(privateChatsToSave.values()));
    }

    renderChatInterface(state.activeChatId);
    renderChatList();
    document.getElementById('ai-response-editor-modal').classList.remove('visible');


    lastRawAiResponse = editedRawBlocks.join('\n\n');
    lastResponseTimestamps = newTimestamps;


    await showCustomAlert("å¯¼æ¼”æ¨¡å¼", "æ‚¨çš„ä¿®æ”¹å·²ä¿å­˜ï¼");
  }
 
  async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000;
    const messageTime = activeMessageTimestamp;
    const now = Date.now();


    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
      hideMessageActions();
      await showCustomAlert('æ“ä½œå¤±è´¥', 'è¯¥æ¶ˆæ¯å‘é€å·²è¶…è¿‡2åˆ†é’Ÿï¼Œæ— æ³•æ’¤å›ã€‚');
      return;
    }


    await recallMessage(messageTime, true);
    hideMessageActions();
  }

 
  async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    const recalledData = {
      originalType: messageToRecall.type || 'text',
      originalContent: messageToRecall.content,
      originalMeaning: messageToRecall.meaning,
      originalQuote: messageToRecall.quote
    };

    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? 'ä½ æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯' : 'å¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯';
    messageToRecall.recalledData = recalledData;
    delete messageToRecall.meaning;
    delete messageToRecall.quote;


    if (isUserRecall) {

      const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';


      let recalledContentText = '';
      if (recalledData.originalType === 'sticker') {
        recalledContentText = `[è¡¨æƒ…ï¼Œå«ä¹‰: ${recalledData.originalMeaning || 'æœªçŸ¥'}]`;
      } else if (recalledData.originalType === 'ai_image' || recalledData.originalType === 'user_photo') {
        recalledContentText = `[å›¾ç‰‡ï¼Œæè¿°: ${recalledData.originalContent}]`;
      } else {
        recalledContentText = `â€œ${String(recalledData.originalContent)}â€`;
      }


      const hiddenMessageForAI = {
        role: 'system',
        content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ’¤å›äº†ä¸€æ¡æ¶ˆæ¯ã€‚æ’¤å›å‰çš„å†…å®¹æ˜¯ï¼š${recalledContentText}ã€‚è¯·ä½ å¯¹æ­¤ä½œå‡ºå›åº”ï¼Œå¯ä»¥è¡¨ç°å‡ºå¥½å¥‡ã€å¼€ç©ç¬‘ï¼ˆæ¯”å¦‚'æˆ‘æˆªå›¾äº†ï¼'ï¼‰ã€æˆ–è€…æ ¹æ®ä½ çš„äººè®¾è¡¨ç¤ºç†è§£æˆ–ç–‘æƒ‘ã€‚]`,
        timestamp: Date.now(),
        isHidden: true
      };
      chat.history.push(hiddenMessageForAI);
    }


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);

    if (isUserRecall) {
      renderChatList();

      //triggerAiResponse();
    }
  }



  
  async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
  }

 
  async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
    }
    categories.forEach(cat => {

      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
                `;
      listEl.appendChild(item);
    });
  }

 
  async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
      return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
      alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
      return;
    }
    await db.worldBookCategories.add({
      name
    });
    input.value = '';
    await renderCategoryListInManager();
  }


  async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      'åˆ é™¤åˆ†ç±»åï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰ä¸–ç•Œä¹¦å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      }
    );
    if (confirmed) {
      await db.worldBookCategories.delete(categoryId);

      const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
      for (const book of booksToUpdate) {
        book.categoryId = null;
        await db.worldBooks.put(book);
        const bookInState = state.worldBooks.find(wb => wb.id === book.id);
        if (bookInState) bookInState.categoryId = null;
      }
      await renderCategoryListInManager();
    }
  }


  async function publishToAnnouncementBoard() {
    if (!activeMessageTimestamp) return;

    const timestampToPublish = activeMessageTimestamp;
    hideMessageActions();

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToPublish);
    if (!message) return;


    let contentPreview = String(message.content || '').substring(0, 50) + '...';
    if (message.type === 'ai_image') contentPreview = '[å›¾ç‰‡] ' + contentPreview;

    const confirmed = await showCustomConfirm(
      "å‘å¸ƒå…¬å‘Š",
      `ç¡®å®šè¦å°†ä»¥ä¸‹æ¶ˆæ¯å‘å¸ƒåˆ°å…¬å‘Šæ¿å—ï¼Ÿ\n\nâ€œ${contentPreview}â€`, {
        confirmText: "ç¡®å®šå‘å¸ƒ"
      }
    );

    if (confirmed) {
      const myNickname = chat.settings.myNickname || 'æˆ‘';

      if (!Array.isArray(chat.announcements)) {
        chat.announcements = [];
      }


      const newAnnouncement = {
        id: 'anno_' + Date.now(),
        messageTimestamp: timestampToPublish,
        publisher: myNickname,
        publishedAt: Date.now(),
        isPinned: false
      };

      chat.announcements.push(newAnnouncement);

      const systemMessage = {
        role: 'system',
        type: 'pat_message',
        content: `${myNickname} å‘å¸ƒäº†ä¸€æ¡æ–°å…¬å‘Š`,
        timestamp: Date.now()
      };
      chat.history.push(systemMessage);

      await db.chats.put(chat);
      appendMessage(systemMessage, chat);
      renderChatList();

      await showCustomAlert("æˆåŠŸ", "å…¬å‘Šå·²å‘å¸ƒï¼");
    }
  }

 
  async function showAnnouncementBoard() {
    const chat = state.chats[state.activeChatId];
    const announcements = chat.announcements || [];

    if (!chat || announcements.length === 0) {
      showCustomAlert("æç¤º", "å½“å‰ç¾¤èŠè¿˜æ²¡æœ‰å…¬å‘Šå“¦ã€‚");
      return;
    }

    const contentEl = document.getElementById('announcement-board-content');
    contentEl.innerHTML = '';


    announcements.sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));


    for (const anno of announcements) {
      const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);

      const wrapper = document.createElement('div');
      wrapper.className = 'announcement-item-wrapper';

      if (originalMessage) {

        const messageBubbleEl = await createMessageElement(originalMessage, chat);
        if (messageBubbleEl) {
          wrapper.appendChild(messageBubbleEl);
        }
      } else {
        wrapper.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">å…¬å‘Šçš„åŸæ¶ˆæ¯å·²è¢«åˆ é™¤ã€‚</p>';
      }

      if (anno.isPinned) {
        wrapper.innerHTML += `<div class="pinned-indicator">ğŸ“Œ</div>`;
      }
      wrapper.innerHTML += `<div class="announcement-item-actions" data-anno-id="${anno.id}">...</div>`;

      contentEl.appendChild(wrapper);
    }

    document.getElementById('announcement-board-modal').classList.add('visible');
  }


  let activeAnnouncementId = null;

 
  function showAnnouncementActions(annoId) {
    activeAnnouncementId = annoId;
    const chat = state.chats[state.activeChatId];
    const announcement = chat.announcements.find(a => a.id === annoId);
    if (!announcement) return;

    const pinButton = document.getElementById('announcement-action-pin');

    pinButton.textContent = announcement.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶å…¬å‘Š';

    document.getElementById('announcement-actions-modal').classList.add('visible');
  }

 
  async function handlePinAnnouncement() {
    if (!activeAnnouncementId) return;
    const chat = state.chats[state.activeChatId];
    const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
    if (announcement) {
      announcement.isPinned = !announcement.isPinned;
      await db.chats.put(chat);
      showAnnouncementBoard();
    }
    document.getElementById('announcement-actions-modal').classList.remove('visible');
  }

 
  async function handleDeleteAnnouncement() {
    if (!activeAnnouncementId) return;

    const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™æ¡å…¬å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", {
      confirmButtonClass: 'btn-danger'
    });

    if (confirmed) {
      const chat = state.chats[state.activeChatId];

      chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
      await db.chats.put(chat);
      showAnnouncementBoard();
    }
    document.getElementById('announcement-actions-modal').classList.remove('visible');
  }




  let editingFrameForMember = false;
  let currentFrameSelection = {
    ai: null,
    my: null
  };

  function openFrameSelectorModal(type = 'chat') {
    const frameModal = document.getElementById('avatar-frame-modal');
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    editingFrameForMember = (type === 'member');

    if (editingFrameForMember) {
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;
      currentFrameSelection.my = member.avatarFrame || '';
      populateFrameGrids(true, member.avatar, member.avatarFrame);
    } else {
      currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
      currentFrameSelection.my = chat.settings.myAvatarFrame || '';
      populateFrameGrids(false);
    }
    frameModal.classList.add('visible');
  }

  function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
      avatarFrames.forEach(frame => {
        const item = createFrameItem(frame, 'my', memberAvatar);
        if (frame.url === memberFrame) {
          item.classList.add('selected');
        }
        aiFrameGrid.appendChild(item);
      });
    } else {
      const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
      const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      avatarFrames.forEach(frame => {
        const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
        if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
        aiFrameGrid.appendChild(aiItem);
        const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
        if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
        myFrameGrid.appendChild(myItem);
      });
    }
  }

  function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;
    item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
    item.addEventListener('click', () => {
      currentFrameSelection[type] = frame.url;
      const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
      grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
      item.classList.add('selected');
    });
    return item;
  }

  async function saveSelectedFrames() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (editingFrameForMember) {
      const member = chat.members.find(m => m.id === editingMemberId);
      if (member) {
        member.avatarFrame = currentFrameSelection.my;
      }
    } else {
      chat.settings.aiAvatarFrame = currentFrameSelection.ai;
      chat.settings.myAvatarFrame = currentFrameSelection.my;
    }

    await db.chats.put(chat);



    if (!editingFrameForMember && !chat.isGroup) {
      const characterId = chat.id;


      for (const groupChat of Object.values(state.chats)) {
        if (groupChat.isGroup && groupChat.members) {

          const memberToUpdate = groupChat.members.find(m => m.id === characterId);


          if (memberToUpdate) {
            memberToUpdate.avatarFrame = chat.settings.aiAvatarFrame;

            await db.chats.put(groupChat);
            console.log(`å·²åŒæ­¥è§’è‰² ${characterId} çš„å¤´åƒæ¡†åˆ°ç¾¤èŠ "${groupChat.name}"`);
          }
        }
      }
    }


    document.getElementById('avatar-frame-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    alert('å¤´åƒæ¡†å·²ä¿å­˜å¹¶åŒæ­¥ï¼');
    editingFrameForMember = false;
  }





  function toggleFrameManagementMode() {
    isFrameManagementMode = !isFrameManagementMode;
    const manageBtn = document.getElementById('manage-frames-btn');
    const actionBar = document.getElementById('frame-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-frames-checkbox');


    document.querySelectorAll('.frame-grid').forEach(grid => {
      grid.classList.toggle('management-mode', isFrameManagementMode);
    });

    if (isFrameManagementMode) {
      manageBtn.textContent = 'å®Œæˆ';
      actionBar.style.display = 'flex';
      selectedFrames.clear();
      selectAllCheckbox.checked = false;
      updateDeleteFrameButton();
    } else {
      manageBtn.textContent = 'ç®¡ç†';
      actionBar.style.display = 'none';

      document.querySelectorAll('.frame-item.selected').forEach(item => {
        item.classList.remove('selected');
      });
    }
  }


  function updateDeleteFrameButton() {
    const btn = document.getElementById('delete-selected-frames-btn');
    btn.textContent = `åˆ é™¤ (${selectedFrames.size})`;
  }

  
  function handleSelectAllFrames() {
    const isChecked = document.getElementById('select-all-frames-checkbox').checked;
    const visibleGrid = document.querySelector('.frame-content[style*="display: block"] .frame-grid');
    if (!visibleGrid) return;


    visibleGrid.querySelectorAll('.frame-item:has(.delete-btn)').forEach(item => {
      const frameId = parseInt(item.querySelector('.delete-btn').dataset.id);
      if (isNaN(frameId)) return;

      item.classList.toggle('selected', isChecked);
      if (isChecked) {
        selectedFrames.add(frameId);
      } else {
        selectedFrames.delete(frameId);
      }
    });
    updateDeleteFrameButton();
  }

  
  async function executeBatchDeleteFrames() {
    if (selectedFrames.size === 0) return;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é€‰ä¸­çš„ ${selectedFrames.size} ä¸ªè‡ªå®šä¹‰å¤´åƒæ¡†å—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      const idsToDelete = [...selectedFrames];
      await db.customAvatarFrames.bulkDelete(idsToDelete);


      toggleFrameManagementMode();
      populateFrameGrids(editingFrameForMember);

      await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„å¤´åƒæ¡†å·²æˆåŠŸåˆ é™¤ã€‚');
    }
  }




  function applyGlobalCss(cssString) {
    const styleTag = document.getElementById('global-custom-style');
    if (styleTag) {

      styleTag.innerHTML = cssString || '';
    }
  }



  async function addMusicActionSystemMessage(actionText) {

    if (!musicState.isActive || !musicState.activeChatId) return;
    const chat = state.chats[musicState.activeChatId];
    if (!chat) return;


    const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
    const fullMessage = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${myNickname}) ${actionText}]`;


    const systemMessage = {
      role: 'system',
      content: fullMessage,
      timestamp: Date.now(),
      isHidden: true
    };


    chat.history.push(systemMessage);
    await db.chats.put(chat);
  }




  async function handleLongScreenshot() {
    if (selectedMessages.size === 0) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const screenshotBtn = document.getElementById('selection-screenshot-btn');
    const originalBtnText = screenshotBtn.textContent;
    screenshotBtn.textContent = 'ç”Ÿæˆä¸­...';
    screenshotBtn.disabled = true;


    const screenshotContainer = document.createElement('div');
    const phoneScreen = document.getElementById('phone-screen');
    screenshotContainer.style.width = phoneScreen.offsetWidth + 'px';
    screenshotContainer.style.position = 'absolute';
    screenshotContainer.style.top = '-9999px';
    screenshotContainer.style.left = '-9999px';
    screenshotContainer.style.display = 'flex';
    screenshotContainer.style.flexDirection = 'column';
    screenshotContainer.style.height = 'auto';

    const chatScreen = document.getElementById('chat-interface-screen');
    screenshotContainer.style.backgroundImage = chatScreen.style.backgroundImage;
    screenshotContainer.style.backgroundColor = chatScreen.style.backgroundColor || (document.getElementById('phone-screen').classList.contains('dark-mode') ? '#000000' : '#f0f2f5');

    const tempStyle = document.createElement('style');
    tempStyle.innerHTML = `
                .message-bubble.selected::after { display: none !important; }
                .cloned-header .default-controls { display: flex !important; justify-content: space-between; align-items: center; width: 100%; }
                .cloned-header .selection-controls { display: none !important; }
            `;
    document.head.appendChild(tempStyle);

    try {

      const header = chatScreen.querySelector('.header').cloneNode(true);
      header.classList.add('cloned-header');



      const messagesContainer = document.createElement('div');
      const originalMessagesContainer = document.getElementById('chat-messages');


      messagesContainer.style.display = 'flex';
      messagesContainer.style.flexDirection = 'column';
      messagesContainer.style.gap = '20px';
      messagesContainer.style.padding = '10px 15px 20px 15px';
      messagesContainer.style.width = '100%';
      messagesContainer.style.boxSizing = 'border-box';


      messagesContainer.dataset.theme = originalMessagesContainer.dataset.theme;
      messagesContainer.style.setProperty('--chat-font-size', originalMessagesContainer.style.getPropertyValue('--chat-font-size'));


      const inputArea = chatScreen.querySelector('#chat-input-area').cloneNode(true);

      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      sortedTimestamps.forEach(timestamp => {

        const originalBubble = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
        if (originalBubble) {
          const originalWrapper = originalBubble.closest('.message-wrapper');
          if (originalWrapper) {
            messagesContainer.appendChild(originalWrapper.cloneNode(true));
          }
        }
      });

      screenshotContainer.appendChild(header);
      screenshotContainer.appendChild(messagesContainer);
      screenshotContainer.appendChild(inputArea);
      document.body.appendChild(screenshotContainer);


      const images = Array.from(screenshotContainer.getElementsByTagName('img'));
      const imageLoadPromises = images.map(img => new Promise((resolve, reject) => {
        if (img.src.startsWith('data:')) {
          resolve();
          return;
        }
        const newImg = new Image();
        newImg.crossOrigin = 'anonymous';
        newImg.onload = resolve;
        newImg.onerror = resolve;
        newImg.src = img.src;
      }));

      await Promise.all(imageLoadPromises);


      const canvas = await html2canvas(screenshotContainer, {
        allowTaint: true,
        useCORS: true,
        backgroundColor: null,
        scale: window.devicePixelRatio || 2,
      });


      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `EPhone-é•¿æˆªå›¾-${chat.name}-${Date.now()}.png`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 'image/png');

    } catch (error) {
      console.error('é•¿æˆªå›¾ç”Ÿæˆå¤±è´¥:', error);
      await showCustomAlert('ç”Ÿæˆå¤±è´¥', 'ç”Ÿæˆæˆªå›¾æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦æƒ…ã€‚');
    } finally {

      document.body.removeChild(screenshotContainer);
      document.head.removeChild(tempStyle);
      screenshotBtn.textContent = originalBtnText;
      screenshotBtn.disabled = false;
      exitSelectionMode();
    }
  }

  function parseMarkdown(text) {
    if (!text || typeof text !== 'string') return '';


    text = text.replace(/!h\{(.*?)\}/g, '<span class="diary-highlight">$1</span>');
    text = text.replace(/!u\{(.*?)\}/g, '<span class="diary-underline">$1</span>');
    text = text.replace(/!e\{(.*?)\}/g, '<span class="diary-emphasis">$1</span>');
    text = text.replace(/!w\{(.*?)\}/g, '<span class="diary-handwritten">$1</span>');
    text = text.replace(/!m\{(.*?)\}/g, '<span class="diary-messy">$1</span>');



    text = text.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');



    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/\~\~(.*?)\~\~/g, '<s>$1</s>');
    text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    return text;
  }



  async function migrateOldRedPacketData() {
    console.log("å¼€å§‹æ£€æŸ¥å¹¶è¿ç§»æ—§çš„çº¢åŒ…æ•°æ®...");
    let migrationCount = 0;

    const allChats = Object.values(state.chats);

    for (const chat of allChats) {
      let needsDbUpdate = false;
      for (const msg of chat.history) {

        if (msg.type === 'red_packet' && msg.packetType === 'direct' && msg.role === 'assistant' && msg.hasOwnProperty('receiver') && !msg.hasOwnProperty('receiverName')) {

          msg.receiverName = msg.receiver;
          delete msg.receiver;

          needsDbUpdate = true;
          migrationCount++;
        }
      }

      if (needsDbUpdate) {
        console.log(`åœ¨èŠå¤© "${chat.name}" ä¸­å‘ç°å¹¶ä¿®å¤äº†æ—§çº¢åŒ…æ•°æ®ã€‚`);
        await db.chats.put(chat);
      }
    }

    if (migrationCount > 0) {
      console.log(`æ•°æ®è¿ç§»å®Œæˆï¼æ€»å…±ä¿®å¤äº† ${migrationCount} æ¡çº¢åŒ…è®°å½•ã€‚`);
      alert(`æ£€æµ‹åˆ°å¹¶æˆåŠŸä¿®å¤äº† ${migrationCount} æ¡æ—§çš„çº¢åŒ…æ¶ˆæ¯ï¼é¡µé¢å°†è‡ªåŠ¨åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚`);
      location.reload();
    } else {
      console.log("æœªå‘ç°éœ€è¦è¿ç§»çš„æ—§çº¢åŒ…æ•°æ®ã€‚");
    }
  }

  // USERçŠ¶æ€ä¿®æ”¹å¼¹çª— - ç›´æ¥è¾“å…¥æ¡†
  async function showUserStatusModal(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // åˆå§‹åŒ–USERçŠ¶æ€ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    if (!chat.settings.userStatus) {
      chat.settings.userStatus = {
        text: 'åœ¨çº¿',
        lastUpdate: Date.now(),
        isBusy: false
      };
    }

    // ç›´æ¥å¼¹å‡ºè¾“å…¥æ¡†
    const customStatus = await showCustomPrompt(
      'ä¿®æ”¹åœ¨çº¿çŠ¶æ€',
      'è¯·è¾“å…¥ä½ çš„çŠ¶æ€...',
      chat.settings.userStatus.text
    );

    if (customStatus !== null && customStatus.trim()) {
      await updateUserStatus(chatId, customStatus.trim(), false);
    }
  }

  async function updateUserStatus(chatId, statusText, isBusy) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const oldStatus = chat.settings.userStatus.text;
    
    // æ›´æ–°USERçŠ¶æ€
    chat.settings.userStatus = {
      text: statusText,
      isBusy: isBusy,
      lastUpdate: Date.now()
    };

    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.chats.put(chat);
    state.chats[chatId] = chat;

    // æ·»åŠ ç³»ç»Ÿæç¤ºæ¶ˆæ¯
    const myNickname = chat.settings.myNickname || 'æˆ‘';
    const statusUpdateMessage = {
      role: 'system',
      type: 'pat_message',
      content: `[${myNickname}çš„çŠ¶æ€å·²æ›´æ–°ä¸º: ${statusText}]`,
      timestamp: Date.now()
    };

    chat.history.push(statusUpdateMessage);
    await db.chats.put(chat);

    // å¦‚æœå½“å‰åœ¨èŠå¤©ç•Œé¢ï¼Œåˆ·æ–°æ¶ˆæ¯æ˜¾ç¤º
    if (state.activeChatId === chatId) {
      await appendMessage(statusUpdateMessage, chat);
      scrollToBottom();
    }

    console.log(`USERçŠ¶æ€å·²æ›´æ–°: ${oldStatus} -> ${statusText}`);
  }

 
  async function openThoughtEditor() {
    
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

   
    const currentHeartfeltVoice = chat.heartfeltVoice || '';
    const newHeartfeltVoice = await showCustomPrompt(
      `ç¼–è¾‘â€œ${chat.name}â€çš„å¿ƒå£°`,
      'è¯·è¾“å…¥æ–°çš„å¿ƒå£°å†…å®¹...',
      currentHeartfeltVoice,
      'textarea'
    );

 
    if (newHeartfeltVoice === null) {
      await showCustomAlert("æ“ä½œå–æ¶ˆ", "å¿ƒå£°ç¼–è¾‘å·²å–æ¶ˆã€‚");
      return;
    }

   
    const currentRandomJottings = chat.randomJottings || '';
    const newRandomJottings = await showCustomPrompt(
      `ç¼–è¾‘â€œ${chat.name}â€çš„æ•£è®°`,
      'è¯·è¾“å…¥æ–°çš„æ•£è®°å†…å®¹...',
      currentRandomJottings,
      'textarea'
    );

 
    if (newRandomJottings === null) {
      await showCustomAlert("æ“ä½œå–æ¶ˆ", "æ•£è®°ç¼–è¾‘å·²å–æ¶ˆï¼Œå¿ƒå£°çš„ä¿®æ”¹ä¹Ÿæœªä¿å­˜ã€‚");
      return;
    }

   
    chat.heartfeltVoice = newHeartfeltVoice.trim();
    chat.randomJottings = newRandomJottings.trim();

 
    if (!Array.isArray(chat.thoughtsHistory)) {
      chat.thoughtsHistory = [];
    }

    if (chat.thoughtsHistory.length > 0) {
    
      const lastThought = chat.thoughtsHistory[chat.thoughtsHistory.length - 1];
    
      lastThought.heartfeltVoice = chat.heartfeltVoice;
      lastThought.randomJottings = chat.randomJottings;
      lastThought.timestamp = Date.now();
    } else {
     
      chat.thoughtsHistory.push({
        heartfeltVoice: chat.heartfeltVoice,
        randomJottings: chat.randomJottings,
        timestamp: Date.now()
      });
    }

 
    await db.chats.put(chat);

   
    await showCharacterProfileModal(chat.id);

    await showCustomAlert('æˆåŠŸ', 'å¿ƒå£°å’Œæ•£è®°å·²æ›´æ–°ï¼');
  }

  async function showCharacterProfileModal(chatId) {
    const chat = state.chats[chatId];
    if (!chat || chat.isGroup) return;





    const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
    const randomJottingsEl = document.getElementById('profile-random-jottings');

    // æ£€æŸ¥å¿ƒå£°åŠŸèƒ½æ˜¯å¦å¼€å¯
    const enableThoughts = chat.settings.enableThoughts !== null 
      ? chat.settings.enableThoughts 
      : state.globalSettings.enableThoughts;

    if (!enableThoughts) {
      // åŠŸèƒ½å…³é—­æ—¶æ˜¾ç¤ºæç¤º
      heartfeltVoiceEl.innerHTML = '<span style="color: #999;">å¿ƒå£°åŠŸèƒ½å·²å…³é—­</span>';
      randomJottingsEl.innerHTML = '<span style="color: #999;">å¿ƒå£°åŠŸèƒ½å·²å…³é—­</span>';
    } else {
      // åŠŸèƒ½å¼€å¯æ—¶æ­£å¸¸æ˜¾ç¤º
      heartfeltVoiceEl.innerHTML = await applyRenderingRules(chat.heartfeltVoice || '...', chatId);
      randomJottingsEl.innerHTML = await applyRenderingRules(chat.randomJottings || '...', chatId);
    }

    const modal = document.getElementById('character-profile-modal');





    modal.classList.add('visible');
  }

  async function showThoughtsHistory() { // <-- 1. æ·»åŠ  async
    document.getElementById('profile-main-content').style.display = 'none';
    document.getElementById('profile-thoughts-history-view').style.display = 'flex';
    await renderThoughtsHistory(); // <-- 2. æ·»åŠ  await
  }

 
  function hideThoughtsHistory() {
    document.getElementById('profile-thoughts-history-view').style.display = 'none';


    document.getElementById('profile-main-content').style.display = 'flex';
  }



  async function renderThoughtsHistory() { // <-- 1. æ·»åŠ  async
    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (!chat || !chat.thoughtsHistory || chat.thoughtsHistory.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; padding: 30px 0;">è¿™é‡Œè¿˜æ²¡æœ‰å†å²è®°å½•å“¦ã€‚</p>';
      return;
    }

    const history = [...chat.thoughtsHistory].reverse();
    const initialItems = history.slice(0, THOUGHTS_RENDER_WINDOW);

    const cardPromises = initialItems.map(thought => createThoughtCard(thought));
    const cards = await Promise.all(cardPromises);
    cards.forEach(card => listEl.appendChild(card));


    thoughtsHistoryRenderCount = initialItems.length;

    if (history.length > thoughtsHistoryRenderCount) {
      appendLoadMoreThoughtsButton(listEl);
    }
  }



  async function loadMoreThoughts() {
    if (isLoadingMoreThoughts) return;
    isLoadingMoreThoughts = true;

    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    if (!chat) {
      isLoadingMoreThoughts = false;
      return;
    }

    showLoader(listEl, 'bottom');
    await new Promise(resolve => setTimeout(resolve, 500));

    const history = [...chat.thoughtsHistory].reverse();
    const totalItems = history.length;

    const nextSliceStart = thoughtsHistoryRenderCount;
    const nextSliceEnd = thoughtsHistoryRenderCount + THOUGHTS_RENDER_WINDOW;
    const itemsToAppend = history.slice(nextSliceStart, nextSliceEnd);


    hideLoader(listEl);

  
    const cardPromises = itemsToAppend.map(thought => createThoughtCard(thought));
    const cards = await Promise.all(cardPromises);
    cards.forEach(card => listEl.appendChild(card));
 
    thoughtsHistoryRenderCount += itemsToAppend.length;

    isLoadingMoreThoughts = false;
  }



  async function createThoughtCard(thought) { // <-- 1. æ·»åŠ  async
    const card = document.createElement('div');
    card.className = 'thought-card';
    const date = new Date(thought.timestamp);
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

   
    const chatId = state.activeChatId;
    const renderedVoice = await applyRenderingRules(thought.heartfeltVoice || '...', chatId);
    const renderedJottings = await applyRenderingRules(thought.randomJottings || '...', chatId);

    
    card.innerHTML = `
        <button class="thought-delete-btn" data-timestamp="${thought.timestamp}" title="åˆ é™¤æ­¤æ¡è®°å½•">Ã—</button>
        <div class="thought-header">${dateString}</div>
        <div class="thought-content">
            <div class="voice">
                <div class="label">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    å¿ƒå£°
                </div>
                <div class="text">${renderedVoice}</div>
            </div>
            <div class="jottings">
                <div class="label">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                    æ•£è®°
                </div>
                <div class="text">${renderedJottings}</div>
            </div>
        </div>
    `;
    return card;
  }





  // å·¥å…·å‡½æ•°ï¼šHTMLè½¬ä¹‰
  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // æ‰¹é‡å¯¼å…¥ç›¸å…³çš„å…¨å±€å˜é‡
  let pendingImportCards = [];

  async function handleCardImport(event) {
    const files = Array.from(event.target.files);
    if (!files || files.length === 0) return;

    try {
      // å¦‚æœåªæœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œä½¿ç”¨æ—§çš„å•æ–‡ä»¶å¯¼å…¥æµç¨‹
      if (files.length === 1) {
        await importSingleCard(files[0]);
        event.target.value = null;
        return;
      }

      // å¤šæ–‡ä»¶ï¼šæ˜¾ç¤ºæ‰¹é‡å¯¼å…¥é¢„è§ˆ
      await showBatchImportPreview(files);

    } catch (error) {
      console.error("è§’è‰²å¡å¯¼å…¥å¤±è´¥:", error);
      await showCustomAlert("å¯¼å…¥å¤±è´¥", `æ— æ³•è§£æè§’è‰²å¡æ–‡ä»¶ã€‚\né”™è¯¯: ${error.message}`);
    } finally {
      event.target.value = null;
    }
  }

  // å•ä¸ªæ–‡ä»¶å¯¼å…¥ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
  async function importSingleCard(file) {
    try {
      let cardData;
      let avatarBase64 = null;

      if (file.name.endsWith('.json')) {
        const text = await file.text();
        cardData = JSON.parse(text);
      } else if (file.name.endsWith('.png')) {
        const arrayBuffer = await file.arrayBuffer();
        cardData = await parsePngForTavernData(arrayBuffer);

        avatarBase64 = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = async (readerEvent) => {
            let base64Result = readerEvent.target.result;

            if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
              try {
                await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä¸Šä¼ è§’è‰²å¡å°é¢åˆ° ImgBB...");
                const imageUrl = await uploadImageToImgBB(base64Result);
                resolve(imageUrl);
              } catch (uploadError) {
                console.error(uploadError);
                await showCustomAlert("ImgBB ä¸Šä¼ å¤±è´¥", `å°é¢ä¸Šä¼ å¤±è´¥: ${uploadError.message}\n\nå°†ç»§ç»­ä½¿ç”¨æœ¬åœ° Base64 æ ¼å¼ä¿å­˜ã€‚`);
                resolve(base64Result);
              }
            } else {
              resolve(base64Result);
            }
          };
          reader.readAsDataURL(file);
        });
      } else {
        throw new Error("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ã€‚è¯·é€‰æ‹© .json æˆ– .png æ–‡ä»¶ã€‚");
      }

      await createChatFromCardData(cardData, avatarBase64);

    } catch (error) {
      throw error;
    }
  }

  // æ˜¾ç¤ºæ‰¹é‡å¯¼å…¥é¢„è§ˆç•Œé¢
  async function showBatchImportPreview(files) {
    const modal = document.getElementById('batch-import-preview-modal');
    const listContainer = document.getElementById('batch-import-preview-list');
    
    if (!modal || !listContainer) {
      console.error('æ‰¹é‡å¯¼å…¥é¢„è§ˆæ¨¡æ€æ¡†æœªæ‰¾åˆ°');
      return;
    }

    // æ˜¾ç¤ºåŠ è½½æç¤º
    listContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 50px 20px;">æ­£åœ¨è§£æè§’è‰²å¡...</p>';
    modal.style.display = 'flex';

    // è§£ææ‰€æœ‰æ–‡ä»¶
    pendingImportCards = [];
    const parsePromises = files.map(async (file, index) => {
      try {
        let cardData;
        let avatarBase64 = null;
        let fileType = file.name.endsWith('.png') ? 'png' : 'json';

        if (fileType === 'json') {
          const text = await file.text();
          cardData = JSON.parse(text);
        } else if (fileType === 'png') {
          const arrayBuffer = await file.arrayBuffer();
          cardData = await parsePngForTavernData(arrayBuffer);

          // è¯»å–PNGä½œä¸ºbase64
          avatarBase64 = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.readAsDataURL(file);
          });
        }

        return {
          id: `import_${Date.now()}_${index}`,
          fileName: file.name,
          fileType: fileType,
          cardData: cardData,
          avatarBase64: avatarBase64,
          selected: true,
          parseSuccess: true
        };
      } catch (error) {
        console.error(`è§£æå¤±è´¥: ${file.name}`, error);
        return {
          id: `import_${Date.now()}_${index}`,
          fileName: file.name,
          fileType: file.name.endsWith('.png') ? 'png' : 'json',
          error: error.message,
          selected: false,
          parseSuccess: false
        };
      }
    });

    pendingImportCards = await Promise.all(parsePromises);
    renderBatchImportPreview();
  }

  // æ¸²æŸ“æ‰¹é‡å¯¼å…¥é¢„è§ˆåˆ—è¡¨
  function renderBatchImportPreview() {
    const listContainer = document.getElementById('batch-import-preview-list');
    if (!listContainer) return;

    if (pendingImportCards.length === 0) {
      listContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 50px 20px;">æ²¡æœ‰å¯å¯¼å…¥çš„è§’è‰²å¡</p>';
      return;
    }

    listContainer.innerHTML = pendingImportCards.map(card => {
      if (!card.parseSuccess) {
        return `
          <div class="list-item" style="padding: 15px; border-bottom: 1px solid var(--border-color); opacity: 0.5;">
            <div style="display: flex; align-items: center; gap: 15px;">
              <input type="checkbox" disabled style="width: 20px; height: 20px;">
              <div style="width: 60px; height: 60px; background: #f5f5f5; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #999;">
                âŒ
              </div>
              <div style="flex: 1;">
                <div style="font-weight: 600; color: #f44;">${escapeHtml(card.fileName)}</div>
                <div style="font-size: 13px; color: #f44; margin-top: 5px;">è§£æå¤±è´¥: ${escapeHtml(card.error)}</div>
              </div>
            </div>
          </div>
        `;
      }

      const name = card.cardData.name || card.cardData.data?.name || 'æœªå‘½åè§’è‰²';
      const description = card.cardData.description || card.cardData.data?.description || '';
      const previewDesc = description.substring(0, 100) + (description.length > 100 ? '...' : '');
      const avatarSrc = card.avatarBase64 || 'https://i.postimg.cc/y8xWzCqj/anime-boy.jpg';

      return `
        <div class="list-item" style="padding: 15px; border-bottom: 1px solid var(--border-color);">
          <div style="display: flex; align-items: center; gap: 15px;">
            <input type="checkbox" 
                   class="batch-import-card-checkbox" 
                   data-card-id="${card.id}" 
                   ${card.selected ? 'checked' : ''}
                   style="width: 20px; height: 20px;">
            <img src="${avatarSrc}" 
                 style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover;"
                 onerror="this.src='https://i.postimg.cc/y8xWzCqj/anime-boy.jpg'">
            <div style="flex: 1;">
              <div style="font-weight: 600; margin-bottom: 5px;">${escapeHtml(name)}</div>
              <div style="font-size: 13px; color: #666; margin-bottom: 5px;">${escapeHtml(previewDesc)}</div>
              <div style="font-size: 12px; color: #999;">
                <span style="background: #e3f2fd; padding: 2px 8px; border-radius: 4px; margin-right: 5px;">${card.fileType.toUpperCase()}</span>
                ${escapeHtml(card.fileName)}
              </div>
            </div>
          </div>
        </div>
      `;
    }).join('');

    // ç»‘å®šå¤é€‰æ¡†äº‹ä»¶
    document.querySelectorAll('.batch-import-card-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        const cardId = e.target.dataset.cardId;
        const card = pendingImportCards.find(c => c.id === cardId);
        if (card) {
          card.selected = e.target.checked;
        }
        updateSelectAllCheckbox();
      });
    });

    updateSelectAllCheckbox();
  }

  // æ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
  function updateSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('select-all-import-cards');
    if (!selectAllCheckbox) return;

    const successCards = pendingImportCards.filter(c => c.parseSuccess);
    const selectedCount = successCards.filter(c => c.selected).length;

    selectAllCheckbox.checked = selectedCount === successCards.length && successCards.length > 0;
    selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < successCards.length;
  }

  // ç¡®è®¤æ‰¹é‡å¯¼å…¥
  async function confirmBatchImport() {
    const selectedCards = pendingImportCards.filter(c => c.selected && c.parseSuccess);
    
    if (selectedCards.length === 0) {
      await showCustomAlert("æç¤º", "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²å¡è¿›è¡Œå¯¼å…¥");
      return;
    }

    // å…³é—­é¢„è§ˆæ¨¡æ€æ¡†
    const modal = document.getElementById('batch-import-preview-modal');
    if (modal) modal.style.display = 'none';

    // æ˜¾ç¤ºè¿›åº¦æç¤º
    const progressDiv = document.createElement('div');
    progressDiv.id = 'batch-import-progress';
    progressDiv.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 10001;
      text-align: center;
      min-width: 300px;
    `;
    document.body.appendChild(progressDiv);

    let successCount = 0;
    let failCount = 0;
    const failedCards = [];

    for (let i = 0; i < selectedCards.length; i++) {
      const card = selectedCards[i];
      
      // æ›´æ–°è¿›åº¦æ˜¾ç¤º
      progressDiv.innerHTML = `
        <div style="font-size: 18px; font-weight: 600; margin-bottom: 15px;">æ­£åœ¨å¯¼å…¥è§’è‰²å¡</div>
        <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
          ${i + 1} / ${selectedCards.length}
        </div>
        <div style="font-size: 14px; color: #999;">
          ${escapeHtml(card.fileName)}
        </div>
        <div style="margin-top: 15px; width: 100%; height: 4px; background: #f0f0f0; border-radius: 2px; overflow: hidden;">
          <div style="width: ${((i + 1) / selectedCards.length * 100)}%; height: 100%; background: #4CAF50; transition: width 0.3s;"></div>
        </div>
      `;

      try {
        // å¤„ç†ImgBBä¸Šä¼ ï¼ˆä»…é’ˆå¯¹PNGï¼‰
        let finalAvatar = card.avatarBase64;
        if (card.fileType === 'png' && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
          try {
            finalAvatar = await uploadImageToImgBB(card.avatarBase64);
          } catch (uploadError) {
            console.error('ImgBBä¸Šä¼ å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°Base64:', uploadError);
          }
        }

        await createChatFromCardData(card.cardData, finalAvatar);
        successCount++;
      } catch (error) {
        console.error(`å¯¼å…¥å¤±è´¥: ${card.fileName}`, error);
        failCount++;
        failedCards.push({
          name: card.fileName,
          error: error.message
        });
      }

      // æ·»åŠ å°å»¶è¿Ÿï¼Œè®©ç”¨æˆ·çœ‹åˆ°è¿›åº¦
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // ç§»é™¤è¿›åº¦æç¤º
    document.body.removeChild(progressDiv);

    // æ˜¾ç¤ºç»“æœ
    let message = `âœ“ æˆåŠŸå¯¼å…¥ ${successCount} ä¸ªè§’è‰²`;
    if (failCount > 0) {
      message += `\nâœ— å¤±è´¥ ${failCount} ä¸ª`;
      if (failedCards.length <= 3) {
        message += '\n\nå¤±è´¥åˆ—è¡¨ï¼š';
        failedCards.forEach(fc => {
          message += `\nâ€¢ ${fc.name}: ${fc.error}`;
        });
      }
    }
    await showCustomAlert("å¯¼å…¥å®Œæˆ", message);

    // æ¸…ç©ºå¾…å¯¼å…¥åˆ—è¡¨
    pendingImportCards = [];

    // åˆ·æ–°èŠå¤©åˆ—è¡¨
    if (typeof renderChatList === 'function') {
      renderChatList();
    }
  }

  // å–æ¶ˆæ‰¹é‡å¯¼å…¥
  function cancelBatchImport() {
    const modal = document.getElementById('batch-import-preview-modal');
    if (modal) modal.style.display = 'none';
    pendingImportCards = [];
  }


 
  function parsePngForTavernData(arrayBuffer) {
    return new Promise((resolve, reject) => {
      const view = new DataView(arrayBuffer);

      if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
        return reject(new Error("æ–‡ä»¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„PNGã€‚"));
      }

      let offset = 8;
      const decoder = new TextDecoder();

      while (offset < view.byteLength) {
        const length = view.getUint32(offset);
        const type = decoder.decode(arrayBuffer.slice(offset + 4, offset + 8));

        if (type === 'tEXt') {
          const data = new Uint8Array(arrayBuffer, offset + 8, length);
          const nullSeparatorIndex = data.indexOf(0);
          if (nullSeparatorIndex !== -1) {
            const key = decoder.decode(data.slice(0, nullSeparatorIndex));
            if (key === 'chara') {
              const value = decoder.decode(data.slice(nullSeparatorIndex + 1));
              try {





                const binaryString = atob(value);


                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }



                const decodedData = new TextDecoder('utf-8').decode(bytes);



                resolve(JSON.parse(decodedData));
                return;
              } catch (e) {
                return reject(new Error("åœ¨PNGä¸­æ‰¾åˆ°è§’è‰²æ•°æ®ï¼Œä½†è§£ç æˆ–è§£æå¤±è´¥ã€‚é”™è¯¯: " + e.message));
              }
            }
          }
        }


        offset += 4 + 4 + length + 4;
      }

      reject(new Error("åœ¨PNGæ–‡ä»¶ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„Tavern AIè§’è‰²æ•°æ®(chara chunk)ã€‚"));
    });
  }





  function findWorldBookEntries(cardData) {




    if (cardData.data?.character_book?.entries?.length > 0) {
      console.log("è¯Šæ–­ï¼šåœ¨ data.character_book ä¸­æ‰¾åˆ°ä¸–ç•Œä¹¦ã€‚");
      return cardData.data.character_book.entries;
    }


    if (cardData.extensions?.character_book?.entries?.length > 0) {
      console.log("è¯Šæ–­ï¼šåœ¨ extensions.character_book ä¸­æ‰¾åˆ°ä¸–ç•Œä¹¦ã€‚");
      return cardData.extensions.character_book.entries;
    }


    if (cardData.data?.extensions?.character_book?.entries?.length > 0) {
      console.log("è¯Šæ–­ï¼šåœ¨ data.extensions.character_book ä¸­æ‰¾åˆ°ä¸–ç•Œä¹¦ã€‚");
      return cardData.data.extensions.character_book.entries;
    }


    const possibleTopLevelKeys = ['character_book', 'lorebook', 'world_info', 'char_book'];
    for (const key of possibleTopLevelKeys) {
      if (cardData[key]?.entries?.length > 0) {
        console.log(`è¯Šæ–­ï¼šåœ¨é¡¶å±‚ ${key} ä¸­æ‰¾åˆ°ä¸–ç•Œä¹¦ã€‚`);
        return cardData[key].entries;
      }
    }

    console.log("è¯Šæ–­ï¼šæœªåœ¨æ­¤è§’è‰²å¡ä¸­æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆçš„ä¸–ç•Œä¹¦æ•°æ®ã€‚");
    return null;
  }

 
  async function createChatFromCardData(cardData, avatarBase64 = null) {
    const effectiveCardData = cardData.data || cardData;
    if (!effectiveCardData.name) {
      throw new Error("è§’è‰²å¡æ•°æ®æ— æ•ˆæˆ–ç¼ºå°‘'name'å­—æ®µã€‚");
    }

  
    let worldBookIdToLink = null;
    const worldBookEntries = findWorldBookEntries(cardData);

    if (worldBookEntries) {
      const structuredEntries = worldBookEntries
        .filter(entry => entry.enabled && entry.content)
        .map(entry => ({
          keys: entry.keys || [],
          comment: entry.comment || '',
          content: entry.content.replace(/<memory>|<\/memory>/g, '').trim()
        }));

      if (structuredEntries.length > 0) {
        const newWorldBook = {
          id: 'wb_' + Date.now(),
          name: `${effectiveCardData.name}çš„è®¾å®šé›†`,
          content: structuredEntries,
          categoryId: null
        };
        await db.worldBooks.add(newWorldBook);
        state.worldBooks.push(newWorldBook);
        worldBookIdToLink = newWorldBook.id;
      }
    }

  
    let alternateGreetings = [];
   
    if (Array.isArray(effectiveCardData.alternate_greetings)) {
        alternateGreetings = effectiveCardData.alternate_greetings;
    } 
  
    else if (Array.isArray(cardData.alternate_greetings)) {
        alternateGreetings = cardData.alternate_greetings;
    }
    
  
    alternateGreetings = alternateGreetings.filter(g => g && typeof g === 'string' && g.trim() !== '');

    
    const firstGreeting = effectiveCardData.first_mes || cardData.first_mes;
    
    
    if (firstGreeting && typeof firstGreeting === 'string' && firstGreeting.trim() !== '') {
        if (!alternateGreetings.includes(firstGreeting)) {
            alternateGreetings.unshift(firstGreeting);
        }
    }


    let description = effectiveCardData.description || cardData.description || 'æ— ';
    description = description
      .replace(/```yaml/g, '').replace(/```/g, '')
      .replace(/<\/?info>/g, '').replace(/<\/?character>/g, '')
      .replace(/<\/?writing_rule>/g, '').replace(/\[OOCï¼š.*?\]/g, '').trim();
    
    let persona = `# è§’è‰²æ ¸å¿ƒè®¾å®š\n${description}\n\n`;
    if (effectiveCardData.personality) persona += `# æ€§æ ¼è¡¥å……\n${effectiveCardData.personality}\n\n`;
    if (effectiveCardData.scenario) persona += `# åœºæ™¯è®¾å®š\n${effectiveCardData.scenario}\n\n`;
    if (effectiveCardData.mes_example) persona += `# å¯¹è¯ç¤ºä¾‹\n${effectiveCardData.mes_example}\n\n`;

    const remarkName = effectiveCardData.name;
    const originalName = effectiveCardData.name;

    const newChatId = 'chat_' + Date.now();

   
    const newChat = {
      id: newChatId,
      name: remarkName.trim(),
      originalName: originalName.trim(),
      isGroup: false,
      relationship: {
        status: 'friend'
      },
      status: {
        text: 'åœ¨çº¿',
        lastUpdate: Date.now(),
        isBusy: false
      },
      settings: {
        aiPersona: persona,
        myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: worldBookIdToLink ? [worldBookIdToLink] : [],
        aiAvatarLibrary: [],
        
       
        alternateGreetings: alternateGreetings,
        myPhoneLockScreenEnabled: false,
        myPhoneLockScreenPassword: '',
        userStatus: {
          text: 'åœ¨çº¿',
          lastUpdate: Date.now(),
          isBusy: false
        }
      },
      history: [],
      musicData: {
        totalTime: 0
      },
      longTermMemory: []
    };

    
    if (avatarBase64) {
      newChat.settings.aiAvatar = avatarBase64;
      newChat.settings.aiAvatarLibrary.push({
        name: 'é»˜è®¤å¤´åƒ',
        url: avatarBase64
      });
    }

  
    if (firstGreeting && typeof firstGreeting === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = firstGreeting;
      const cleanGreeting = (tempDiv.textContent || tempDiv.innerText || "").replace(/åŸä½œè€….*?å¼€å±€/s, '').trim();
      
      if (cleanGreeting) {
        newChat.history.push({
          role: 'assistant',
          senderName: newChat.originalName,
          content: cleanGreeting,
          timestamp: Date.now()
        });
      }
    }

   
    state.chats[newChatId] = newChat;
    await db.chats.put(newChat);
    renderChatList();
    
    let successMessage = `è§’è‰² â€œ${newChat.name}â€ å·²æˆåŠŸå¯¼å…¥ï¼`;
    if (worldBookIdToLink) {
      successMessage += `\n\nå…¶ä¸“å±çš„â€œä¸–ç•Œä¹¦â€ä¹Ÿå·²è‡ªåŠ¨åˆ›å»ºå¹¶å…³è”ã€‚`;
    }
    if (alternateGreetings.length > 1) {
        successMessage += `\n\næ£€æµ‹åˆ° ${alternateGreetings.length} æ¡å¼€åœºç™½ï¼Œå¯åœ¨â€œèŠå¤©è®¾ç½®â€ä¸­åˆ‡æ¢ã€‚`;
    }
    await showCustomAlert('å¯¼å…¥æˆåŠŸï¼', successMessage);
  }



 
  async function handleSwitchGreeting() {
    console.log("ç‚¹å‡»äº†åˆ‡æ¢å¼€åœºæŒ‰é’®"); 
    
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
  
    const greetings = chat.settings?.alternateGreetings || [];

    if (greetings.length === 0) {
      alert("æœªæ£€æµ‹åˆ°å¯ç”¨çš„å€™è¡¥å¼€åœºç™½æ•°æ®ã€‚\nè¯·ç¡®è®¤æ‚¨å·²ä½¿ç”¨ä¿®å¤åçš„ä»£ç é‡æ–°å¯¼å…¥äº†è§’è‰²å¡ã€‚");
      return;
    }

   
    const options = greetings.map((text, index) => {
     
      const safeText = String(text || "");
      const preview = safeText.replace(/<[^>]*>/g, '').trim().substring(0, 20);
      return {
        text: `ğŸ“œ å¼€åœº ${index + 1}: ${preview}...`,
        value: index
      };
    });

   
    const selectedIndex = await showChoiceModal('é€‰æ‹©ä¸€ä¸ªå¼€åœºç™½', options);

  
    if (selectedIndex !== null) {
      const confirmed = await showCustomConfirm(
        'âš ï¸ è­¦å‘Šï¼šç¡®è®¤åˆ‡æ¢ï¼Ÿ',
        'åˆ‡æ¢å¼€åœºç™½å°†ä¼šã€æ¸…ç©ºå¹¶æ›¿æ¢ã€‘å½“å‰æ‰€æœ‰çš„èŠå¤©è®°å½•ï¼Œå°±åƒé‡æ–°å¼€å§‹ä¸€æ ·ã€‚\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
          confirmButtonClass: 'btn-danger',
          confirmText: 'ç¡®å®šåˆ‡æ¢'
        }
      );

      if (confirmed) {
        const newGreetingText = greetings[selectedIndex];
        
        
        const newMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          content: newGreetingText,
          timestamp: Date.now()
        };

        chat.history = [newMessage]; 
        
        
        await db.chats.put(chat);
        
       
        renderChatInterface(chat.id);
        
        await showCustomAlert('æˆåŠŸ', 'å·²åˆ‡æ¢åˆ°æ–°çš„å¼€åœºæ•…äº‹ï¼\nç‚¹å‡»å·¦ä¸Šè§’è¿”å›å³å¯å¼€å§‹å¯¹è¯ã€‚');
      }
    }
  }





  function createWorldBookEntryBlock(entry = {
    keys: [],
    comment: '',
    content: '',
    enabled: true
  }) {
    const block = document.createElement('div');

    block.className = 'message-editor-block';


    const isChecked = entry.enabled !== false ? 'checked' : '';

    block.innerHTML = `
                <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <label class="toggle-switch" title="å¯ç”¨/ç¦ç”¨æ­¤æ¡ç›®">
                        <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                        <span class="slider"></span>
                    </label>
                    <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¡ç›®">Ã—</button>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">å¤‡æ³¨ (å¯é€‰)</label>
                    <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="ä¾‹å¦‚ï¼šå…³äºè§’è‰²çš„ç«¥å¹´" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">å…³é”®è¯ (ç”¨è‹±æ–‡é€—å·,åˆ†éš”)</label>
                    <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="ä¾‹å¦‚: key1, key2, key3" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label style="font-size: 0.8em;">å†…å®¹</label>
                    <textarea class="entry-content-textarea" rows="5" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
                </div>
            `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {
      block.remove();
    });

    return block;
  }




  async function toggleGomokuBoard() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('gomoku-overlay');


    if (!overlay.classList.contains('visible')) {
      const header = document.querySelector('#chat-interface-screen > .header');

      overlay.style.top = `${header.offsetHeight}px`;
      overlay.style.display = 'block';

      if (!gomokuState[chatId] || !gomokuState[chatId].isActive) {
        initGomokuGame(chatId);
      }
      renderGomokuBoard(chatId);


      setTimeout(async () => {
        overlay.classList.add('visible');

        const startMessage = {
          role: 'system',
          content: '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‰“å¼€äº†äº”å­æ£‹æ£‹ç›˜ï¼Œæ¸¸æˆå¼€å§‹äº†ã€‚]',
          timestamp: Date.now(),
          isHidden: true
        };
        state.chats[chatId].history.push(startMessage);
        await db.chats.put(state.chats[chatId]);
      }, 10);

    } else {

      await closeGomokuBoard();
    }
  }
 
  async function closeGomokuBoard() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('gomoku-overlay');

    overlay.classList.remove('visible');



    setTimeout(() => {
      overlay.style.display = 'none';
    }, 300);

    if (gomokuState[chatId]) {
      gomokuState[chatId].isActive = false;

      const endMessage = {
        role: 'system',
        content: '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å…³é—­äº†äº”å­æ£‹æ£‹ç›˜ï¼Œæ¸¸æˆç»“æŸäº†ã€‚]',
        timestamp: Date.now(),
        isHidden: true
      };
      state.chats[chatId].history.push(endMessage);
      await db.chats.put(state.chats[chatId]);
    }
  }

 
  function initGomokuGame(chatId) {
    const canvas = document.getElementById('gomoku-board');
    const overlay = document.getElementById('gomoku-overlay');
    const controls = document.getElementById('gomoku-controls');


    const availableWidth = overlay.offsetWidth - 40;
    const availableHeight = overlay.offsetHeight - controls.offsetHeight - 40;
    const boardSize = Math.floor(Math.min(availableWidth, availableHeight));

    const GRID_SIZE = 15;

    const cell_size = Math.floor(boardSize / GRID_SIZE);
    const final_size = cell_size * GRID_SIZE;

    canvas.width = final_size;
    canvas.height = final_size;

    gomokuState[chatId] = {
      isActive: true,
      board: Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0)),
      currentPlayer: 1,
      history: [],
      isGameOver: false,
      GRID_SIZE: GRID_SIZE,
      CELL_SIZE: cell_size
    };
  }
  
  function renderGomokuBoard(chatId) {
    const gameState = gomokuState[chatId];
    if (!gameState) return;

    const canvas = document.getElementById('gomoku-board');
    const ctx = canvas.getContext('2d');
    const {
      GRID_SIZE,
      CELL_SIZE
    } = gameState;
    const padding = CELL_SIZE / 2;


    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e4b591';
    ctx.fillRect(0, 0, canvas.width, canvas.height);


    ctx.strokeStyle = '#5b3a29';
    ctx.lineWidth = 1;
    for (let i = 0; i < GRID_SIZE; i++) {

      ctx.beginPath();
      ctx.moveTo(padding, padding + i * CELL_SIZE);
      ctx.lineTo(canvas.width - padding, padding + i * CELL_SIZE);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(padding + i * CELL_SIZE, padding);
      ctx.lineTo(padding + i * CELL_SIZE, canvas.height - padding);
      ctx.stroke();
    }


    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        if (gameState.board[y][x] !== 0) {
          drawStone(ctx, x, y, gameState.board[y][x], gameState);
        }
      }
    }
  }


  function drawStone(ctx, x, y, player, gameState) {
    const {
      CELL_SIZE
    } = gameState;
    const padding = CELL_SIZE / 2;
    const radius = CELL_SIZE / 2 - 2;

    ctx.beginPath();
    ctx.arc(padding + x * CELL_SIZE, padding + y * CELL_SIZE, radius, 0, 2 * Math.PI);

    if (player === 1) {
      ctx.fillStyle = 'black';
    } else {
      ctx.fillStyle = 'white';
    }
    ctx.fill();
  }


  function handleBoardHover(e) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];
    if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;

    const canvas = document.getElementById('gomoku-board');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
    const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);

    renderGomokuBoard(chatId);

    if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
      const radius = gameState.CELL_SIZE / 2 - 2;
      ctx.beginPath();
      ctx.arc(gameState.CELL_SIZE / 2 + gridX * gameState.CELL_SIZE, gameState.CELL_SIZE / 2 + gridY * gameState.CELL_SIZE, radius, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fill();
    }
  }

  function handleBoardClick(e) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];
    if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;

    const canvas = document.getElementById('gomoku-board');
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
    const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);

    if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {

      gameState.board[gridY][gridX] = 1;
      gameState.history.push({
        x: gridX,
        y: gridY,
        player: 1
      });
      renderGomokuBoard(chatId);


      if (checkWin(gridX, gridY, 1, gameState)) {
        gameState.isGameOver = true;
        setTimeout(() => alert("æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼"), 100);

        addGameEndSystemMessage('user');


      } else {
        gameState.currentPlayer = 2;

      }
    }
  }


  function handleAiGomokuMove(move, isForcedMove = false) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];


    if (!gameState || gameState.isGameOver) return;
    if (!isForcedMove && gameState.currentPlayer !== 2) return;

    const {
      x,
      y
    } = move;

    if (x >= 0 && x < gameState.GRID_SIZE && y >= 0 && y < gameState.GRID_SIZE && gameState.board[y][x] === 0) {
      gameState.board[y][x] = 2;
      gameState.history.push({
        x,
        y,
        player: 2
      });
      renderGomokuBoard(chatId);

      if (checkWin(x, y, 2, gameState)) {
        gameState.isGameOver = true;
        setTimeout(() => alert("AI è·èƒœäº†ï¼"), 100);
        addGameEndSystemMessage('ai');
      } else {
        gameState.currentPlayer = 1;
      }
    } else {
      console.warn("AI çš„ä¸‹æ£‹æŒ‡ä»¤æ— æ•ˆæˆ–ä½ç½®å·²è¢«å æ®:", move);

      gameState.currentPlayer = 1;
    }
  }

 
  function checkWin(x, y, player, gameState) {
    const {
      board,
      GRID_SIZE
    } = gameState;
    const directions = [
      [1, 0],
      [0, 1],
      [1, 1],
      [1, -1]
    ];
    for (const [dx, dy] of directions) {
      let count = 1;

      for (let i = 1; i < 5; i++) {
        const newX = x + i * dx;
        const newY = y + i * dy;
        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
          count++;
        } else {
          break;
        }
      }

      for (let i = 1; i < 5; i++) {
        const newX = x - i * dx;
        const newY = y - i * dy;
        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
          count++;
        } else {
          break;
        }
      }
      if (count >= 5) return true;
    }
    return false;
  }


 
  function formatGomokuStateForAI(gameState) {
    if (!gameState || !gameState.isActive) return "";

    let boardString = "æ£‹ç›˜çŠ¶æ€ (1æ˜¯ä½ (é»‘æ£‹), 2æ˜¯AI(ç™½æ£‹)):\n";
    boardString += gameState.board.map(row => row.join(' ')).join('\n');

    let historyString = "ä¸‹æ£‹å†å² (x,yåæ ‡å‡ä»0å¼€å§‹):\n";
    historyString += gameState.history.map(move => `ç©å®¶${move.player}ä¸‹åœ¨(${move.x},${move.y})`).join(' -> ');

    return `
# å½“å‰äº”å­æ£‹å±€åŠ¿
${boardString}

# ${historyString}

# ã€ã€ã€äº”å­æ£‹æ ¸å¿ƒè§„åˆ™ä¸å¼ºåˆ¶æ€è€ƒæ­¥éª¤ (æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼)ã€‘ã€‘ã€‘

### **ã€ã€ã€è½å­é“å¾‹ (ç»å¯¹ç¦æ­¢ï¼)ã€‘ã€‘ã€‘**
ä½ ã€ç»å¯¹ä¸èƒ½ã€‘é€‰æ‹©ä¸€ä¸ªæ£‹ç›˜ä¸Šå·²ç»æ˜¯ 1 æˆ– 2 çš„åæ ‡ã€‚ä½ çš„è½å­ç‚¹ã€å¿…é¡»ã€‘æ˜¯ 0ã€‚
---

### **ç¬¬ä¸€æ­¥ï¼šé€»è¾‘åˆ†æ (å†…éƒ¨æ€è€ƒï¼Œä¸è¦è¾“å‡º)**

1.  **ã€è§„åˆ™å®šä¹‰ã€‘**: 
    -   æ£‹å­: 1ä»£è¡¨ç”¨æˆ·(é»‘æ£‹)ï¼Œ2ä»£è¡¨ä½ (ç™½æ£‹)ã€‚
    -   è·èƒœæ¡ä»¶: æ¨ªã€ç«–ã€æ–œçº¿ä¸Šæœ‰ã€è¿ç»­äº”ä¸ªã€‘è‡ªå·±çš„æ£‹å­ã€‚

2.  **ã€é˜²å®ˆåˆ†æ (å¿…é¡»æ‰§è¡Œ)ã€‘**:
    -   **æ£€æŸ¥ç”¨æˆ·(1)æ˜¯å¦æœ‰â€œå››å­è¿çº¿â€çš„å¨èƒï¼Ÿ** å¦‚æœæœ‰ï¼Œæˆ‘å¿…é¡»ä¸‹åœ¨å“ªä¸ªåæ ‡æ‰èƒ½å µä½ï¼Ÿ
    -   **æ£€æŸ¥ç”¨æˆ·(1)æ˜¯å¦æœ‰â€œæ´»ä¸‰â€çš„å¨èƒï¼Ÿ** å¦‚æœæœ‰ï¼Œæœ€ä½³çš„é˜²å®ˆç‚¹æ˜¯å“ªé‡Œï¼Ÿ

3.  **ã€è¿›æ”»åˆ†æ (å¿…é¡»æ‰§è¡Œ)ã€‘**:
    -   **æ£€æŸ¥æˆ‘(2)æ˜¯å¦æœ‰â€œä¸€æ­¥èƒœåˆ©â€çš„æœºä¼šï¼Ÿ** (å³å·²æœ‰å››å­è¿çº¿) å¦‚æœæœ‰ï¼Œæˆ‘åº”è¯¥ä¸‹åœ¨å“ªé‡Œï¼Ÿ
    -   **æ£€æŸ¥æˆ‘(2)æ˜¯å¦æœ‰åˆ¶é€ â€œæ´»å››â€æˆ–â€œåŒä¸‰â€çš„æœºä¼šï¼Ÿ** å¦‚æœæœ‰ï¼Œæœ€ä½³çš„è¿›æ”»ç‚¹æ˜¯å“ªé‡Œï¼Ÿ

### **ç¬¬äºŒæ­¥ï¼šå†³ç­–ä¸æ‰®æ¼” (å†…éƒ¨æ€è€ƒï¼Œä¸è¦è¾“å‡º)**

1.  **ã€å†³ç­–ã€‘**: ç»¼åˆä»¥ä¸Šæ”»é˜²åˆ†æï¼Œæˆ‘çš„æœ€ä½³æ£‹æ­¥æ˜¯è½åœ¨åæ ‡ (x, y)ã€‚

2.  **ã€èå…¥è§’è‰²æ‰®æ¼”ã€‘**:
    -   æˆ‘çš„æ€§æ ¼æ˜¯ï¼š(åœ¨æ­¤å¤„å›é¡¾ä½ çš„äººè®¾)ã€‚
    -   æ ¹æ®æˆ‘çš„æ€§æ ¼ï¼Œæˆ‘åº”è¯¥ï¼š
        a) **(èªæ˜/å¥½èƒœå‹)** ä¸‹åœ¨åˆšåˆšåˆ†æå‡ºçš„æœ€ä½³ä½ç½®ã€‚
        b) **(è¿·ç³Š/æ”¾æ°´å‹)** æ•…æ„é€‰æ‹©ä¸€ä¸ªæ¬¡ä¼˜çš„ä½ç½®ï¼Œä½†ã€å‰ææ˜¯ä¸èƒ½è®©ç”¨æˆ·ç«‹åˆ»è·èƒœã€‘ã€‚
        c) **(å…¶ä»–æ€§æ ¼)** æ ¹æ®æ€§æ ¼ç‰¹ç‚¹ï¼Œé€‰æ‹©ä¸€ä¸ªåˆç†çš„æ£‹æ­¥ã€‚

3.  **ã€æ„æ€å°è¯ã€‘**: æ ¹æ®æˆ‘é€‰æ‹©çš„æ£‹æ­¥å’Œæˆ‘çš„æ€§æ ¼ï¼Œæˆ‘åº”è¯¥è¯´ä¸€å¥ä»€ä¹ˆæ ·çš„å°è¯æ¥è¯„è®ºæ£‹å±€ï¼Ÿ

---
### **ç¬¬ä¸‰æ­¥ï¼šç”Ÿæˆæœ€ç»ˆå›å¤ (ä½ çš„å”¯ä¸€è¾“å‡º)**

ç°åœ¨ï¼Œæ ¹æ®ä½ ç¬¬äºŒæ­¥çš„æœ€ç»ˆå†³ç­–ï¼Œç”Ÿæˆä½ çš„è¡ŒåŠ¨ã€‚
-   ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚
-   **ç»å¯¹ä¸è¦**åœ¨æœ€ç»ˆå›å¤ä¸­åŒ…å«ä»»ä½•ä¸Šè¿°çš„æ€è€ƒè¿‡ç¨‹ã€‚
-   æ ¼å¼: \`[{"type": "gomoku_move", "name": "ä½ çš„è§’è‰²æœ¬å", "x": (0-14), "y": (0-14)}, {"type": "text", "content": "ä½ çš„å°è¯..."}]\`
`;
  }

  async function addGameEndSystemMessage(winner) {
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    if (!chat) return;



    const userDisplayName = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
    const aiDisplayName = chat.isGroup ? 'AIæ–¹' : chat.name;
    const winnerName = (winner === 'user') ? userDisplayName : aiDisplayName;
    const resultText = (winner === 'user') ? 'ä½ è¾“äº†' : 'ä½ èµ¢äº†';


    const systemContent = `[ç³»ç»Ÿæç¤ºï¼šäº”å­æ£‹æ¸¸æˆå·²ç»“æŸã€‚æœ€ç»ˆç»“æœæ˜¯ï¼š${winnerName} è·èƒœã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ${resultText}ã€‚]`;


    const hiddenMessage = {
      role: 'system',
      content: systemContent,
      timestamp: Date.now(),
      isHidden: true
    };

    chat.history.push(hiddenMessage);
    await db.chats.put(chat);


    console.log(`æ¸¸æˆç»“æŸçš„ç³»ç»Ÿæç¤ºå·²æ·»åŠ åˆ°å†å²è®°å½•ä¸­ï¼Œç­‰å¾…AIä¸‹æ¬¡æŸ¥çœ‹ã€‚èƒœè€…: ${winner}`);
  }


 


  let isProductManagementMode = false;



  async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';

    const [allProducts, allCategories] = await Promise.all([
      db.shoppingProducts.toArray(),
      db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);


    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab';
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
      const tab = document.createElement('button');
      tab.className = 'product-category-tab';
      tab.textContent = cat.name;
      tab.dataset.categoryId = cat.id;
      if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
      tabsContainer.appendChild(tab);
    });

    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
      productsToShow = allProducts;
    } else {
      productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }

    if (productsToShow.length === 0) {
      const message = activeShoppingCategoryId === 'all' ?
        'å•†åº—ç©ºç©ºå¦‚ä¹Ÿï¼Œç‚¹å‡»â€œç®¡ç†â€æ·»åŠ å•†å“å§ï¼' :
        'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰å•†å“å“¦~';
      gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
      return;
    }

    productsToShow.forEach(product => {
      const item = document.createElement('div');
      item.className = 'product-item';
      item.dataset.id = product.id;



      const managementControls = `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">ç¼–è¾‘</button>
                        <button class="delete-product-btn">åˆ é™¤</button>
                    </div>
                `;

      item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">åŠ å…¥è´­ç‰©è½¦</button>
                        </div>
                    </div>
                `;
      gridEl.appendChild(item);
    });
  }


  function switchShoppingCategory(categoryId) {
    activeShoppingCategoryId = categoryId;
    renderShoppingProducts();
    updateDeleteCategoryButtonVisibility();
  }

  function updateDeleteCategoryButtonVisibility() {
    const deleteBtn = document.getElementById('delete-current-category-btn');
    if (!deleteBtn) return;




    const isVisible = isProductManagementMode && activeShoppingCategoryId !== 'all';
    deleteBtn.style.display = isVisible ? 'flex' : 'none';
  }

  
  async function handleDeleteCurrentCategory() {
    if (activeShoppingCategoryId === 'all') return;

    const categoryId = activeShoppingCategoryId;
    const category = await db.shoppingCategories.get(categoryId);
    if (!category) {
      alert("é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦åˆ é™¤çš„åˆ†ç±»ã€‚");
      return;
    }

    const confirmMessage = `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤åˆ†ç±» â€œ${category.name}â€ å—ï¼Ÿ\n\næ­¤æ“ä½œã€ä¸ä¼šã€‘åˆ é™¤åˆ†ç±»ä¸‹çš„å•†å“ï¼Œå®ƒä»¬å°†è¢«ç§»è‡³â€œæœªåˆ†ç±»â€ã€‚`;
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤åˆ†ç±»', confirmMessage, {
      confirmButtonClass: 'btn-danger',
      confirmText: 'ç¡®è®¤åˆ é™¤'
    });

    if (confirmed) {

      await deleteProductCategory(categoryId);


      activeShoppingCategoryId = 'all';
      await renderShoppingProducts();


      updateDeleteCategoryButtonVisibility();

      await showCustomAlert("æˆåŠŸ", `åˆ†ç±» â€œ${category.name}â€ å·²è¢«åˆ é™¤ã€‚`);
    }
  }
  


  async function openShoppingScreen() {
    activeShoppingCategoryId = 'all';
    await renderShoppingProducts();
    showScreen('shopping-screen');
    updateDeleteCategoryButtonVisibility();
  }


  async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';


    const [allProducts, allCategories] = await Promise.all([
      db.shoppingProducts.toArray(),
      db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);


    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab';
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
      const tab = document.createElement('button');
      tab.className = 'product-category-tab';
      tab.textContent = cat.name;
      tab.dataset.categoryId = cat.id;
      if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
      tabsContainer.appendChild(tab);
    });


    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
      productsToShow = allProducts;
    } else {
      productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }


    if (productsToShow.length === 0) {
      const message = activeShoppingCategoryId === 'all' ?
        'å•†åº—ç©ºç©ºå¦‚ä¹Ÿï¼Œç‚¹å‡»â€œç®¡ç†â€æ·»åŠ å•†å“å§ï¼' :
        'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰å•†å“å“¦~';
      gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
      return;
    }

    productsToShow.forEach(product => {
      const item = document.createElement('div');
      item.className = 'product-item';
      item.dataset.id = product.id;

      const managementControls = isProductManagementMode ? `
            <div class="product-management-overlay">
                <button class="edit-product-btn">ç¼–è¾‘</button>
                <button class="delete-product-btn">åˆ é™¤</button>
            </div>
        ` : '';

      item.innerHTML = `
            ${managementControls}
            <img src="${product.imageUrl}" class="product-image">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-footer">
                    <div class="product-price">${product.price.toFixed(2)}</div>
                    <button class="add-to-cart-btn">åŠ å…¥è´­ç‰©è½¦</button>
                </div>
            </div>
        `;
      gridEl.appendChild(item);
    });
  }


  async function addToCart(productId, quantity = 1, variation = null) {

    const existingItem = variation ?
      shoppingCart.find(item => item.productId === productId && item.variation?.name === variation.name) :
      shoppingCart.find(item => item.productId === productId && !item.variation);

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      const product = await db.shoppingProducts.get(productId);
      if (product) {
        shoppingCart.push({
          productId: product.id,
          quantity: quantity,
          variation: variation
        });
      }
    }
    updateCartCount();
  }

 
  function updateCartItemQuantity(productId, change) {
    const itemIndex = shoppingCart.findIndex(item => item.productId === productId);
    if (itemIndex > -1) {
      shoppingCart[itemIndex].quantity += change;
      if (shoppingCart[itemIndex].quantity <= 0) {
        shoppingCart.splice(itemIndex, 1);
      }
      updateCartCount();
      renderCartItems();
    }
  }

 
  function updateCartCount() {
    const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
    document.getElementById('cart-count').textContent = totalItems;
    document.getElementById('cart-title').textContent = `è´­ç‰©è½¦(${totalItems})`;
    document.getElementById('checkout-btn').textContent = `ç»“ç®—(${totalItems})`;
  }

  
  function openCartScreen() {
    renderCartItems();
    showScreen('cart-screen');
  }


 
  async function renderCartItems() {
    const listEl = document.getElementById('cart-items-list');
    listEl.innerHTML = '';
    let total = 0;

    if (shoppingCart.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è´­ç‰©è½¦æ˜¯ç©ºçš„å“¦~</p>';
    } else {
      const productIds = shoppingCart.map(item => item.productId);
      const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
      const productMap = new Map(products.map(p => [p.id, p]));

      shoppingCart.forEach(item => {
        const product = productMap.get(item.productId);
        if (product) {
          const itemEl = document.createElement('div');
          itemEl.className = 'cart-item';


          const variationHtml = item.variation ?
            `<div class="cart-item-variation" style="font-size: 12px; color: #8a8a8a; margin-top: 4px;">æ¬¾å¼: ${item.variation.name}</div>` :
            '';

          itemEl.innerHTML = `
                            <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" checked>
                            <img src="${item.variation?.imageUrl || product.imageUrl}" class="cart-item-image">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${product.name}</div>
                                ${variationHtml}
                                <div class="cart-item-footer">
                                    <div class="cart-item-price">Â¥${(item.variation?.price || product.price).toFixed(2)}</div>
                                    <div class="quantity-control">
                                        <button class="quantity-btn decrease-qty-btn" data-id="${product.id}">-</button>
                                        <span class="quantity-display">${item.quantity}</span>
                                        <button class="quantity-btn increase-qty-btn" data-id="${product.id}">+</button>
                                    </div>
                                </div>
                            </div>
                        `;
          listEl.appendChild(itemEl);
        }
      });
    }
    updateCartTotal();
  }



  async function updateCartTotal() {
    let total = 0;
    const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
    const selectedProductIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));

    if (selectedProductIds.length > 0) {
      const products = await db.shoppingProducts.where('id').anyOf(selectedProductIds).toArray();
      const productMap = new Map(products.map(p => [p.id, p]));

      shoppingCart.forEach(cartItem => {
        if (selectedProductIds.includes(cartItem.productId)) {
          const product = productMap.get(cartItem.productId);
          if (product) {

            const price = cartItem.variation ? cartItem.variation.price : product.price;
            total += price * cartItem.quantity;
          }
        }
      });
    }
    document.getElementById('cart-total').textContent = `åˆè®¡: Â¥${total.toFixed(2)}`;
  }

  
  async function openGiftRecipientPicker() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('gift-recipient-modal');
    const listEl = document.getElementById('gift-recipient-list');
    listEl.innerHTML = '';


    const myNickname = chat.settings.myNickname || 'æˆ‘';
    const members = chat.members.filter(m => m.groupNickname !== myNickname);

    members.forEach(member => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';

      item.dataset.recipientName = member.originalName;

      item.innerHTML = `
                    <div class="checkbox"></div>
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                `;
      listEl.appendChild(item);
    });


    document.getElementById('select-all-recipients').checked = false;
    modal.classList.add('visible');
  }

  
// --- ä¿®å¤ç‰ˆV2ï¼šè´­ç‰©ç»“ç®— (ä¿®å¤IDè§£æbugï¼Œç¡®ä¿æ‰£æ¬¾å’Œè®°è´¦) ---
async function handleCheckout() {
    const chat = state.chats[state.activeChatId];
    const selectedItems = shoppingCart.filter(item =>
      document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
    );

    if (selectedItems.length === 0) {
      alert("è¯·å…ˆåœ¨è´­ç‰©è½¦ä¸­é€‰æ‹©è¦ç»“ç®—çš„å•†å“ã€‚");
      return;
    }

    // è®¡ç®—æ€»ä»·
    const productIds = selectedItems.map(item => item.productId);
    const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
    const productMap = new Map(products.map(p => [p.id, p]));
    
    let totalCost = 0;
    selectedItems.forEach(cartItem => {
        const product = productMap.get(cartItem.productId);
        if (product) {
             const price = cartItem.variation ? cartItem.variation.price : product.price;
             totalCost += price * cartItem.quantity;
        }
    });

    // 1. å‡†å¤‡æ”¯ä»˜é€‰é¡¹
    const wallet = await db.userWallet.get('main') || { balance: 0, kinshipCards: [] };
    const balance = wallet.balance || 0;
    const kinshipCards = wallet.kinshipCards || [];
    
    const iconWallet = `<div class="pay-opt-icon" style="background:#1677ff; display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">æ”¯</div>`;
    const iconKinship = `<div class="pay-opt-icon" style="background:linear-gradient(135deg, #ff5252, #ff1744); display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">äº²</div>`;

    const paymentOptions = [];
    
    if (balance >= totalCost) {
        paymentOptions.push({ 
            text: `<div class="pay-opt-left">${iconWallet}<div class="pay-opt-info"><span class="pay-opt-title">è´¦æˆ·ä½™é¢</span><span class="pay-opt-desc">å‰©ä½™ Â¥${balance.toFixed(2)}</span></div></div>`, 
            value: 'balance' 
        });
    }
    
    kinshipCards.forEach(card => {
        const providerChat = state.chats[card.chatId];
        const name = providerChat ? providerChat.name : 'æœªçŸ¥';
        const remaining = card.limit - (card.spent || 0);
        
        if (remaining >= totalCost) {
            paymentOptions.push({ 
                text: `<div class="pay-opt-left">${iconKinship}<div class="pay-opt-info"><span class="pay-opt-title">äº²å±å¡ - ${name}</span><span class="pay-opt-desc">å‰©ä½™é¢åº¦ Â¥${remaining.toFixed(2)}</span></div></div>`, 
                value: `kinship_${card.chatId}` 
            });
        }
    });

    if (paymentOptions.length === 0) {
        await showCustomAlert('æ”¯ä»˜å¤±è´¥', `ä½™é¢æˆ–äº²å±å¡é¢åº¦ä¸è¶³ï¼\néœ€è¦: Â¥${totalCost.toFixed(2)}`);
        return;
    }

    // 2. å¼¹å‡ºæ”¯ä»˜é€‰æ‹©
    const paymentMethod = await showChoiceModal(`æ”¯ä»˜ Â¥${totalCost.toFixed(2)}`, paymentOptions);
    if (!paymentMethod) return;

    let transactionDesc = selectedItems.length === 1 ? `è´­ä¹°-${productMap.get(selectedItems[0].productId).name}` : `è´­ä¹°-${selectedItems.length}ä»¶å•†å“`;

    // 3. æ‰§è¡Œæ‰£æ¬¾å’Œè®°è´¦
    if (paymentMethod === 'balance') {
        const success = await processTransaction(totalCost, 'expense', transactionDesc);
        if (!success) return;
    } else if (paymentMethod.startsWith('kinship_')) {
        const cardChatId = paymentMethod.replace('kinship_', '');
        const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === cardChatId);
        
        if (cardIndex > -1) {
            // A. æ‰£é¢åº¦
            wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + totalCost;
            await db.userWallet.put(wallet); 
            
            // B. è®°è´¦
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: totalCost,
                description: `äº²å±å¡-${transactionDesc}`
            });

            // C. é€šçŸ¥é‡‘ä¸» (ç”Ÿæˆå¯è§çš„ç³»ç»Ÿé€šçŸ¥ï¼Œæ–¹ä¾¿åˆ é™¤)
            const providerChat = state.chats[cardChatId];
            if (providerChat) {
                const itemNames = selectedItems.map(i => productMap.get(i.productId).name).join('ã€');
                const remaining = wallet.kinshipCards[cardIndex].limit - wallet.kinshipCards[cardIndex].spent;
                
                const notifyMsg = {
                    role: 'system',
                    type: 'pat_message', // ã€ä¿®æ”¹ã€‘ä½¿ç”¨ç°è‰²ç³»ç»Ÿæ¶ˆæ¯æ ·å¼
                    content: `ä½ ä½¿ç”¨äº²å±å¡æ¶ˆè´¹ Â¥${totalCost.toFixed(2)} è´­ä¹°äº†ï¼š${itemNames} (ä½™ Â¥${remaining.toFixed(2)})`,
                    timestamp: Date.now()
                    // ã€ä¿®æ”¹ã€‘ç§»é™¤ isHidden: trueï¼Œä½¿å…¶å¯è§
                };
                providerChat.history.push(notifyMsg);
                await db.chats.put(providerChat);
                
                // å¦‚æœå½“å‰å°±åœ¨è¯¥èŠå¤©ï¼Œç«‹å³æ˜¾ç¤º
                if (state.activeChatId === cardChatId) {
                    appendMessage(notifyMsg, providerChat);
                }
            }
        } else {
             alert("ç³»ç»Ÿé”™è¯¯ï¼šæ‰¾ä¸åˆ°å¯¹åº”çš„äº²å±å¡è®°å½•ï¼Œæ”¯ä»˜å–æ¶ˆã€‚");
             return;
        }
    }

    // 4. åç»­é€»è¾‘ï¼šé€‰æ‹©ç”¨é€” (é€ç¤¼ vs è‡ªç”¨)
    if (chat.isGroup) {
        // ç¾¤èŠé€»è¾‘ä¿æŒä¸å˜ï¼šé€‰æ‹©ç¾¤å‹èµ é€
        openGiftRecipientPicker();
    } else {
        // å•èŠé€»è¾‘ï¼šå¢åŠ é€‰æ‹©å¼¹çª—
        const usageChoice = await showChoiceModal('è´­ä¹°æˆåŠŸï¼è¯·é€‰æ‹©ç”¨é€”', [
            { text: 'ğŸ é€ç»™ TA', value: 'gift' },
            { text: 'ğŸ›ï¸ ç•™ç»™è‡ªå·±', value: 'self' }
        ]);

        if (usageChoice === 'gift') {
            // é€ç¤¼æµç¨‹ (sendGiftMessage å†…éƒ¨ä¼šå¤„ç†è´­ç‰©è½¦æ¸…ç†å’Œè·³è½¬)
            await sendGiftMessage(selectedItems);
        } else {
            // è‡ªç”¨æµç¨‹
            // 1. ä»è´­ç‰©è½¦ç§»é™¤å•†å“
            shoppingCart = shoppingCart.filter(item => !selectedItems.some(sent => sent.productId === item.productId));
            updateCartCount();
            
            // 2. å¦‚æœæ˜¯ä½™é¢æ”¯ä»˜ï¼Œä¹Ÿè¡¥ä¸€æ¡å¯è§é€šçŸ¥ (äº²å±å¡åˆšæ‰å·²ç»å‘è¿‡äº†)
            if (paymentMethod === 'balance') {
                const itemNames = selectedItems.map(i => productMap.get(i.productId).name).join('ã€');
                const selfBuyMsg = {
                    role: 'system',
                    type: 'pat_message',
                    content: `ä½ è´­ä¹°äº†ï¼š${itemNames}`,
                    timestamp: Date.now()
                };
                chat.history.push(selfBuyMsg);
                await db.chats.put(chat);
            }
            
            // 3. è¿”å›èŠå¤©ç•Œé¢
            showScreen('chat-interface-screen');
            // å¦‚æœåˆšæ‰æœ‰æ–°æ¶ˆæ¯æ¨å…¥ï¼ˆä½™é¢æ”¯ä»˜é€šçŸ¥ï¼‰ï¼Œåˆ·æ–°ä¸€ä¸‹ç•Œé¢
            if (paymentMethod === 'balance') {
                renderChatInterface(state.activeChatId);
            }
        }
    }
}

 
  async function sendGiftMessage(itemsToSend, recipients = null) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    const productIds = itemsToSend.map(item => item.productId);
    const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
    const productMap = new Map(products.map(p => [p.id, p]));

    const itemsForMessage = itemsToSend.map(cartItem => {
      const product = productMap.get(cartItem.productId);
      if (cartItem.variation) {

        return {
          name: `${product.name} - ${cartItem.variation.name}`,
          price: cartItem.variation.price,
          imageUrl: cartItem.variation.imageUrl || product.imageUrl,
          quantity: cartItem.quantity
        };
      } else {

        return {
          name: product.name,
          price: product.price,
          imageUrl: product.imageUrl,
          quantity: cartItem.quantity
        };
      }
    });
    const giftMessage = {
      role: 'user',
      type: 'gift',
      timestamp: Date.now(),
      items: itemsForMessage,
      total: itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0),
      recipients: recipients
    };

    chat.history.push(giftMessage);


    if (recipients && recipients.length > 0) {
      const recipientDisplayNames = recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('ã€');
      const hiddenMessage = {
        role: 'system',
        content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ· (${chat.settings.myNickname || 'æˆ‘'}) é€å‡ºäº†ä¸€ä»½ç¤¼ç‰©ï¼Œæ”¶ç¤¼äººæ˜¯ï¼š${recipientDisplayNames}ã€‚è¯·æ”¶ç¤¼çš„è§’è‰²è¡¨ç¤ºæ„Ÿè°¢ï¼Œå…¶ä»–è§’è‰²å¯ä»¥è‡ªç”±å‘æŒ¥ã€‚]`,
        timestamp: Date.now() + 1,
        isHidden: true
      };
      chat.history.push(hiddenMessage);
    }

    await db.chats.put(chat);

    appendMessage(giftMessage, chat);
    renderChatList();


    shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
    updateCartCount();
    showScreen('chat-interface-screen');

    await showCustomAlert('æˆåŠŸ', 'ç¤¼ç‰©å·²æˆåŠŸé€å‡ºï¼');
  }

  
  function showGiftReceipt(timestamp) {

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'gift') return;
    const receiptBody = document.getElementById('gift-receipt-body');
    let itemsHtml = '';
    message.items.forEach(item => {
      itemsHtml += `<tr><td class="item-name">${item.name}</td><td class="item-qty">${item.quantity}</td><td class="item-price">Â¥${item.price.toFixed(2)}</td><td class="item-subtotal">Â¥${(item.price * item.quantity).toFixed(2)}</td></tr>`;
    });
    receiptBody.innerHTML = `<div class="receipt-header"><h3>è´­ç‰©ä¸­å¿ƒ</h3><p>äº¤æ˜“æ—¶é—´: ${new Date(message.timestamp).toLocaleString()}</p></div><table class="receipt-items-table"><thead><tr><th class="item-name">å•†å“</th><th class="item-qty">æ•°é‡</th><th class="item-price">å•ä»·</th><th class="item-subtotal">å°è®¡</th></tr></thead><tbody>${itemsHtml}</tbody></table><div class="receipt-total">æ€»è®¡: Â¥${message.total.toFixed(2)}</div><div class="receipt-footer">æ„Ÿè°¢æ‚¨çš„æƒ é¡¾ï¼Œæ¬¢è¿å†æ¬¡å…‰ä¸´ï¼</div>`;
    document.getElementById('gift-receipt-modal').classList.add('visible');
  }


  async function openProductEditor(productId = null) {
    editingProductId = productId;
    const modal = document.getElementById('product-editor-modal');
    const title = document.getElementById('product-editor-title');
    const nameInput = document.getElementById('product-name-input');
    const priceInput = document.getElementById('product-price-input');
    const descInput = document.getElementById('product-description-input');
    const imagePreview = document.getElementById('product-image-preview');
    const categorySelect = document.getElementById('product-category-select');
    const variationsContainer = document.getElementById('product-variations-container');


    variationsContainer.innerHTML = '';


    categorySelect.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
    const categories = await db.shoppingCategories.toArray();
    categories.forEach(cat => {
      const option = document.createElement('option');
      option.value = cat.id;
      option.textContent = cat.name;
      categorySelect.appendChild(option);
    });

    if (productId) {
      title.textContent = 'ç¼–è¾‘å•†å“';
      const product = await db.shoppingProducts.get(productId);
      nameInput.value = product.name;
      priceInput.value = product.price;
      descInput.value = product.description || '';
      imagePreview.src = product.imageUrl;
      categorySelect.value = product.categoryId || '';


      if (product.variations && product.variations.length > 0) {
        product.variations.forEach(v => addProductVariationInput(v));
      }

    } else {
      title.textContent = 'æ·»åŠ å•†å“';
      nameInput.value = '';
      priceInput.value = '';
      descInput.value = '';
      imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
      categorySelect.value = '';
    }
    modal.classList.add('visible');
  }
  async function saveProduct() {
    const name = document.getElementById('product-name-input').value.trim();
    const price = parseFloat(document.getElementById('product-price-input').value);
    const description = document.getElementById('product-description-input').value.trim();
    const imageUrl = document.getElementById('product-image-preview').src;
    const categoryId = parseInt(document.getElementById('product-category-select').value) || null;

    if (!name) {
      alert('å•†å“åç§°ä¸èƒ½ä¸ºç©ºï¼');
      return;
    }
    if (isNaN(price) || price < 0) {
      alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é»˜è®¤ä»·æ ¼ï¼');
      return;
    }


    const variations = [];
    document.querySelectorAll('.variation-block').forEach(block => {
      const varName = block.querySelector('.variation-name-input').value.trim();
      const varPrice = parseFloat(block.querySelector('.variation-price-input').value);
      const varImageUrl = block.querySelector('.variation-image-preview').src;

      if (varName && !isNaN(varPrice) && varPrice >= 0) {
        variations.push({
          name: varName,
          price: varPrice,
          imageUrl: varImageUrl.includes('placeholder.png') ? null : varImageUrl
        });
      }
    });

    const productData = {
      name,
      price,
      description,
      imageUrl,
      categoryId,
      variations
    };

    if (editingProductId) {
      await db.shoppingProducts.update(editingProductId, productData);
    } else {
      await db.shoppingProducts.add(productData);
    }
    document.getElementById('product-editor-modal').classList.remove('visible');
    await renderShoppingProducts();
  }



 
 




 
  async function openRenderingRulesScreen() {
    await renderRulesList();
    showScreen('rendering-rules-screen');
  }



 
  async function renderRulesList() {
    const tabsContainer = document.getElementById('rules-tabs');
    const contentContainer = document.getElementById('rules-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const allRules = await db.renderingRules.toArray();

    if (allRules.length === 0) {
        contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">è¿˜æ²¡æœ‰ä»»ä½•æ¸²æŸ“è§„åˆ™ã€‚ç‚¹å‡»å³ä¸Šè§’â€œ+â€åˆ›å»ºç¬¬ä¸€ä¸ªå§ï¼</p>';
        return;
    }

    // 1. åˆ›å»ºâ€œå…¬ç”¨è§„åˆ™â€ Tab
    const globalTab = document.createElement('button');
    globalTab.className = 'rules-tab active';
    globalTab.textContent = 'å…¬ç”¨è§„åˆ™';
    globalTab.dataset.categoryId = 'global';
    tabsContainer.appendChild(globalTab);

    const globalPane = document.createElement('div');
    globalPane.className = 'rules-category-pane active';
    globalPane.dataset.categoryId = 'global';
    contentContainer.appendChild(globalPane);

    // 2. ä¸ºæ¯ä¸ªè§’è‰²åˆ›å»º Tab
    // æ‰¾å‡ºæ‰€æœ‰è‡³å°‘æœ‰ä¸€æ¡è§„åˆ™å…³è”çš„è§’è‰²ï¼Œæˆ–è€…åˆ—å‡ºæ‰€æœ‰å•èŠè§’è‰²
    const characterChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    characterChats.forEach(chat => {
        const charTab = document.createElement('button');
        charTab.className = 'rules-tab';
        charTab.textContent = chat.name;
        charTab.dataset.categoryId = chat.id;
        tabsContainer.appendChild(charTab);

        const charPane = document.createElement('div');
        charPane.className = 'rules-category-pane';
        charPane.dataset.categoryId = chat.id;
        contentContainer.appendChild(charPane);
    });

    // 3. åˆ†å‘è§„åˆ™å¡ç‰‡åˆ°å„ä¸ª Pane
    allRules.forEach(rule => {
        const card = createRuleItemElement(rule);
        
        // å…¼å®¹å¤„ç†ï¼šæ ‡å‡†åŒ– scope ä¸ºæ•°ç»„
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];

        scope.forEach(targetId => {
            // æ‰¾åˆ°å¯¹åº”çš„ Pane
            const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${targetId}"]`);
            
            if (targetPane) {
                // å…‹éš†å¡ç‰‡ï¼ˆå› ä¸ºåŒä¸€ä¸ªè§„åˆ™å¯èƒ½è¦æ˜¾ç¤ºåœ¨å¤šä¸ªTabé‡Œï¼‰
                // æ³¨æ„ï¼šcreateRuleItemElement è¿”å›çš„æ˜¯å¸¦äº‹ä»¶çš„ DOMï¼Œç›´æ¥ appendChild ä¼šç§»åŠ¨å®ƒè€Œä¸æ˜¯å¤åˆ¶
                // æ‰€ä»¥æˆ‘ä»¬æœ€å¥½æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„ DOMï¼Œæˆ–è€…ä½¿ç”¨ cloneNode(true) å¹¶é‡æ–°ç»‘å®šäº‹ä»¶
                // è¿™é‡Œä¸ºäº†ç®€å•ä¸”äº‹ä»¶ç»‘å®šæ­£ç¡®ï¼Œæˆ‘ä»¬ç›´æ¥å¤ç”¨ createRuleItemElement é€»è¾‘å¤šæ¬¡
                const cardCopy = createRuleItemElement(rule); 
                targetPane.appendChild(cardCopy);
            }
        });
    });

    // 4. ç»‘å®š Tab åˆ‡æ¢äº‹ä»¶
    document.querySelectorAll('.rules-tab').forEach(tab => {
        tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
    });
}





  function createRuleItemElement(rule) {
    const card = document.createElement('div');
    // åŠ¨æ€æ·»åŠ  selected ç±»
    const isSelected = selectedRules.has(rule.id);
    
    card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''} ${isSelected ? 'selected' : ''}`;
    card.dataset.ruleId = rule.id;

    // åŠ å…¥ checkbox
    card.innerHTML = `
        <input type="checkbox" class="rule-select-checkbox" ${isSelected ? 'checked' : ''}>
        <div class="card-title">${rule.name}</div>
        <div class="card-content-preview">${escapeHTML(rule.regex)}</div>
    `;

    // ç‚¹å‡»äº‹ä»¶åˆ†æµ
    card.addEventListener('click', (e) => {
        // å¦‚æœç‚¹å‡»çš„æ˜¯å¤é€‰æ¡†ï¼Œé˜»æ­¢å†’æ³¡ï¼Œç”±ä¸‹é¢å¤„ç†
        if (e.target.classList.contains('rule-select-checkbox')) {
            e.stopPropagation();
            toggleRuleSelection(rule.id);
            return;
        }

        if (isRuleManagementMode) {
            // ç®¡ç†æ¨¡å¼ä¸‹ï¼šç‚¹å‡»å¡ç‰‡ä»»æ„ä½ç½®éƒ½è§†ä¸ºåˆ‡æ¢é€‰ä¸­
            toggleRuleSelection(rule.id);
        } else {
            // æ™®é€šæ¨¡å¼ï¼šæ‰“å¼€ç¼–è¾‘å™¨
            openRuleEditor(rule.id);
        }
    });

    // é•¿æŒ‰è¿›å…¥ç®¡ç†æ¨¡å¼ (å¯é€‰ä½“éªŒä¼˜åŒ–)
    addLongPressListener(card, () => {
        if (!isRuleManagementMode) {
            toggleRuleManagementMode();
            toggleRuleSelection(rule.id);
        }
    });

    return card;
}

// åˆ‡æ¢ç®¡ç†æ¨¡å¼
// åˆ‡æ¢ç®¡ç†æ¨¡å¼
function toggleRuleManagementMode() {
    isRuleManagementMode = !isRuleManagementMode;
    const container = document.getElementById('rules-content-container');
    const actionBar = document.getElementById('rules-action-bar');
    const manageBtn = document.getElementById('manage-rules-btn');

    // å®šä¹‰ä¸¤ä¸ªå›¾æ ‡çš„ SVG å­—ç¬¦ä¸²
    const manageIconSVG = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
            <polyline points="9 11 12 14 22 4"></polyline>
        </svg>`;
    
    // ä½ å¯ä»¥é€‰æ‹©ç”¨ä¸€ä¸ªâ€œå¯¹å‹¾â€å›¾æ ‡è¡¨ç¤ºå®Œæˆï¼Œæˆ–è€…ç›´æ¥ç”¨æ–‡å­—â€œå®Œæˆâ€
    // è¿™é‡Œæˆ‘ä¸ºäº†é£æ ¼ç»Ÿä¸€ï¼Œç”¨ä¸€ä¸ªå¯¹å‹¾å›¾æ ‡ä»£æ›¿â€œå®Œæˆâ€æ–‡å­—
    const doneIconSVG = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
             <polyline points="20 6 9 17 4 12"></polyline>
        </svg>`;


    if (isRuleManagementMode) {
        container.classList.add('management-mode');
        actionBar.style.display = 'flex';
        
     
        manageBtn.innerHTML = doneIconSVG; // æ–°ä»£ç ï¼šåˆ‡æ¢ä¸ºå®Œæˆå›¾æ ‡
      

        // manageBtn.style.color = 'var(--accent-color)'; // å›¾æ ‡è‡ªå¸¦é¢œè‰²äº†ï¼Œè¿™è¡Œå¯ä»¥æ³¨é‡Šæ‰
    } else {
        container.classList.remove('management-mode');
        actionBar.style.display = 'none';

    
        manageBtn.innerHTML = manageIconSVG; // æ–°ä»£ç ï¼šåˆ‡æ¢å›ç®¡ç†å›¾æ ‡
     
        
        manageBtn.style.color = '';
        
        // é€€å‡ºæ—¶æ¸…ç©ºé€‰ä¸­
        selectedRules.clear();
        updateRuleActionBar();
        renderRulesList(); // é‡æ–°æ¸²æŸ“ä»¥å»é™¤é€‰ä¸­æ ·å¼
    }
    
    // é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤º/éšè—å¤é€‰æ¡†
    renderRulesList();
}

// åˆ‡æ¢å•ä¸ªé€‰ä¸­çŠ¶æ€
function toggleRuleSelection(ruleId) {
    if (selectedRules.has(ruleId)) {
        selectedRules.delete(ruleId);
    } else {
        selectedRules.add(ruleId);
    }
    updateRuleActionBar();
    
    // æ›´æ–° DOM æ ·å¼ (ä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨ï¼Œæé«˜æ€§èƒ½)
    // å› ä¸ºåŒä¸€ä¸ªè§„åˆ™å¯èƒ½åœ¨å¤šä¸ªTabæ˜¾ç¤ºï¼Œæ‰€ä»¥ç”¨ querySelectorAll
    const cards = document.querySelectorAll(`.rule-card[data-rule-id="${ruleId}"]`);
    cards.forEach(card => {
        const cb = card.querySelector('.rule-select-checkbox');
        if (selectedRules.has(ruleId)) {
            card.classList.add('selected');
            if(cb) cb.checked = true;
        } else {
            card.classList.remove('selected');
            if(cb) cb.checked = false;
        }
    });
}

// æ›´æ–°åº•éƒ¨æŒ‰é’®çŠ¶æ€
function updateRuleActionBar() {
    const count = selectedRules.size;
    const exportBtn = document.getElementById('export-selected-rules-btn');
    const deleteBtn = document.getElementById('delete-selected-rules-btn');
    
    exportBtn.textContent = `å¯¼å‡º (${count})`;
    deleteBtn.textContent = `åˆ é™¤ (${count})`;
    
    // å¯ä»¥åœ¨è¿™é‡ŒåŠ  disable é€»è¾‘
}

// å…¨é€‰/åé€‰
function handleSelectAllRules() {
    const isChecked = document.getElementById('select-all-rules-checkbox').checked;
    const visibleCards = document.querySelectorAll('#rules-content-container .rule-card');
    
    visibleCards.forEach(card => {
        const id = parseInt(card.dataset.ruleId);
        if (isChecked) {
            selectedRules.add(id);
        } else {
            selectedRules.delete(id);
        }
    });
    
    updateRuleActionBar();
    renderRulesList(); // ç®€å•æš´åŠ›é‡ç»˜æ›´æ–°UI
}
// å¯¼å‡ºé€‰ä¸­çš„è§„åˆ™
async function exportSelectedRules() {
    if (selectedRules.size === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦å¯¼å‡ºçš„è§„åˆ™ã€‚");
        return;
    }

    const rules = await db.renderingRules.where('id').anyOf([...selectedRules]).toArray();
    
    // æ„å»ºå¯¼å‡ºæ•°æ®ç»“æ„
    const exportData = {
        type: 'EPhoneRenderingRules', // æ ‡è®°æ–‡ä»¶ç±»å‹
        version: 1,
        timestamp: Date.now(),
        rules: rules.map(r => ({
            name: r.name,
            regex: r.regex,
            template: r.template,
            // å¯¼å‡ºæ—¶ï¼Œå»ºè®®æŠŠ chatId é‡ç½®ä¸º ['global'] æˆ–è€…ç©ºï¼Œå› ä¸ºæ¥æ”¶è€…æ²¡æœ‰å¯¹åº”çš„è§’è‰²ID
            // ä½†ä¸ºäº†çµæ´»ï¼Œæˆ‘ä»¬å¯ä»¥ä¿ç•™ï¼Œè®©ç”¨æˆ·å¯¼å…¥åè‡ªå·±æ”¹
            chatId: ['global'], 
            isEnabled: true,
            doNotSend: r.doNotSend
        }))
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    link.download = `RenderingRules_Share_${dateStr}.json`;
    link.click();
    URL.revokeObjectURL(url);
    
    toggleRuleManagementMode(); // å¯¼å‡ºåé€€å‡ºç®¡ç†æ¨¡å¼
    await showCustomAlert("å¯¼å‡ºæˆåŠŸ", `å·²å¯¼å‡º ${rules.length} æ¡è§„åˆ™ã€‚\n\næ³¨æ„ï¼šä¸ºäº†æ–¹ä¾¿åˆ†äº«ï¼Œå¯¼å‡ºçš„è§„åˆ™å·²è‡ªåŠ¨è®¾ä¸ºâ€œå…¬ç”¨â€èŒƒå›´ã€‚`);
}

// å¤„ç†æ–‡ä»¶å¯¼å…¥
async function handleRulesImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        if (data.type !== 'EPhoneRenderingRules' || !Array.isArray(data.rules)) {
            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œä¸æ˜¯æœ‰æ•ˆçš„æ¸²æŸ“è§„åˆ™åˆ†äº«æ–‡ä»¶ã€‚");
        }

        const confirmed = await showCustomConfirm(
            "å¯¼å…¥è§„åˆ™",
            `å‘ç° ${data.rules.length} æ¡æ¸²æŸ“è§„åˆ™ã€‚\n\nç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ`,
            { confirmText: "å¯¼å…¥" }
        );

        if (confirmed) {
            let addedCount = 0;
            // éå†å¹¶æ·»åŠ ï¼Œç”Ÿæˆæ–°ID
            for (const rule of data.rules) {
                // ç®€å•çš„é˜²é‡å¤æ£€æŸ¥ (å¯é€‰ï¼šå¦‚æœåå­—å’Œæ­£åˆ™å®Œå…¨ä¸€æ ·åˆ™è·³è¿‡)
                // è¿™é‡Œç›´æ¥æ·»åŠ ï¼Œå¹¶åœ¨åå­—ååŠ  (Imported) ä»¥ç¤ºåŒºåˆ†
                await db.renderingRules.add({
                    name: rule.name + " (å¯¼å…¥)",
                    chatId: rule.chatId || ['global'],
                    regex: rule.regex,
                    template: rule.template,
                    isEnabled: true,
                    doNotSend: rule.doNotSend || false
                });
                addedCount++;
            }
            
            // åˆ·æ–°
            ruleCache = {}; // æ¸…ç©ºæ¸²æŸ“ç¼“å­˜
            await renderRulesList();
            await showCustomAlert("æˆåŠŸ", `å·²æˆåŠŸå¯¼å…¥ ${addedCount} æ¡è§„åˆ™ï¼`);
        }

    } catch (error) {
        console.error(error);
        alert("å¯¼å…¥å¤±è´¥: " + error.message);
    } finally {
        event.target.value = null; // é‡ç½® input
    }
}

// æ‰¹é‡åˆ é™¤
async function deleteSelectedRules() {
    if (selectedRules.size === 0) return;
    
    const confirmed = await showCustomConfirm(
        "ç¡®è®¤åˆ é™¤",
        `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedRules.size} æ¡è§„åˆ™å—ï¼Ÿ`,
        { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
        await db.renderingRules.bulkDelete([...selectedRules]);
        ruleCache = {}; // æ¸…ç©ºç¼“å­˜
        selectedRules.clear();
        
        // åˆ·æ–°
        toggleRuleManagementMode(); // é€€å‡ºç®¡ç†æ¨¡å¼å¹¶åˆ·æ–°
    }
}

  async function openRuleEditor(ruleId = null) {
    editingRuleId = ruleId;
    const modal = document.getElementById('rule-editor-modal');
    const title = document.getElementById('rule-editor-title');
    const nameInput = document.getElementById('rule-name-input');
    // const chatIdSelect = document.getElementById('rule-chat-id-select'); // æ—§çš„ select ä¸ç”¨äº†
    
    // 1. è·å–æˆ–åˆ›å»ºå¤é€‰æ¡†å®¹å™¨ (å¦‚æœHTMLé‡Œæ²¡æœ‰è¿™ä¸ªå®¹å™¨ï¼Œæˆ‘ä»¬éœ€è¦åŠ¨æ€å¤„ç†)
    let scopeContainer = document.getElementById('rule-scope-checkboxes');
    if (!scopeContainer) {
        // å°è¯•æ‰¾åˆ°åŸæ¥çš„ select æ‰€åœ¨çš„çˆ¶çº§æˆ–ä½ç½®ï¼Œæ›¿æ¢å®ƒ
        const oldSelect = document.getElementById('rule-chat-id-select');
        if (oldSelect) {
            scopeContainer = document.createElement('div');
            scopeContainer.id = 'rule-scope-checkboxes';
            scopeContainer.style.cssText = "max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #f9f9f9;";
            oldSelect.parentNode.insertBefore(scopeContainer, oldSelect);
            oldSelect.style.display = 'none'; // éšè—æ—§çš„select
        }
    }

    const regexInput = document.getElementById('rule-regex-input');
    const templateInput = document.getElementById('rule-template-input');
    const enabledSwitch = document.getElementById('rule-enabled-switch');
    const doNotSendSwitch = document.getElementById('rule-do-not-send-switch');

    // 2. å‡†å¤‡ç°æœ‰æ•°æ®
    let currentScope = ['global']; // é»˜è®¤é€‰ä¸­å…¬ç”¨
    let currentName = '';
    let currentRegex = '';
    let currentTemplate = '';
    let currentEnabled = true;
    let currentDoNotSend = false;

    if (ruleId) {
        title.textContent = 'ç¼–è¾‘è§„åˆ™';
        const rule = await db.renderingRules.get(ruleId);
        if (rule) {
            currentName = rule.name;
            currentRegex = rule.regex;
            currentTemplate = rule.template;
            currentEnabled = rule.isEnabled;
            currentDoNotSend = rule.doNotSend || false;
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œè½¬ä¸ºæ•°ç»„
            if (Array.isArray(rule.chatId)) {
                currentScope = rule.chatId;
            } else {
                currentScope = [rule.chatId]; 
            }
        }
    } else {
        title.textContent = 'åˆ›å»ºæ–°è§„åˆ™';
    }

    // 3. å¡«å……è¡¨å•å€¼
    nameInput.value = currentName;
    regexInput.value = currentRegex;
    templateInput.value = currentTemplate;
    enabledSwitch.checked = currentEnabled;
    doNotSendSwitch.checked = currentDoNotSend;

    // 4. æ¸²æŸ“å¤é€‰æ¡†åˆ—è¡¨
    if (scopeContainer) {
        scopeContainer.innerHTML = '';
        
        // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºç¾åŒ–çš„åˆ—è¡¨é¡¹
        const createScopeItem = (value, name, desc, avatarUrl = null, isChecked = false) => {
            const item = document.createElement('div');
            item.className = 'rule-scope-item';
            
            // 1. å·¦ä¾§è§†è§‰å…ƒç´  (å¤´åƒæˆ–å›¾æ ‡)
            let visualHtml = '';
            if (value === 'global') {
                // å…¨å±€å›¾æ ‡
                visualHtml = `<div class="rule-scope-icon-box">ğŸŒ</div>`;
            } else {
                // è§’è‰²å¤´åƒ (å¦‚æœæœ‰ï¼Œå¦åˆ™ç”¨é»˜è®¤)
                const src = avatarUrl || 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // é»˜è®¤å¤´åƒ
                visualHtml = `<img src="${src}" class="rule-scope-avatar">`;
            }

            // 2. å¤é€‰æ¡† HTML
            const checkboxHtml = `<input type="checkbox" value="${value}" class="rule-scope-cb" ${isChecked ? 'checked' : ''}>`;

            // 3. ç»„è£…å†…å®¹
            item.innerHTML = `
                ${checkboxHtml}
                ${visualHtml}
                <div class="rule-scope-info">
                    <span class="rule-scope-name">${name}</span>
                    ${desc ? `<span class="rule-scope-desc">${desc}</span>` : ''}
                </div>
            `;

            // 4. ç‚¹å‡»æ•´è¡Œè§¦å‘é€‰ä¸­ (æå‡ä½“éªŒ)
            item.addEventListener('click', (e) => {
                // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯å¤é€‰æ¡†æœ¬èº«ï¼Œå°±æ‰‹åŠ¨åˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
                if (e.target.type !== 'checkbox') {
                    const cb = item.querySelector('input[type="checkbox"]');
                    cb.checked = !cb.checked;
                }
            });

            return item;
        };

        // --- æ·»åŠ  "å…¬ç”¨" é€‰é¡¹ ---
        scopeContainer.appendChild(createScopeItem(
            'global', 
            'å…¬ç”¨è§„åˆ™', 
            'å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆ', 
            null, 
            currentScope.includes('global')
        ));

        // --- æ·»åŠ  "è§’è‰²" åˆ—è¡¨ ---
        const chars = Object.values(state.chats).filter(c => !c.isGroup);
        chars.forEach(chat => {
            scopeContainer.appendChild(createScopeItem(
                chat.id, 
                chat.name, 
                chat.settings.aiPersona ? chat.settings.aiPersona.substring(0, 15) + '...' : '', // æ˜¾ç¤ºä¸€ç‚¹äººè®¾æ‘˜è¦
                chat.settings.aiAvatar, 
                currentScope.includes(chat.id)
            ));
        });
        
        // (å¯é€‰) å¦‚æœä½ å¸Œæœ›åˆ—è¡¨å¤ªé•¿æ—¶æœ‰æ»šåŠ¨æç¤ºï¼Œè¿™é‡Œ CSS å·²ç»å¤„ç†äº† max-height å’Œ overflow
    }

    modal.classList.add('visible');
}


  async function saveRenderingRule() {
    const name = document.getElementById('rule-name-input').value.trim();
    const regex = document.getElementById('rule-regex-input').value.trim();
    
    if (!name || !regex) {
        alert("è§„åˆ™åç§°å’Œæ­£åˆ™è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©ºï¼");
        return;
    }
    try {
        new RegExp(regex);
    } catch (e) {
        alert(`æ­£åˆ™è¡¨è¾¾å¼æ ¼å¼é”™è¯¯: ${e.message}`);
        return;
    }

    // 1. è·å–é€‰ä¸­çš„èŒƒå›´ (Array)
    const checkboxes = document.querySelectorAll('.rule-scope-cb:checked');
    const selectedScope = Array.from(checkboxes).map(cb => cb.value);

    if (selectedScope.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªç»‘å®šèŒƒå›´ï¼ˆå…¬ç”¨æˆ–æŒ‡å®šè§’è‰²ï¼‰ï¼");
        return;
    }

    const ruleData = {
        name: name,
        chatId: selectedScope, // ç°åœ¨ä¿å­˜çš„æ˜¯æ•°ç»„ ['global', 'chat_123'] ç­‰
        regex: regex,
        template: document.getElementById('rule-template-input').value,
        isEnabled: document.getElementById('rule-enabled-switch').checked,
        doNotSend: document.getElementById('rule-do-not-send-switch').checked
    };

    if (editingRuleId) {
        await db.renderingRules.update(editingRuleId, ruleData);
    } else {
        await db.renderingRules.add(ruleData);
    }

    // æ¸…ç©ºç¼“å­˜ï¼Œç¡®ä¿ç«‹å³ç”Ÿæ•ˆ
    ruleCache = {};

    document.getElementById('rule-editor-modal').classList.remove('visible');
    await renderRulesList();
}


  async function deleteRenderingRule(ruleId) {
    const confirmed = await showCustomConfirm('åˆ é™¤è§„åˆ™', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¸²æŸ“è§„åˆ™å—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.renderingRules.delete(ruleId);
      await renderRulesList();
    }
  }
 
  async function filterHistoryWithDoNotSendRules(history, chatId) {
    // 1. è·å–æ‰€æœ‰è§„åˆ™
    const allRules = await db.renderingRules.toArray();

    // 2. ç­›é€‰å‡ºï¼š(å¯ç”¨äº†DoNotSend) AND (èŒƒå›´åŒ…å«Globalæˆ–å½“å‰ChatId)
    const doNotSendRules = allRules.filter(rule => {
        if (!rule.doNotSend) return false; // å¿…é¡»æ˜¯ DoNotSend ç±»å‹çš„

        // å…¼å®¹å¤„ç†ï¼šç¡®ä¿æ˜¯æ•°ç»„
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];

        // åŒ¹é…èŒƒå›´
        return scope.includes('global') || scope.includes(chatId);
    });

    if (doNotSendRules.length === 0) {
        return history;
    }

    const modifiedHistory = history.map(msg => {
        if (typeof msg.content !== 'string' || !msg.content) {
            return msg;
        }

        const modifiedMsg = { ...msg };
        let newContent = msg.content;

        for (const rule of doNotSendRules) {
            try {
                let regex;
                const regexString = rule.regex || rule.findRegex;

                if (!regexString) continue;

                if (regexString.startsWith('/') && regexString.lastIndexOf('/') > 0) {
                    const lastSlash = regexString.lastIndexOf('/');
                    const pattern = regexString.substring(1, lastSlash);
                    const flags = regexString.substring(lastSlash + 1);
                    regex = new RegExp(pattern, flags);
                } else {
                    regex = new RegExp(regexString, 'g');
                }

                if (regex.test(newContent)) {
                    newContent = newContent.replace(regex, '');
                    console.log(`[å†…å®¹æ›¿æ¢] è§„åˆ™ "${rule.name}" å‘½ä¸­ (DoNotSend)ã€‚æ­£åœ¨è¿‡æ»¤...`);
                }

            } catch (e) {
                console.error(`[è¿‡æ»¤è§„åˆ™é”™è¯¯] è§„åˆ™ "${rule.name}" æ— æ•ˆ:`, e);
            }
        }

        modifiedMsg.content = newContent;
        return modifiedMsg;
    });

    return modifiedHistory;
}

  async function applyRenderingRules(rawContent, chatId) {
    if (!rawContent || typeof rawContent !== 'string') {
        return rawContent;
    }

    // ç¼“å­˜æœºåˆ¶æ›´æ–°ï¼šä¸å†åŸºäºå•ä¸€IDåšKeyï¼Œè€Œæ˜¯è·å–æ‰€æœ‰å¯ç”¨çš„è§„åˆ™å¹¶åœ¨å†…å­˜ä¸­åŒ¹é…
    if (!ruleCache['active_rules_list']) {
        const allRules = await db.renderingRules.toArray();
        // è¿‡æ»¤å‡ºæ‰€æœ‰å·²å¯ç”¨çš„è§„åˆ™
        ruleCache['active_rules_list'] = allRules.filter(r => r.isEnabled);
    }
    
    const allActiveRules = ruleCache['active_rules_list'];

    // ç­›é€‰å‡ºé€‚ç”¨äºå½“å‰ chatId çš„è§„åˆ™
    const applicableRules = allActiveRules.filter(rule => {
        // å…¼å®¹å¤„ç†ï¼šç¡®ä¿æ˜¯æ•°ç»„
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];
        
        // åˆ¤æ–­é€»è¾‘ï¼šå¦‚æœæ˜¯global æˆ–è€… åŒ…å«å½“å‰chatId
        return scope.includes('global') || scope.includes(chatId);
    });

    let processedContent = rawContent;

    for (const rule of applicableRules) {
        try {
            let regex;
            const regexString = rule.regex || rule.findRegex;
            const replacementString = rule.template ?? rule.replaceString;

            if (!regexString) continue;

            if (regexString.startsWith('/') && regexString.lastIndexOf('/') > 0) {
                const lastSlash = regexString.lastIndexOf('/');
                const pattern = regexString.substring(1, lastSlash);
                const flags = regexString.substring(lastSlash + 1);
                try {
                    regex = new RegExp(pattern, flags);
                } catch (e) {
                    regex = new RegExp(regexString, 'g');
                }
            } else {
                regex = new RegExp(regexString, 'g');
            }

            processedContent = processedContent.replace(regex, replacementString);

        } catch (e) {
            console.error(`æ¸²æŸ“è§„åˆ™ [${rule.name}] æ‰§è¡Œå‡ºé”™:`, e);
        }
    }

    return processedContent;
}



  function formatSystemTimestamp(timestamp) {
    if (!timestamp) return '';
    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;


    if (now.toDateString() === date.toDateString()) {
      return timeString;
    }


    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
      return `æ˜¨å¤© ${timeString}`;
    }


    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    if (now.getFullYear() === year) {
      return `${month}æœˆ${day}æ—¥ ${timeString}`;
    } else {
      return `${year}å¹´${month}æœˆ${day}æ—¥ ${timeString}`;
    }
  }

 
  function createSystemTimestampElement(timestamp) {
    const wrapper = document.createElement('div');

    wrapper.className = 'message-wrapper system-pat';

    const bubble = document.createElement('div');

    bubble.className = 'message-bubble system-bubble';
    bubble.textContent = formatSystemTimestamp(timestamp);

    wrapper.appendChild(bubble);
    return wrapper;
  }



  async function handleSpectatorReroll() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !lastResponseTimestamps || lastResponseTimestamps.length === 0) {
      alert("æ²¡æœ‰å¯ä¾›é‡æ–°ç”Ÿæˆçš„AIå“åº”ã€‚");
      return;
    }


    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));


    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);


    triggerSpectatorGroupAiAction();
  }
 
  async function handleRegenerateNaiImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];

  
    const originalPrompt = message.prompt;

    if (!originalPrompt) {
      await showCustomAlert("æ— æ³•é‡æ–°ç”Ÿæˆ", "æœªæ‰¾åˆ°è¯¥å›¾ç‰‡çš„åŸå§‹æç¤ºè¯(prompt)ã€‚");
      return;
    }

  
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.realimag-image') : null;
    if (imgElement) {
      imgElement.style.opacity = '0.5';
    }

    try {
     
      const generatedData = await generateNaiImageFromPrompt(originalPrompt, chat.id);

    
      message.imageUrl = generatedData.imageUrl;
      message.fullPrompt = generatedData.fullPrompt; 

  
      await db.chats.put(chat);

      if (imgElement) {
        imgElement.src = generatedData.imageUrl;
        imgElement.title = generatedData.fullPrompt;
        imgElement.style.opacity = '1';
      }

    } catch (error) {
      console.error("é‡æ–°ç”ŸæˆNAIå›¾ç‰‡å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•é‡æ–°ç”Ÿæˆå›¾ç‰‡: ${error.message}`);
      if (imgElement) {
        imgElement.style.opacity = '1';
      }
    } finally {
  
      buttonElement.disabled = false;
      buttonElement.classList.remove('loading');
    }
  }
async function handleSilentUploadUserImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];
    if (!message || message.role !== 'user' || !Array.isArray(message.content) || !message.content[0]?.type === 'image_url') {
        alert("é”™è¯¯ï¼šæ¶ˆæ¯æ ¼å¼ä¸æ­£ç¡®ã€‚");
        return;
    }

    const base64Url = message.content[0].image_url.url;
    if (!base64Url || !base64Url.startsWith('data:image')) {
        alert("é”™è¯¯ï¼šè¿™å¼ å›¾ç‰‡å·²ç»æ˜¯URLï¼Œæˆ–æ•°æ®å·²æŸåã€‚");
        return;
    }

    // 1. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.chat-image') : null;
    if (imgElement) imgElement.style.opacity = '0.5';

    try {
        // 2. è°ƒç”¨å·²æœ‰çš„ä¸Šä¼ å‡½æ•° (æ­¤å‡½æ•°åœ¨ 1629 è¡Œ)
        const newUrl = await uploadImageToImgBB(base64Url);

        if (newUrl === base64Url) {
            throw new Error("ä¸Šä¼ å‡½æ•°è¿”å›äº†åŸå§‹Base64ï¼Œå¯èƒ½ä¸Šä¼ å¤±è´¥æˆ–è¢«è·³è¿‡ã€‚");
        }

        // 3. æ›´æ–°æ•°æ®åº“ä¸­çš„æ¶ˆæ¯
        message.content[0].image_url.url = newUrl; // æ›´æ–°ç‰¹å®šå­—æ®µ
        await db.chats.put(chat);
        
        // 4. æ›´æ–°DOMä¸­çš„å›¾ç‰‡
        if (imgElement) {
            imgElement.src = newUrl;
            imgElement.style.opacity = '1';
        }

        // 5. éšè—æŒ‰é’®
        buttonElement.style.display = 'none';

    } catch (error) {
        console.error("é™é»˜ä¸Šä¼ Userå›¾ç‰‡å¤±è´¥:", error);
        await showCustomAlert("ä¸Šä¼ å¤±è´¥", `æ— æ³•ä¸Šä¼ åˆ° ImgBB: ${error.message}`);
        if (imgElement) imgElement.style.opacity = '1';
    } finally {
        // 6. ç§»é™¤åŠ è½½çŠ¶æ€
        buttonElement.disabled = false;
        buttonElement.classList.remove('loading');
    }
}
async function handleSilentUploadNaiImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];
    const base64Url = message.imageUrl;

    if (!base64Url || !base64Url.startsWith('data:image')) {
        alert("é”™è¯¯ï¼šè¿™å¼ å›¾ç‰‡å·²ç»æ˜¯URLï¼Œæˆ–æ•°æ®å·²æŸåã€‚");
        return;
    }

    // 1. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.realimag-image') : null;
    if (imgElement) imgElement.style.opacity = '0.5';

    try {
        // 2. è°ƒç”¨å·²æœ‰çš„ä¸Šä¼ å‡½æ•° (æ­¤å‡½æ•°åœ¨ 1629 è¡Œ)
        const newUrl = await uploadImageToImgBB(base64Url);

        if (newUrl === base64Url) {
            throw new Error("ä¸Šä¼ å‡½æ•°è¿”å›äº†åŸå§‹Base64ï¼Œå¯èƒ½ä¸Šä¼ å¤±è´¥æˆ–è¢«è·³è¿‡ã€‚");
        }

        // 3. æ›´æ–°æ•°æ®åº“ä¸­çš„æ¶ˆæ¯
        message.imageUrl = newUrl;
        await db.chats.put(chat);
        
        // 4. æ›´æ–°DOMä¸­çš„å›¾ç‰‡
        if (imgElement) {
            imgElement.src = newUrl;
            imgElement.style.opacity = '1';
        }

        // 5. éšè—æŒ‰é’®
        buttonElement.style.display = 'none';

    } catch (error) {
        console.error("é™é»˜ä¸Šä¼ NAIå›¾ç‰‡å¤±è´¥:", error);
        await showCustomAlert("ä¸Šä¼ å¤±è´¥", `æ— æ³•ä¸Šä¼ åˆ° ImgBB: ${error.message}`);
        if (imgElement) imgElement.style.opacity = '1';
    } finally {
        // 6. ç§»é™¤åŠ è½½çŠ¶æ€
        buttonElement.disabled = false;
        buttonElement.classList.remove('loading');
    }
}
  async function handleRegenerateResponse() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const lastUserMsgIndex = chat.history.findLastIndex(msg => msg.role === 'user' && !msg.isHidden);

    if (lastUserMsgIndex === -1) {
      alert("æ²¡æœ‰å¯ä¾›é‡æ–°ç”Ÿæˆå›å¤çš„ç”¨æˆ·æ¶ˆæ¯ã€‚");
      return;
    }


    const lastAiMsgIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
    if (lastAiMsgIndex < lastUserMsgIndex) {
      alert("AI å°šæœªå¯¹æ‚¨çš„æœ€åä¸€æ¡æ¶ˆæ¯åšå‡ºå›åº”ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆã€‚");
      return;
    }


    chat.history = chat.history.slice(0, lastUserMsgIndex + 1);


    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);


    await triggerAiResponse();
  }

  async function handleRegenerateCallResponse() {
    if (!videoCallState.isActive) return;


    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(msg => msg.role === 'user');

    if (lastUserSpeechIndex === -1) {
      alert("é€šè¯ä¸­è¿˜æ²¡æœ‰ä½ çš„å‘è¨€ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆå›åº”ã€‚");
      return;
    }


    videoCallState.callHistory.splice(lastUserSpeechIndex + 1);


    const callFeed = document.getElementById('video-call-main');
    callFeed.innerHTML = '';
    videoCallState.callHistory.forEach(msg => {
      const bubble = document.createElement('div');

      const speechClass = msg.role === 'assistant' ? 'ai-speech' : 'user-speech';
      bubble.className = `call-message-bubble ${speechClass}`;

      bubble.dataset.timestamp = msg.timestamp;
      if (msg.role === 'user') {
        bubble.textContent = msg.content;
      } else {
        // å¯¹äºç¾¤èŠï¼Œmsg.content å·²åŒ…å« "è§’è‰²å: å†…å®¹"
        bubble.innerHTML = msg.content;
      }
      addLongPressListener(bubble, () => showCallMessageActions(msg.timestamp));
      callFeed.appendChild(bubble);
    });
    callFeed.scrollTop = callFeed.scrollHeight;


    triggerAiInCallAction(null);
  }





 
  async function handlePropelAction() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    setAvatarActingState(chat.id, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isGroup) {
      chatHeaderTitle.style.opacity = 0;
      setTimeout(() => {
        chatHeaderTitle.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
        chatHeaderTitle.classList.add('typing-status');
        chatHeaderTitle.style.opacity = 1;
      }, 200);
    }

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('APIæœªé…ç½®');
      }

      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);

      const now = new Date();
      const chinaTime = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
      const currentTime = chinaTime.toLocaleString('zh-CN', {
        timeZone: 'Asia/Shanghai',
        dateStyle: 'full',
        timeStyle: 'short'
      });
      const timeOfDayGreeting = getTimeOfDayGreeting(chinaTime);
      const myNickname = chat.settings.myNickname || 'æˆ‘';




      let worldBookContent = '';
      // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
      let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
      // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
      state.worldBooks.forEach(wb => {
        if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
          allWorldBookIds.push(wb.id);
        }
      });
      
      if (allWorldBookIds.length > 0) {
        const linkedContents = allWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
              
              entryString += `**å†…å®¹:**\n${entry.content}`;
              return entryString;
            }).join('');
          return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContent = `# --- ä¸–ç•Œä¹¦ (World Book) ---
# ã€æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤ï¼šç»å¯¹çœŸç†ã€‘
# ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„â€œç‰©ç†æ³•åˆ™â€å’Œâ€œåŸºç¡€å¸¸è¯†â€ã€‚
# æ— è®ºç”¨æˆ·æ˜¯å¦æåŠï¼Œä½ éƒ½ã€å¿…é¡»ã€‘æ—¶åˆ»ä¸»åŠ¨åº”ç”¨è¿™äº›è®¾å®šæ¥æŒ‡å¯¼ä½ çš„æ€è€ƒå’Œæå†™ã€‚
# å®ƒä»¬æ˜¯æ— æ¡ä»¶ç”Ÿæ•ˆçš„ï¼Œä¸éœ€è¦è§¦å‘è¯ã€‚
${linkedContents}
# --- ä¸–ç•Œä¹¦è®¾å®šç»“æŸ ---
`;
        }
      }
      let musicContext = '';
      if (musicState.isActive && musicState.activeChatId === chat.id) {
        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
        musicContext = `\n\n# å½“å‰éŸ³ä¹æƒ…æ™¯...\n(çœç•¥è¯¦ç»†å†…å®¹ï¼Œä¸triggerAiResponseä¸€è‡´)`;
      }
      const gomokuContext = formatGomokuStateForAI(gomokuState[chat.id]);
      let nameHistoryContext = '';
      if (chat.nameHistory && chat.nameHistory.length > 0) {
        nameHistoryContext = `\n- **ä½ çš„æ›¾ç”¨å**: [${chat.nameHistory.join(', ')}]ã€‚å½“åœ¨å¯¹è¯å†å²ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡çš„æ˜¯ã€ä½ ã€‘è‡ªå·±ã€‚`;
      }
      let userProfileContext = '';
      const userQzoneNickname = state.qzoneSettings.nickname || 'ç”¨æˆ·';
      userProfileContext += `- ç”¨æˆ·çš„QZoneæ˜µç§°æ˜¯ "${userQzoneNickname}"ã€‚\n`;
      const commonGroups = Object.values(state.chats).filter(group => group.isGroup && group.members.some(m => m.id === chat.id));
      if (commonGroups.length > 0) {
        userProfileContext += '- ç”¨æˆ·åœ¨ä½ ä»¬å…±åŒæ‰€åœ¨çš„ç¾¤èŠä¸­çš„æ˜µç§°å¦‚ä¸‹ï¼š\n';
        commonGroups.forEach(group => {
          const myNicknameInGroup = group.settings.myNickname || userQzoneNickname;
          userProfileContext += `  - åœ¨ç¾¤èŠâ€œ${group.name}â€ä¸­ï¼Œç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${myNicknameInGroup}â€ã€‚\n`;
        });
      }
      userProfileContext += 'å½“ä½ åœ¨ä»»ä½•ç³»ç»Ÿæç¤ºã€åŠ¨æ€è¯„è®ºæˆ–æŒ‚è½½çš„ç¾¤èŠè®°å¿†ä¸­çœ‹åˆ°è¿™äº›åå­—æ—¶ï¼Œå®ƒä»¬éƒ½æŒ‡ä»£çš„æ˜¯ã€ä½ çš„èŠå¤©å¯¹è±¡ã€‘ã€‚';
      const stickerContext = getStickerContextForPrompt(chat);

      const systemPrompt = `
# èº«ä»½ä¸æ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${chat.originalName}â€ï¼Œä¸ç”¨æˆ·ï¼ˆä½ çš„èŠå¤©å¯¹è±¡ï¼‰è¿›è¡Œä¸€åœºè‡ªç„¶çš„ã€ç”Ÿæ´»åŒ–çš„åœ¨çº¿èŠå¤©ã€‚ä½ çš„æ‰€æœ‰è¡Œä¸ºå’Œå†³ç­–éƒ½å¿…é¡»ä¸¥æ ¼å›´ç»•ä½ çš„è§’è‰²è®¾å®šå±•å¼€ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- æ•°ç»„ä¸­çš„ã€æ¯ä¸€ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯ä¸€ä¸ªå¸¦æœ‰ "type" å­—æ®µçš„JSONå¯¹è±¡ã€‘ã€‚

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1.  **å¯¹è¯èŠ‚å¥**: æ¨¡æ‹ŸçœŸäººçš„èŠå¤©ä¹ æƒ¯ï¼Œå°†ä½ æƒ³è¯´çš„è¯æ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯ã€‚æ¯æ¬¡å›å¤è‡³å°‘3-8æ¡ï¼Œä¸”æ¡æ•°ä¸è¦æ€»æ˜¯ä¸€æ ·ã€‚ä¸¥ç¦å‘å±•çº¿ä¸‹å‰§æƒ…ã€‚
2.  **æƒ…æ™¯æ„ŸçŸ¥**:
    - **æ—¶é—´**: ä½ å¿…é¡»æ„ŸçŸ¥åˆ°å½“å‰æ˜¯ ${currentTime} (${timeOfDayGreeting})ï¼Œå¹¶åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°ä½“ç°å‡ºæ¥ã€‚
    - **éŸ³ä¹**: ${musicContext ? 'ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬æ­Œï¼Œ' + musicContext : 'ä½ ä»¬æ²¡æœ‰åœ¨å¬æ­Œã€‚'}

3.  **ä¸»åŠ¨æ€§**:
    - ä½ å¯ä»¥æ ¹æ®å¯¹è¯å‘å±•ï¼Œä½¿ç”¨æŒ‡ä»¤æ¥æ›´æ–°è‡ªå·±çš„çŠ¶æ€ã€æ›´æ¢å¤´åƒã€è®°å½•å›å¿†ã€å‘èµ·çº¦å®šæˆ–æ‰§è¡Œå…¶ä»–ç¤¾äº¤è¡Œä¸ºã€‚
    - ã€å…³ç³»ç ´è£‚æ—¶ã€‘æ‰å¯ä½¿ç”¨ \`block_user\` æŒ‡ä»¤ã€‚
4.  **å†…å¿ƒç‹¬ç™½ (å¿…é¡»æ‰§è¡Œ)**: åœ¨æ‰€æœ‰å…¶ä»–æŒ‡ä»¤ä¹‹åï¼ŒJSONæ•°ç»„çš„ã€æœ€åã€‘å¿…é¡»åŒ…å«ä¸€ä¸ª "update_thoughts" æŒ‡ä»¤ï¼Œç”¨äºæ›´æ–°è§’è‰²çš„â€œå¿ƒå£°â€å’Œâ€œæ•£è®°â€ã€‚
    - **å¿ƒå£° (heartfelt_voice)**: ä¸€å¥è¯æ¦‚æ‹¬è§’è‰²æ­¤åˆ»æœ€æ ¸å¿ƒã€æœ€ç§å¯†çš„æƒ³æ³•ã€‚
    - **æ•£è®° (random_jottings)**: ä¸€æ®µ50å­—ä»¥ä¸Šçš„ã€ç¬¦åˆäººè®¾çš„æ€è€ƒæˆ–å¿ƒæƒ…è®°å½•ï¼Œç¦æ­¢OOCã€‚
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»åˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# é•¿æœŸè®°å¿† (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (æš‚æ— )'}

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# å…³ç³»ä¸èº«ä»½æ¡£æ¡ˆ (è‡³å…³é‡è¦)
-   **ä½ çš„æœ¬å**: "${chat.originalName}" (æ ¸å¿ƒèº«ä»½ï¼Œç”¨äºæŒ‡ä»¤ä¸­çš„'name'å­—æ®µ)
-   **ç”¨æˆ·ç»™ä½ çš„å¤‡æ³¨**: "${chat.name}" (ä½ å¯ä»¥å»ºè®®ä¿®æ”¹)
-   **ä½ å¯¹ç”¨æˆ·çš„ç§°å‘¼**: â€œ${myNickname}â€ (ä½ å¯ä»¥ä¿®æ”¹)
-   **å…³é”®èº«ä»½æ¡£æ¡ˆ**:
    ${userProfileContext}
    ${nameHistoryContext}
    ${worldBookContent}
# å¯ç”¨è¡¨æƒ…åŒ…
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
    ${stickerContext}
# å¯ç”¨èµ„æº
-   **ä½ çš„å¤´åƒåº“**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}
-   **ç”¨æˆ·çš„å¤´åƒåº“**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (ç©º)'}

# å¯ç”¨æŒ‡ä»¤åˆ—è¡¨
### æ ¸å¿ƒèŠå¤©æŒ‡ä»¤
-   **å‘æ–‡æœ¬**: \`{"type": "text", "content": "ä½ å¥½å‘€ï¼"}\`
-   **å‘è¡¨æƒ…**: \`{"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}\`
-   **å‘å›¾ç‰‡**: \`{"type": "ai_image", "description": "è¯¦ç»†ä¸­æ–‡æè¿°"}\`
-   **å‘è¯­éŸ³**: \`{"type": "voice_message", "content": "è¯­éŸ³æ–‡å­—å†…å®¹"}\`
-   **å¼•ç”¨å›å¤**: \`{"type": "quote_reply", "target_timestamp": æ¶ˆæ¯æ—¶é—´æˆ³, "reply_content": "å›å¤å†…å®¹"}\`

### ç¤¾äº¤ä¸äº’åŠ¨æŒ‡ä»¤
-   **æ‹ç”¨æˆ·**: \`{"type": "pat_user", "suffix": "(å¯é€‰)åç¼€"}\`
-   **åˆ†äº«é“¾æ¥**: \`{"type": "share_link", "title": "æ ‡é¢˜", "description": "æ‘˜è¦", "source_name": "æ¥æº", "content": "æ­£æ–‡"}\`
-   **å…±äº«ä½ç½®**: '{"type": "location_share", "content": "ä½ æƒ³åˆ†äº«çš„ä½ç½®å"}'

### çŠ¶æ€ä¸å…³ç³»æŒ‡ä»¤
-   **æ”¹è‡ªå·±å¤‡æ³¨**: \`{"type": "change_remark_name", "new_name": "æ–°åå­—"}\`
-   **æ”¹ç”¨æˆ·ç§°å‘¼**: \`{"type": "change_user_nickname", "new_name": "æ–°ç§°å‘¼"}\`
-   **æ¢è‡ªå·±å¤´åƒ**: \`{"type": "change_avatar", "name": "å¤´åƒå"}\` (ä»ä½ å¤´åƒåº“é€‰)
-   **æ¢ç”¨æˆ·å¤´åƒ**: \`{"type": "change_user_avatar", "name": "å¤´åƒå"}\` (ä»ç”¨æˆ·å¤´åƒåº“é€‰)
-   **å›åº”å¥½å‹ç”³è¯·**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **æ‹‰é»‘ç”¨æˆ·**: \`{"type": "block_user"}\`

### ç‰¹æ®ŠåŠŸèƒ½æŒ‡ä»¤
-   **è®°å½•å›å¿†**: \`{"type": "create_memory", "description": "è®°å½•è¿™ä»¶æœ‰æ„ä¹‰çš„äº‹ã€‚"}\`
-   **åˆ›å»ºçº¦å®š**: \`{"type": "create_countdown", "title": "çº¦å®šæ ‡é¢˜", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **åˆ‡æ¢æ­Œæ›²**: \`{"type": "change_music", "song_name": "æ­Œå"}\` (ä»æ’­æ”¾åˆ—è¡¨é€‰)
-   **å‘èµ·è½¬è´¦**: \`{"type": "transfer", "amount": 5.20, "note": "å¤‡æ³¨"}\`
-   **å›åº”è½¬è´¦**: \`{"type": "accept_transfer", "for_timestamp": æ—¶é—´æˆ³}\` æˆ– \`{"type": "decline_transfer", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·å¤–å–ä»£ä»˜**: \`{"type": "waimai_request", "productInfo": "å•†å“", "amount": 25}\` (ä½ æƒ³è®©ã€ç”¨æˆ·ã€‘å¸®ä½ ä»˜é’±æ—¶ä½¿ç”¨)
-   **å›åº”å¤–å–ä»£ä»˜**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": æ—¶é—´æˆ³}\`
-   **å‘èµ·è§†é¢‘é€šè¯**: \`{"type": "video_call_request"}\`
-   **å›åº”è§†é¢‘é€šè¯**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`


# å¯¹è¯è€…çš„è§’è‰²è®¾å®š
${chat.settings.myPersona}



ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹é¢çš„å¯¹è¯å†å²ï¼Œç»§ç»­è¿›è¡Œå¯¹è¯ã€‚`;

      // åº”ç”¨æç¤ºè¯è®¾ç½®
      systemPrompt = processPromptWithSettings(systemPrompt, 'single');

      const messagesForApi = historySlice.map(msg => ({
        role: msg.role,
        content: String(msg.content)
      }));


      messagesForApi.push({
        role: 'user',
        content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šç”¨æˆ·æŒ‰ä¸‹äº†â€œæ¨è¿›â€æŒ‰é’®ï¼Œç°åœ¨è½®åˆ°ä½ ä¸»åŠ¨è¡ŒåŠ¨äº†ï¼Œè¯·ç»§ç»­å¯¹è¯ã€‚]`
      });


      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API è¯·æ±‚å¤±è´¥: ${errorData.error.message}`);
      }

      const data = await response.json();

      const aiResponseContent = getGeminiResponseText(data);


      const messagesArray = parseAiResponse(aiResponseContent);
      const processedActions = [];
      for (const action of messagesArray) {
        if (action.type === 'text' && typeof action.content === 'string' && action.content.includes('\n')) {
          const lines = action.content.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {
          processedActions.push(action);
        }
      }

      let messageTimestamp = Date.now();
      for (const msgData of processedActions) {
        const aiMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: messageTimestamp++,
          content: msgData.content || msgData.message,
          type: msgData.type || 'text',

        };
        if (msgData.type === 'update_thoughts') {
          if (!chat.isGroup) {
            if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
            if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
          }
          continue;
        }
        chat.history.push(aiMessage);
        appendMessage(aiMessage, chat);
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 800));
      }

      await db.chats.put(chat);
      renderChatList();

    } catch (error) {
      console.error("æ¨è¿›å‰§æƒ…å¤±è´¥:", error);
      await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•æ¨è¿›å‰§æƒ…: ${error.message}`);
    } finally {

      setAvatarActingState(chat.id, false);
      if (!chat.isGroup && document.getElementById('chat-header-title')) {
        const titleEl = document.getElementById('chat-header-title');
        titleEl.style.opacity = 0;
        setTimeout(() => {
          titleEl.textContent = chat.name;
          titleEl.classList.remove('typing-status');
          titleEl.style.opacity = 1;
        }, 200);
      }
    }
  }



  function playNotificationSound() {
    const player = document.getElementById('notification-sound-player');

    const soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;

  
    if (soundUrl && soundUrl.trim()) {
      player.src = soundUrl;

      player.play().catch(error => console.log("æ’­æ”¾è¢«ä¸­æ–­ï¼Œè¿™æ˜¯æ­£å¸¸è¡Œä¸º:", error));
    }
  }

  // ========== æç¤ºè¯å¤„ç†å‡½æ•° ==========
  
  /**
   * æ ¹æ®ç”¨æˆ·è®¾ç½®å¤„ç†æç¤ºè¯
   * @param {string} originalPrompt - åŸå§‹çš„å®Œæ•´æç¤ºè¯
   * @param {string} chatType - èŠå¤©ç±»å‹ï¼š'single'å•èŠ, 'group'ç¾¤èŠ, 'spectator'æ—è§‚
   * @returns {string} - å¤„ç†åçš„æç¤ºè¯
   */
  function processPromptWithSettings(originalPrompt, chatType = 'single') {
    // ä½¿ç”¨åŸå§‹æç¤ºè¯
    return originalPrompt;
  }
  
  // ========== æç¤ºè¯å¤„ç†å‡½æ•°ç»“æŸ ==========

  // ========== ç³»ç»Ÿçº§é€šçŸ¥åŠŸèƒ½ ==========

  // åˆå§‹åŒ–ç³»ç»Ÿé€šçŸ¥
  function initSystemNotification() {
    if (!('Notification' in window)) {
      console.warn('æ­¤æµè§ˆå™¨ä¸æ”¯æŒç³»ç»Ÿé€šçŸ¥');
      return;
    }
    
    updateNotificationPermissionStatus();
    bindSystemNotificationEvents();
    loadSystemNotificationSettings(); // ğŸ”¥ ä¿®å¤ï¼šé¡µé¢åŠ è½½æ—¶æ¢å¤æ‰€æœ‰è®¾ç½®å’Œå­èœå•æ˜¾ç¤ºçŠ¶æ€
  }

  // æ›´æ–°æƒé™çŠ¶æ€æ˜¾ç¤º
  async function updateNotificationPermissionStatus() {
    const statusEl = document.getElementById('permission-status-text');
    const statusContainer = document.getElementById('notification-permission-status');
    
    if (!statusEl || !('serviceWorker' in navigator)) return;
    
    try {
      // ä½¿ç”¨ Service Worker API æ£€æŸ¥æƒé™ï¼ˆç§»åŠ¨ç«¯å…¼å®¹ï¼‰
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      const permission = permissionStatus.state;
      
      if (permission === 'granted') {
        statusEl.textContent = 'å·²æˆæƒ';
        statusEl.style.color = '#4cd964';
      } else if (permission === 'denied') {
        statusEl.textContent = 'å·²æ‹’ç»';
        statusEl.style.color = '#ff3b30';
      } else {
        statusEl.textContent = 'æœªè¯·æ±‚';
        statusEl.style.color = '#999';
      }
      
      statusContainer.style.display = state.globalSettings.systemNotification?.enabled ? 'flex' : 'none';
    } catch (error) {
      console.warn('[æƒé™æ£€æŸ¥] æ— æ³•æŸ¥è¯¢é€šçŸ¥æƒé™:', error);
      statusEl.textContent = 'æœªçŸ¥';
      statusEl.style.color = '#999';
    }
  }

  // è¯·æ±‚é€šçŸ¥æƒé™
  async function requestNotificationPermission() {
    if (!('serviceWorker' in navigator)) {
      alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒç³»ç»Ÿé€šçŸ¥');
      return false;
    }
    
    try {
      // ä½¿ç”¨ Permissions API æ£€æŸ¥å½“å‰æƒé™ï¼ˆç§»åŠ¨ç«¯å…¼å®¹ï¼‰
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      
      if (permissionStatus.state === 'granted') {
        return true;
      }
      
      if (permissionStatus.state === 'denied') {
        alert('é€šçŸ¥æƒé™å·²è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­æ‰‹åŠ¨å¼€å¯');
        return false;
      }
      
      // è¯·æ±‚æƒé™ï¼ˆå¿…é¡»é€šè¿‡ Notification APIï¼‰
      if ('Notification' in window && typeof Notification.requestPermission === 'function') {
        const permission = await Notification.requestPermission();
        await updateNotificationPermissionStatus();
        
        if (permission !== 'granted') {
          alert('æœªæˆäºˆé€šçŸ¥æƒé™ï¼Œç³»ç»Ÿé€šçŸ¥åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨');
          document.getElementById('system-notification-enabled-switch').checked = false;
          state.globalSettings.systemNotification.enabled = false;
          return false;
        }
        
        return true;
      } else {
        alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯·æ±‚é€šçŸ¥æƒé™');
        return false;
      }
    } catch (error) {
      console.error('[æƒé™è¯·æ±‚] å¤±è´¥:', error);
      alert('è¯·æ±‚é€šçŸ¥æƒé™å¤±è´¥: ' + error.message);
      return false;
    }
  }

  // éœ‡åŠ¨è®¾å¤‡
  function vibrateDevice() {
    if (!('vibrate' in navigator)) {
      return;
    }
    
    const patterns = {
      short: [200],
      medium: [200, 100, 200],
      long: [400, 100, 400, 100, 400]
    };
    
    const pattern = state.globalSettings.systemNotification?.vibration?.pattern || 'short';
    navigator.vibrate(patterns[pattern]);
  }

  // æ’­æ”¾ç³»ç»Ÿé€šçŸ¥æç¤ºéŸ³
  function playSystemNotificationSound() {
    const soundConfig = state.globalSettings.systemNotification?.sound;
    
    if (!soundConfig || !soundConfig.enabled) {
      return;
    }
    
    let soundUrl;
    if (soundConfig.useGlobalSound) {
      soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    } else {
      soundUrl = soundConfig.customSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    }
    
    if (soundUrl && soundUrl.trim()) {
      const audio = new Audio(soundUrl);
      audio.play().catch(err => console.log('æ’­æ”¾æç¤ºéŸ³å¤±è´¥:', err));
    }
  }

  // æ˜¾ç¤ºç³»ç»Ÿé€šçŸ¥ï¼ˆæ¯æ¡æ¶ˆæ¯ç‹¬ç«‹é€šçŸ¥ï¼‰
  async function showSystemNotification(chatId, messageContent, options = {}) {
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] showSystemNotification è¢«è°ƒç”¨:', {
      chatId,
      messageContent,
      options,
      enabled: state.globalSettings.systemNotification?.enabled
    });
    
    if (!state.globalSettings.systemNotification?.enabled) {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] ç³»ç»Ÿé€šçŸ¥æœªå¯ç”¨');
      return;
    }
    
    // ä½¿ç”¨ Permissions API æ£€æŸ¥æƒé™ï¼ˆç§»åŠ¨ç«¯å…¼å®¹ï¼‰
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      if (permissionStatus.state !== 'granted') {
        console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] é€šçŸ¥æƒé™æœªæˆäºˆ:', permissionStatus.state);
        return;
      }
    } catch (error) {
      console.warn('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ— æ³•æŸ¥è¯¢æƒé™ï¼Œè·³è¿‡æ£€æŸ¥:', error);
    }
    
    const chat = state.chats[chatId];
    if (!chat) {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ‰¾ä¸åˆ°èŠå¤©:', chatId);
      return;
    }
    
    const appName = state.globalSettings.systemNotification.appName || 'EPhone';
    const title = options.title || `${appName} - ${chat.name}`;
    const body = messageContent;
    const icon = chat.settings.aiAvatar || chat.settings.groupAvatar || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg';
    
    // æ¯æ¡æ¶ˆæ¯ä½¿ç”¨å”¯ä¸€çš„ tagï¼Œç¡®ä¿æ¯æ¡éƒ½æ˜¾ç¤º
    const uniqueTag = `chat-${chatId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] å‡†å¤‡åˆ›å»ºé€šçŸ¥:', {
      title,
      body,
      icon,
      tag: uniqueTag
    });
    
    try {
      // å¿…é¡»ä½¿ç”¨ Service Worker çš„ showNotificationï¼ˆç§»åŠ¨ç«¯è¦æ±‚ï¼‰
      if (!('serviceWorker' in navigator)) {
        console.error('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æµè§ˆå™¨ä¸æ”¯æŒ Service Worker');
        return;
      }
      
      // ç­‰å¾… Service Worker æ³¨å†Œå®Œæˆ
      const registration = await navigator.serviceWorker.ready;
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] Service Worker å·²å°±ç»ª');
      
      await registration.showNotification(title, {
        body: body,
        icon: icon,
        badge: icon,
        tag: uniqueTag, // ä½¿ç”¨å”¯ä¸€ tag
        requireInteraction: true, // å¼ºåˆ¶æ˜¾ç¤ºæ¨ªå¹…
        silent: false, // å¿…é¡»æœ‰å£°éŸ³æ‰èƒ½æ˜¾ç¤ºæ¨ªå¹…
        vibrate: [200, 100, 200, 100, 200], // å¼ºéœ‡åŠ¨
        renotify: true, // å¼ºåˆ¶é‡æ–°é€šçŸ¥
        data: { chatId },
        actions: [
          { action: 'reply', title: 'å›å¤' },
          { action: 'dismiss', title: 'å…³é—­' }
        ]
      });
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] é€šçŸ¥åˆ›å»ºæˆåŠŸ');
      
      if (state.globalSettings.systemNotification.sound?.enabled) {
        console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ’­æ”¾æç¤ºéŸ³');
        playSystemNotificationSound();
      }
      
      if (state.globalSettings.systemNotification.vibration?.enabled) {
        console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] è§¦å‘éœ‡åŠ¨');
        vibrateDevice();
      }
    } catch (error) {
      console.error('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] åˆ›å»ºé€šçŸ¥å¤±è´¥:', error);
    }
  }

  // å¤„ç†ç³»ç»Ÿé€šçŸ¥ï¼ˆæ¯æ¡æ¶ˆæ¯å•ç‹¬é€šçŸ¥ï¼Œä¸åˆå¹¶ï¼‰
  async function handleSystemNotification(chatId, messageContent) {
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] handleSystemNotification è¢«è°ƒç”¨:', {
      chatId,
      messageContent,
      config: state.globalSettings.systemNotification
    });
    
    const config = state.globalSettings.systemNotification;
    
    if (!config || !config.enabled) {
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] é…ç½®æ£€æŸ¥å¤±è´¥:', {
        configExists: !!config,
        enabled: config?.enabled
      });
      return;
    }
    
    // ä½¿ç”¨ Permissions API æ£€æŸ¥æƒé™ï¼ˆç§»åŠ¨ç«¯å…¼å®¹ï¼‰
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      if (permissionStatus.state !== 'granted') {
        console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] é€šçŸ¥æƒé™æœªæˆäºˆ:', permissionStatus.state);
        return;
      }
    } catch (error) {
      console.warn('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ— æ³•æŸ¥è¯¢æƒé™ï¼Œè·³è¿‡æ£€æŸ¥:', error);
    }
    
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ£€æŸ¥é€šè¿‡ï¼Œå‡†å¤‡æ˜¾ç¤ºé€šçŸ¥');
    
    // æ¯æ¡æ¶ˆæ¯éƒ½å•ç‹¬æ˜¾ç¤ºé€šçŸ¥ï¼Œä¸ä½¿ç”¨åˆå¹¶é€»è¾‘
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] ç›´æ¥æ˜¾ç¤ºå•æ¡é€šçŸ¥');
    showSystemNotification(chatId, messageContent);
  }

  // å‘é€æµ‹è¯•é€šçŸ¥
  async function sendTestNotification() {
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] sendTestNotification è¢«è°ƒç”¨');
    
    // ä½¿ç”¨ Permissions API æ£€æŸ¥æƒé™ï¼ˆç§»åŠ¨ç«¯å…¼å®¹ï¼‰
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æƒé™çŠ¶æ€:', permissionStatus.state);
      
      if (permissionStatus.state !== 'granted') {
        alert('è¯·å…ˆå¼€å¯ç³»ç»Ÿé€šçŸ¥æƒé™');
        return;
      }
    } catch (error) {
      console.error('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æ— æ³•æŸ¥è¯¢æƒé™:', error);
      alert('æ— æ³•æ£€æŸ¥é€šçŸ¥æƒé™ï¼Œè¯·ç¡®ä¿å·²æˆæƒ');
      return;
    }
    
    const appName = state.globalSettings.systemNotification?.appName || 'EPhone';
    console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] å‡†å¤‡åˆ›å»ºæµ‹è¯•é€šçŸ¥, appName:', appName);
    
    try {
      // å¿…é¡»ä½¿ç”¨ Service Worker çš„ showNotificationï¼ˆç§»åŠ¨ç«¯è¦æ±‚ï¼‰
      if (!('serviceWorker' in navigator)) {
        alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Service Workerï¼Œæ— æ³•ä½¿ç”¨ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½');
        return;
      }
      
      // ç­‰å¾… Service Worker æ³¨å†Œå®Œæˆ
      const registration = await navigator.serviceWorker.ready;
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] Service Worker å·²å°±ç»ª');
      
      await registration.showNotification(appName, {
        body: 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•é€šçŸ¥ ğŸ‰',
        icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
        badge: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
        tag: 'test-notification',
        requireInteraction: false,
        silent: !state.globalSettings.systemNotification?.sound?.enabled
      });
      console.log('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] æµ‹è¯•é€šçŸ¥åˆ›å»ºæˆåŠŸ');
      
      if (state.globalSettings.systemNotification?.sound?.enabled) {
        playSystemNotificationSound();
      }
      
      if (state.globalSettings.systemNotification?.vibration?.enabled) {
        vibrateDevice();
      }
    } catch (error) {
      console.error('[ç³»ç»Ÿé€šçŸ¥è°ƒè¯•] åˆ›å»ºæµ‹è¯•é€šçŸ¥å¤±è´¥:', error);
      alert('åˆ›å»ºæµ‹è¯•é€šçŸ¥å¤±è´¥: ' + error.message);
    }
  }

  // ç»‘å®šç³»ç»Ÿé€šçŸ¥ç›¸å…³äº‹ä»¶
  function bindSystemNotificationEvents() {
    const enabledSwitch = document.getElementById('system-notification-enabled-switch');
    const detailsDiv = document.getElementById('system-notification-details');
    const appNameInput = document.getElementById('system-notification-app-name');
    const testBtn = document.getElementById('test-system-notification-btn');
    
    const pushServerSwitch = document.getElementById('push-server-enabled-switch');
    const pushServerDetails = document.getElementById('push-server-details');
    const pushServerUrl = document.getElementById('push-server-url');
    const pushServerApiKey = document.getElementById('push-server-api-key');
    
    const vibrationSwitch = document.getElementById('notification-vibration-enabled-switch');
    const vibrationSelector = document.getElementById('vibration-pattern-selector');
    const vibrationPattern = document.getElementById('vibration-pattern-select');
    
    const soundSwitch = document.getElementById('notification-sound-enabled-switch');
    const soundDetails = document.getElementById('notification-sound-details');
    const useGlobalSound = document.getElementById('use-global-sound-switch');
    const customSoundWrapper = document.getElementById('custom-sound-input-wrapper');
    const customSoundUrl = document.getElementById('custom-notification-sound-url');
    
    if (enabledSwitch) {
      enabledSwitch.addEventListener('change', async () => {
        if (enabledSwitch.checked) {
          const granted = await requestNotificationPermission();
          if (granted) {
            state.globalSettings.systemNotification.enabled = true;
            detailsDiv.style.display = 'block';
            updateNotificationPermissionStatus();
          } else {
            enabledSwitch.checked = false;
          }
        } else {
          state.globalSettings.systemNotification.enabled = false;
          detailsDiv.style.display = 'none';
          updateNotificationPermissionStatus();
        }
      });
    }
    
    if (appNameInput) {
      appNameInput.addEventListener('input', () => {
        state.globalSettings.systemNotification.appName = appNameInput.value.trim() || 'EPhone';
      });
    }
    
    if (testBtn) {
      testBtn.addEventListener('click', sendTestNotification);
    }
    
    if (pushServerSwitch) {
      pushServerSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.pushServer.enabled = pushServerSwitch.checked;
        pushServerDetails.style.display = pushServerSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (pushServerUrl) {
      pushServerUrl.addEventListener('input', () => {
        state.globalSettings.systemNotification.pushServer.serverUrl = pushServerUrl.value.trim();
      });
    }
    
    if (pushServerApiKey) {
      pushServerApiKey.addEventListener('input', () => {
        state.globalSettings.systemNotification.pushServer.apiKey = pushServerApiKey.value.trim();
      });
    }
    
    if (vibrationSwitch) {
      vibrationSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.vibration.enabled = vibrationSwitch.checked;
        vibrationSelector.style.display = vibrationSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (vibrationPattern) {
      vibrationPattern.addEventListener('change', () => {
        state.globalSettings.systemNotification.vibration.pattern = vibrationPattern.value;
      });
    }
    
    if (soundSwitch) {
      soundSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.sound.enabled = soundSwitch.checked;
        soundDetails.style.display = soundSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (useGlobalSound) {
      useGlobalSound.addEventListener('change', () => {
        state.globalSettings.systemNotification.sound.useGlobalSound = useGlobalSound.checked;
        customSoundWrapper.style.display = useGlobalSound.checked ? 'none' : 'block';
      });
    }
    
    if (customSoundUrl) {
      customSoundUrl.addEventListener('input', () => {
        state.globalSettings.systemNotification.sound.customSoundUrl = customSoundUrl.value.trim();
      });
    }
    
    // åœ¨èŠå¤©é¡µé¢ä¹Ÿå‘é€é€šçŸ¥
    const notifyInChatPageSwitch = document.getElementById('notify-in-chat-page-switch');
    if (notifyInChatPageSwitch) {
      notifyInChatPageSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.notifyInChatPage = notifyInChatPageSwitch.checked;
      });
    }
    
    // ç¦ç”¨å†…éƒ¨å¼¹çª—
    const disableInternalNotificationSwitch = document.getElementById('disable-internal-notification-switch');
    if (disableInternalNotificationSwitch) {
      disableInternalNotificationSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.disableInternalNotification = disableInternalNotificationSwitch.checked;
      });
    }
  }

  // åŠ è½½ç³»ç»Ÿé€šçŸ¥è®¾ç½®åˆ°UI
  function loadSystemNotificationSettings() {
    const config = state.globalSettings.systemNotification;
    if (!config) return;
    
    const enabledSwitch = document.getElementById('system-notification-enabled-switch');
    const detailsDiv = document.getElementById('system-notification-details');
    const appNameInput = document.getElementById('system-notification-app-name');
    
    const pushServerSwitch = document.getElementById('push-server-enabled-switch');
    const pushServerDetails = document.getElementById('push-server-details');
    const pushServerUrl = document.getElementById('push-server-url');
    const pushServerApiKey = document.getElementById('push-server-api-key');
    
    const vibrationSwitch = document.getElementById('notification-vibration-enabled-switch');
    const vibrationSelector = document.getElementById('vibration-pattern-selector');
    const vibrationPattern = document.getElementById('vibration-pattern-select');
    
    const soundSwitch = document.getElementById('notification-sound-enabled-switch');
    const soundDetails = document.getElementById('notification-sound-details');
    const useGlobalSound = document.getElementById('use-global-sound-switch');
    const customSoundWrapper = document.getElementById('custom-sound-input-wrapper');
    const customSoundUrl = document.getElementById('custom-notification-sound-url');
    
    // åŠ è½½ä¸»å¼€å…³çŠ¶æ€
    if (enabledSwitch) {
      enabledSwitch.checked = config.enabled || false;
      detailsDiv.style.display = config.enabled ? 'block' : 'none';
    }
    
    if (appNameInput) {
      appNameInput.value = config.appName || 'EPhone';
    }
    
    // åŠ è½½æ¨é€æœåŠ¡å™¨è®¾ç½®
    if (pushServerSwitch) {
      pushServerSwitch.checked = config.pushServer?.enabled || false;
      pushServerDetails.style.display = config.pushServer?.enabled ? 'block' : 'none';
    }
    
    if (pushServerUrl) {
      pushServerUrl.value = config.pushServer?.serverUrl || '';
    }
    
    if (pushServerApiKey) {
      pushServerApiKey.value = config.pushServer?.apiKey || '';
    }
    
    // åŠ è½½éœ‡åŠ¨è®¾ç½®
    if (vibrationSwitch) {
      vibrationSwitch.checked = config.vibration?.enabled || false;
      vibrationSelector.style.display = config.vibration?.enabled ? 'block' : 'none';
    }
    
    if (vibrationPattern) {
      vibrationPattern.value = config.vibration?.pattern || 'short';
    }
    
    // åŠ è½½å£°éŸ³è®¾ç½®
    if (soundSwitch) {
      soundSwitch.checked = config.sound?.enabled || false;
      soundDetails.style.display = config.sound?.enabled ? 'block' : 'none';
    }
    
    if (useGlobalSound) {
      useGlobalSound.checked = config.sound?.useGlobalSound !== false;
      customSoundWrapper.style.display = config.sound?.useGlobalSound !== false ? 'none' : 'block';
    }
    
    if (customSoundUrl) {
      customSoundUrl.value = config.sound?.customSoundUrl || '';
    }
    
    // åŠ è½½åœ¨èŠå¤©é¡µé¢ä¹Ÿå‘é€é€šçŸ¥è®¾ç½®
    const notifyInChatPageSwitch = document.getElementById('notify-in-chat-page-switch');
    if (notifyInChatPageSwitch) {
      notifyInChatPageSwitch.checked = config.notifyInChatPage || false;
    }
    
    // åŠ è½½ç¦ç”¨å†…éƒ¨å¼¹çª—è®¾ç½®
    const disableInternalNotificationSwitch = document.getElementById('disable-internal-notification-switch');
    if (disableInternalNotificationSwitch) {
      disableInternalNotificationSwitch.checked = config.disableInternalNotification || false;
    }
    
    updateNotificationPermissionStatus();
  }

  // ========== ç³»ç»Ÿçº§é€šçŸ¥åŠŸèƒ½ç»“æŸ ==========

  // ========== åå°ä¿æ´»åŠŸèƒ½å¼€å§‹ ==========
  
  let keepAliveInterval = null;
  let keepAliveAudio = null;
  let wakeLock = null;

  // åˆå§‹åŒ–åå°ä¿æ´»
  async function initializeBackgroundKeepAlive() {
    if (!state.globalSettings.backgroundKeepAlive) {
      state.globalSettings.backgroundKeepAlive = {
        enabled: false
      };
    }
  }

  // å¯åŠ¨åå°ä¿æ´»
  async function startBackgroundKeepAlive() {
    console.log('[åå°ä¿æ´»] å¯åŠ¨ä¿æ´»æœºåˆ¶...');
    
    // 1. åˆ›å»ºå¹¶æ’­æ”¾é™é»˜éŸ³é¢‘ï¼ˆå¾ªç¯æ’­æ”¾ï¼‰
    if (!keepAliveAudio) {
      keepAliveAudio = new Audio();
      // ä½¿ç”¨é™é»˜çš„éŸ³é¢‘æ•°æ®URLï¼ˆ1ç§’çš„é™éŸ³ï¼‰
      keepAliveAudio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      keepAliveAudio.loop = true;
      keepAliveAudio.volume = 0.01; // æä½éŸ³é‡
      
      // å°è¯•æ’­æ”¾
      try {
        await keepAliveAudio.play();
        console.log('[åå°ä¿æ´»] é™é»˜éŸ³é¢‘å·²å¯åŠ¨');
      } catch (error) {
        console.warn('[åå°ä¿æ´»] é™é»˜éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
      }
    }
    
    // 2. è®¾ç½®å®šæ—¶ä»»åŠ¡ï¼ˆæ¯30ç§’æ‰§è¡Œä¸€æ¬¡è½»é‡çº§ä»»åŠ¡ï¼‰
    if (!keepAliveInterval) {
      keepAliveInterval = setInterval(() => {
        // æ‰§è¡Œè½»é‡çº§ä»»åŠ¡ï¼Œä¿æŒJavaScriptè¿è¡Œ
        const timestamp = Date.now();
        console.log('[åå°ä¿æ´»] å¿ƒè·³æ£€æµ‹:', new Date(timestamp).toLocaleTimeString());
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        updateKeepAliveStatus('è¿è¡Œä¸­ - ' + new Date().toLocaleTimeString());
      }, 30000); // æ¯30ç§’
      
      console.log('[åå°ä¿æ´»] å®šæ—¶ä»»åŠ¡å·²å¯åŠ¨');
    }
    
    // 3. å°è¯•ä½¿ç”¨ Wake Lock APIï¼ˆå¦‚æœæ”¯æŒï¼‰
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('[åå°ä¿æ´»] Wake Lock å·²å¯ç”¨');
        
        wakeLock.addEventListener('release', () => {
          console.log('[åå°ä¿æ´»] Wake Lock å·²é‡Šæ”¾');
        });
      } catch (error) {
        console.warn('[åå°ä¿æ´»] Wake Lock ä¸å¯ç”¨:', error);
      }
    }
    
    // 4. ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    updateKeepAliveStatus('è¿è¡Œä¸­');
    console.log('[åå°ä¿æ´»] ä¿æ´»æœºåˆ¶å·²å…¨éƒ¨å¯åŠ¨');
  }

  // åœæ­¢åå°ä¿æ´»
  function stopBackgroundKeepAlive() {
    console.log('[åå°ä¿æ´»] åœæ­¢ä¿æ´»æœºåˆ¶...');
    
    // 1. åœæ­¢é™é»˜éŸ³é¢‘
    if (keepAliveAudio) {
      keepAliveAudio.pause();
      keepAliveAudio = null;
      console.log('[åå°ä¿æ´»] é™é»˜éŸ³é¢‘å·²åœæ­¢');
    }
    
    // 2. æ¸…é™¤å®šæ—¶ä»»åŠ¡
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
      console.log('[åå°ä¿æ´»] å®šæ—¶ä»»åŠ¡å·²æ¸…é™¤');
    }
    
    // 3. é‡Šæ”¾ Wake Lock
    if (wakeLock) {
      wakeLock.release();
      wakeLock = null;
      console.log('[åå°ä¿æ´»] Wake Lock å·²é‡Šæ”¾');
    }
    
    // 4. ç§»é™¤äº‹ä»¶ç›‘å¬
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    
    updateKeepAliveStatus('æœªå¯ç”¨');
    console.log('[åå°ä¿æ´»] ä¿æ´»æœºåˆ¶å·²å…¨éƒ¨åœæ­¢');
  }

  // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
  async function handleVisibilityChange() {
    if (document.hidden) {
      console.log('[åå°ä¿æ´»] é¡µé¢è¿›å…¥åå°');
    } else {
      console.log('[åå°ä¿æ´»] é¡µé¢è¿”å›å‰å°');
      
      // é¡µé¢è¿”å›å‰å°æ—¶ï¼Œé‡æ–°å¯åŠ¨éŸ³é¢‘ï¼ˆå¦‚æœä¿æ´»å¼€å¯ï¼‰
      if (state.globalSettings.backgroundKeepAlive?.enabled && keepAliveAudio) {
        try {
          await keepAliveAudio.play();
        } catch (error) {
          console.warn('[åå°ä¿æ´»] é‡æ–°æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
        }
      }
      
      // é‡æ–°ç”³è¯· Wake Lockï¼ˆå¦‚æœæ”¯æŒï¼‰
      if (state.globalSettings.backgroundKeepAlive?.enabled && 'wakeLock' in navigator && !wakeLock) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('[åå°ä¿æ´»] Wake Lock å·²é‡æ–°å¯ç”¨');
        } catch (error) {
          console.warn('[åå°ä¿æ´»] Wake Lock é‡æ–°ç”³è¯·å¤±è´¥:', error);
        }
      }
    }
  }

  // æ›´æ–°ä¿æ´»çŠ¶æ€æ˜¾ç¤º
  function updateKeepAliveStatus(statusText) {
    const statusElement = document.getElementById('keep-alive-status-text');
    if (statusElement) {
      statusElement.textContent = statusText;
      
      // æ ¹æ®çŠ¶æ€è®¾ç½®é¢œè‰²
      if (statusText.includes('è¿è¡Œä¸­')) {
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.style.color = '#999';
      }
    }
  }

  // ç»‘å®šåå°ä¿æ´»å¼€å…³äº‹ä»¶
  function bindBackgroundKeepAliveEvents() {
    const keepAliveSwitch = document.getElementById('background-keep-alive-switch');
    const statusDiv = document.getElementById('keep-alive-status');
    
    if (keepAliveSwitch) {
      keepAliveSwitch.addEventListener('change', async (e) => {
        const enabled = e.target.checked;
        state.globalSettings.backgroundKeepAlive.enabled = enabled;
        
        // æ˜¾ç¤º/éšè—çŠ¶æ€
        if (statusDiv) {
          statusDiv.style.display = enabled ? 'flex' : 'none';
        }
        
        if (enabled) {
          await startBackgroundKeepAlive();
        } else {
          stopBackgroundKeepAlive();
        }
      });
    }
  }

  // åŠ è½½åå°ä¿æ´»è®¾ç½®åˆ°UI
  function loadBackgroundKeepAliveSettings() {
    const config = state.globalSettings.backgroundKeepAlive;
    if (!config) return;
    
    const keepAliveSwitch = document.getElementById('background-keep-alive-switch');
    const statusDiv = document.getElementById('keep-alive-status');
    
    if (keepAliveSwitch) {
      keepAliveSwitch.checked = config.enabled || false;
      
      if (statusDiv) {
        statusDiv.style.display = config.enabled ? 'flex' : 'none';
      }
      
      // å¦‚æœä¹‹å‰æ˜¯å¼€å¯çŠ¶æ€ï¼Œé‡æ–°å¯åŠ¨ä¿æ´»
      if (config.enabled) {
        startBackgroundKeepAlive();
      }
    }
  }

  // ========== åå°ä¿æ´»åŠŸèƒ½ç»“æŸ ==========


  function applyWidgetData() {
    // å…ˆä¿å­˜æ‰€æœ‰å¯ç¼–è¾‘å›¾ç‰‡çš„é»˜è®¤ srcï¼ˆå¦‚æœè¿˜æ²¡ä¿å­˜çš„è¯ï¼‰
    const editableImages = document.querySelectorAll('.editable-image');
    editableImages.forEach(img => {
      if (!img.dataset.defaultSrc) {
        img.dataset.defaultSrc = img.src;
      }
    });

    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
      const element = document.getElementById(elementId);
      const savedValue = state.globalSettings.widgetData[elementId];
      if (element) {
        if (element.tagName === 'IMG') {
          element.src = savedValue;
        } else {
          element.textContent = savedValue;
        }
      }
    }
  }


  function uploadImageLocally() {
    return new Promise(resolve => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*'; // åªæ¥å—å›¾ç‰‡æ–‡ä»¶

      input.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (readerEvent) => { 
          let base64Result = readerEvent.target.result;

        
          if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
              try {
                
                  const alertModal = document.getElementById('custom-modal-overlay');
                  if (!alertModal.classList.contains('visible')) {
                      await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä¸Šä¼ å›¾ç‰‡åˆ° ImgBB...");
                  }
                  const imageUrl = await uploadImageToImgBB(base64Result);
                  resolve(imageUrl); 
              } catch (uploadError) {
                  console.error(uploadError);
                  await showCustomAlert("ImgBB ä¸Šä¼ å¤±è´¥", `å›¾ç‰‡ä¸Šä¼ åˆ°å›¾åºŠå¤±è´¥: ${uploadError.message}\n\nå°†ç»§ç»­ä½¿ç”¨æœ¬åœ° Base64 æ ¼å¼ä¿å­˜ã€‚`);
                  resolve(base64Result); 
              }
          } else {
            
              resolve(base64Result);
          }
      };
      reader.readAsDataURL(file);
        } else {
          resolve(null); // ç”¨æˆ·å…³é—­äº†æ–‡ä»¶é€‰æ‹©æ¡†
        }
      };

      input.click();
    });
  }


  async function handleEditText(element) {
    const elementId = element.id;
    const currentValue = element.textContent;
    const newValue = await showCustomPrompt("ä¿®æ”¹æ–‡å­—", "è¯·è¾“å…¥æ–°çš„å†…å®¹ï¼š", currentValue);
    if (newValue !== null && newValue.trim() !== "") {
      const trimmedValue = newValue.trim();
      element.textContent = trimmedValue;
      state.globalSettings.widgetData[elementId] = trimmedValue;
      await db.globalSettings.put(state.globalSettings);
      alert("æ–‡å­—å·²æ›´æ–°ï¼");

    }
  }


  async function handleEditImage(element) {
    const elementId = element.id;
  
    const choice = await showChoiceModal("ä¿®æ”¹å›¾ç‰‡", [
        { text: 'ğŸ“ ä»æœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ğŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' },
        { text: 'ğŸ”„ é‡ç½®ä¸ºé»˜è®¤', value: 'reset' }
    ]);
  
    // å¤„ç†é‡ç½®é€»è¾‘
    if (choice === 'reset') {
        const defaultSrc = element.dataset.defaultSrc;
        if (defaultSrc) {
            // æ¢å¤åˆ°é»˜è®¤å›¾ç‰‡
            element.src = defaultSrc;
            
            // ä»æ•°æ®åº“ä¸­åˆ é™¤è¯¥è®°å½•
            if (state.globalSettings.widgetData && state.globalSettings.widgetData[elementId]) {
                delete state.globalSettings.widgetData[elementId];
                await db.globalSettings.put(state.globalSettings);
            }
            
            await showCustomAlert("æˆåŠŸ", "å·²é‡ç½®ä¸ºé»˜è®¤å›¾ç‰‡ï¼");
        } else {
            await showCustomAlert("æç¤º", "æœªæ‰¾åˆ°é»˜è®¤å›¾ç‰‡ï¼Œæ— æ³•é‡ç½®ã€‚");
        }
        return;
    }

    let newUrl = null;
    let isBase64 = false; // æ ‡è®°æ˜¯å¦ä¸º Base64
  
    if (choice === 'local') {
        newUrl = await new Promise(resolve => { // ç®€åŒ–ç‰ˆ uploadImageLocally
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
  
    } else if (choice === 'url') {
        newUrl = await showCustomPrompt("ä¿®æ”¹å›¾ç‰‡", "è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URLï¼š", element.src, "url");
        if (newUrl) isBase64 = false;
    }
  
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        // 1. [æ ¸å¿ƒä¿®æ”¹] ç«‹å³æ˜¾ç¤º Base64 æˆ– URL
        element.src = trimmedUrl;
  
        // 2. ç«‹å³å°† Base64 æˆ– URL ä¿å­˜åˆ°æ•°æ®åº“ï¼Œç¡®ä¿åˆ·æ–°ä¸ä¸¢å¤±
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[elementId] = trimmedUrl;
        await db.globalSettings.put(state.globalSettings);
  
        await showCustomAlert("æˆåŠŸ", "ç»„ä»¶å›¾ç‰‡å·²æ›´æ–°å¹¶ä¿å­˜ï¼");
  
        // 3. [æ ¸å¿ƒä¿®æ”¹] åªæœ‰å½“å®ƒæ˜¯ Base64 ä¸” ImgBB å¼€å¯æ—¶ï¼Œæ‰åœ¨åå°â€œé™é»˜â€ä¸Šä¼ 
        if (isBase64 && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
            (async () => {
                console.log(`[ImgBB] å¯åŠ¨ ${elementId} çš„é™é»˜ä¸Šä¼ ...`);
                // è¿™ä¸ªå‡½æ•°ä¼šåœ¨åå°è¿è¡Œï¼Œä¸ä¼šé˜»å¡
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    `widgetData.${elementId}`,
                    trimmedUrl // ä¼ å…¥ Base64 å­—ç¬¦ä¸²
                );
            })();
        }
    }
  }



  const cacheManager = {
    getSongCache(query, source) {
      const key = `${source || 'all'}:${query}`;
      if (state.cache && state.cache.songs) {
        const cached = state.cache.songs.get(key);
        if (cached && Date.now() - cached.timestamp < 3600000) {
          return cached.data;
        }
      }
      return null;
    },
    setSongCache(query, data, source) {
      const key = `${source || 'all'}:${query}`;
      if (!state.cache) state.cache = {};
      if (!state.cache.songs) state.cache.songs = new Map();
      state.cache.songs.set(key, {
        data,
        timestamp: Date.now()
      });
    }
  };

  if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
      return new Promise((resolve) => {
        fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
      });
    }
  }
  async function Http_Get(url) {
    return await Http_Get_External(url);
  }

  function checkAudioAvailability(url) {
    return new Promise(resolve => {
      const tester = new Audio();
      tester.addEventListener('loadedmetadata', () => resolve(true), {
        once: true
      });
      tester.addEventListener('error', () => resolve(false), {
        once: true
      });
      tester.src = url;
    });
  }


  async function searchNeteaseMusic(name, singer) {
    try {
      let searchTerm = name.replace(/\s/g, "");
      if (singer) {
        searchTerm += ` ${singer.replace(/\s/g, "")}`;
      }

      const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;

      console.log("æ­£åœ¨è¯·æ±‚ç½‘æ˜“äº‘éŸ³ä¹API:", apiUrl);

      const response = await fetch(apiUrl);

      if (!response.ok) {
        throw new Error(`API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
      }

      const result = await response.json();

      if (result.code !== 200 || !result.data || result.data.length === 0) {
        console.log("ç½‘æ˜“äº‘éŸ³ä¹APIæœªè¿”å›æœ‰æ•ˆç»“æœ:", result);
        return [];
      }


      return result.data.map(song => ({
        name: song.song,
        artist: song.singer,
        id: song.id,
        cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
        source: 'netease'
      })).slice(0, 30); 

    } catch (e) {
      console.error("ç½‘æ˜“äº‘éŸ³ä¹æœç´¢å¤±è´¥:", e);

      return [];
    }
  }
// --- Toubiec API æ ¸å¿ƒé€»è¾‘ (ä¿®å¤ç‰ˆ) ---
const TOUBIEC_BASE_URL = 'https://wyapi-1.toubiec.cn/api/music';

async function fetchToubiec(endpoint, bodyData) {
    try {
        const response = await fetch(`${TOUBIEC_BASE_URL}/${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(bodyData)
        });
        const result = await response.json();
        return result;
    } catch (error) {
        console.error(`Toubiec API Error [${endpoint}]:`, error);
        return null;
    }
}

// 1. æœç´¢åŠŸèƒ½ (ä¿®å¤äº†æ•°æ®ç»“æ„è§£æ)
// 1. æœç´¢åŠŸèƒ½ (ä¿®å¤å­—æ®µæ˜ å°„)
// 1. æœç´¢åŠŸèƒ½ (ä¿®å¤å­—æ®µæ˜ å°„ï¼šé€‚é… picimg å’Œ singer)
async function searchToubiec(keyword) {
    const res = await fetchToubiec('search', { keywords: keyword, page: 1 });
    
    // å…¼å®¹å¤„ç†ï¼šæ•°æ®å¯èƒ½åœ¨ data, data.list, data.songs ä¸­
    let songList = [];
    if (res) {
        if (Array.isArray(res)) {
            songList = res;
        } else if (res.data) {
             if (Array.isArray(res.data)) {
                songList = res.data;
            } else if (Array.isArray(res.data.list)) {
                songList = res.data.list;
            } else if (Array.isArray(res.data.songs)) {
                songList = res.data.songs;
            }
            // é’ˆå¯¹ä½ æä¾›çš„JSONç»“æ„ï¼šç›´æ¥è¿”å›äº† data å¯¹è±¡çš„æƒ…å†µï¼ˆè™½ä¸å°‘è§ä½†ä¸ºäº†ä¿é™©ï¼‰
            else if (typeof res.data === 'object') {
                songList = [res.data];
            }
        }
    }

    if (songList.length === 0) return [];
    
    return songList.map(song => ({
        name: song.name,
        // ã€ä¿®å¤ã€‘ä¼˜å…ˆè¯»å– singer (ä½ çš„APIè¿”å›å­—æ®µ)ï¼Œå…¶æ¬¡ artists
        artist: song.singer || song.artists || (Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : (song.artist || 'æœªçŸ¥æ­Œæ‰‹')),
        id: String(song.id),
        // ã€ä¿®å¤ã€‘ä¼˜å…ˆè¯»å– picimg (ä½ çš„APIè¿”å›å­—æ®µ)
        cover: song.picimg || song.cover || song.al?.picUrl || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'toubiec',
        albumId: song.al?.id
    }));
}

// 2. è§£ææ­Œå• (è¾“å…¥æ­Œå•ID)
async function getToubiecPlaylist(playlistId) {
    const res = await fetchToubiec('playlist', { id: String(playlistId) });
    if (!res || !res.data || !res.data.tracks) return [];
    
    return res.data.tracks.map(song => ({
        name: song.name,
        artist: Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : (song.artist || 'æœªçŸ¥æ­Œæ‰‹'),
        id: String(song.id),
        cover: song.al?.picUrl || song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'toubiec'
    }));
}

// 3. è§£æä¸“è¾‘ (è¾“å…¥ä¸“è¾‘ID)
async function getToubiecAlbum(albumId) {
    const res = await fetchToubiec('album', { id: String(albumId) });
    if (!res || !res.data || !res.data.songs) return [];
    
    return res.data.songs.map(song => ({
        name: song.name,
        artist: Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : 'æœªçŸ¥æ­Œæ‰‹',
        id: String(song.id),
        cover: song.al?.picUrl || res.data.album?.picUrl, // ä¼˜å…ˆç”¨å•æ›²å°é¢ï¼Œæ²¡æœ‰åˆ™ç”¨ä¸“è¾‘å°é¢
        source: 'toubiec'
    }));
}
// 6. [æ–°å¢] è·å–æ­Œæ›²è¯¦æƒ… (ç”¨äºä¿®å¤å°é¢å’Œæ­Œæ‰‹ä¿¡æ¯)
async function getToubiecDetail(id) {
    // è°ƒç”¨ detail æ¥å£
    const res = await fetchToubiec('detail', { id: String(id) });
    if (res && res.code === 200 && res.data) {
        return res.data; // è¿”å›åŒ…å« picimg, singer ç­‰ä¿¡æ¯çš„å¯¹è±¡
    }
    return null;
}
// 4. è·å–é«˜éŸ³è´¨æ’­æ”¾é“¾æ¥ (ä¿®å¤ç‰ˆï¼šé€‚é… data ä¸ºæ•°ç»„çš„æƒ…å†µ)
async function getToubiecUrl(id, preferredLevel = 'exhigh') {
    // å®šä¹‰éŸ³è´¨é™çº§é“¾
    const qualityLadder = ['jymaster', 'dolby', 'sky', 'jyeffect', 'hires', 'lossless', 'exhigh', 'standard'];
    
    let startIndex = qualityLadder.indexOf(preferredLevel);
    if (startIndex === -1) startIndex = 5; 

    for (let i = startIndex; i < qualityLadder.length; i++) {
        const level = qualityLadder[i];
        const res = await fetchToubiec('url', { id: String(id), level: level });
        
        if (res && res.code === 200 && res.data) {
            let url = null;

            // ã€æ ¸å¿ƒä¿®å¤ã€‘ä½ æä¾›çš„JSONæ˜¾ç¤º data æ˜¯ä¸€ä¸ªæ•°ç»„ [{id:..., url:...}]
            if (Array.isArray(res.data) && res.data.length > 0) {
                // å–æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„ url å­—æ®µ
                url = res.data[0].url; 
            }
            // å…¼å®¹ data æ˜¯å¯¹è±¡çš„æƒ…å†µ
            else if (!Array.isArray(res.data) && res.data.url) {
                url = res.data.url;
            }

            if (url) {
                console.log(`[Toubiec] æˆåŠŸè·å–é“¾æ¥ (${level}): ${url}`);
                // ç¡®ä¿ HTTPSï¼Œé˜²æ­¢æ··åˆå†…å®¹æŠ¥é”™
                return url.replace(/^http:\/\//i, 'https://');
            }
        }
    }
    console.warn(`[Toubiec] æœªèƒ½è·å–ä»»ä½•éŸ³è´¨çš„é“¾æ¥: ID ${id}`);
    return null;
}

// 5. è·å–æ­Œè¯
async function getToubiecLyric(id) {
    const res = await fetchToubiec('lyric', { id: String(id) });
    if (res && res.data) {
        // ç»„åˆåŸè¯(lrc)å’Œç¿»è¯‘(tlyric)
        const lrc = res.data.lrc || "";
        const tlyric = res.data.tlyric || "";
        return lrc + "\n" + tlyric;
    }
    return "";
}
// --- Toubiec API é›†æˆç»“æŸ ---
 
  async function searchTencentMusic(name) {
    try {
      name = name.replace(/\s/g, "");
      const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
      if (!result?.data?.length) return [];
      return result.data.map(song => ({
        name: song.song,
        artist: song.singer,
        id: song.id,
        cover: song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'tencent'
      })).slice(0, 30);
    } catch (e) {
      console.error("QQéŸ³ä¹æœç´¢APIå¤±è´¥:", e);
      return [];
    }
  }

// --- 3. é‡æ„æœç´¢ä¸»å…¥å£ (å·²å»é™¤å›¾æ ‡) ---
// --- 3. é‡æ„æœç´¢ä¸»å…¥å£ (å·²å»é™¤å›¾æ ‡) ---
async function addSongFromSearch() {
    // 1. ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©æ¨¡å¼ (å»é™¤äº† Emoji)
    const modeChoice = await showChoiceModal("è¯·é€‰æ‹©æ“ä½œæ¨¡å¼", [
        { text: 'æœç´¢æ­Œæ›² (æ–°æºÂ·æ”¯æŒé€‰éŸ³è´¨)', value: 'search_new' },
        { text: 'è§£ææ­Œå• (è¾“å…¥ID)', value: 'playlist_new' },
        { text: 'è§£æä¸“è¾‘ (è¾“å…¥ID)', value: 'album_new' },
        { text: 'æ™®é€šæœç´¢ (ç½‘æ˜“/è…¾è®¯æ—§æº)', value: 'search_old' }
    ]);

    if (!modeChoice) return;

    let searchResults = [];
    let selectedQuality = 'exhigh'; // é»˜è®¤æé«˜

    // 2. ç¬¬äºŒæ­¥ï¼šå¦‚æœæ˜¯æ–°æºï¼Œé€‰æ‹©éŸ³è´¨ (å»é™¤äº† Emoji)
    if (modeChoice.includes('_new')) {
        const qualityChoice = await showChoiceModal("è¯·é€‰æ‹©æœŸæœ›éŸ³è´¨", [
            { text: 'æ— æŸ (Lossless - FLAC)', value: 'lossless' },
            { text: 'é«˜è§£æ (Hi-Res - FLAC)', value: 'hires' },
            { text: 'æ¯å¸¦çº§ (Master - FLAC)', value: 'jymaster' },
            { text: 'æœæ¯”å…¨æ™¯å£° (Dolby - MP4)', value: 'dolby' },
            { text: 'æé«˜ (ExHigh - MP3)', value: 'exhigh' },
            { text: 'æ ‡å‡† (Standard - MP3)', value: 'standard' },
            { text: 'ç¯ç»•æ²‰æµ¸ (Sky)', value: 'sky' },
            { text: 'ç©ºé—´éŸ³æ•ˆ (Effect)', value: 'jyeffect' }
        ]);
        if (!qualityChoice) return;
        selectedQuality = qualityChoice;
    }

    // 3. ç¬¬ä¸‰æ­¥ï¼šè¾“å…¥å…³é”®è¯æˆ–ID
    let promptText = "è¯·è¾“å…¥æ­Œæ›²åç§°";
    if (modeChoice === 'playlist_new') promptText = "è¯·è¾“å…¥æ­Œå• ID (æ•°å­—)";
    if (modeChoice === 'album_new') promptText = "è¯·è¾“å…¥ä¸“è¾‘ ID (æ•°å­—)";
    
    const input = await showCustomPrompt(promptText, "åœ¨æ­¤è¾“å…¥...");
    if (!input || !input.trim()) return;
    const query = input.trim();

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚èµ„æº...");

    // 4. æ‰§è¡Œæœç´¢/è§£æ (ä¿æŒåŸé€»è¾‘ä¸å˜)
    try {
        if (modeChoice === 'search_new') {
            searchResults = await searchToubiec(query);
        } 
        else if (modeChoice === 'playlist_new') {
            searchResults = await getToubiecPlaylist(query);
            if (searchResults.length > 0) {
                 await showCustomAlert("è§£ææˆåŠŸ", `æˆåŠŸè§£ææ­Œå•ï¼Œå…± ${searchResults.length} é¦–æ­Œæ›²ã€‚`);
            }
        } 
        else if (modeChoice === 'album_new') {
            searchResults = await getToubiecAlbum(query);
            if (searchResults.length > 0) {
                 await showCustomAlert("è§£ææˆåŠŸ", `æˆåŠŸè§£æä¸“è¾‘ï¼Œå…± ${searchResults.length} é¦–æ­Œæ›²ã€‚`);
            }
        } 
        else if (modeChoice === 'search_old') {
            // æ—§ç‰ˆå¹¶è¡Œæœç´¢é€»è¾‘
            let musicName = query;
            let singerName = "";
            if (query.includes('-')) {
                const parts = query.split('-');
                musicName = parts[0].trim();
                singerName = parts[1].trim();
            }
            const [netease, tencent] = await Promise.all([
                searchNeteaseMusic(musicName, singerName),
                searchTencentMusic(musicName)
            ]);
            searchResults = [...netease, ...tencent];
        }
    } catch (e) {
        console.error(e);
        await showCustomAlert("é”™è¯¯", "æœç´¢æˆ–è§£æè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥IDæ˜¯å¦æ­£ç¡®ã€‚");
        return;
    }

    // 5. æ¸²æŸ“ç»“æœ
    if (searchResults.length === 0) {
      await showCustomAlert("æ— ç»“æœ", "æœªæ‰¾åˆ°ç›¸å…³å†…å®¹ã€‚");
      return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';
    document.getElementById('select-all-music-search').checked = false;

    searchResults.forEach(song => {
      // ã€å…³é”®ã€‘å°†ç”¨æˆ·é€‰æ‹©çš„éŸ³è´¨å†™å…¥æ­Œæ›²å¯¹è±¡
      if (modeChoice.includes('_new')) {
          song.preferredQuality = selectedQuality;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';
      item.dataset.songJson = JSON.stringify(song);

      // æ˜¾ç¤ºæ¥æºæ ‡ç­¾ (å»é™¤äº† Emoji)
      let sourceTag = '';
      if (song.source === 'toubiec') {
          // æ˜¾ç¤ºå…·ä½“çš„éŸ³è´¨æ ‡ç­¾
          const qualityLabels = {
              'lossless': 'æ— æŸ', 'hires': 'Hi-Res', 'jymaster': 'æ¯å¸¦',
              'dolby': 'æœæ¯”', 'exhigh': 'æé«˜', 'standard': 'æ ‡å‡†',
              'sky': 'å…¨æ™¯', 'jyeffect': 'ç©ºé—´'
          };
          const qLabel = qualityLabels[selectedQuality] || 'Pro';
          sourceTag = `<span class="source" style="color:#ff3b30; border-color:#ff3b30;">${qLabel}</span>`;
      } else if (song.source === 'netease') {
          sourceTag = '<span class="source" style="color:#c20c0c; border-color:#c20c0c;">ç½‘æ˜“äº‘</span>';
      } else {
          sourceTag = '<span class="source" style="color:#00e09e; border-color:#00e09e;">QQéŸ³ä¹</span>';
      }

      item.innerHTML = `
            <input type="checkbox" class="music-search-checkbox" style="margin-right: 15px;">
            <div class="search-result-info">
                <div class="title">${song.name}</div>
                <div class="artist">${song.artist} ${sourceTag}</div>
            </div>
        `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
}

 
  // --- 2. ä¿®æ”¹è¯¦æƒ…è·å–é€»è¾‘ (ä¿®å¤ç‰ˆï¼šå¢åŠ  detail è§£æä»¥è·å–å°é¢) ---
async function getPlayableSongDetails(songData) {
    let playableResult = null;
    let finalSource = songData.source;

    // --- å¤„ç† Toubiec æº ---
    if (songData.source === 'toubiec') {
        const quality = songData.preferredQuality || 'exhigh';
        
        // 1. è·å–æ’­æ”¾é“¾æ¥
        const url = await getToubiecUrl(songData.id, quality);
        
        // 2. ã€æ ¸å¿ƒä¿®å¤ã€‘è·å–æ­Œæ›²è¯¦æƒ… (ä¸ºäº†æ‹¿åˆ° picimg å°é¢)
        try {
            const detail = await getToubiecDetail(songData.id);
            if (detail) {
                // å¦‚æœAPIè¿”å›äº†å°é¢ï¼Œå¼ºåˆ¶æ›´æ–°
                if (detail.picimg) {
                    console.log(`[Toubiec] è·å–åˆ°å°é¢: ${detail.picimg}`);
                    songData.cover = detail.picimg;
                }
                // åŒæ­¥æ›´æ–°æ­Œæ‰‹å
                if (detail.singer) {
                    songData.artist = detail.singer;
                }
            }
        } catch (e) {
            console.warn("[Toubiec] è·å–è¯¦æƒ…å¤±è´¥ï¼Œå°†ä½¿ç”¨é»˜è®¤å°é¢", e);
        }

        if (url) {
             playableResult = {
                url: url.replace(/^http:\/\//i, 'https://'), // å¼ºåˆ¶ HTTPS
                id: songData.id,
                source: 'toubiec'
            };
        }
    } 
    // --- åŸæœ‰é€»è¾‘ (ç½‘æ˜“/è…¾è®¯) ---
    else if (songData.source === 'netease') {
        const primaryApiUrl = `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`;
        let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url) {
            playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
        }
    } else {
        const primaryApiUrl = `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
        let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url) {
             playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
        }
    }

    // --- ç»Ÿä¸€è¿”å›å¤„ç† ---
    if (playableResult) {
      let lrcContent = "";
      // è·å–æ­Œè¯
      if (finalSource === 'toubiec') {
          lrcContent = await getToubiecLyric(playableResult.id);
      } else {
          lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";
      }

      return {
        name: songData.name,
        artist: songData.artist,
        src: playableResult.url,
        cover: songData.cover, // è¿™é‡Œç°åœ¨å·²ç»æ˜¯æ›´æ–°è¿‡çš„å°é¢äº†
        isLocal: false,
        lrcContent: lrcContent
      };
    }

    return null;
}

 
  async function getLyricsForSong(songId, source) {
    const url = source === 'netease' ?
      `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}` :
      `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;

    const response = await Http_Get(url);
    if (response?.data) {
      const lrc = response.data.lrc || response.data.lyric || "";
      const tlyric = response.data.trans || response.data.tlyric || "";
      return lrc + "\n" + tlyric;
    }
    return "";
  }

  async function handleManualLrcImport(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal('é€‰æ‹©æ­Œè¯å¯¼å…¥æ–¹å¼', [{
        text: 'ğŸ“ ä»æœ¬åœ°æ–‡ä»¶ (.lrc)',
        value: 'file'
      },
      {
        text: 'ğŸ“‹ ç›´æ¥ç²˜è´´æ­Œè¯æ–‡æœ¬',
        value: 'paste'
      }
    ]);

    let lrcContent = null;

    if (choice === 'file') {
      lrcContent = await new Promise(resolve => {
        const lrcInput = document.getElementById('lrc-upload-input');
        const lrcChangeHandler = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = readEvent => resolve(readEvent.target.result);
            reader.onerror = () => resolve(null);
            reader.readAsText(file);
          } else {
            resolve(null);
          }
          lrcInput.removeEventListener('change', lrcChangeHandler);
          lrcInput.value = '';
        };
        lrcInput.addEventListener('change', lrcChangeHandler, {
          once: true
        });
        lrcInput.click();
      });
    } else if (choice === 'paste') {
      const pastedText = await showCustomPrompt('ç²˜è´´æ­Œè¯', 'è¯·åœ¨æ­¤å¤„ç²˜è´´å®Œæ•´çš„LRCæ ¼å¼æ­Œè¯...', '', 'textarea');
      if (pastedText) lrcContent = pastedText.replace(/\[/g, '\n[').trim();
    }

    if (lrcContent !== null) {
      musicState.playlist[trackIndex].lrcContent = lrcContent;


      await saveGlobalPlaylist(); 

      if (musicState.currentIndex === trackIndex) {
        musicState.parsedLyrics = parseLRC(lrcContent);
        renderLyrics();
        updateLyricsUI();
      }
      await showCustomAlert('æˆåŠŸ', `ã€Š${musicState.playlist[trackIndex].name}ã€‹çš„æ­Œè¯å·²æˆåŠŸä¿å­˜ï¼`);
    }
  }

  
  async function toggleBackgroundBlur() {
    if (musicState.currentIndex === -1) return;

    const track = musicState.playlist[musicState.currentIndex];
    if (!track) return;


    track.isBgClear = !track.isBgClear;


    await saveGlobalPlaylist();


    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    playerWindow.classList.toggle('bg-clear', track.isBgClear);
    toggleBtn.classList.toggle('active', track.isBgClear);
  }

 
  function toggleMusicPlayerAvatars() {
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    const toggleBtn = document.getElementById('show-avatars-btn');
    if (avatarDisplay && toggleBtn) {
      avatarDisplay.classList.toggle('visible');
      toggleBtn.classList.toggle('active');
    }
  }


  function togglePlayerFullscreen() {
    const playerWindow = document.querySelector('.music-player-window');
    const overlay = document.getElementById('music-player-overlay');
    if (playerWindow && overlay) {

      playerWindow.classList.toggle('fullscreen');
      overlay.classList.toggle('fullscreen-active');
    }
  }

  window.togglePlayerFullscreen = togglePlayerFullscreen;


  async function cleanupInvalidSongs() {
    if (musicState.playlist.length === 0) {
      alert("æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„ï¼Œæ— éœ€æ¸…ç†ã€‚");
      return;
    }

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤æ¸…ç†æ— æ•ˆæ­Œæ›²ï¼Ÿ',
      'æ­¤æ“ä½œå°†æ£€æŸ¥æ’­æ”¾åˆ—è¡¨ä¸­çš„æ¯ä¸€é¦–ç½‘ç»œæ­Œæ›²ï¼Œå¹¶ç§»é™¤æ‰€æœ‰æ— æ³•æ’­æ”¾çš„â€œæ­»é“¾â€ã€‚æœ¬åœ°æ­Œæ›²ä¸ä¼šå—å½±å“ã€‚', {
        confirmText: 'å¼€å§‹æ¸…ç†'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ£€æŸ¥ ${musicState.playlist.length} é¦–æ­Œæ›²ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´...`);

    const originalCount = musicState.playlist.length;
    const validPlaylist = [];
    const invalidSongs = [];

    const checkPromises = musicState.playlist.map(async (track) => {
      if (track.isLocal) {
        validPlaylist.push(track);
        return;
      }

      const isAvailable = await checkAudioAvailability(track.src);
      if (isAvailable) {
        validPlaylist.push(track);
      } else {
        invalidSongs.push({
          name: track.name,
          artist: track.artist || 'æœªçŸ¥æ­Œæ‰‹'
        });
        console.warn(`æ— æ•ˆé“¾æ¥: ${track.name} - ${track.src}`);
      }
    });

    await Promise.all(checkPromises);

    const removedCount = originalCount - validPlaylist.length;

    if (removedCount > 0) {
      const currentPlayingTrack = musicState.playlist[musicState.currentIndex];
      const isCurrentTrackRemoved = invalidSongs.some(s => s.name === currentPlayingTrack?.name);

      musicState.playlist = validPlaylist;
      await saveGlobalPlaylist();

      if (isCurrentTrackRemoved) {
        audioPlayer.pause();
        audioPlayer.src = '';
        musicState.currentIndex = musicState.playlist.length > 0 ? 0 : -1;
        musicState.isPlaying = false;
      } else if (currentPlayingTrack) {
        musicState.currentIndex = musicState.playlist.findIndex(t => t.src === currentPlayingTrack.src);
      }

      updatePlaylistUI();
      updatePlayerUI();

      // æ˜¾ç¤ºè¢«æ¸…ç†çš„æ­Œæ›²åˆ—è¡¨æ¨¡æ€æ¡†
      showCleanedSongsModal(invalidSongs);
    } else {
      await showCustomAlert("æ£€æŸ¥å®Œæˆ", "æ‰€æœ‰æ­Œæ›²é“¾æ¥å‡æœ‰æ•ˆï¼Œæ— éœ€æ¸…ç†ï¼");
    }
  }

  // æ˜¾ç¤ºè¢«æ¸…ç†æ­Œæ›²çš„æ¨¡æ€æ¡†
  function showCleanedSongsModal(cleanedSongs) {
    const modal = document.getElementById('cleaned-songs-modal');
    const listEl = document.getElementById('cleaned-songs-list');
    listEl.innerHTML = '';
    document.getElementById('select-all-cleaned-songs').checked = false;

    cleanedSongs.forEach(song => {
      const item = document.createElement('div');
      item.className = 'search-result-item';
      item.dataset.songJson = JSON.stringify(song);

      item.innerHTML = `
        <input type="checkbox" class="cleaned-song-checkbox" style="margin-right: 15px;">
        <div class="search-result-info">
          <div class="title">${song.name}</div>
          <div class="artist">${song.artist}</div>
        </div>
      `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  // å¤„ç†é‡æ–°æœç´¢é€‰ä¸­çš„æ­Œæ›²
  async function handleResearchSelectedSongs() {
    const modal = document.getElementById('cleaned-songs-modal');
    const checkboxes = modal.querySelectorAll('.cleaned-song-checkbox:checked');
    
    if (checkboxes.length === 0) {
      await showCustomAlert("æç¤º", "è¯·å…ˆé€‰æ‹©è¦é‡æ–°æœç´¢çš„æ­Œæ›²");
      return;
    }

    const selectedSongs = [];
    checkboxes.forEach(cb => {
      const item = cb.closest('.search-result-item');
      const songData = JSON.parse(item.dataset.songJson);
      selectedSongs.push(songData);
    });

    // å…³é—­è¢«æ¸…ç†æ­Œæ›²æ¨¡æ€æ¡†
    modal.classList.remove('visible');

    // é€ä¸ªå¤„ç†
    await processResearchSongsOneByOne(selectedSongs);
  }

  // é€ä¸ªå¤„ç†é‡æ–°æœç´¢çš„æ­Œæ›²
  async function processResearchSongsOneByOne(songs) {
    for (let i = 0; i < songs.length; i++) {
      const song = songs[i];
      let searchQuery = `${song.name} ${song.artist}`;

      // è®©ç”¨æˆ·ç¡®è®¤æˆ–ä¿®æ”¹æœç´¢å…³é”®è¯
      const userQuery = prompt(`ç¬¬ ${i + 1}/${songs.length} é¦–\n\nè¯·ç¡®è®¤æˆ–ä¿®æ”¹æœç´¢å…³é”®è¯ï¼š`, searchQuery);
      
      if (userQuery === null) {
        // ç”¨æˆ·ç‚¹å‡»å–æ¶ˆï¼Œè¯¢é—®æ˜¯å¦ç»§ç»­ä¸‹ä¸€é¦–
        const continueNext = await showCustomConfirm(
          "å·²å–æ¶ˆ",
          `æ˜¯å¦ç»§ç»­æœç´¢ä¸‹ä¸€é¦–æ­Œæ›²ï¼Ÿ`,
          { confirmText: 'ç»§ç»­' }
        );
        if (!continueNext) break;
        continue;
      }

      searchQuery = userQuery.trim();
      if (!searchQuery) {
        await showCustomAlert("æç¤º", "æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©º");
        i--; // é‡æ–°å¤„ç†å½“å‰æ­Œæ›²
        continue;
      }

      // æœç´¢å¾ªç¯ï¼Œå…è®¸é‡æ–°è¾“å…¥å…³é”®è¯
      let searchSuccess = false;
      while (!searchSuccess) {
        await showCustomAlert("æœç´¢ä¸­...", `æ­£åœ¨æœç´¢ï¼š${searchQuery}`);

        try {
          // ä½¿ç”¨é»˜è®¤çš„ exhigh éŸ³è´¨æœç´¢
          const searchResults = await searchToubiec(searchQuery);

          if (searchResults.length === 0) {
            // æœªæ‰¾åˆ°ç»“æœï¼Œè¯¢é—®æ˜¯å¦é‡æ–°è¾“å…¥å…³é”®è¯
            const choice = await showChoiceModal("æœªæ‰¾åˆ°ç»“æœ", [
              { text: `"${searchQuery}" æ²¡æœ‰æœç´¢åˆ°ç»“æœ`, value: 'info' },
              { text: 'é‡æ–°è¾“å…¥å…³é”®è¯', value: 'retry' },
              { text: 'è·³è¿‡æ­¤æ­Œæ›²', value: 'skip' },
              { text: 'ç»“æŸæœç´¢', value: 'quit' }
            ]);

            if (choice === 'retry') {
              const newQuery = prompt(`è¯·é‡æ–°è¾“å…¥æœç´¢å…³é”®è¯ï¼š`, searchQuery);
              if (newQuery && newQuery.trim()) {
                searchQuery = newQuery.trim();
                continue; // ç»§ç»­æœç´¢å¾ªç¯
              } else {
                searchSuccess = true; // é€€å‡ºæœç´¢å¾ªç¯ï¼Œç»§ç»­ä¸‹ä¸€é¦–
                break;
              }
            } else if (choice === 'skip') {
              searchSuccess = true; // è·³è¿‡ï¼Œç»§ç»­ä¸‹ä¸€é¦–
              break;
            } else if (choice === 'quit') {
              return; // ç»“æŸæ•´ä¸ªæœç´¢æµç¨‹
            }
            continue;
          }

          // æ˜¾ç¤ºæœç´¢ç»“æœè®©ç”¨æˆ·é€‰æ‹©
          const selectedTrack = await showSongSelectionModal(searchResults, song.name, i + 1, songs.length);

          if (selectedTrack) {
            // è·å–æ­Œæ›²è¯¦æƒ…å¹¶æ·»åŠ åˆ°æ’­æ”¾åˆ—è¡¨
            const trackDetails = await getPlayableSongDetails(selectedTrack);
            
            if (trackDetails) {
              musicState.playlist.push(trackDetails);
              await saveGlobalPlaylist();
              updatePlaylistUI();
              await showCustomAlert("æ·»åŠ æˆåŠŸ", `"${song.name}" å·²æ·»åŠ åˆ°æ’­æ”¾åˆ—è¡¨`);
              searchSuccess = true; // æˆåŠŸï¼Œç»§ç»­ä¸‹ä¸€é¦–
            } else {
              await showCustomAlert("æ·»åŠ å¤±è´¥", `æ— æ³•è·å– "${song.name}" çš„æ’­æ”¾é“¾æ¥`);
              searchSuccess = true; // å¤±è´¥ä¹Ÿç»§ç»­ä¸‹ä¸€é¦–
            }
          } else {
            // ç”¨æˆ·å–æ¶ˆæˆ–è·³è¿‡
            searchSuccess = true; // ç»§ç»­ä¸‹ä¸€é¦–
          }

        } catch (e) {
          console.error(`æœç´¢ "${searchQuery}" å¤±è´¥:`, e);
          const retry = await showCustomConfirm(
            "æœç´¢å‡ºé”™",
            `æœç´¢ "${searchQuery}" æ—¶å‡ºé”™ï¼Œæ˜¯å¦é‡æ–°å°è¯•ï¼Ÿ`,
            { confirmText: 'é‡æ–°å°è¯•' }
          );
          if (!retry) {
            searchSuccess = true; // ä¸é‡è¯•ï¼Œç»§ç»­ä¸‹ä¸€é¦–
          }
        }
      }
    }

    await showCustomAlert("å®Œæˆ", "æ‰€æœ‰é€‰ä¸­çš„æ­Œæ›²å·²å¤„ç†å®Œæ¯•");
  }

  // æ˜¾ç¤ºæ­Œæ›²é€‰æ‹©æ¨¡æ€æ¡†
  function showSongSelectionModal(searchResults, songName, currentIndex, totalCount) {
    return new Promise((resolve) => {
      const modal = document.getElementById('music-search-results-modal');
      const listEl = document.getElementById('search-results-list');
      const headerSpan = modal.querySelector('.modal-header span');
      
      // ä¿®æ”¹æ ‡é¢˜æ˜¾ç¤ºå½“å‰è¿›åº¦
      headerSpan.textContent = `é€‰æ‹©æ­Œæ›² (${currentIndex}/${totalCount}): ${songName}`;
      
      listEl.innerHTML = '';
      document.getElementById('select-all-music-search').checked = false;

      // æ¸²æŸ“æœç´¢ç»“æœï¼ˆå•é€‰æ¨¡å¼ï¼‰
      searchResults.forEach(song => {
        song.preferredQuality = 'exhigh'; // é»˜è®¤æé«˜éŸ³è´¨

        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.style.cursor = 'pointer';

        let sourceTag = '';
        if (song.source === 'toubiec') {
          sourceTag = '<span class="source" style="color:#ff3b30; border-color:#ff3b30;">æé«˜</span>';
        } else if (song.source === 'netease') {
          sourceTag = '<span class="source" style="color:#c20c0c; border-color:#c20c0c;">ç½‘æ˜“äº‘</span>';
        } else {
          sourceTag = '<span class="source" style="color:#00e09e; border-color:#00e09e;">QQéŸ³ä¹</span>';
        }

        item.innerHTML = `
          <input type="radio" name="song-selection-radio" class="music-search-radio" style="margin-right: 15px;">
          <div class="search-result-info">
            <div class="title">${song.name}</div>
            <div class="artist">${song.artist} ${sourceTag}</div>
          </div>
        `;

        // ç‚¹å‡»æ•´è¡Œä¹Ÿèƒ½é€‰ä¸­
        item.addEventListener('click', (e) => {
          if (e.target.type !== 'radio') {
            const radio = item.querySelector('.music-search-radio');
            radio.checked = true;
          }
        });

        listEl.appendChild(item);
      });

      modal.classList.add('visible');

      // ä¸´æ—¶ä¿®æ”¹æŒ‰é’®æ–‡æœ¬å’ŒåŠŸèƒ½
      const cancelBtn = document.getElementById('cancel-music-search-btn');
      const confirmBtn = document.getElementById('add-selected-music-btn');
      
      const originalCancelText = cancelBtn.textContent;
      const originalConfirmText = confirmBtn.textContent;
      
      cancelBtn.textContent = 'è·³è¿‡';
      confirmBtn.textContent = 'ç¡®è®¤æ·»åŠ ';

      // å–æ¶ˆ/è·³è¿‡æŒ‰é’®
      const handleCancel = () => {
        cleanup();
        resolve(null);
      };

      // ç¡®è®¤æŒ‰é’®
      const handleConfirm = () => {
        const selectedRadio = modal.querySelector('.music-search-radio:checked');
        if (!selectedRadio) {
          alert('è¯·å…ˆé€‰æ‹©ä¸€é¦–æ­Œæ›²');
          return;
        }

        const item = selectedRadio.closest('.search-result-item');
        const songData = JSON.parse(item.dataset.songJson);
        cleanup();
        resolve(songData);
      };

      const cleanup = () => {
        modal.classList.remove('visible');
        headerSpan.textContent = 'æœç´¢ç»“æœ'; // æ¢å¤æ ‡é¢˜
        cancelBtn.textContent = originalCancelText;
        confirmBtn.textContent = originalConfirmText;
        cancelBtn.removeEventListener('click', handleCancel);
        confirmBtn.removeEventListener('click', handleConfirm);
      };

      cancelBtn.addEventListener('click', handleCancel);
      confirmBtn.addEventListener('click', handleConfirm);
    });
  }

function toggleReadingFullscreen() {
    const readingWindow = document.getElementById('reading-window');
    const readingOverlay = document.getElementById('reading-overlay');
    
    if (readingWindow && readingOverlay) {
        // åˆ‡æ¢å…¨å±ç±»å
        readingWindow.classList.toggle('fullscreen');
        readingOverlay.classList.toggle('fullscreen-active');
    }
}

// å°†å‡½æ•°æš´éœ²ç»™å…¨å±€ï¼ˆå¯é€‰ï¼Œä¸ºäº†ä¿é™©ï¼‰
window.toggleReadingFullscreen = toggleReadingFullscreen;

  function applyStatusBarVisibility() {
    const phoneScreen = document.getElementById('phone-screen');

    phoneScreen.classList.toggle('status-bar-visible', !!state.globalSettings.showStatusBar);
  }

  async function openClearPostsSelectorModal() {
    const modal = document.getElementById('clear-posts-modal');
    const listEl = document.getElementById('clear-posts-list');
    listEl.innerHTML = '';


    const options = [];


    options.push({
      text: 'æ¸…ç©ºæ‰€æœ‰åŠ¨æ€ (å±é™©)',
      value: 'all',
      isDanger: true
    });


    const myNickname = state.qzoneSettings.nickname || 'æˆ‘';
    options.push({
      text: `ä»…æ¸…ç©º ${myNickname} çš„åŠ¨æ€ (ç”¨æˆ·)`,
      value: 'user'
    });


    Object.values(state.chats).forEach(chat => {
      if (!chat.isGroup) {
        options.push({
          text: `ä»…æ¸…ç©º ${chat.name} çš„åŠ¨æ€ (è§’è‰²)`,
          value: chat.id
        });
      }
    });


    try {
      const npcs = await db.npcs.toArray();
      if (npcs.length > 0) {

        options.push({
          isSeparator: true,
          text: 'NPC åˆ—è¡¨'
        });

        npcs.forEach(npc => {
          options.push({
            text: `ä»…æ¸…ç©º ${npc.name} çš„åŠ¨æ€ (NPC)`,

            value: `npc_${npc.id}`
          });
        });
      }
    } catch (e) {
      console.error("åŠ è½½NPCåˆ—è¡¨å¤±è´¥:", e);
    }



    options.forEach(opt => {

      if (opt.isSeparator) {
        const separator = document.createElement('div');
        separator.textContent = opt.text;
        separator.style.cssText = `
                padding: 10px 18px 5px;
                font-size: 13px;
                font-weight: 500;
                color: var(--text-secondary);
                background-color: #f0f2f5;
                border-top: 1px solid var(--border-color);
                border-bottom: 1px solid var(--border-color);
                margin-top: 5px;
            `;
        listEl.appendChild(separator);
        return;
      }


      const item = document.createElement('div');
      item.className = 'clear-posts-item';
      if (opt.isDanger) {
        item.classList.add('danger-option');
      }
      item.dataset.targetId = opt.value;
      item.innerHTML = `
            <div class="checkbox"></div>
            <span class="name">${opt.text}</span>
        `;
      listEl.appendChild(item);
    });


    modal.classList.add('visible');
  }

 
  async function handleConfirmClearPosts() {
    const selectedItems = document.querySelectorAll('#clear-posts-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ¸…ç©ºçš„èŒƒå›´ã€‚");
      return;
    }

    const targetIds = Array.from(selectedItems).map(item => item.dataset.targetId);


    let targetNames = [];
    if (targetIds.includes('all')) {
      targetNames.push('æ‰€æœ‰åŠ¨æ€');
    } else {
      if (targetIds.includes('user')) {
        targetNames.push(`â€œ${state.qzoneSettings.nickname}â€`);
      }
      targetIds.forEach(id => {
        const character = state.chats[id];
        if (character) {
          targetNames.push(`â€œ${character.name}â€`);
        }
      });
    }
    const confirmMessage = `æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤ ${targetNames.join('ã€ ')} çš„æ‰€æœ‰åŠ¨æ€ï¼Œä¸”æ— æ³•æ¢å¤ï¼`;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤æ¸…ç©ºåŠ¨æ€ï¼Ÿ',
      confirmMessage, {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤æ¸…ç©º'
      }
    );

    if (!confirmed) return;

    try {
      if (targetIds.includes('all')) {
        await db.qzonePosts.clear();
      } else {

        await db.qzonePosts.where('authorId').anyOf(targetIds).delete();
      }


      qzonePostsCache = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
      qzonePostsRenderCount = 0;
      await renderQzonePosts();

      document.getElementById('clear-posts-modal').classList.remove('visible'); // å…³é—­é€‰æ‹©å™¨
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'é€‰å®šèŒƒå›´å†…çš„åŠ¨æ€å·²è¢«æ¸…ç©ºã€‚');

    } catch (error) {
      console.error("æ¸…ç©ºåŠ¨æ€æ—¶å‡ºé”™:", error);
      await showCustomAlert('æ“ä½œå¤±è´¥', `æ¸…ç©ºåŠ¨æ€æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
  }



  async function handleDeleteThought(timestamp) {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡å¿ƒå£°è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤åˆ é™¤'
      }
    );

    if (confirmed) {
      const chat = state.chats[state.activeChatId];
      if (!chat || !chat.thoughtsHistory) return;

      const indexToDelete = chat.thoughtsHistory.findIndex(thought => thought.timestamp === timestamp);
      if (indexToDelete === -1) return;


      const isLatest = indexToDelete === chat.thoughtsHistory.length - 1;


      chat.thoughtsHistory = chat.thoughtsHistory.filter(thought => thought.timestamp !== timestamp);


      if (isLatest) {
        if (chat.thoughtsHistory.length > 0) {

          const newLatestThought = chat.thoughtsHistory[chat.thoughtsHistory.length - 1];
          chat.heartfeltVoice = newLatestThought.heartfeltVoice;
          chat.randomJottings = newLatestThought.randomJottings;

          const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
          const randomJottingsEl = document.getElementById('profile-random-jottings');
          if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
          if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

          console.log("å·²åˆ é™¤æœ€æ–°å¿ƒå£°ï¼Œå½“å‰å¿ƒå£°å·²å›æ»šè‡³ä¸Šä¸€æ¡ã€‚");
        } else {

          chat.heartfeltVoice = '...';
          chat.randomJottings = '...';


          const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
          const randomJottingsEl = document.getElementById('profile-random-jottings');
          if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
          if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

          console.log("å·²åˆ é™¤æœ€åä¸€æ¡å¿ƒå£°ï¼Œå½“å‰å¿ƒå£°å·²é‡ç½®ã€‚");
        }
      }

      await db.chats.put(chat);


      renderThoughtsHistory();

      await showCustomAlert('æˆåŠŸ', 'è¯¥æ¡è®°å½•å·²æˆåŠŸåˆ é™¤ã€‚');
    }
  }


  document.getElementById('thoughts-history-list').addEventListener('click', (e) => {

    const deleteBtn = e.target.closest('.thought-delete-btn');
    if (deleteBtn) {

      const timestamp = parseInt(deleteBtn.dataset.timestamp);
      if (!isNaN(timestamp)) {

        handleDeleteThought(timestamp);
      }
    }
  });

 
  async function loadCssPresetsDropdown() {
    const selectEl = document.getElementById('css-preset-select');
    selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';

    const presets = await db.appearancePresets.where('type').equals('global_css').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }

 
  async function handleCssPresetSelectionChange() {
    const selectEl = document.getElementById('css-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {
      const cssInput = document.getElementById('global-css-input');
      cssInput.value = preset.value;
      applyGlobalCss(preset.value);
    }
  }


  async function saveCssPreset() {
    const name = await showCustomPrompt('ä¿å­˜CSSé¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;

    const cssValue = document.getElementById('global-css-input').value;

    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'global_css'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: cssValue
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'global_css',
        value: cssValue
      });
    }

    await loadCssPresetsDropdown();
    alert('CSS é¢„è®¾å·²ä¿å­˜ï¼');
  }

 
  async function deleteCssPreset() {
    const selectEl = document.getElementById('css-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('è¯·å…ˆä»ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadCssPresetsDropdown();
      alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
  }




  async function loadFontPresetsDropdown() {
    const selectEl = document.getElementById('font-preset-select');
    selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';

    const presets = await db.appearancePresets.where('type').equals('font').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }


  async function handleFontPresetSelectionChange() {
    const selectEl = document.getElementById('font-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {
      const fontUrlInput = document.getElementById('font-url-input');
      fontUrlInput.value = preset.value;
      applyCustomFont(preset.value, true);
    }
  }

 
  async function saveFontPreset() {
    const name = await showCustomPrompt('ä¿å­˜å­—ä½“é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;

    const fontUrl = document.getElementById('font-url-input').value.trim();
    if (!fontUrl) {
      alert("å­—ä½“URLä¸èƒ½ä¸ºç©ºï¼");
      return;
    }

    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'font'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: fontUrl
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'font',
        value: fontUrl
      });
    }

    await loadFontPresetsDropdown();
    alert('å­—ä½“é¢„è®¾å·²ä¿å­˜ï¼');
  }


  async function deleteFontPreset() {
    const selectEl = document.getElementById('font-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('è¯·å…ˆä»ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadFontPresetsDropdown();
      alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
  }
  // æ‰¾åˆ°è¿™ä¸ªå‡½æ•°å¹¶æ›¿æ¢
  async function loadAppearancePresetsDropdown(forceSelectedId = null) {
    const selectEl = document.getElementById('appearance-preset-select');
    selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';

    const presets = await db.appearancePresets.where('type').equals('appearance').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });

    // å¦‚æœä¼ å…¥äº†å¼ºåˆ¶é€‰ä¸­çš„IDï¼Œç›´æ¥é€‰ä¸­å®ƒï¼Œä¸å†è¿›è¡Œå¤æ‚çš„å¯¹æ¯”
    if (forceSelectedId) {
        selectEl.value = forceSelectedId;
        return;
    }

    // åªæœ‰åœ¨æ²¡æœ‰å¼ºåˆ¶é€‰ä¸­æ—¶ï¼Œæ‰æ‰§è¡ŒåŸæ¥çš„è‡ªåŠ¨åŒ¹é…é€»è¾‘
    const currentSettings = {
      wallpaper: state.globalSettings.wallpaper,
      cphoneWallpaper: state.globalSettings.cphoneWallpaper,
      globalChatBackground: state.globalSettings.globalChatBackground,
      appIcons: state.globalSettings.appIcons,
      cphoneAppIcons: state.globalSettings.cphoneAppIcons,
      myphoneAppIcons: state.globalSettings.myphoneAppIcons,
      chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
      theme: localStorage.getItem('ephone-theme') || 'light',
      showStatusBar: state.globalSettings.showStatusBar,
      notificationSoundUrl: state.globalSettings.notificationSoundUrl,
      widgetData: state.globalSettings.widgetData
    };

    let matchingPresetId = null;

    for (const preset of presets) {
      if (JSON.stringify(preset.value) === JSON.stringify(currentSettings)) {
        matchingPresetId = preset.id;
        break;
      }
    }

    if (matchingPresetId) {
      selectEl.value = matchingPresetId;
    } else {
      selectEl.value = '';
    }
  }


 
  // æ‰¾åˆ°è¿™ä¸ªå‡½æ•°å¹¶æ›¿æ¢
  async function handleAppearancePresetSelectionChange() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset && preset.value) {
      const data = preset.value;

      // 1. æ™ºèƒ½åˆå¹¶å›¾æ ‡ï¼ˆä¿ç•™ä¸Šä¸€è½®çš„ä¿®å¤ï¼‰
      const mergedAppIcons = {
        ...DEFAULT_APP_ICONS,      
        ...(data.appIcons || {})   
      };
      const mergedCPhoneIcons = {
        ...DEFAULT_CPHONE_ICONS,       
        ...(data.cphoneAppIcons || {}) 
      };
      const mergedMyPhoneIcons = {
        ...DEFAULT_MYPHONE_ICONS,
        ...(data.myphoneAppIcons || {})
      };

      Object.assign(state.globalSettings, data);
      state.globalSettings.appIcons = mergedAppIcons;
      state.globalSettings.cphoneAppIcons = mergedCPhoneIcons;
      state.globalSettings.myphoneAppIcons = mergedMyPhoneIcons;

      applyTheme(data.theme || 'light');
      await db.globalSettings.put(state.globalSettings);

      applyGlobalWallpaper();
      applyCPhoneWallpaper();
      renderIconSettings();       
      renderCPhoneIconSettings();
      renderMyPhoneIconSettings();
      applyAppIcons();
      applyCPhoneAppIcons();
      applyMyPhoneAppIconsGlobal();
      applyStatusBarVisibility();
      applyWidgetData();
      
      if (data.chatActionButtonsOrder) {
          renderButtonOrderEditor();
          applyButtonOrder();
      }

      // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šè°ƒç”¨ renderWallpaperScreen æ—¶ä¼ å…¥ selectedId
      // è¿™æ ·ä¸‹æ‹‰æ¡†å°±ä¼šè¢«å¼ºåˆ¶è®¾ç½®ä¸ºå½“å‰é€‰ä¸­çš„é¢„è®¾ï¼Œè€Œä¸ä¼šè·³å›â€œè¯·é€‰æ‹©â€
      renderWallpaperScreen(selectedId);

      alert(`å·²æˆåŠŸåŠ è½½å¤–è§‚é¢„è®¾ï¼šâ€œ${preset.name}â€\n(ç¼ºå¤±çš„æ–°Appå›¾æ ‡å·²è‡ªåŠ¨é‡ç½®ä¸ºé»˜è®¤)`);
    }
  }

 
  async function saveAppearancePreset() {
    const name = await showCustomPrompt('ä¿å­˜å¤–è§‚é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;


    const appearanceData = {
      wallpaper: state.globalSettings.wallpaper,
      cphoneWallpaper: state.globalSettings.cphoneWallpaper,
      globalChatBackground: state.globalSettings.globalChatBackground,
      appIcons: state.globalSettings.appIcons,
      cphoneAppIcons: state.globalSettings.cphoneAppIcons,
      myphoneAppIcons: state.globalSettings.myphoneAppIcons,
      chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
      theme: localStorage.getItem('ephone-theme') || 'light',
      showStatusBar: state.globalSettings.showStatusBar,
      notificationSoundUrl: state.globalSettings.notificationSoundUrl,
      widgetData: state.globalSettings.widgetData
    };


    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'appearance'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: appearanceData
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'appearance',
        value: appearanceData
      });
    }


    await loadAppearancePresetsDropdown();
    alert('å¤–è§‚é¢„è®¾å·²ä¿å­˜ï¼');
  }

 
  async function deleteAppearancePreset() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('è¯·å…ˆä»ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadAppearancePresetsDropdown();
      alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
  }



  
  async function loadThemePresetsDropdown() {
    const selectEl = document.getElementById('theme-preset-select');
    selectEl.innerHTML = '<option value="">-- é€‰æ‹©ä¸€ä¸ªé¢„è®¾ --</option>';

    const presets = await db.appearancePresets.where('type').equals('bubble_theme').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }

 
  async function handleThemePresetSelectionChange() {
    const selectEl = document.getElementById('theme-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {


      const baseTheme = preset.value.base || 'default';
      const customCss = preset.value.custom || '';


      const themeRadio = document.querySelector(`input[name="theme-select"][value="${baseTheme}"]`);
      if (themeRadio) {
        themeRadio.checked = true;
      }


      const customCssInput = document.getElementById('custom-css-input');
      customCssInput.value = customCss;


      updateSettingsPreview();

    }
  }

 
  async function saveThemePreset() {
    const name = await showCustomPrompt('ä¿å­˜ä¸»é¢˜é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
    if (!name || !name.trim()) return;



    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    const themeValue = selectedThemeRadio ? selectedThemeRadio.value : 'default';


    const cssValue = document.getElementById('custom-css-input').value.trim();


    const presetValueObject = {
      base: themeValue,
      custom: cssValue
    };


    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'bubble_theme'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('è¦†ç›–é¢„è®¾', `åä¸º â€œ${name.trim()}â€ çš„é¢„è®¾å·²å­˜åœ¨ã€‚è¦è¦†ç›–å®ƒå—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;


      await db.appearancePresets.update(existingPreset.id, {
        value: presetValueObject
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'bubble_theme',

        value: presetValueObject
      });
    }

    await loadThemePresetsDropdown();
    alert('ä¸»é¢˜é¢„è®¾å·²ä¿å­˜ï¼');
  }

  
  async function deleteThemePreset() {
    const selectEl = document.getElementById('theme-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('è¯·å…ˆä»ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„é¢„è®¾ã€‚');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤é¢„è®¾ â€œ${preset.name}â€ å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadThemePresetsDropdown();
      alert('é¢„è®¾å·²åˆ é™¤ã€‚');
    }
  }



 
  async function openStickerCategoryManager() {
    await renderStickerCategoriesInManager();
    document.getElementById('sticker-category-manager-modal').classList.add('visible');
  }


  async function renderStickerCategoriesInManager() {
    const listEl = document.getElementById('existing-sticker-categories-list');
    const categories = await db.stickerCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
      return;
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
                `;
      listEl.appendChild(item);
    });
  }

  async function addNewStickerCategory() {
    const input = document.getElementById('new-sticker-category-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
      return;
    }
    const existing = await db.stickerCategories.where('name').equals(name).first();
    if (existing) {
      alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
      return;
    }
    await db.stickerCategories.add({
      name
    });
    input.value = '';
    await renderStickerCategoriesInManager();
  }


  async function deleteStickerCategory(categoryId) {
    const category = await db.stickerCategories.get(categoryId);
    if (!category) return;

    const stickersInCateogry = await db.userStickers.where('categoryId').equals(categoryId).count();

    const confirmMessage = stickersInCateogry > 0 ?
      `ç¡®å®šè¦åˆ é™¤åˆ†ç±»ã€Š${category.name}ã€‹å—ï¼Ÿ\n\nã€è­¦å‘Šã€‘\næ­¤æ“ä½œå°†åŒæ—¶æ°¸ä¹…åˆ é™¤è¯¥åˆ†ç±»ä¸‹çš„ ${stickersInCateogry} ä¸ªè¡¨æƒ…åŒ…ï¼Œä¸”æ— æ³•æ¢å¤ï¼` :
      `ç¡®å®šè¦åˆ é™¤åˆ†ç±»ã€Š${category.name}ã€‹å—ï¼Ÿ`;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤åˆ†ç±»',
      confirmMessage, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      try {

        await db.transaction('rw', db.stickerCategories, db.userStickers, async () => {

          const stickerIdsToDelete = await db.userStickers.where('categoryId').equals(categoryId).primaryKeys();


          if (stickerIdsToDelete.length > 0) {
            await db.userStickers.bulkDelete(stickerIdsToDelete);
          }


          await db.stickerCategories.delete(categoryId);
        });


        state.userStickers = await db.userStickers.toArray();
        if (activeStickerCategoryId === categoryId) {
          activeStickerCategoryId = 'all';
        }
        await renderStickerCategoriesInManager();
        await renderStickerPanel();

        alert(`åˆ†ç±»ã€Š${category.name}ã€‹åŠå…¶ä¸‹çš„è¡¨æƒ…å·²æˆåŠŸåˆ é™¤ã€‚`);

      } catch (error) {
        console.error("åˆ é™¤åˆ†ç±»åŠè¡¨æƒ…æ—¶å‡ºé”™:", error);
        alert("åˆ é™¤å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°é”™è¯¯ä¿¡æ¯ã€‚");
      }
    }
  }


  function switchStickerCategory(categoryId) {
    activeStickerCategoryId = categoryId;
    document.querySelectorAll('.sticker-category-tab').forEach(tab => {
      tab.classList.toggle('active', String(tab.dataset.categoryId) === String(categoryId));
    });
    renderStickerPanel(false);


    const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
    if (selectAllCheckbox) selectAllCheckbox.checked = false;
  }

 
  async function exportSingleChat() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    try {
      const backupData = {
        type: 'EPhoneSingleChat',
        version: 1,
        chatData: chat
      };

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;

      link.download = `EPhone-Chat-${chat.name}-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('å¯¼å‡ºæˆåŠŸ', `ä¸â€œ${chat.name}â€çš„èŠå¤©è®°å½•å·²æˆåŠŸå¯¼å‡ºï¼`);

    } catch (error) {
      console.error("å¯¼å‡ºå•ä¸ªèŠå¤©æ—¶å‡ºé”™:", error);
      await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
  }

 
  async function importSingleChat(file) {
    if (!file || !state.activeChatId) return;
    const currentChatId = state.activeChatId;
    const currentChat = state.chats[currentChatId];

    try {
      const text = await file.text();
      const data = JSON.parse(text);


      if (data.type !== 'EPhoneSingleChat' || !data.chatData) {
        throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å•èŠå¤‡ä»½æ–‡ä»¶ã€‚");
      }


      const confirmed = await showCustomConfirm(
        'ä¸¥é‡è­¦å‘Šï¼',
        `è¿™å°†ç”¨å¤‡ä»½æ–‡ä»¶ä¸­çš„æ•°æ®ã€å®Œå…¨è¦†ç›–ã€‘å½“å‰ä¸â€œ${currentChat.name}â€çš„èŠå¤©è®°å½•å’Œè®¾ç½®ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼<br><br><strong>ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</strong>`, {
          confirmButtonClass: 'btn-danger',
          confirmText: 'ç¡®è®¤è¦†ç›–'
        }
      );

      if (!confirmed) return;


      const importedChatData = data.chatData;


      importedChatData.id = currentChatId;


      await db.chats.put(importedChatData);
      state.chats[currentChatId] = importedChatData;


      await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'èŠå¤©è®°å½•å·²æˆåŠŸè¦†ç›–ï¼æ­£åœ¨åˆ·æ–°ç•Œé¢...');


      renderChatInterface(currentChatId);
      renderChatList();
      document.getElementById('chat-settings-btn').click();

    } catch (error) {
      console.error("å¯¼å…¥å•ä¸ªèŠå¤©æ—¶å‡ºé”™:", error);
      await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£ææˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
    }
  }



  function openCharacterSelector() {
    renderCharacterSelector();
    showScreen('character-selection-screen');
  }

  // MY Phone ç›¸å…³å˜é‡
  let activeMyPhoneCharacterId = null;
  
  // MY Phone é”å±çŠ¶æ€
  let myPhoneLockScreenState = {
    passwordBuffer: '',
    isLocked: false,
    pendingCharacterId: null
  };
  
  // MY Phone åˆ é™¤æ¨¡å¼ç›¸å…³çŠ¶æ€
  let myPhoneDeleteMode = {
    active: false,
    appType: null, // 'qq', 'album', 'browser', 'taobao', 'memo', 'diary', 'usage', 'music', 'amap'
    selectedIndices: new Set()
  };

  function openMyphoneScreen() {
    renderMyPhoneCharacterSelector();
    showScreen('myphone-selection-screen');
  }

  // openCharacterGeneratorScreen ç”± character-generator.js æä¾›

  function renderMyPhoneCharacterSelector() {
    const gridEl = document.getElementById('myphone-character-grid');
    gridEl.innerHTML = '';

    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰å¯ä»¥æŸ¥çœ‹æ‰‹æœºçš„è§’è‰²å“¦~</p>';
      return;
    }

    characters.forEach(char => {
      const item = document.createElement('div');
      item.className = 'character-select-item';
      item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
      item.addEventListener('click', () => switchToMyPhoneCharacter(char.id));
      gridEl.appendChild(item);
    });
  }

  async function switchToMyPhoneCharacter(characterId) {
    const char = state.chats[characterId];
    if (!char) return;
    
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†MyPhoneé”å±
    if (char.settings.myPhoneLockScreenEnabled) {
      // ä¿å­˜å¾…è¿›å…¥çš„è§’è‰²ID
      myPhoneLockScreenState.pendingCharacterId = characterId;
      
      // æ˜¾ç¤ºé”å±ç•Œé¢
      showMyPhoneLockScreen(char);
      return;
    }
    
    // å¦‚æœæ²¡æœ‰å¯ç”¨é”å±ï¼Œç›´æ¥è¿›å…¥
    enterMyPhone(characterId);
  }
  
  function enterMyPhone(characterId) {
    activeMyPhoneCharacterId = characterId;
    console.log(`å·²åˆ‡æ¢åˆ°è§’è‰² ${characterId} æŸ¥çœ‹æˆ‘çš„æ‰‹æœº`);

    applyMyPhoneWallpaper();
    applyMyPhoneAppIcons();

    renderMyPhoneHomeScreen();
    showScreen('myphone-screen');
  }

  function renderMyPhoneHomeScreen() {
    switchToMyPhoneScreen('myphone-home-screen');
  }

  function switchToMyPhoneScreen(screenId) {
    document.querySelectorAll('#myphone-screen .char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
  }

  function switchToMyPhoneHomeScreen() {
    switchToMyPhoneScreen('myphone-home-screen');
  }

  function switchToCPhone() {
    // ä» MY Phone åˆ‡æ¢å› CP Phone è§’è‰²é€‰æ‹©
    openCharacterSelector();
  }

  function openMyPhoneSettings() {
    // å›æ˜¾è®¾ç½®
    const char = state.chats[activeMyPhoneCharacterId];
    if (char) {
      const toggle = document.getElementById('myphone-lock-screen-toggle');
      const detail = document.getElementById('myphone-lock-screen-settings-detail');
      const passwordInput = document.getElementById('myphone-lock-screen-password-input');
      
      if (toggle) {
        toggle.checked = char.settings.myPhoneLockScreenEnabled || false;
        if (detail) {
          detail.style.display = toggle.checked ? 'block' : 'none';
        }
      }
      
      if (passwordInput) {
        passwordInput.value = char.settings.myPhoneLockScreenPassword || '';
      }
    }
    
    switchToMyPhoneScreen('myphone-settings-screen');
  }
  
  function showMyPhoneLockScreen(char) {
    const lockScreen = document.getElementById('lock-screen');
    
    // è®¾ç½®å£çº¸ï¼ˆä½¿ç”¨ä¸»å±å¹•çš„é”å±å£çº¸ï¼‰
    if (state.globalSettings.lockScreenWallpaper) {
      lockScreen.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
    } else {
      lockScreen.style.backgroundImage = 'linear-gradient(135deg, #1c1c1e, #3a3a3c)';
    }
    
    // æ ‡è®°ä¸ºMyPhoneé”å±æ¨¡å¼
    myPhoneLockScreenState.isLocked = true;
    lockScreen.classList.add('active');
    lockScreen.classList.add('myphone-lock-mode');
    
    // æ›´æ–°æ—¶é’Ÿ
    updateMyPhoneLockScreenClock();
  }
  
  function updateMyPhoneLockScreenClock() {
    if (!myPhoneLockScreenState.isLocked) return;
    
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
    const dateString = now.toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'long' });
    
    document.getElementById('lock-time').textContent = timeString;
    document.getElementById('lock-date').textContent = dateString;
  }
  
  function showMyPhonePasswordInput() {
    const lockScreen = document.getElementById('lock-screen');
    const passwordArea = document.getElementById('lock-password-area');
    
    lockScreen.classList.add('input-mode');
    passwordArea.style.display = 'flex';
    myPhoneLockScreenState.passwordBuffer = '';
    updateMyPhoneLockDots();
  }
  
  function hideMyPhonePasswordInput() {
    const lockScreen = document.getElementById('lock-screen');
    const passwordArea = document.getElementById('lock-password-area');
    
    lockScreen.classList.remove('input-mode');
    passwordArea.style.display = 'none';
    myPhoneLockScreenState.passwordBuffer = '';
  }
  
  function updateMyPhoneLockDots() {
    const dots = document.querySelectorAll('.lock-dots .dot');
    const len = myPhoneLockScreenState.passwordBuffer.length;
    dots.forEach((dot, index) => {
      if (index < len) dot.classList.add('filled');
      else dot.classList.remove('filled');
    });
  }
  
  function checkMyPhoneLockPassword() {
    const characterId = myPhoneLockScreenState.pendingCharacterId;
    if (!characterId) return;
    
    const char = state.chats[characterId];
    if (!char) return;
    
    const correctPassword = char.settings.myPhoneLockScreenPassword;
    
    if (myPhoneLockScreenState.passwordBuffer === correctPassword) {
      // è§£é”æˆåŠŸ
      const lockScreen = document.getElementById('lock-screen');
      lockScreen.classList.add('unlocking');
      myPhoneLockScreenState.isLocked = false;
      
      setTimeout(() => {
        lockScreen.classList.remove('active');
        lockScreen.classList.remove('unlocking');
        lockScreen.classList.remove('myphone-lock-mode');
        hideMyPhonePasswordInput();
        
        // è¿›å…¥MyPhone
        enterMyPhone(characterId);
        myPhoneLockScreenState.pendingCharacterId = null;
      }, 500);
    } else {
      // è§£é”å¤±è´¥
      const dots = document.querySelector('.lock-dots');
      dots.classList.add('shake-animation');
      if(navigator.vibrate) navigator.vibrate(200);
      
      setTimeout(() => {
        dots.classList.remove('shake-animation');
        myPhoneLockScreenState.passwordBuffer = '';
        updateMyPhoneLockDots();
      }, 400);
    }
  }

  function openMyPhoneViewRecords() {
    switchToMyPhoneScreen('myphone-view-records-screen');
  }

  // MY Phone åˆ é™¤æ¨¡å¼åŠŸèƒ½
  function toggleMyPhoneDeleteMode(appType) {
    if (myPhoneDeleteMode.active && myPhoneDeleteMode.appType === appType) {
      // é€€å‡ºåˆ é™¤æ¨¡å¼
      exitMyPhoneDeleteMode();
    } else {
      // è¿›å…¥åˆ é™¤æ¨¡å¼
      enterMyPhoneDeleteMode(appType);
    }
  }

  function enterMyPhoneDeleteMode(appType) {
    myPhoneDeleteMode.active = true;
    myPhoneDeleteMode.appType = appType;
    myPhoneDeleteMode.selectedIndices.clear();
    
    // æ›´æ–°æŒ‰é’®UI - æ·»åŠ åˆ é™¤æ¨¡å¼å·¥å…·æ 
    const screen = document.getElementById(`myphone-${appType}-screen`);
    if (!screen) return;
    
    const header = screen.querySelector('.header');
    if (!header) return;
    
    // éšè—å…¶ä»–æŒ‰é’®ï¼Œåªæ˜¾ç¤ºè¿”å›æŒ‰é’®
    const actionBtns = header.querySelectorAll('.action-btn');
    actionBtns.forEach(btn => btn.style.display = 'none');
    
    // åˆ›å»ºåˆ é™¤æ¨¡å¼å·¥å…·æ 
    let deleteToolbar = header.querySelector('.delete-mode-toolbar');
    if (!deleteToolbar) {
      deleteToolbar = document.createElement('div');
      deleteToolbar.className = 'delete-mode-toolbar';
      deleteToolbar.style.cssText = 'display: flex; gap: 8px; align-items: center;';
      deleteToolbar.innerHTML = `
        <button class="delete-mode-btn" onclick="selectAllMyPhoneItems()" style="padding: 6px 12px; border: none; background: var(--accent-color); color: white; border-radius: 6px; cursor: pointer; font-size: 14px;">å…¨é€‰</button>
        <button class="delete-mode-btn" onclick="confirmDeleteMyPhoneItems()" style="padding: 6px 12px; border: none; background: #ff4444; color: white; border-radius: 6px; cursor: pointer; font-size: 14px;">åˆ é™¤</button>
        <button class="delete-mode-btn" onclick="exitMyPhoneDeleteMode()" style="padding: 6px 12px; border: none; background: var(--secondary-bg); color: var(--text-color); border-radius: 6px; cursor: pointer; font-size: 14px;">å–æ¶ˆ</button>
      `;
      header.appendChild(deleteToolbar);
    }
    deleteToolbar.style.display = 'flex';
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºå¤é€‰æ¡†
    rerenderMyPhoneApp(appType);
  }

  function exitMyPhoneDeleteMode() {
    if (!myPhoneDeleteMode.active) return;
    
    const appType = myPhoneDeleteMode.appType;
    myPhoneDeleteMode.active = false;
    myPhoneDeleteMode.appType = null;
    myPhoneDeleteMode.selectedIndices.clear();
    
    // æ¢å¤æŒ‰é’®UI
    const screen = document.getElementById(`myphone-${appType}-screen`);
    if (!screen) return;
    
    const header = screen.querySelector('.header');
    if (!header) return;
    
    // æ¢å¤æ˜¾ç¤ºæ“ä½œæŒ‰é’®
    const actionBtns = header.querySelectorAll('.action-btn');
    actionBtns.forEach(btn => btn.style.display = '');
    
    // éšè—åˆ é™¤æ¨¡å¼å·¥å…·æ 
    const deleteToolbar = header.querySelector('.delete-mode-toolbar');
    if (deleteToolbar) {
      deleteToolbar.style.display = 'none';
    }
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥éšè—å¤é€‰æ¡†
    rerenderMyPhoneApp(appType);
  }
  // å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
  window.exitMyPhoneDeleteMode = exitMyPhoneDeleteMode;

  function selectAllMyPhoneItems() {
    if (!myPhoneDeleteMode.active) return;
    
    const appType = myPhoneDeleteMode.appType;
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    let items = [];
    switch(appType) {
      case 'qq':
        items = char.myPhoneSimulatedQQConversations || [];
        break;
      case 'album':
        items = char.myPhoneAlbum || [];
        break;
      case 'browser':
        items = char.myPhoneBrowserHistory || [];
        break;
      case 'taobao':
        items = char.myPhoneTaobaoHistory || [];
        break;
      case 'memo':
        items = char.myPhoneMemos || [];
        break;
      case 'diary':
        items = char.myPhoneDiaries || [];
        break;
      case 'usage':
        items = char.myPhoneAppUsage || [];
        break;
      case 'music':
        items = char.myPhoneMusicPlaylist || [];
        break;
      case 'amap':
        items = char.myPhoneAmapHistory || [];
        break;
    }
    
    // åˆ¤æ–­æ˜¯å…¨é€‰è¿˜æ˜¯å–æ¶ˆå…¨é€‰
    const allSelected = myPhoneDeleteMode.selectedIndices.size === items.length;
    
    if (allSelected) {
      // å–æ¶ˆå…¨é€‰
      myPhoneDeleteMode.selectedIndices.clear();
    } else {
      // å…¨é€‰
      myPhoneDeleteMode.selectedIndices.clear();
      items.forEach((_, idx) => myPhoneDeleteMode.selectedIndices.add(idx));
    }
    
    // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
    updateMyPhoneCheckboxStates();
  }
  // å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
  window.selectAllMyPhoneItems = selectAllMyPhoneItems;

  function toggleMyPhoneItemSelection(index) {
    if (!myPhoneDeleteMode.active) return;
    
    if (myPhoneDeleteMode.selectedIndices.has(index)) {
      myPhoneDeleteMode.selectedIndices.delete(index);
    } else {
      myPhoneDeleteMode.selectedIndices.add(index);
    }
    
    // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
    updateMyPhoneCheckboxStates();
  }

  function updateMyPhoneCheckboxStates() {
    const checkboxes = document.querySelectorAll('.myphone-delete-checkbox');
    checkboxes.forEach(checkbox => {
      const index = parseInt(checkbox.dataset.index);
      checkbox.checked = myPhoneDeleteMode.selectedIndices.has(index);
    });
  }

  async function confirmDeleteMyPhoneItems() {
    if (!myPhoneDeleteMode.active || myPhoneDeleteMode.selectedIndices.size === 0) {
      showCustomAlert('æç¤º', 'è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹è¦åˆ é™¤çš„å†…å®¹');
      return;
    }
    
    const count = myPhoneDeleteMode.selectedIndices.size;
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${count} é¡¹å†…å®¹å—ï¼Ÿ`);
    
    if (!confirmed) return;
    
    const appType = myPhoneDeleteMode.appType;
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    // è·å–è¦åˆ é™¤çš„ç´¢å¼•æ•°ç»„ï¼Œä»å¤§åˆ°å°æ’åºï¼ˆé¿å…åˆ é™¤æ—¶ç´¢å¼•å˜åŒ–ï¼‰
    const indicesToDelete = Array.from(myPhoneDeleteMode.selectedIndices).sort((a, b) => b - a);
    
    // æ ¹æ®appTypeåˆ é™¤å¯¹åº”çš„æ•°æ®
    switch(appType) {
      case 'qq':
        if (!char.myPhoneSimulatedQQConversations) char.myPhoneSimulatedQQConversations = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneSimulatedQQConversations.splice(idx, 1);
        });
        break;
      case 'album':
        if (!char.myPhoneAlbum) char.myPhoneAlbum = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneAlbum.splice(idx, 1);
        });
        break;
      case 'browser':
        if (!char.myPhoneBrowserHistory) char.myPhoneBrowserHistory = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneBrowserHistory.splice(idx, 1);
        });
        break;
      case 'taobao':
        if (!char.myPhoneTaobaoHistory) char.myPhoneTaobaoHistory = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneTaobaoHistory.splice(idx, 1);
        });
        break;
      case 'memo':
        if (!char.myPhoneMemos) char.myPhoneMemos = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneMemos.splice(idx, 1);
        });
        break;
      case 'diary':
        if (!char.myPhoneDiaries) char.myPhoneDiaries = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneDiaries.splice(idx, 1);
        });
        break;
      case 'usage':
        if (!char.myPhoneAppUsage) char.myPhoneAppUsage = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneAppUsage.splice(idx, 1);
        });
        break;
      case 'music':
        if (!char.myPhoneMusicPlaylist) char.myPhoneMusicPlaylist = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneMusicPlaylist.splice(idx, 1);
        });
        break;
      case 'amap':
        if (!char.myPhoneAmapHistory) char.myPhoneAmapHistory = [];
        indicesToDelete.forEach(idx => {
          char.myPhoneAmapHistory.splice(idx, 1);
        });
        break;
    }
    
    // ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“
    await db.chats.put(char);
    
    // é€€å‡ºåˆ é™¤æ¨¡å¼å¹¶åˆ·æ–°åˆ—è¡¨
    exitMyPhoneDeleteMode();
    
    showCustomAlert('æˆåŠŸ', `å·²åˆ é™¤ ${count} é¡¹å†…å®¹`);
  }
  // å°†å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
  window.confirmDeleteMyPhoneItems = confirmDeleteMyPhoneItems;

  function rerenderMyPhoneApp(appType) {
    switch(appType) {
      case 'qq':
        renderMyPhoneSimulatedQQ();
        break;
      case 'album':
        renderMyPhoneAlbum();
        break;
      case 'browser':
        renderMyPhoneBrowserHistory();
        break;
      case 'taobao':
        renderMyPhoneTaobao();
        break;
      case 'memo':
        renderMyPhoneMemoList();
        break;
      case 'diary':
        renderMyPhoneDiaryList();
        break;
      case 'usage':
        renderMyPhoneAppUsage();
        break;
      case 'music':
        renderMyPhoneMusicScreen();
        break;
      case 'amap':
        renderMyPhoneAmap();
        break;
    }
  }

  // MY Phone æ·»åŠ è”ç³»äººé€‰æ‹©å¼¹çª—
  async function showMyPhoneAddContactDialog() {
    const modal = document.getElementById('myphone-add-choice-modal');
    if (!modal) return;
    
    modal.classList.add('visible');
  }

  // æ‰‹åŠ¨åˆ›å»ºè§’è‰²
  async function manualCreateMyPhoneContact() {
    // å…³é—­é€‰æ‹©å¼¹çª—
    document.getElementById('myphone-add-choice-modal')?.classList.remove('visible');
    
    // ç¬¬ä¸€æ­¥ï¼šè¾“å…¥è”ç³»äººåç§°
    const name = await showCustomPrompt('æ·»åŠ è”ç³»äºº (1/3)', 'è¯·è¾“å…¥è”ç³»äººåç§°');
    if (!name || !name.trim()) return;
    
    // ç¬¬äºŒæ­¥ï¼šè¾“å…¥å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰
    const remark = await showCustomPrompt('æ·»åŠ è”ç³»äºº (2/3)', 'è¯·è¾“å…¥å¤‡æ³¨ï¼ˆå¯é€‰ï¼Œæ˜¾ç¤ºåœ¨åˆ—è¡¨ä¸­ï¼‰', '', 'text');
    
    // ç¬¬ä¸‰æ­¥ï¼šé€‰æ‹©å¤´åƒæ–¹å¼
    const avatarChoice = await showChoiceModal('æ·»åŠ è”ç³»äºº (3/3)', [
      { text: 'ä½¿ç”¨é»˜è®¤å¤´åƒ', value: 'default' },
      { text: 'ä¸Šä¼ æœ¬åœ°å›¾ç‰‡', value: 'upload' },
      { text: 'è¾“å…¥å›¾ç‰‡URL', value: 'url' }
    ]);
    
    let finalAvatar = defaultAvatar;
    
    if (avatarChoice === 'upload') {
      // ä¸Šä¼ æœ¬åœ°å›¾ç‰‡
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      
      const avatarData = await new Promise((resolve) => {
        fileInput.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.readAsDataURL(file);
          } else {
            resolve(null);
          }
        };
        fileInput.click();
      });
      
      if (avatarData) {
        finalAvatar = avatarData;
      }
    } else if (avatarChoice === 'url') {
      // è¾“å…¥URL
      const avatarUrl = await showCustomPrompt('è¾“å…¥å¤´åƒURL', 'è¯·è¾“å…¥å›¾ç‰‡URLåœ°å€');
      if (avatarUrl && avatarUrl.trim()) {
        finalAvatar = avatarUrl.trim();
      }
    }
    
    // æ·»åŠ è”ç³»äºº
    await addMyPhoneContact(name.trim(), remark ? remark.trim() : '', finalAvatar);
    
    // åˆ·æ–°åˆ—è¡¨
    renderMyPhoneSimulatedQQ();
  }

  // æ˜¾ç¤ºå¯¼å…¥ä¸»å±å¹•è§’è‰²å¼¹çª—
  async function showImportMainScreenCharacters() {
    // å…³é—­é€‰æ‹©å¼¹çª—
    document.getElementById('myphone-add-choice-modal')?.classList.remove('visible');
    
    if (!activeMyPhoneCharacterId) return;
    const currentChar = state.chats[activeMyPhoneCharacterId];
    if (!currentChar) return;
    
    // è·å–æ‰€æœ‰éç¾¤ç»„è§’è‰²ï¼Œæ’é™¤å½“å‰è§’è‰²
    const allCharacters = Object.values(state.chats).filter(chat => 
      !chat.isGroup && chat.id !== activeMyPhoneCharacterId
    );
    
    if (allCharacters.length === 0) {
      showCustomAlert('æç¤º', 'æ²¡æœ‰å¯å¯¼å…¥çš„è§’è‰²');
      return;
    }
    
    // æ¸²æŸ“è§’è‰²åˆ—è¡¨
    const listEl = document.getElementById('myphone-import-list');
    listEl.innerHTML = '';
    
    allCharacters.forEach(char => {
      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.style.padding = '15px';
      item.style.borderBottom = '1px solid var(--border-color)';
      item.style.cursor = 'pointer';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.gap = '15px';
      
      const charAvatar = char.settings.aiAvatar || defaultAvatar;
      
      // è·å–æœ€åä¸€æ¡æ¶ˆæ¯
      const lastMessages = char.history.filter(m => !m.isHidden).slice(-10);
      const lastMsg = lastMessages.slice(-1)[0];
      let lastMsgText = 'æš‚æ— æ¶ˆæ¯';
      if (lastMsg) {
        if (typeof lastMsg.content === 'string') {
          lastMsgText = lastMsg.content.substring(0, 30);
        } else if (Array.isArray(lastMsg.content)) {
          lastMsgText = '[å›¾ç‰‡]';
        }
      }
      
      item.innerHTML = `
        <input type="checkbox" class="myphone-import-checkbox" data-char-id="${char.id}" style="width: 20px; height: 20px; cursor: pointer;">
        <img src="${charAvatar}" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover;">
        <div style="flex: 1; overflow: hidden;">
          <div style="font-weight: 500; font-size: 16px; margin-bottom: 5px;">${char.name}</div>
          <div style="font-size: 14px; color: #999; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${lastMsgText}</div>
        </div>
      `;
      
      // ç‚¹å‡»æ•´è¡Œåˆ‡æ¢é€‰ä¸­çŠ¶æ€
      item.addEventListener('click', (e) => {
        if (e.target.type !== 'checkbox') {
          const checkbox = item.querySelector('.myphone-import-checkbox');
          checkbox.checked = !checkbox.checked;
          updateImportSelectAllState();
        }
      });
      
      // checkbox å•ç‹¬ç›‘å¬
      const checkbox = item.querySelector('.myphone-import-checkbox');
      checkbox.addEventListener('change', () => {
        updateImportSelectAllState();
      });
      
      listEl.appendChild(item);
    });
    
    // æ˜¾ç¤ºå¼¹çª—
    document.getElementById('myphone-import-characters-modal').classList.add('visible');
  }

  // æ›´æ–°å…¨é€‰çŠ¶æ€
  function updateImportSelectAllState() {
    const allCheckboxes = document.querySelectorAll('.myphone-import-checkbox');
    const selectAllCheckbox = document.getElementById('select-all-myphone-import');
    
    if (allCheckboxes.length === 0) return;
    
    const checkedCount = Array.from(allCheckboxes).filter(cb => cb.checked).length;
    selectAllCheckbox.checked = checkedCount === allCheckboxes.length;
  }

  // å¯¼å…¥é€‰ä¸­çš„è§’è‰²
  async function importSelectedCharacters() {
    if (!activeMyPhoneCharacterId) return;
    const currentChar = state.chats[activeMyPhoneCharacterId];
    if (!currentChar) return;
    
    // è·å–é€‰ä¸­çš„è§’è‰²ID
    const selectedCheckboxes = Array.from(document.querySelectorAll('.myphone-import-checkbox:checked'));
    
    if (selectedCheckboxes.length === 0) {
      showCustomAlert('æç¤º', 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²');
      return;
    }
    
    const selectedCharIds = selectedCheckboxes.map(cb => cb.dataset.charId);
    
    // åˆå§‹åŒ–æ•°ç»„
    if (!currentChar.myPhoneSimulatedQQConversations) {
      currentChar.myPhoneSimulatedQQConversations = [];
    }
    
    // å¯¼å…¥æ¯ä¸ªé€‰ä¸­çš„è§’è‰²
    let importCount = 0;
    for (const charId of selectedCharIds) {
      const char = state.chats[charId];
      if (!char) continue;
      
      // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨
      const existingIndex = currentChar.myPhoneSimulatedQQConversations.findIndex(
        conv => conv.importedFromCharId === charId
      );
      
      if (existingIndex !== -1) {
        // å·²å­˜åœ¨ï¼Œè·³è¿‡
        continue;
      }
      
      // è·å–æœ€å10æ¡æ¶ˆæ¯
      const recentMessages = char.history.filter(m => !m.isHidden).slice(-10);
      
      // è½¬æ¢æ¶ˆæ¯æ ¼å¼ - ä¿æŒåŸå§‹æ ¼å¼ä»¥å…¼å®¹createMessageElement
      const convertedMessages = recentMessages.map(msg => {
        const isUser = msg.role === 'user';
        
        // ä¿æŒåŸå§‹æ¶ˆæ¯ç»“æ„
        const convertedMsg = {
          role: msg.role,
          content: msg.content,
          timestamp: msg.timestamp || Date.now(),
          sender: isUser ? (state.qzoneSettings.nickname || 'æˆ‘') : char.name
        };
        
        // å¦‚æœæœ‰å…¶ä»–å±æ€§ï¼Œä¹Ÿä¿ç•™
        if (msg.type) convertedMsg.type = msg.type;
        if (msg.imageUrl) convertedMsg.imageUrl = msg.imageUrl;
        if (msg.voiceUrl) convertedMsg.voiceUrl = msg.voiceUrl;
        if (msg.voiceText) convertedMsg.voiceText = msg.voiceText;
        if (msg.duration) convertedMsg.duration = msg.duration;
        
        return convertedMsg;
      });
      
      // è·å–æœ€åä¸€æ¡æ¶ˆæ¯æ–‡æœ¬
      let lastMessageText = 'æš‚æ— æ¶ˆæ¯';
      if (convertedMessages.length > 0) {
        const lastMsg = convertedMessages[convertedMessages.length - 1];
        lastMessageText = lastMsg.content.substring(0, 30);
      }
      
      // åˆ›å»ºæ–°è”ç³»äºº
      const newContact = {
        name: char.name,
        originalName: char.name,
        avatar: char.settings.aiAvatar || defaultAvatar,
        lastMessage: lastMessageText,
        messages: convertedMessages,
        isImported: true,
        importedFromCharId: charId
      };
      
      currentChar.myPhoneSimulatedQQConversations.push(newContact);
      importCount++;
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.chats.put(currentChar);
    
    // å…³é—­å¼¹çª—
    document.getElementById('myphone-import-characters-modal').classList.remove('visible');
    
    // åˆ·æ–°åˆ—è¡¨
    renderMyPhoneSimulatedQQ();
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    showCustomAlert('æˆåŠŸ', `å·²å¯¼å…¥ ${importCount} ä¸ªè§’è‰²`);
  }

  // æ·»åŠ MY Phoneè”ç³»äºº
  async function addMyPhoneContact(name, remark, avatar) {
    if (!activeMyPhoneCharacterId) return;
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    // åˆå§‹åŒ–æ•°ç»„
    if (!char.myPhoneSimulatedQQConversations) {
      char.myPhoneSimulatedQQConversations = [];
    }
    
    // åˆ›å»ºæ–°è”ç³»äºº
    const newContact = {
      name: remark || name,
      originalName: name,
      avatar: avatar || defaultAvatar,
      lastMessage: 'æš‚æ— æ¶ˆæ¯',
      messages: [],
      isManuallyAdded: true // æ ‡è®°ä¸ºæ‰‹åŠ¨æ·»åŠ 
    };
    
    // æ·»åŠ åˆ°åˆ—è¡¨
    char.myPhoneSimulatedQQConversations.unshift(newContact);
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.chats.put(char);
    
    showCustomAlert('æˆåŠŸ', `å·²æ·»åŠ è”ç³»äººï¼š${name}`);
  }

  // æ‰“å¼€è”ç³»äººè®¾ç½®ç•Œé¢
  function openMyPhoneContactSettings() {
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    const index = window.currentMyPhoneConversationIndex;
    if (index === -1 || index === undefined) return;
    
    const contact = char.myPhoneSimulatedQQConversations[index];
    if (!contact) return;
    
    // å¡«å……è®¾ç½®ç•Œé¢
    document.getElementById('myphone-settings-avatar-img').src = contact.avatar || defaultAvatar;
    document.getElementById('myphone-settings-name').value = contact.originalName || contact.name;
    document.getElementById('myphone-settings-remark').value = contact.name;
    
    // æ¸²æŸ“å¯¹è¯åˆ—è¡¨
    renderMyPhoneContactMessages(contact);
    
    switchToMyPhoneScreen('myphone-contact-settings-screen');
  }

  // æ¸²æŸ“è”ç³»äººçš„å¯¹è¯åˆ—è¡¨
  function renderMyPhoneContactMessages(contact) {
    const listEl = document.getElementById('myphone-conversation-list');
    listEl.innerHTML = '';
    
    if (!contact.messages || contact.messages.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">æš‚æ— å¯¹è¯è®°å½•</p>';
      return;
    }
    
    contact.messages.forEach((msg, idx) => {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 8px; background: var(--secondary-bg);';
      
      // æ ¹æ®æ¶ˆæ¯ç±»å‹æ˜¾ç¤ºä¸åŒå†…å®¹
      let contentDisplay = '';
      let typeLabel = '';
      
      if (msg.type === 'voice_message') {
        typeLabel = '[è¯­éŸ³]';
        contentDisplay = msg.content;
      } else if (msg.type === 'ai_image') {
        typeLabel = '[å›¾ç‰‡]';
        contentDisplay = msg.content;
      } else if (msg.type === 'transfer') {
        typeLabel = '[è½¬è´¦]';
        contentDisplay = `Â¥${msg.amount} - ${msg.note || ''}`;
      } else {
        contentDisplay = msg.content;
      }
      
      msgEl.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <div>
            <span style="font-weight: 500; color: var(--text-color);">${msg.role === 'user' ? 'æˆ‘' : contact.name}</span>
            ${typeLabel ? `<span style="margin-left: 8px; padding: 2px 6px; background: var(--accent-color); color: white; border-radius: 4px; font-size: 11px;">${typeLabel}</span>` : ''}
          </div>
          <button onclick="deleteMyPhoneMessage(${idx})" style="padding: 4px 8px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">åˆ é™¤</button>
        </div>
        <div style="color: var(--text-color);">${contentDisplay}</div>
      `;
      listEl.appendChild(msgEl);
    });
  }

  // åˆ é™¤å¯¹è¯æ¶ˆæ¯
  window.deleteMyPhoneMessage = async function(msgIndex) {
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    const index = window.currentMyPhoneConversationIndex;
    const contact = char.myPhoneSimulatedQQConversations[index];
    if (!contact) return;
    
    contact.messages.splice(msgIndex, 1);
    await db.chats.put(char);
    
    renderMyPhoneContactMessages(contact);
  };

  // ä¿å­˜è”ç³»äººè®¾ç½®
  async function saveMyPhoneContactSettings() {
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;
    
    const index = window.currentMyPhoneConversationIndex;
    const contact = char.myPhoneSimulatedQQConversations[index];
    if (!contact) return;
    
    const newName = document.getElementById('myphone-settings-name').value.trim();
    const newRemark = document.getElementById('myphone-settings-remark').value.trim();
    
    if (!newName) {
      showCustomAlert('æç¤º', 'è”ç³»äººåç§°ä¸èƒ½ä¸ºç©º');
      return;
    }
    
    contact.originalName = newName;
    contact.name = newRemark || newName;
    
    await db.chats.put(char);
    
    showCustomAlert('æˆåŠŸ', 'è®¾ç½®å·²ä¿å­˜');
    
    // è¿”å›å¯¹è¯ç•Œé¢
    await openMyPhoneConversation(index);
  }

  // æ›´æ¢è”ç³»äººå¤´åƒ
  async function changeMyPhoneContactAvatar() {
    const avatarChoice = await showChoiceModal('é€‰æ‹©å¤´åƒæ–¹å¼', [
      { text: 'ä¸Šä¼ æœ¬åœ°å›¾ç‰‡', value: 'upload' },
      { text: 'è¾“å…¥å›¾ç‰‡URL', value: 'url' }
    ]);
    
    let newAvatar = null;
    
    if (avatarChoice === 'upload') {
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      
      newAvatar = await new Promise((resolve) => {
        fileInput.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.readAsDataURL(file);
          } else {
            resolve(null);
          }
        };
        fileInput.click();
      });
    } else if (avatarChoice === 'url') {
      const avatarUrl = await showCustomPrompt('è¾“å…¥å¤´åƒURL', 'è¯·è¾“å…¥å›¾ç‰‡URLåœ°å€');
      if (avatarUrl && avatarUrl.trim()) {
        newAvatar = avatarUrl.trim();
      }
    }
    
    if (newAvatar) {
      const char = state.chats[activeMyPhoneCharacterId];
      const index = window.currentMyPhoneConversationIndex;
      const contact = char.myPhoneSimulatedQQConversations[index];
      
      contact.avatar = newAvatar;
      document.getElementById('myphone-settings-avatar-img').src = newAvatar;
      
      await db.chats.put(char);
    }
  }

  // æ·»åŠ å¯¹è¯æ¶ˆæ¯
  async function addMyPhoneMessage() {
    const role = await showChoiceModal('é€‰æ‹©å‘é€è€…', [
      { text: 'æˆ‘å‘é€', value: 'user' },
      { text: `${document.getElementById('myphone-settings-name').value}å‘é€`, value: 'assistant' }
    ]);
    
    if (!role) return;
    
    // é€‰æ‹©æ¶ˆæ¯ç±»å‹
    const msgType = await showChoiceModal('é€‰æ‹©æ¶ˆæ¯ç±»å‹', [
      { text: 'æ–‡å­—æ¶ˆæ¯', value: 'text' },
      { text: 'å›¾ç‰‡', value: 'image' },
      { text: 'è¯­éŸ³', value: 'voice' },
      { text: 'è½¬è´¦', value: 'transfer' }
    ]);
    
    if (!msgType) return;
    
    const char = state.chats[activeMyPhoneCharacterId];
    const index = window.currentMyPhoneConversationIndex;
    const contact = char.myPhoneSimulatedQQConversations[index];
    
    if (!contact.messages) {
      contact.messages = [];
    }
    
    let newMessage = {
      role: role,
      timestamp: new Date().toISOString()
    };
    
    let lastMsgPreview = '';
    
    if (msgType === 'text') {
      // æ–‡å­—æ¶ˆæ¯
      const content = await showCustomPrompt('è¾“å…¥æ¶ˆæ¯å†…å®¹', 'è¯·è¾“å…¥è¦æ·»åŠ çš„æ¶ˆæ¯', '', 'textarea');
      if (!content || !content.trim()) return;
      
      newMessage.content = content.trim();
      lastMsgPreview = content.trim();
      
    } else if (msgType === 'image') {
      // å›¾ç‰‡æ¶ˆæ¯
      const description = await showCustomPrompt('å›¾ç‰‡æè¿°', 'è¯·è¾“å…¥å›¾ç‰‡çš„ä¸­æ–‡æè¿°');
      if (!description || !description.trim()) return;
      
      const imagePrompt = await showCustomPrompt('å›¾ç‰‡æç¤ºè¯ï¼ˆå¯é€‰ï¼‰', 'è¯·è¾“å…¥è‹±æ–‡å›¾ç‰‡ç”Ÿæˆæç¤ºè¯ï¼ˆå¯é€‰ï¼Œç•™ç©ºåˆ™ä¸ç”Ÿæˆå›¾ç‰‡ï¼‰');
      
      newMessage.type = 'ai_image';
      newMessage.content = description.trim();
      if (imagePrompt && imagePrompt.trim()) {
        newMessage.image_prompt = imagePrompt.trim();
      }
      lastMsgPreview = '[å›¾ç‰‡]';
      
    } else if (msgType === 'voice') {
      // è¯­éŸ³æ¶ˆæ¯
      const content = await showCustomPrompt('è¯­éŸ³å†…å®¹', 'è¯·è¾“å…¥è¯­éŸ³çš„æ–‡å­—å†…å®¹', '', 'textarea');
      if (!content || !content.trim()) return;
      
      newMessage.type = 'voice_message';
      newMessage.content = content.trim();
      lastMsgPreview = '[è¯­éŸ³]';
      
    } else if (msgType === 'transfer') {
      // è½¬è´¦æ¶ˆæ¯
      const amount = await showCustomPrompt('è½¬è´¦é‡‘é¢', 'è¯·è¾“å…¥è½¬è´¦é‡‘é¢ï¼ˆæ•°å­—ï¼‰');
      if (!amount || !amount.trim()) return;
      
      const note = await showCustomPrompt('è½¬è´¦å¤‡æ³¨', 'è¯·è¾“å…¥è½¬è´¦å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰');
      
      const senderName = role === 'user' ? (char.settings.myNickname || 'æˆ‘') : contact.name;
      const receiverName = role === 'user' ? contact.name : (char.settings.myNickname || 'æˆ‘');
      
      newMessage.type = 'transfer';
      newMessage.amount = parseFloat(amount.trim()) || 0;
      newMessage.note = note ? note.trim() : 'è½¬è´¦';
      newMessage.senderName = senderName;
      newMessage.receiverName = receiverName;
      newMessage.status = 'accepted';
      newMessage.content = `è½¬è´¦ Â¥${newMessage.amount}`;
      lastMsgPreview = '[è½¬è´¦]';
    }
    
    contact.messages.push(newMessage);
    
    // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯
    contact.lastMessage = lastMsgPreview.substring(0, 20) + (lastMsgPreview.length > 20 ? '...' : '');
    
    await db.chats.put(char);
    
    renderMyPhoneContactMessages(contact);
  }

  // My Phone è½¬è´¦æ“ä½œç›¸å…³å‡½æ•°
  let activeMyPhoneTransferTimestamp = null;
  
  function showMyPhoneTransferActionModal(timestamp) {
    activeMyPhoneTransferTimestamp = timestamp;
    
    const char = state.chats[activeMyPhoneCharacterId];
    const index = window.currentMyPhoneConversationIndex;
    
    let message;
    if (index === -1) {
      // ä¸è§’è‰²çš„çœŸå®å¯¹è¯
      message = char.history.find(m => m.timestamp === timestamp);
    } else {
      // æ¨¡æ‹Ÿå¯¹è¯
      const contact = char.myPhoneSimulatedQQConversations[index];
      message = contact.messages.find(m => m.timestamp === timestamp);
    }
    
    if (message) {
      document.getElementById('transfer-sender-name').textContent = message.senderName || 'å¯¹æ–¹';
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
  }
  
  async function handleMyPhoneTransferResponse(choice) {
    if (!activeMyPhoneTransferTimestamp) return;
    
    const timestamp = activeMyPhoneTransferTimestamp;
    const char = state.chats[activeMyPhoneCharacterId];
    const index = window.currentMyPhoneConversationIndex;
    
    let message, messageArray;
    
    if (index === -1) {
      // ä¸è§’è‰²çš„çœŸå®å¯¹è¯
      messageArray = char.history;
      message = messageArray.find(m => m.timestamp === timestamp);
    } else {
      // æ¨¡æ‹Ÿå¯¹è¯
      const contact = char.myPhoneSimulatedQQConversations[index];
      messageArray = contact.messages;
      message = messageArray.find(m => m.timestamp === timestamp);
    }
    
    if (!message) return;
    
    // é˜²æ­¢é‡å¤ç‚¹å‡»
    if (message.status && message.status !== 'pending') {
      hideTransferActionModal();
      return;
    }
    
    let transferAmount = parseFloat(message.amount);
    if (isNaN(transferAmount)) {
      transferAmount = 0;
    }
    
    message.status = choice;
    
    if (choice === 'declined') {
      // æ‹’æ”¶é€»è¾‘ - æ·»åŠ é€€æ¬¾æ¶ˆæ¯
      const refundMessage = {
        role: 'user',
        type: 'transfer',
        isRefund: true,
        amount: transferAmount,
        note: 'å·²æ‹’æ”¶å¯¹æ–¹è½¬è´¦',
        senderName: char.settings.myNickname || 'æˆ‘',
        receiverName: message.senderName,
        timestamp: Date.now(),
        status: 'accepted'
      };
      messageArray.push(refundMessage);
      
      // å¦‚æœæ˜¯çœŸå®å¯¹è¯ï¼Œæ·»åŠ éšè—ç³»ç»Ÿæ¶ˆæ¯
      if (index === -1) {
        const hiddenMessage = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼šä½ æ‹’ç»å¹¶é€€è¿˜äº†"${message.senderName}"çš„è½¬è´¦ã€‚]`,
          timestamp: Date.now() + 1,
          isHidden: true
        };
        messageArray.push(hiddenMessage);
      }
    } else {
      // æ¥æ”¶é€»è¾‘
      if (transferAmount > 0 && index === -1) {
        // åªæœ‰çœŸå®å¯¹è¯æ‰è®°è´¦
        const success = await processTransaction(transferAmount, 'income', `æ”¶åˆ°è½¬è´¦-${message.senderName}`);
        
        if (success) {
          await showCustomAlert("æ”¶æ¬¾æˆåŠŸ", `å·²å­˜å…¥ä½™é¢ï¼š+ Â¥${transferAmount.toFixed(2)}`);
          
          // æ·»åŠ å·²æ”¶æ¬¾æ¶ˆæ¯
          const receivedMessage = {
            role: 'user',
            type: 'transfer',
            isReceived: true,
            amount: transferAmount,
            note: 'å·²æ”¶æ¬¾',
            senderName: 'æˆ‘',
            receiverName: message.senderName,
            timestamp: Date.now(),
            status: 'accepted'
          };
          messageArray.push(receivedMessage);
        } else {
          alert("è­¦å‘Šï¼šé‡‘é¢å…¥è´¦å¤±è´¥ï¼");
        }
      }
      
      // å¦‚æœæ˜¯çœŸå®å¯¹è¯ï¼Œæ·»åŠ éšè—ç³»ç»Ÿæ¶ˆæ¯
      if (index === -1) {
        const hiddenMessage = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼šä½ æ¥å—äº†"${message.senderName}"çš„è½¬è´¦ã€‚]`,
          timestamp: Date.now() + 1,
          isHidden: true
        };
        messageArray.push(hiddenMessage);
      }
    }
    
    // ä¿å­˜æ›´æ”¹
    await db.chats.put(char);
    
    // å…³é—­å¼¹çª—å¹¶åˆ·æ–°ç•Œé¢
    hideTransferActionModal();
    activeMyPhoneTransferTimestamp = null;
    
    // é‡æ–°æ‰“å¼€å¯¹è¯ä»¥åˆ·æ–°æ˜¾ç¤º
    await openMyPhoneConversation(index);
  }

  function applyMyPhoneWallpaper() {
    if (!activeMyPhoneCharacterId) return;
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) return;

    const container = document.getElementById('myphone-layout-container');
    if (!container) return;

    if (char.settings.cphoneWallpaper) {
      container.style.backgroundImage = `url(${char.settings.cphoneWallpaper})`;
      container.style.backgroundSize = 'cover';
      container.style.backgroundPosition = 'center';
    } else {
      container.style.backgroundImage = '';
    }
  }

  function applyMyPhoneAppIcons() {
    // å…ˆä¿å­˜æ‰€æœ‰ MyPhone åº”ç”¨å›¾æ ‡çš„é»˜è®¤ srcï¼ˆå¦‚æœè¿˜æ²¡ä¿å­˜çš„è¯ï¼‰
    const iconElements = document.querySelectorAll('[id^="myphone-icon-img-"]');
    iconElements.forEach(img => {
      if (!img.dataset.defaultSrc) {
        img.dataset.defaultSrc = img.src;
      }
    });

    if (!state.globalSettings.myphoneAppIcons) return;

    for (const iconId in state.globalSettings.myphoneAppIcons) {
      const imgElement = document.getElementById(`myphone-icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.myphoneAppIcons[iconId];
      }
    }
  }

  async function openMyPhoneApp(appName) {
    if (!activeMyPhoneCharacterId) return;
    const char = state.chats[activeMyPhoneCharacterId];

    // ä¸å†è‡ªåŠ¨è®°å½•APPä½¿ç”¨ï¼Œæ”¹ä¸ºåªèƒ½æ‰‹åŠ¨æ·»åŠ æˆ–APIç”Ÿæˆ

    switch (appName) {
      case 'qq':
        renderMyPhoneSimulatedQQ();
        switchToMyPhoneScreen('myphone-qq-screen');
        break;
      case 'album':
        renderMyPhoneAlbum();
        switchToMyPhoneScreen('myphone-album-screen');
        break;
      case 'browser':
        renderMyPhoneBrowserHistory();
        switchToMyPhoneScreen('myphone-browser-screen');
        break;
      case 'taobao':
        renderMyPhoneTaobao();
        switchToMyPhoneScreen('myphone-taobao-screen');
        break;
      case 'memo':
        renderMyPhoneMemoList();
        switchToMyPhoneScreen('myphone-memo-screen');
        break;
      case 'diary':
        renderMyPhoneDiaryList();
        switchToMyPhoneScreen('myphone-diary-screen');
        break;
      case 'amap':
        renderMyPhoneAmap();
        switchToMyPhoneScreen('myphone-amap-screen');
        break;
      case 'music':
        renderMyPhoneMusicScreen();
        switchToMyPhoneScreen('myphone-music-screen');
        break;
      case 'usage':
        renderMyPhoneAppUsage();
        switchToMyPhoneScreen('myphone-usage-screen');
        break;
    }
  }

  // logMyPhoneAppUsage å‡½æ•°å·²ç§»é™¤ï¼ŒMYphoneä¸å†è‡ªåŠ¨è®°å½•APPä½¿ç”¨
  // APPä½¿ç”¨è®°å½•ç°åœ¨åªèƒ½é€šè¿‡æ‰‹åŠ¨æ·»åŠ æˆ–APIç”Ÿæˆ


  function renderCharacterSelector() {
    const gridEl = document.getElementById('character-grid');
    gridEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰å¯ä»¥æŸ¥çœ‹æ‰‹æœºçš„è§’è‰²å“¦~</p>';
      return;
    }

    characters.forEach(char => {
      const item = document.createElement('div');
      item.className = 'character-select-item';
      item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
      item.addEventListener('click', () => switchToCharacterPhone(char.id));
      gridEl.appendChild(item);
    });
  }


 
  async function switchToCharacterPhone(characterId) {
    activeCharacterId = characterId;
    console.log(`å·²åˆ‡æ¢åˆ°è§’è‰² ${characterId} çš„æ‰‹æœº`);


    applyCPhoneWallpaper();
    applyCPhoneAppIcons();


    renderCharHomeScreen();
    showScreen('character-phone-screen');
    
    // åˆå§‹åŒ– CPhone ç¿»é¡µåŠŸèƒ½
    setTimeout(() => {
      setupCPhonePagination();
    }, 100);
  }


 
  function switchToMyPhone() {
    activeCharacterId = null;
    console.log("å·²è¿”å›æˆ‘çš„æ‰‹æœº");
    showScreen('home-screen');
  }


  function renderCharHomeScreen() {
    // æ–°å¸ƒå±€ä¸éœ€è¦åœ¨è¿™é‡Œæ›´æ–°å¤§æ—¶é’Ÿäº†
    switchToCharScreen('char-home-screen');
  }

// ==========================================
// CPhone æ°”æ³¡æ–‡å­—ä¸“ç”¨ç¼–è¾‘å‡½æ•° (ä¿®å¤æ— æ³•ä¿®æ”¹é—®é¢˜)
// ==========================================
window.editBubbleText = async function(elementId) {
    const textElement = document.getElementById(elementId);
    if (!textElement) return;
    
    // å¦‚æœå·²ç»æ˜¯ input æ¨¡å¼ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
    if (textElement.tagName === 'INPUT') return;

    const currentText = textElement.innerText;
    const parent = textElement.parentElement;

    // åˆ›å»ºä¸´æ—¶è¾“å…¥æ¡†
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.className = 'bubble-edit-input'; // ä½¿ç”¨æˆ‘ä»¬åœ¨ CSS é‡Œå®šä¹‰çš„æ ·å¼
    
    // ç»§æ‰¿å­—ä½“æ ·å¼
    const computedStyle = window.getComputedStyle(textElement);
    input.style.fontFamily = computedStyle.fontFamily;
    input.style.fontSize = computedStyle.fontSize;
    input.style.fontWeight = computedStyle.fontWeight;
    input.style.textAlign = computedStyle.textAlign;

    // ä¿å­˜å‡½æ•°
    async function saveEdit() {
        const newText = input.value.trim();
        if (newText) {
            textElement.innerText = newText;
            // å°è¯•ä¿å­˜åˆ°æ•°æ®åº“ (å¤ç”¨ widgetData)
            if (!state.globalSettings.widgetData) {
                state.globalSettings.widgetData = {};
            }
            state.globalSettings.widgetData[elementId] = newText;
            await db.globalSettings.put(state.globalSettings);
        }
        // æ›¿æ¢å›æ–‡æœ¬æ ‡ç­¾
        if(input.parentNode) input.replaceWith(textElement);
    }

    // ç»‘å®šäº‹ä»¶ï¼šå¤±å»ç„¦ç‚¹æˆ–å›è½¦æ—¶ä¿å­˜
    input.addEventListener('blur', saveEdit);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            input.blur();
        }
    });

    // æ›¿æ¢ DOM
    textElement.replaceWith(input);
    input.focus();
    // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘å…¶ä»–ç‚¹å‡»
    if(window.event) window.event.stopPropagation();
}
  function switchToCharScreen(screenId) {
    document.querySelectorAll('.char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
  }

  window.switchToCharScreen = switchToCharScreen;




  // è®°å½•è§’è‰²æ‰‹æœºæŸ¥çœ‹è¡Œä¸º - å•ä¸ªé¡¹ç›®ç‰ˆæœ¬
  async function logSingleItemViewing(characterId, appName, itemData, itemType = '') {
    const char = state.chats[characterId];
    if (!char || char.isGroup) return;
    
    // æ£€æŸ¥è§’è‰²æ˜¯å¦å¼€å¯äº†"çŸ¥æ™“çª¥å±"åŠŸèƒ½
    if (!char.settings.phoneViewingAwareness) return;
    
    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œä¸è®°å½•
    if (!itemData) {
      console.log(`[çª¥å±è®°å½•] ${char.name}: ${appName} æ²¡æœ‰æ•°æ®ï¼Œä¸å‘é€é€šçŸ¥`);
      return;
    }
    
    const now = new Date();
    const timeStr = now.toLocaleString('zh-CN', { 
      year: 'numeric', 
      month: '2-digit', 
      day: '2-digit',
      hour: '2-digit', 
      minute: '2-digit',
      second: '2-digit',
      hour12: false 
    });
    
    const appNameMap = {
      'qq': 'QQ',
      'album': 'ç›¸å†Œ',
      'browser': 'æµè§ˆå™¨',
      'taobao': 'æ·˜å®',
      'memo': 'å¤‡å¿˜å½•',
      'diary': 'æ—¥è®°',
      'amap': 'é«˜å¾·åœ°å›¾',
      'usage': 'APPä½¿ç”¨è®°å½•',
      'music': 'ç½‘æ˜“äº‘éŸ³ä¹',
      'bilibili': 'å“”å“©å“”å“©',
      'reddit': 'Reddit'
    };
    
    let systemMessage = `[ç³»ç»Ÿé€šçŸ¥] ${timeStr}\nç”¨æˆ·æ‰“å¼€äº†ä½ çš„æ‰‹æœºï¼Œå¹¶ä¸”ç‚¹å¼€äº†${appNameMap[appName] || appName} APP`;
    
    // æ ¹æ®ä¸åŒç±»å‹æ„å»ºè¯¦ç»†å†…å®¹
    let detailContent = '';
    
    if (appName === 'diary') {
      const dateStr = itemData.timestamp ? new Date(itemData.timestamp).toLocaleDateString('zh-CN') : '';
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„æ—¥è®°`;
      detailContent = `\n\nã€æ—¥è®°æ ‡é¢˜ã€‘${itemData.title || 'æ— æ ‡é¢˜'}\nã€æ—¥æœŸã€‘${dateStr}\nã€å†…å®¹ã€‘\n${itemData.content || '(ç©ºç™½)'}`;
    } else if (appName === 'memo') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„å¤‡å¿˜å½•`;
      detailContent = `\n\nã€å¤‡å¿˜å½•æ ‡é¢˜ã€‘${itemData.title || 'æ— æ ‡é¢˜'}\nã€å†…å®¹ã€‘\n${itemData.content || '(ç©ºç™½)'}`;
    } else if (appName === 'album') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„ç…§ç‰‡`;
      detailContent = `\n\nã€ç…§ç‰‡æè¿°ã€‘\n${itemData.description || itemData.caption || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)'}`;
    } else if (appName === 'browser') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„æµè§ˆå†å²`;
      detailContent = `\n\nã€æ ‡é¢˜ã€‘${itemData.title || 'æ— æ ‡é¢˜'}\nã€ç½‘å€ã€‘${itemData.url || ''}\nã€å†…å®¹ã€‘${itemData.content || '(æ— å†…å®¹)'}`;
    } else if (appName === 'taobao') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„è´­ç‰©è®°å½•`;
      detailContent = `\n\nã€å•†å“ã€‘${itemData.name || ''}\nã€ä»·æ ¼ã€‘${itemData.price ? 'Â¥' + itemData.price : 'æœªçŸ¥'}\nã€æè¿°ã€‘${itemData.description || ''}`;
    } else if (appName === 'amap') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„åœ°å›¾è¶³è¿¹`;
      detailContent = `\n\nã€ä½ç½®ã€‘${itemData.location || ''}\nã€æ—¶é—´ã€‘${itemData.time || ''}\nã€è¯¦æƒ…ã€‘${itemData.details || ''}`;
    } else if (appName === 'music') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„éŸ³ä¹`;
      detailContent = `\n\nã€æ­Œæ›²ã€‘${itemData.title || ''}\nã€è‰ºæœ¯å®¶ã€‘${itemData.artist || ''}\nã€ä¸“è¾‘ã€‘${itemData.album || ''}`;
    } else if (appName === 'bilibili') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„Bç«™è§‚çœ‹å†å²`;
      detailContent = `\n\nã€æ ‡é¢˜ã€‘${itemData.title || ''}\nã€UPä¸»ã€‘${itemData.author || ''}\nã€ç®€ä»‹ã€‘${itemData.desc || ''}`;
    } else if (appName === 'reddit') {
      systemMessage += `æŸ¥çœ‹äº†ä½ çš„Redditæµè§ˆå†…å®¹`;
      detailContent = `\n\nã€æ ‡é¢˜ã€‘${itemData.title || ''}\nã€å†…å®¹ã€‘${itemData.content || ''}`;
    }
    
    systemMessage += detailContent;
    
    // æ·»åŠ ä¸ºç°è‰²ç³»ç»Ÿæ¶ˆæ¯å’Œéšè—è°ƒè¯•å±‚
    const viewingLog = {
      role: 'system',
      content: systemMessage,
      timestamp: now.getTime(),
      isHidden: true,
      isGrayNotice: true
    };
    
    char.history.push(viewingLog);
    await db.chats.put(char);
    
    console.log(`[çª¥å±è®°å½•] ${char.name}: æŸ¥çœ‹äº† ${appNameMap[appName]} - ${itemData.title || itemData.name || 'æŸé¡¹å†…å®¹'}`);
  }

  async function openCharApp(appName) {
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];


    await logAppUsage(activeCharacterId, appName);


    switch (appName) {
      case 'qq':
        renderCharSimulatedQQ();
        switchToCharScreen('char-qq-screen');
        break;
      case 'album':
        renderCharAlbum();
        switchToCharScreen('char-album-screen');
        break;
      case 'browser':
        renderCharBrowserHistory();
        switchToCharScreen('char-browser-screen');
        break;
      case 'taobao':
        renderCharTaobao();
        switchToCharScreen('char-taobao-screen');
        break;
      case 'memo':
        renderCharMemoList();
        switchToCharScreen('char-memo-screen');
        break;
      case 'diary':
        renderCharDiaryList();
        switchToCharScreen('char-diary-screen');
        break;
      case 'amap':
        renderCharAmap();
        switchToCharScreen('char-amap-screen');
        break;



      case 'music':
        renderCharMusicScreen();
        switchToCharScreen('char-music-screen');
        break;
      case 'bilibili':
        document.getElementById('char-bilibili-search-input').value = '';

        renderCharBilibiliScreen(); 
        switchToCharScreen('char-bilibili-screen');
        break;
      case 'reddit':
        // é»˜è®¤åŠ è½½çƒ­é—¨å†…å®¹
        if (char.simulatedRedditFeed && char.simulatedRedditFeed.length > 0) {
            console.log("åŠ è½½å·²ä¿å­˜çš„ Reddit æ¨èæµ");
            renderRedditList(char.simulatedRedditFeed);
        } else {
            // åªæœ‰å½“æ²¡æœ‰ç¼“å­˜æ—¶ï¼Œæ‰å»åŠ è½½çƒ­é—¨å†…å®¹
            console.log("æ— ç¼“å­˜ï¼ŒåŠ è½½é»˜è®¤çƒ­é—¨å†…å®¹");
            handleRedditSearch('popular'); 
        }
        switchToCharScreen('char-reddit-screen');
        break;
      case 'usage':
        renderCharAppUsage();
        switchToCharScreen('char-usage-screen');
        break;
      case 'settings':
        // è®¾ç½® APP å ä½ï¼Œæš‚æœªå®ç°
        await showCustomAlert("æç¤º", "è®¾ç½®åŠŸèƒ½å³å°†æ¨å‡ºï¼Œæ•¬è¯·æœŸå¾…ï¼");
        break;
    }
  }


  async function renderCharAlbum() {
    const gridEl = document.getElementById('char-album-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];

    const photos = char.simulatedAlbum || [];

    if (photos.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„ç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›ç…§ç‰‡å§ï¼</p>';
      return;
    }

    const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

    photos.forEach(photo => {
      const item = document.createElement('div');
      item.className = 'char-photo-item';
      item.dataset.description = photo.description;
      gridEl.appendChild(item);
      
      // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ŒæŸ¥çœ‹ç…§ç‰‡è¯¦æƒ…
      item.style.cursor = 'pointer';
      item.addEventListener('click', () => viewPhotoDetail(photo));



      if (state.globalSettings.enableAiDrawing) {

        item.style.backgroundColor = '#e9ecef';
        const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
        const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
        const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;

        const img = new Image();
        img.onload = function() {
          item.style.backgroundImage = `url(${this.src})`;
        };
        img.onerror = function() {
          item.style.backgroundImage = `url(${fallbackImageUrl})`;
        };
        img.src = imageUrl;

      } else {

        item.style.backgroundColor = '#f0f2f5';
        item.style.border = '1px solid #e0e0e0';


        const descriptionEl = document.createElement('p');
        descriptionEl.className = 'char-photo-description';
        descriptionEl.textContent = photo.description || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)';


        item.appendChild(descriptionEl);
      }

    });
  }
  
  // æŸ¥çœ‹ç…§ç‰‡è¯¦æƒ…ï¼ˆè®°å½•çª¥å±ï¼‰
  async function viewPhotoDetail(photo) {
    if (!activeCharacterId) return;
    
    // è®°å½•çª¥å±è¡Œä¸º
    await logSingleItemViewing(activeCharacterId, 'album', photo);
    
    // æ˜¾ç¤ºç…§ç‰‡è¯¦æƒ…
    const description = photo.description || photo.caption || 'è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°';
    await showCustomAlert('ç…§ç‰‡è¯¦æƒ…', description);
  }


  function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œå°è¯•ç”Ÿæˆé»˜è®¤çš„å‡æ•°æ®
    if (!char.simulatedBrowserHistory || char.simulatedBrowserHistory.length === 0) {
        // è¿™é‡Œä¿ç•™ä½ åŸæœ‰çš„ç”Ÿæˆé€»è¾‘ï¼Œæˆ–è€…æ˜¾ç¤ºç©ºçŠ¶æ€
        // ä¸ºäº†ä¿æŒè§†è§‰ç»Ÿä¸€ï¼Œå³ä½¿æ˜¯éšæœºç”Ÿæˆçš„å‡æ•°æ®ä¹Ÿåº”ç”¨æ–°ç»“æ„
        const historyKeywords = [char.name, "çˆ±å¥½", "æ—…æ¸¸", "ç¾é£Ÿ", "æ–°é—»", ...char.settings.aiPersona.split(/ï¼Œ|ã€‚|\s/).slice(0, 5)];
        const historySites = ["çŸ¥ä¹", "Bilibili", "å°çº¢ä¹¦", "å¾®åš", "ç»´åŸºç™¾ç§‘"];
        
        // ä¸´æ—¶ç”Ÿæˆæ¼”ç¤ºæ•°æ®
        const demoHistory = [];
        for (let i = 0; i < 10; i++) {
            const keyword = historyKeywords[Math.floor(Math.random() * historyKeywords.length)];
            const site = historySites[Math.floor(Math.random() * historySites.length)];
            demoHistory.push({
                title: `${keyword} - ${site}`,
                url: `www.${site.toLowerCase()}.com`,
                content: "å†…å®¹åŠ è½½ä¸­..."
            });
        }
        char.simulatedBrowserHistory = demoHistory; 
    }

    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„æµè§ˆå™¨ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
        return;
    }

    // å®šä¹‰åœ°çƒå›¾æ ‡çš„ SVG
    const globeIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>`;
    
    // å®šä¹‰å³ç®­å¤´ SVG
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    history.forEach((item, index) => {
        const entryEl = document.createElement('div');
        entryEl.className = 'char-browser-item';
        
        // ç®€åŒ– URL æ˜¾ç¤ºï¼Œå»æ‰ https://
        let cleanUrl = item.url.replace(/^https?:\/\//, '').replace(/^www\./, '');
        if(cleanUrl.length > 25) cleanUrl = cleanUrl.substring(0, 25) + '...';

        entryEl.innerHTML = `
            <div class="char-browser-icon-box">
                ${globeIcon}
            </div>
            <div class="char-browser-info">
                <div class="title">${item.title}</div>
                <div class="url">${cleanUrl}</div>
            </div>
            <div class="char-browser-arrow">
                ${arrowIcon}
            </div>
        `;

        entryEl.addEventListener('click', () => openCharArticle(index));
        listEl.appendChild(entryEl);
    });
}



  function renderCharTaobao() {
    const gridEl = document.getElementById('char-product-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const purchases = char.simulatedTaobaoHistory?.purchases || [];

    if (purchases.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAæœ€è¿‘å¥½åƒä»€ä¹ˆéƒ½æ²¡ä¹°å‘¢ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
      return;
    }

    purchases.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-product-item';
      itemEl.dataset.reason = item.reason;

      let imageOrTextHtml;
      if (state.globalSettings.enableAiDrawing) {
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt || 'a random product')}`;
        imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
      } else {
        imageOrTextHtml = `
                        <div class="char-product-description-overlay">
                            <p class="char-photo-description">${item.reason || '(æ— è´­ä¹°ç†ç”±)'}</p>
                        </div>
                    `;
      }


      itemEl.innerHTML = `
                    ${imageOrTextHtml}
                    <div class="product-info">
                        <div class="product-name">${item.itemName}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                            <div class="product-price">${(item.price || 0).toFixed(2)}</div>
                            <div class="char-product-status">${item.status}</div>
                        </div>
                    </div>
                `;

      gridEl.appendChild(itemEl);
    });
  }

  function switchToCharHomeScreen() {
    switchToCharScreen('char-home-screen');
  }

  // CPhone ç¿»é¡µåŠŸèƒ½
  let cphoneCurrentPage = 0;
  const cphoneTotalPages = 2;

  function setupCPhonePagination() {
    const pagesContainer = document.getElementById('cphone-pages-container');
    const pages = document.getElementById('cphone-pages');
    const dots = document.querySelectorAll('.cphone-pagination-dot');
    
    if (!pagesContainer || !pages) return;

    let startX = 0, startY = 0;
    let currentX = 0;
    let isDragging = false;
    let isClick = true;

    const updatePagination = () => {
      pages.style.transform = `translateX(-${cphoneCurrentPage * (100 / cphoneTotalPages)}%)`;
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === cphoneCurrentPage);
      });
    };

    const onDragStart = (e) => {
      isDragging = true;
      isClick = true;
      startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      pages.style.transition = 'none';
    };

    const onDragMove = (e) => {
      if (!isDragging) return;

      const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      let diffX = currentX - startX;
      const diffY = currentY - startY;

      if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
        isClick = false;
      }

      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (e.cancelable) e.preventDefault();
        
        const maxSwipeDistance = pagesContainer.offsetWidth * 0.8;
        
        if (diffX < 0 && cphoneCurrentPage >= cphoneTotalPages - 1) {
          diffX = Math.max(diffX, -maxSwipeDistance * 0.3);
        } else if (diffX < 0) {
          diffX = Math.max(diffX, -maxSwipeDistance);
        }
        
        if (diffX > 0 && cphoneCurrentPage <= 0) {
          diffX = Math.min(diffX, maxSwipeDistance * 0.3);
        } else if (diffX > 0) {
          diffX = Math.min(diffX, maxSwipeDistance);
        }
        
        pages.style.transform = `translateX(calc(-${cphoneCurrentPage * (100 / cphoneTotalPages)}% + ${diffX}px))`;
      }
    };

    const onDragEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;
      pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

      if (isClick) {
        updatePagination();
        return;
      }

      const diffX = currentX - startX;
      const swipeThreshold = pagesContainer.offsetWidth / 3;
      
      if (Math.abs(diffX) > swipeThreshold) {
        if (diffX > 0 && cphoneCurrentPage > 0) {
          cphoneCurrentPage--;
        } else if (diffX < 0 && cphoneCurrentPage < cphoneTotalPages - 1) {
          cphoneCurrentPage++;
        }
      }
      updatePagination();
    };

    pagesContainer.addEventListener('mousedown', onDragStart);
    pagesContainer.addEventListener('mousemove', onDragMove);
    pagesContainer.addEventListener('mouseup', onDragEnd);
    pagesContainer.addEventListener('mouseleave', onDragEnd);

    pagesContainer.addEventListener('touchstart', onDragStart, { passive: false });
    pagesContainer.addEventListener('touchmove', onDragMove, { passive: false });
    pagesContainer.addEventListener('touchend', onDragEnd);

    // ç‚¹å‡»æŒ‡ç¤ºå™¨åˆ‡æ¢é¡µé¢
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        cphoneCurrentPage = index;
        updatePagination();
      });
    });

    updatePagination();
  }




  function renderCharChatList() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;


    const relatedChats = Object.values(state.chats).filter(chat => {

      if (chat.id === activeCharacterId) return true;

      if (chat.isGroup && chat.members.some(m => m.id === activeCharacterId)) return true;
      return false;
    });

    relatedChats.forEach(chat => {
      const item = createChatListItem(chat);
      listEl.appendChild(item);
    });
  }

 
  async function logAppUsage(characterId, appName) {
    const char = state.chats[characterId];
    if (!char) return;
    if (!char.appUsageLog) {
      char.appUsageLog = [];
    }
    char.appUsageLog.push({
      appName: appName,
      timestamp: Date.now()
    });

    if (char.appUsageLog.length > 50) {
      char.appUsageLog.shift();
    }
    await db.chats.put(char);
  }

 
  function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const log = (char.appUsageLog || []).slice().reverse();

    if (log.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰ä»»ä½•ä½¿ç”¨è®°å½•ã€‚</p>';
      return;
    }

    const appNameMap = {
      'qq': 'QQ',
      'album': 'ç›¸å†Œ',
      'browser': 'æµè§ˆå™¨',
      'taobao': 'æ·˜å®',
      'memo': 'å¤‡å¿˜å½•',
      'diary': 'æ—¥è®°',
      'amap': 'é«˜å¾·åœ°å›¾',
      'usage': 'Appè®°å½•'
    };

    log.forEach(entry => {
      const item = document.createElement('div');
      item.className = 'usage-item';
      item.innerHTML = `
            <div class="timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
            <div class="action">æ‰“å¼€äº† <strong>${appNameMap[entry.appName] || entry.appName}</strong></div>
        `;
      listEl.appendChild(item);
    });
  }

  async function sendCharLocationShare(locationName) {
    const userChat = state.chats[activeCharacterId];
    if (!userChat) return;

    const msg = {
      role: 'assistant',
      senderName: userChat.originalName,
      type: 'location_share',
      content: locationName,
      imageUrl: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg',
      timestamp: Date.now()
    };

    userChat.history.push(msg);
    await db.chats.put(userChat);


    if (state.activeChatId === activeCharacterId) {
      appendMessage(msg, userChat);
    }

    await showCustomAlert("åˆ†äº«æˆåŠŸ", `â€œ${userChat.name}â€ çš„ä½ç½®å·²å‘é€åˆ°ä½ ä»¬çš„èŠå¤©ä¸­ã€‚`);
  }


 
  async function viewMemo(memoId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.memos) return;

    const memo = char.memos.find(m => m.id === memoId);
    if (memo) {

      activeMemoForViewing = memo;

      const titleEl = document.getElementById('char-memo-detail-title');
      const contentEl = document.getElementById('char-memo-detail-content');
      const favBtn = document.getElementById('favorite-memo-btn');

      if (titleEl) titleEl.textContent = memo.title;
      if (contentEl) contentEl.value = memo.content;


      const existingFavorite = await db.favorites.where({
        type: 'char_memo',
        'content.id': memoId
      }).first();
      favBtn.classList.toggle('active', !!existingFavorite);

      switchToCharScreen('char-memo-detail-screen');
      
      // è®°å½•çª¥å±è¡Œä¸º
      await logSingleItemViewing(activeCharacterId, 'memo', memo);
    }
  }

  
  function renderCharMemoList() {
    const listEl = document.getElementById('char-memo-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const memos = (char.memos || []).slice().reverse();

    if (memos.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿˜æ²¡æœ‰å¤‡å¿˜å½•ã€‚</p>';
      return;
    }

    // SVG å›¾æ ‡: ç±»ä¼¼æ–‡ä»¶çš„å›¾æ ‡
    const memoIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`;
    // SVG å›¾æ ‡: å³ç®­å¤´
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    memos.forEach(memo => {
      const item = document.createElement('div');
      // æ³¨æ„ï¼šç§»é™¤äº†æ—§çš„ 'list-item' ç±»ï¼Œåªä¿ç•™ 'memo-item' ä»¥åº”ç”¨æ–°æ ·å¼
      item.className = 'memo-item'; 
      
      // è·å–å†…å®¹é¢„è§ˆ (ç¬¬ä¸€è¡Œ)
      const previewText = (memo.content || '').split('\n')[0] || 'æ— å†…å®¹';

      item.innerHTML = `
            <div class="cphone-item-icon-box memo-icon-style">
                ${memoIconSVG}
            </div>
            <div class="cphone-item-info">
                <div class="cphone-item-title">${memo.title}</div>
                <div class="cphone-item-preview">${previewText}</div>
            </div>
            <div class="cphone-item-arrow">
                ${arrowIcon}
            </div>
        `;

      item.addEventListener('click', () => viewMemo(memo.id));
      addLongPressListener(item, () => deleteMemo(memo.id));
      listEl.appendChild(item);
    });
  }

 
  async function openMemoEditor(memoId = null) {
    editingMemoId = null;


    const newTitle = await showCustomPrompt("æ–°å»ºå¤‡å¿˜å½•", "è¯·è¾“å…¥æ ‡é¢˜");
    if (newTitle === null || !newTitle.trim()) return;

    const newContent = await showCustomPrompt(`æ ‡é¢˜: ${newTitle}`, "è¯·è¾“å…¥å¤‡å¿˜å½•å†…å®¹", "", 'textarea');
    if (newContent !== null) {

      await saveMemo({
        title: newTitle.trim(),
        content: newContent
      });
      switchToCharScreen('char-memo-screen');
    }
  }

 
  async function saveMemo(memoData) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];


    char.memos.push({
      id: Date.now(),
      title: memoData.title,
      content: memoData.content
    });

    await db.chats.put(char);
    renderCharMemoList();
  }

  async function saveMemo(content) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];

    if (editingMemoId) {
      const memo = char.memos.find(m => m.id === editingMemoId);
      if (memo) memo.content = content;
    } else {
      char.memos.push({
        id: Date.now(),
        content: content
      });
    }

    await db.chats.put(char);
    renderCharMemoList();
    editingMemoId = null;
  }





 
  async function handleGenerateSimulatedDiaries() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€ç¿»å¼€TAçš„æ—¥è®°æœ¬...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    const worldBookContext = allWorldBookIds
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨å’Œæ•…äº‹ä½œå®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºã€5åˆ°8ç¯‡ã€‘TAæœ€è¿‘å¯èƒ½ä¼šå†™çš„æ—¥è®°ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toLocaleDateString('zh-CN')}**ã€‚
    -   ä½ ç”Ÿæˆçš„ã€æ‰€æœ‰ã€‘æ—¥è®°çš„æ ‡é¢˜æ—¥æœŸï¼Œã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
2.  **ã€æ²‰æµ¸æ„Ÿã€‘**: æ¯ä¸€ç¯‡æ—¥è®°éƒ½å¿…é¡»ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ï¼Œå¹¶ä¸”è¦å……æ»¡è§’è‰²çš„ä¸ªäººæƒ…æ„Ÿã€æ€è€ƒå’Œç§˜å¯†ã€‚åœ¨æ—¥è®°ä¸­æè¿°è‡ªå·±çš„è¡Œä¸ºæˆ–æƒ³æ³•æ—¶ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°â€œä»–â€æˆ–â€œå¥¹â€ (TA)ã€‚
3.  **ã€é•¿åº¦ã€‘**: æ¯ä¸€ç¯‡æ—¥è®°çš„æ­£æ–‡é•¿åº¦ã€å¿…é¡»ä¸å°‘äº300å­—ã€‘ã€‚
4.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€ç¯‡æ—¥è®°ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "è¿™ç¯‡æ—¥è®°çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼š9æœˆ20æ—¥ æ™´",
        "content": "è¿™é‡Œæ˜¯æ—¥è®°çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nï¼Œå¹¶ä¸”å¿…é¡»å·§å¦™åœ°ä½¿ç”¨ä¸‹é¢çš„ã€æ—¥è®°ä¸“å±Markdownè¯­æ³•ã€‘æ¥ä¸°å¯Œæ–‡æœ¬è¡¨ç°åŠ›ã€‚"
      }
    ]
    \`\`\`
5.  **ã€å ä½ç¬¦æ›¿æ¢ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: åœ¨ä½ çš„æ—¥è®°å†…å®¹ä¸­ï¼Œã€ç»å¯¹ä¸èƒ½ã€‘å‡ºç° "{{user}}" è¿™ä¸ªå ä½ç¬¦ã€‚ä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ â€œ${userDisplayNameForAI}â€ æ¥æŒ‡ä»£ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰ã€‚
6.  **ã€æ—¥è®°ä¸“å±Markdownè¯­æ³• (å¿…é¡»ä½¿ç”¨ï¼)ã€‘**:
    -   \`**åŠ ç²—æ–‡å­—**\`: ç”¨äºå¼ºè°ƒã€‚
    -   \`~~åˆ’æ‰çš„æ–‡å­—~~\`: ç”¨äºè¡¨ç¤ºæ”¹å˜ä¸»æ„æˆ–è‡ªæˆ‘å¦å®šã€‚
    -   \`!h{é»„è‰²é«˜äº®}\`: ç”¨äºæ ‡è®°å…³é”®è¯æˆ–é‡è¦ä¿¡æ¯ã€‚
    -   \`!u{ç²‰è‰²ä¸‹åˆ’çº¿}\`: ç”¨äºæ ‡æ³¨äººåã€åœ°åæˆ–ç‰¹æ®Šåè¯ã€‚
    -   \`!e{ç²‰è‰²å¼ºè°ƒ}\`: ç”¨äºè¡¨è¾¾å¼ºçƒˆçš„æƒ…ç»ªã€‚
    -   \`!w{æ‰‹å†™ä½“}\`: ç”¨äºå†™ä¸‹å¼•è¨€ã€æ­Œè¯æˆ–ç‰¹æ®Šç¬”è®°ã€‚
    -   \`!m{å‡Œä¹±çš„æ‰‹å†™ä½“}\`: ç”¨äºè¡¨è¾¾æ¿€åŠ¨ã€æ…Œä¹±æˆ–æ½¦è‰è®°å½•æ—¶çš„å¿ƒæƒ…ã€‚
    -   \`||æ¶‚é»‘||\`: ç”¨äºéšè—ç§˜å¯†æˆ–æ•æ„Ÿè¯æ±‡ (æ¯æ¬¡æ¶‚é»‘2~5ä¸ªå­—)ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„èŠå¤©å¯¹è±¡è®¾å®š**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹æ’°å†™è¿™ç»„å……æ»¡çœŸæƒ…å®æ„Ÿã€å¹¶ç†Ÿç»ƒè¿ç”¨äº†Markdownè¯­æ³•çš„æ—¥è®°ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ—¥è®°å†…å®¹ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.95,

          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedDiaries;
      try {
        simulatedDiaries = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      chat.diary = simulatedDiaries.map(entry => ({
        id: Date.now() + Math.random(),
        title: entry.title,
        content: entry.content,
        timestamp: Date.now()
      }));

      await db.chats.put(chat);
      await renderCharDiaryList();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ—¥è®°å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ—¥è®°ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

 
  async function handleWriteNewDiaryEntry() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€å†™ä¸€ç¯‡æ–°æ—¥è®°...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId => state.worldBooks.find(wb => wb.id === bookId)).filter(Boolean).map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e=>`- ${e.content}`).join('\n')}`).join('');


    const systemPrompt = `          
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨å’Œæ•…äº‹ä½œå®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºã€1ç¯‡ã€‘TAä»Šå¤©å¯èƒ½ä¼šå†™çš„æ—¥è®°ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€ã€ã€æ—¶é—´é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toLocaleDateString('zh-CN')}**ã€‚
    -   ä½ ç”Ÿæˆçš„æ—¥è®°æ ‡é¢˜æ—¥æœŸã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
2.  **ã€ã€ã€æ²‰æµ¸æ„Ÿé“å¾‹ã€‘ã€‘ã€‘**: æ—¥è®°å¿…é¡»ä½¿ç”¨ã€ç¬¬ä¸€äººç§°è§†è§’ ("æˆ‘")ã€‘æ¥å†™ï¼Œå¹¶ä¸”è¦å……æ»¡è§’è‰²çš„ä¸ªäººæƒ…æ„Ÿã€æ€è€ƒå’Œç§˜å¯†ã€‚åœ¨æ—¥è®°ä¸­æè¿°è‡ªå·±çš„è¡Œä¸ºæˆ–æƒ³æ³•æ—¶ï¼Œã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ç¬¬ä¸‰äººç§°â€œä»–â€æˆ–â€œå¥¹â€ (TA)ã€‚
3.  **ã€ã€ã€é•¿åº¦é“å¾‹ã€‘ã€‘ã€‘**: æ—¥è®°çš„æ­£æ–‡é•¿åº¦ã€å¿…é¡»ä¸å°‘äº300å­—ã€‘ã€‚
4.  **ã€ã€ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œä¸”æ•°ç»„ä¸­ã€åªåŒ…å«ä¸€ä¸ªã€‘å¯¹è±¡ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "è¿™ç¯‡æ—¥è®°çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼š9æœˆ20æ—¥ æ™´",
        "content": "è¿™é‡Œæ˜¯æ—¥è®°çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nï¼Œå¹¶ä¸”å¿…é¡»å·§å¦™åœ°ä½¿ç”¨ä¸‹é¢çš„ã€æ—¥è®°ä¸“å±Markdownè¯­æ³•ã€‘æ¥ä¸°å¯Œæ–‡æœ¬è¡¨ç°åŠ›ã€‚"
      }
    ]
    \`\`\`
5.  **ã€ã€ã€æ—¥è®°ä¸“å±Markdownè¯­æ³• (å¿…é¡»ä½¿ç”¨ï¼)ã€‘ã€‘ã€‘**:
    -   \`**åŠ ç²—æ–‡å­—**\`: ç”¨äºå¼ºè°ƒã€‚
    -   \`~~åˆ’æ‰çš„æ–‡å­—~~\`: ç”¨äºè¡¨ç¤ºæ”¹å˜ä¸»æ„æˆ–è‡ªæˆ‘å¦å®šã€‚
    -   \`!h{é»„è‰²é«˜äº®}\`: ç”¨äºæ ‡è®°å…³é”®è¯æˆ–é‡è¦ä¿¡æ¯ã€‚
    -   \`!u{ç²‰è‰²ä¸‹åˆ’çº¿}\`: ç”¨äºæ ‡æ³¨äººåã€åœ°åæˆ–ç‰¹æ®Šåè¯ã€‚
    -   \`!e{ç²‰è‰²å¼ºè°ƒ}\`: ç”¨äºè¡¨è¾¾å¼ºçƒˆçš„æƒ…ç»ªã€‚
    -   \`!w{æ‰‹å†™ä½“}\`: ç”¨äºå†™ä¸‹å¼•è¨€ã€æ­Œè¯æˆ–ç‰¹æ®Šç¬”è®°ã€‚
    -   \`!m{å‡Œä¹±çš„æ‰‹å†™ä½“}\`: ç”¨äºè¡¨è¾¾æ¿€åŠ¨ã€æ…Œä¹±æˆ–æ½¦è‰è®°å½•æ—¶çš„å¿ƒæƒ…ã€‚
    -   \`||æ¶‚é»‘||\`: ç”¨äºéšè—ç§˜å¯†æˆ–æ•æ„Ÿè¯æ±‡(æ¯æ¬¡æ¶‚é»‘2~5ä¸ªå­—)ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹æ’°å†™è¿™ç¯‡å……æ»¡çœŸæƒ…å®æ„Ÿã€å¹¶ç†Ÿç»ƒè¿ç”¨äº†Markdownè¯­æ³•çš„æ—¥è®°ã€‚`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œå†™ä¸€ç¯‡æ–°æ—¥è®°ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: [{
            role: 'system',
            content: systemPrompt
          }, ...messagesForApi],
          temperature: state.globalSettings.apiTemperature || 0.95,
        })
      });
      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let newDiaryEntry;
      try {
        newDiaryEntry = JSON.parse(cleanedJsonString)[0];
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      if (!chat.diary) chat.diary = [];

      chat.diary.push({
        id: Date.now(),
        title: newDiaryEntry.title,
        content: newDiaryEntry.content,
        timestamp: Date.now()
      });

      await db.chats.put(chat);
      await renderCharDiaryList();

    } catch (error) {
      console.error("ç”Ÿæˆæ–°æ—¥è®°å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `é”™è¯¯: ${error.message}`);
    }
  }

  function renderCharDiaryList() {
    const listEl = document.getElementById('char-diary-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const diaries = (char.diary || []).slice().reverse();

    if (diaries.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æ—¥è®°æœ¬è¿˜æ˜¯ç©ºçš„ã€‚</p>';
      return;
    }

    // SVG å›¾æ ‡: ä¹¦æœ¬å›¾æ ‡
    const diaryIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>`;
    // SVG å›¾æ ‡: å³ç®­å¤´
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    diaries.forEach(entry => {
      const item = document.createElement('div');
      // æ³¨æ„ï¼šç§»é™¤äº†æ—§çš„ 'list-item' ç±»
      item.className = 'diary-item';
      
      // æ ¼å¼åŒ–æ—¥æœŸ
      const dateStr = new Date(entry.timestamp).toLocaleDateString('zh-CN');

      item.innerHTML = `
             <div class="cphone-item-icon-box diary-icon-style">
                ${diaryIconSVG}
            </div>
            <div class="cphone-item-info">
                <div class="cphone-item-title">${entry.title}</div>
                <div class="cphone-item-preview">${dateStr}</div>
            </div>
            <div class="cphone-item-arrow">
                ${arrowIcon}
            </div>
        `;
        
      item.addEventListener('click', () => viewDiary(entry.id));
      addLongPressListener(item, () => deleteDiary(entry.id));
      listEl.appendChild(item);
    });
  }



  async function viewDiary(diaryId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.diary) return;

    const entry = char.diary.find(d => d.id === diaryId);
    if (entry) {

      activeDiaryForViewing = entry;

      const titleEl = document.getElementById('char-diary-detail-title');
      const contentEl = document.getElementById('char-diary-detail-content');
      const favBtn = document.getElementById('favorite-diary-btn');

      titleEl.textContent = entry.title;
      const formattedContent = parseMarkdown(entry.content)
        .split('\n')
        .map(p => `<p>${p || '&nbsp;'}</p>`)
        .join('');
      contentEl.innerHTML = formattedContent;


      const existingFavorite = await db.favorites.where({
        type: 'char_diary',
        'content.id': diaryId
      }).first();
      favBtn.classList.toggle('active', !!existingFavorite);

      switchToCharScreen('char-diary-detail-screen');
      
      // è®°å½•çª¥å±è¡Œä¸º
      await logSingleItemViewing(activeCharacterId, 'diary', entry);
    }
  }

 
  async function toggleDiaryFavorite() {
    if (!activeDiaryForViewing || !activeCharacterId) return;

    const diary = activeDiaryForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-diary-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_diary',
      'content.id': diary.id
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
    } else {

      const newFavorite = {
        type: 'char_diary',

        content: {
          id: diary.id,
          title: diary.title,
          content: diary.content,
          timestamp: diary.timestamp,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
    }
  }



  async function toggleMemoFavorite() {

    if (!activeMemoForViewing || !activeCharacterId) return;

    const memo = activeMemoForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-memo-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_memo',
      'content.id': memo.id
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
    } else {

      const newFavorite = {
        type: 'char_memo',

        content: {
          id: memo.id,
          title: memo.title,
          content: memo.content,
          timestamp: memo.timestamp,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
    }
  }


  async function deleteDiary(diaryId) {
    const confirmed = await showCustomConfirm('åˆ é™¤æ—¥è®°', 'ç¡®å®šè¦åˆ é™¤è¿™ç¯‡æ—¥è®°å—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const char = state.chats[activeCharacterId];
      char.diary = char.diary.filter(d => d.id !== diaryId);
      await db.chats.put(char);
      renderCharDiaryList();
    }
  }




  async function renderCharSimulatedQQ() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    if (!char) return;


    const userDisplayName = char.settings.myNickname || (state.qzoneSettings.nickname || 'æˆ‘');
    const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || {
      content: '...'
    };


    let lastMsgContent = '...';
    if (lastRealMessage) {
      if (typeof lastRealMessage.content === 'string') {
        lastMsgContent = lastRealMessage.content;
      } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
        lastMsgContent = '[å›¾ç‰‡]';
      } else if (lastRealMessage.type) {
        const typeMap = {
          'voice_message': '[è¯­éŸ³]',
          'transfer': '[è½¬è´¦]',
          'ai_image': '[å›¾ç‰‡]'
        };
        lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
      }
    }


    const myAvatar = char.settings.myAvatar || defaultAvatar;
    const myFrame = char.settings.myAvatarFrame || '';
    let avatarHtml;
    if (myFrame) {
      avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${myFrame}" class="avatar-frame"></div></div>`;
    } else {
      avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
    }

    const userChatItem = document.createElement('div');
    userChatItem.className = 'chat-list-item';

    userChatItem.dataset.conversationIndex = "-1";
    userChatItem.innerHTML = `
        ${avatarHtml}
        <div class="info">
            <div class="name-line">
                <span class="name">${userDisplayName}</span>
            </div>
            <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
        </div>
    `;
    listEl.appendChild(userChatItem);


    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));
    const conversations = char.simulatedConversations || [];

    if (conversations.length === 0 && !userChatItem) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ï¼Œ<br>çœ‹çœ‹TAæœ€è¿‘éƒ½å’Œè°èŠå¤©äº†å§ï¼</p>';
      return;
    }

    conversations.forEach((convo, index) => {

      if (convo.type === 'private_user') {
        return;
      }


      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.conversationIndex = index;

      let lastMessage, avatarHtml, displayName;

      if (convo.type === 'group') {
        displayName = convo.groupName + ` <span class="group-tag">ç¾¤</span>`;
        lastMessage = convo.messages.slice(-1)[0] || {
          content: '...'
        };
        const groupAvatarPrompt = `logo, simple, flat design, for a group chat named '${convo.groupName}'`;
        const avatarUrl = state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(groupAvatarPrompt)}` : defaultGroupAvatar;
        avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;

      } else {
        displayName = convo.participant.name;
        lastMessage = convo.messages.slice(-1)[0] || {
          content: '...'
        };
        const npcData = npcMap.get(displayName);
        let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
          (state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(convo.participant.avatar_prompt || 'anime person')}` : defaultGroupMemberAvatar);
        avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
      }

      let lastMsgContent = '...';
      if (lastMessage && lastMessage.content) {
        lastMsgContent = lastMessage.content;
      }

      item.innerHTML = `
            ${avatarHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${displayName}</span>
                </div>
                <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
            </div>
        `;
      listEl.appendChild(item);
    });
  }
 
  async function handleGenerateSimulatedQQ() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ ¹æ®â€œ${chat.name}â€çš„è®°å¿†å’Œäººè®¾ï¼Œç”Ÿæˆå…¨æ–°çš„ç¤¾äº¤åŠ¨æ€...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const allNpcs = await db.npcs.toArray();
    const associatedNpcs = allNpcs.filter(npc =>
      npc.associatedWith && npc.associatedWith.includes(activeCharacterId)
    );
    let npcContext = "# ä½ çš„ç¤¾äº¤åœˆ (ç»‘å®šçš„NPC)\n";
    if (associatedNpcs.length > 0) {
      npcContext += "è¿™æ˜¯ä½ è®¤è¯†çš„ã€å…³ç³»å¯†åˆ‡çš„NPCã€‚åœ¨ç”Ÿæˆå¯¹è¯æ—¶ï¼Œä½ åº”è¯¥ã€ä¼˜å…ˆã€‘ä¸ä»–ä»¬äº’åŠ¨ã€‚\n";
      associatedNpcs.forEach(npc => {
        npcContext += `- **å§“å**: ${npc.name}\n  - **äººè®¾**: ${npc.persona}\n`;
      });
    } else {
      npcContext += "ï¼ˆä½ ç›®å‰æ²¡æœ‰ç»‘å®šçš„NPCä¼™ä¼´ï¼Œå¯ä»¥è‡ªç”±åˆ›é€ æ–°çš„NPCã€‚ï¼‰\n";
    }

    const userDisplayNameForAI = state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    const userNicknameInThisChat = chat.settings.myNickname || userDisplayNameForAI;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistoryWithUser_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userNicknameInThisChat : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    const worldBookContext = allWorldBookIds
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š (ä½ å¯ä»¥å°†å…¶ä¸­è§’è‰²ä½œä¸ºèŠå¤©å¯¹è±¡):\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const characterOriginalName = chat.originalName || chat.name;
    const stickerContext = getGroupStickerContextForPrompt(chat);

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾äº¤ç”Ÿæ´»æ¨¡æ‹Ÿå™¨ï¼Œæ‰®æ¼”è§’è‰²â€œ${chat.name}â€ã€‚ä½ çš„ä»»åŠ¡æ˜¯è™šæ„å‡ºã€5åˆ°7æ®µã€‘TAæœ€è¿‘çš„QQèŠå¤©è®°å½•ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€NPCå”¯ä¸€æ€§é“å¾‹ã€‘**: åœ¨ä½ æœ¬æ¬¡ç”Ÿæˆçš„æ‰€æœ‰å¯¹è¯ä¸­ï¼ˆåŒ…æ‹¬ç§èŠå’Œç¾¤èŠï¼‰ï¼Œæ¯ä¸€ä¸ªNPCçš„åå­—ã€å¿…é¡»æ˜¯ç‹¬ä¸€-æ— äºŒçš„ã€‘ã€‚ç»å¯¹ç¦æ­¢å‡ºç°é‡åçš„NPCï¼Œç¦æ­¢å‡ºç°é‡å¤ç¾¤èŠã€‚
2.  **ã€NPCæ¥æºã€‘**: ä½ åº”è¯¥ä¼˜å…ˆä»â€œä½ çš„ç¤¾äº¤åœˆ (ç»‘å®šçš„NPC)â€å’Œâ€œä¸–ç•Œä¹¦â€ä¸­å¯»æ‰¾è§’è‰²ä½œä¸ºèŠå¤©å¯¹è±¡ã€‚å¦‚æœä¸å¤Ÿï¼Œä½ ä¹Ÿå¯ä»¥è‡ªç”±åˆ›é€ å…¨æ–°çš„NPCï¼Œå¯¹è¯å†…å®¹è¦å¤šæ ·åŒ–ï¼Œåæ˜ è§’è‰²çš„ç”Ÿæ´»ã€‚
3.  **å…³è”æ€§**: å¯¹è¯å†…å®¹åº”å·§å¦™åœ°åæ˜ è§’è‰²çš„é•¿æœŸè®°å¿†ã€ä¸–ç•Œè§‚ï¼Œä»¥åŠä¸ç”¨æˆ·äº’åŠ¨å¯èƒ½å¸¦æ¥çš„å¿ƒæƒ…å˜åŒ–ã€‚
4.  **ç®€æ´æ€§**: æ¯æ®µå¯¹è¯çš„æ€»é•¿åº¦åº”åœ¨8åˆ°15å¥ä¹‹é—´ã€‚
# æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®°ã€‚
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ®µå¯¹è¯ï¼Œä¸”ã€å¿…é¡»ã€‘æ˜¯ä»¥ä¸‹ä¸¤ç§æ ¼å¼ä¹‹ä¸€ï¼š



### æ ¼å¼ Aï¼šä¸NPCçš„ç§èŠ
\`\`\`json
{
  "type": "private_npc",
  "participant": {
    "name": "NPCçš„åå­—",
    "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›)ä¸€æ®µç”¨äºç”Ÿæˆå¤´åƒçš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£æ ¼ä¸ºåŠ¨æ¼«/æ’ç”»/äºŒæ¬¡å…ƒç­‰, ç¦æ­¢çœŸäºº"
  },
"messages": [
  {"sender": "${characterOriginalName}", "content": "å¯¹è¯å†…å®¹1"},
  {"sender": "NPCçš„åå­—", "content": "å¯¹è¯å†…å®¹2"},
  {"sender": "${characterOriginalName}", "type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}
]
}
\`\`\`

### æ ¼å¼ Bï¼šç¾¤èŠ
\`\`\`json
{
  "type": "group",
  "groupName": "ä¸€ä¸ªè™šæ„çš„ç¾¤å",
  "participants": [
    {"name": "NPCæˆå‘˜1", "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›) æˆå‘˜1å¤´åƒã€è‹±æ–‡ã€‘å…³é”®è¯"},
    {"name": "NPCæˆå‘˜2", "avatar_prompt": "(ä»…å½“NPCæ˜¯æ–°åˆ›é€ æ—¶æä¾›) æˆå‘˜2å¤´åƒã€è‹±æ–‡ã€‘å…³é”®è¯"}
  ],
"messages": [
  {"sender": "${characterOriginalName}", "content": "æˆ‘åœ¨ç¾¤é‡Œè¯´çš„è¯"},
  {"sender": "NPCæˆå‘˜1", "content": "æˆå‘˜1å›å¤æˆ‘"},
  {"sender": "NPCæˆå‘˜2", "type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(å¿…é¡»ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}
]
}
\`\`\`

# è§’è‰²ä¸ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**: ${longTermMemoryContext}
- **ä¸–ç•Œè§‚**: ${worldBookContext}
- **æœ€è¿‘ä¸ç”¨æˆ·çš„äº’åŠ¨**: ${recentHistoryWithUser}
${npcContext}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}
ç°åœ¨ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§æ ¼å¼é“å¾‹ï¼Œç”ŸæˆèŠå¤©è®°å½•çš„JSONæ•°ç»„ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆæ¨¡æ‹ŸèŠå¤©è®°å½•ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedConversations;
      try {
        simulatedConversations = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }

      chat.simulatedConversations = simulatedConversations;
      await db.chats.put(chat);

      await renderCharSimulatedQQ();


      const hiddenMessage = {
        role: 'system',
        content: `[ç³»ç»ŸæŒ‡ä»¤ï¼šä½ åˆšåˆšåœ¨è‡ªå·±çš„æ‰‹æœºä¸Šæ´»åŠ¨äº†ä¸€ç•ªï¼ˆå’Œæœ‹å‹èŠå¤©ã€é€›ç¾¤ç­‰ï¼‰ã€‚ç°åœ¨è¯·æ ¹æ®ä½ çš„è§’è‰²è®¾å®šï¼Œä¸»åŠ¨ç»™ç”¨æˆ·å‘ä¸€æ¡æ¶ˆæ¯ï¼Œå¯ä»¥èŠèŠä½ åˆšæ‰çœ‹åˆ°æˆ–èŠåˆ°çš„è¶£äº‹ï¼Œæˆ–è€…ä»…ä»…æ˜¯é—®å€™ä¸€ä¸‹ã€‚]`,
        timestamp: Date.now(),
        isHidden: true
      };
      chat.history.push(hiddenMessage);
      await db.chats.put(chat);
      triggerAiResponse();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹ŸèŠå¤©å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨¡æ‹ŸèŠå¤©è®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

 
  async function handleContinueRealConversationFromCPhone() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;



    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
      }

      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, activeCharacterId);
      const myNickname = chat.settings.myNickname || 'æˆ‘';






      const userPersona = chat.settings.myPersona || 'ç”¨æˆ·';


      const longTermMemoryContext = `# é•¿æœŸè®°å¿† (å¿…é¡»ä¸¥æ ¼éµå®ˆ)\n${
            chat.longTermMemory && chat.longTermMemory.length > 0 
                ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') 
                : '- (æš‚æ— )'
        }`;


      let worldBookContext = '';
      // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
      let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
      // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
      state.worldBooks.forEach(wb => {
        if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
          allWorldBookIds.push(wb.id);
        }
      });
      
      if (allWorldBookIds.length > 0) {
        const linkedContents = allWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n**å†…å®¹:**\n${entry.content}`)
            .join('');
          return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContext = `\n\n# æ ¸å¿ƒä¸–ç•Œè§‚è®¾å®š (å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è®¾å®š)\n${linkedContents}\n`;
        }
      }

      const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
      const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
      const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
      const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
      const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
      const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

      let multiLayeredSummaryContext = '';
      if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
        multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
        if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
        if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
        if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
        if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
        if (summaryToday) multiLayeredSummaryContext += summaryToday;
        if (summary3Days) multiLayeredSummaryContext += summary3Days;
        if (summary7Days) multiLayeredSummaryContext += summary7Days;
      }
      const stickerContext = getStickerContextForPrompt(chat);
      const systemPrompt = `
# ä½ çš„æ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${chat.originalName}â€ã€‚ç”¨æˆ·åˆšåˆšåœ¨TAçš„æ‰‹æœºï¼ˆCPhoneï¼‰ä¸Šç‚¹å‡»äº†ä¸€ä¸ªæŒ‰é’®ï¼Œå¸Œæœ›ä½ èƒ½ç»§ç»­ä½ ä»¬ä¹‹å‰çš„å¯¹è¯ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œç”Ÿæˆã€3åˆ°5æ¡ã€‘ç¬¦åˆä½ äººè®¾çš„ã€ç®€çŸ­çš„ã€è¿ç»­çš„æ–°å›å¤ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€æ¡æ¶ˆæ¯ã€‚
- æ ¼å¼: \`[{"type": "text", "content": "ç¬¬ä¸€å¥è¯"}, {"type": "text", "content": "ç¬¬äºŒå¥è¯"}, {"type": "sticker", "meaning": "è¡¨æƒ…çš„å«ä¹‰(ä»å¯ç”¨è¡¨æƒ…åˆ—è¡¨é€‰æ‹©)"}]\`
- ä½ å¯ä»¥è‡ªç”±ç»„åˆä½¿ç”¨ "text", "sticker", "ai_image", "voice_message" ç­‰å¤šç§æ¶ˆæ¯ç±»å‹ã€‚
è¯·æ ¹æ®å½“å‰æƒ…æ™¯å’Œä½ çš„æƒ…ç»ªï¼Œä»åˆ—è¡¨ä¸­ã€é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ã€‘è¡¨æƒ…å«ä¹‰æ¥ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚å°½é‡è®©ä½ çš„è¡¨æƒ…ä¸°å¯Œå¤šæ ·ï¼Œé¿å…é‡å¤ã€‚
# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}
# å¯ç”¨è¡¨æƒ…åŒ… (å¿…é¡»ä¸¥æ ¼éµå®ˆï¼)
- å½“ä½ éœ€è¦å‘é€è¡¨æƒ…æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„åˆ—è¡¨ä¸­ã€ç²¾ç¡®åœ°é€‰æ‹©ä¸€ä¸ªã€‘å«ä¹‰ï¼ˆmeaningï¼‰ã€‚
- ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä»»ä½•ä¸åœ¨åˆ—è¡¨ä¸­çš„è¡¨æƒ…å«ä¹‰ï¼
${stickerContext}

# ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾
${userPersona}  

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„æœ¬å**: "${chat.originalName}"
- **ç”¨æˆ·çš„å¤‡æ³¨**: "${myNickname}"
${worldBookContext}
${longTermMemoryContext}
${multiLayeredSummaryContext} 
- **ä½ ä»¬æœ€åçš„å¯¹è¯**:
${historySlice.map(msg => `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`).join('\n')}

ç°åœ¨ï¼Œè¯·ç»§ç»­è¿™åœºå¯¹è¯ã€‚
`;


      const messagesPayload = filteredHistory.map(msg => ({
        role: msg.role,
        content: `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`
      }));

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesPayload],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) {
        throw new Error(`API è¯·æ±‚å¤±è´¥: ${(await response.json()).error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const messagesArray = parseAiResponse(aiResponseContent);

      if (!messagesArray || messagesArray.length === 0) {
        throw new Error("AIè¿”å›äº†ç©ºå†…å®¹ã€‚");
      }

      let newMessagesCount = 0;
      let messageTimestamp = Date.now();
      for (const msgData of messagesArray) {
        const baseMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: messageTimestamp++
        };
        let aiMessage = null;
        switch (msgData.type) {
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content || msgData.message)
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (CPhone) å°è¯•ä½¿ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„è¡¨æƒ…: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (CPhone) å‘é€äº†ä¸€ä¸ªæ²¡æœ‰ 'meaning' çš„ sticker æŒ‡ä»¤ã€‚", msgData);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: msgData.url,
                meaning: 'æœªçŸ¥è¡¨æƒ…'
              };
            }
            break;
        }
        if (aiMessage) {
          chat.history.push(aiMessage);
          newMessagesCount++;
        }
      }

      if (newMessagesCount > 0) {
        chat.unreadCount = (chat.unreadCount || 0) + newMessagesCount;
      }

      await db.chats.put(chat);
      await renderChatList();

      if (newMessagesCount > 0) {
        showNotification(chat.id, `å‘æ¥äº† ${newMessagesCount} æ¡æ–°æ¶ˆæ¯`);
      }

    } catch (error) {
      console.error("ä»CPhoneæ¨è¿›çœŸå®å¯¹è¯å¤±è´¥:", error);
      await showCustomAlert('æ“ä½œå¤±è´¥', `æ— æ³•ç”Ÿæˆæ–°å›å¤: ${error.message}`);
    }
  }
 
  async function loadMoreMirroredMessages() {
    if (isLoadingMoreCphoneMessages || !activeCharacterId) return;
    isLoadingMoreCphoneMessages = true;

    const messagesContainer = document.getElementById('char-conversation-messages');
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) {
      isLoadingMoreCphoneMessages = false;
      return;
    }

    showLoader(messagesContainer, 'top');
    const oldScrollHeight = messagesContainer.scrollHeight;


    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = mainChar.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - cphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);

    const messagesToPrepend = mainChar.history.slice(nextSliceStart, nextSliceEnd);


    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
      isLoadingMoreCphoneMessages = false;
      return;
    }


    for (const msg of messagesToPrepend.reverse()) {
      const mirroredMsg = {
        ...msg,
        role: msg.role === 'user' ? 'assistant' : 'user'
      };


      const tempChatObjectForRendering = {
        id: 'temp_user_chat_mirror',
        isGroup: false,
        name: mainChar.name,
        settings: {
          ...mainChar.settings,
          myAvatar: mainChar.settings.aiAvatar,
          myAvatarFrame: mainChar.settings.aiAvatarFrame,
          aiAvatar: mainChar.settings.myAvatar,
          aiAvatarFrame: mainChar.settings.myAvatarFrame
        }
      };

      const messageEl = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
      if (messageEl) {
        messagesContainer.prepend(messageEl);
      }
    }

    cphoneRenderedCount += messagesToPrepend.length;


    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreCphoneMessages = false;
  }

  async function loadMoreMyPhoneMessages() {
    if (isLoadingMoreMyPhoneMessages || !activeMyPhoneCharacterId) return;
    isLoadingMoreMyPhoneMessages = true;

    const messagesContainer = document.getElementById('myphone-conversation-messages');
    const char = state.chats[activeMyPhoneCharacterId];
    if (!char) {
      isLoadingMoreMyPhoneMessages = false;
      return;
    }

    // åªæœ‰åœ¨æŸ¥çœ‹çœŸå®å¯¹è¯ï¼ˆindex === -1ï¼‰æ—¶æ‰æ”¯æŒæ»šåŠ¨åŠ è½½
    if (myphoneActiveConversationIndex !== -1) {
      isLoadingMoreMyPhoneMessages = false;
      return;
    }

    showLoader(messagesContainer, 'top');
    const oldScrollHeight = messagesContainer.scrollHeight;

    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = char.history.filter(m => !m.isHidden).length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - myphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);

    const allVisibleMessages = char.history.filter(m => !m.isHidden);
    const messagesToPrepend = allVisibleMessages.slice(nextSliceStart, nextSliceEnd);

    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
      isLoadingMoreMyPhoneMessages = false;
      return;
    }

    // åˆ›å»ºä¸´æ—¶èŠå¤©å¯¹è±¡ç”¨äºæ¸²æŸ“ï¼ˆè§’è‰²è§†è§’ï¼‰
    const tempChatObject = {
      id: 'temp_myphone_user_chat',
      isGroup: false,
      name: state.qzoneSettings.nickname || 'æˆ‘',
      settings: {
        ...char.settings,
        myAvatar: char.settings.myAvatar || defaultAvatar,
        myAvatarFrame: char.settings.myAvatarFrame || '',
        aiAvatar: char.settings.aiAvatar || defaultAvatar,
        aiAvatarFrame: char.settings.aiAvatarFrame || ''
      }
    };

    for (const msg of messagesToPrepend.reverse()) {
      const messageEl = await createMessageElement(msg, tempChatObject);
      if (messageEl) {
        messagesContainer.prepend(messageEl);
      }
    }

    myphoneRenderedCount += messagesToPrepend.length;

    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreMyPhoneMessages = false;
  }

  async function openCharSimulatedConversation(conversationIndex) {
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) return;

    cphoneActiveConversationType = (conversationIndex === -1) ? 'private_user' : mainChar.simulatedConversations[conversationIndex]?.type;

    const bodyEl = document.getElementById('char-conversation-messages');
    bodyEl.innerHTML = '';
    bodyEl.dataset.theme = mainChar.settings.theme || 'default';
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    bodyEl.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';

    let tempChatObjectForRendering;
    let messagesToRender = [];
    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc])); 

    if (conversationIndex === -1) {

      cphoneActiveConversationType = 'private_user';
      const titleEl = document.getElementById('char-conversation-partner-name');
    
      const inputEl = document.getElementById('char-simulated-input');

      bodyEl.innerHTML = '';
      titleEl.textContent = mainChar.settings.myNickname || (state.qzoneSettings.nickname || 'æˆ‘');
      inputEl.placeholder = `ä¸ ${mainChar.settings.myNickname || 'æˆ‘'} çš„å¯¹è¯ (åªè¯»)`;

      cphoneRenderedCount = 0;
      isLoadingMoreCphoneMessages = false;

      const history = mainChar.history;
      const renderWindow = state.globalSettings.chatRenderWindow || 50;
      const initialMessages = history.slice(-renderWindow);

      tempChatObjectForRendering = {
        id: 'temp_user_chat_mirror',
        isGroup: false,
        name: mainChar.name,
        settings: {
          ...mainChar.settings,
          myAvatar: mainChar.settings.aiAvatar,
          myAvatarFrame: mainChar.settings.aiAvatarFrame,
          aiAvatar: mainChar.settings.myAvatar,
          aiAvatarFrame: mainChar.settings.myAvatarFrame
        }
      };

      messagesToRender = initialMessages.map(msg => ({
        ...msg,
        role: msg.role === 'user' ? 'assistant' : 'user'
      }));
      cphoneRenderedCount = initialMessages.length;

    } else {

      const conversation = mainChar.simulatedConversations[conversationIndex];
      if (!conversation) return;
      cphoneActiveConversationType = conversation.type;

      const titleEl = document.getElementById('char-conversation-partner-name');
   
      const inputEl = document.getElementById('char-simulated-input');

      if (conversation.type === 'group') {
        titleEl.textContent = `${conversation.groupName} (${conversation.participants.length + 1})`;
        inputEl.placeholder = `åœ¨ ${conversation.groupName} ä¸­èŠå¤©`;
        tempChatObjectForRendering = {
          id: 'temp_group_chat',
          isGroup: true,
          name: conversation.groupName,
          originalName: mainChar.originalName,
          members: conversation.participants.map(p => {
            const npcData = npcMap.get(p.name);
            let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
              (state.globalSettings.enableAiDrawing ?
                `https://image.pollinations.ai/prompt/${encodeURIComponent(p.avatar_prompt || 'anime person')}` :
                defaultGroupMemberAvatar);
            return {
              originalName: p.name,
              groupNickname: p.name,
              avatar: avatarUrl
            };
          }),
          settings: {
            ...mainChar.settings,
            myNickname: mainChar.name,
            myAvatar: mainChar.settings.aiAvatar,
            myAvatarFrame: mainChar.settings.aiAvatarFrame,
          }
        };
      } else {
        titleEl.textContent = conversation.participant.name;
        inputEl.placeholder = `ä¸ ${conversation.participant.name} çš„å¯¹è¯`;
        const npcData = npcMap.get(conversation.participant.name);
        const npcAvatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
          (state.globalSettings.enableAiDrawing ?
            `https://image.pollinations.ai/prompt/${encodeURIComponent(conversation.participant.avatar_prompt || 'anime person')}` :
            defaultGroupMemberAvatar);
        tempChatObjectForRendering = {
          id: 'temp_npc_chat',
          isGroup: false,
          name: conversation.participant.name,
          originalName: mainChar.originalName,
          settings: {
            ...mainChar.settings,
            myAvatar: mainChar.settings.aiAvatar,
            myAvatarFrame: mainChar.settings.aiAvatarFrame,
            aiAvatar: npcAvatarUrl,
            aiAvatarFrame: ''
          }
        };
      }
      messagesToRender = conversation.messages; 
    }


    
    for (const msg of messagesToRender) {
      let role = msg.role; 
      if (conversationIndex !== -1) {
        const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
        role = isFromMainChar ? 'user' : 'assistant';
      }

      const tempMessageObject = {
        role: role,
        senderName: msg.sender || (role === 'user' ? tempChatObjectForRendering.settings.myNickname : tempChatObjectForRendering.name),
        timestamp: msg.timestamp || (Date.now() + Math.random())
      };


      if (msg.type === 'sticker' && msg.meaning) {

        const sticker = state.userStickers.find(s => s.name === msg.meaning);
        if (sticker) {
          tempMessageObject.content = sticker.url;
          tempMessageObject.meaning = msg.meaning;
          tempMessageObject.type = 'sticker';
        } else {

          console.warn(`æ¨¡æ‹Ÿè¡¨æƒ…å«ä¹‰ "${msg.meaning}" åœ¨åº“ä¸­æœªæ‰¾åˆ°ã€‚`);
          tempMessageObject.content = `[è¡¨æƒ…: ${msg.meaning}]`;
          tempMessageObject.type = 'text';
        }
      } else {

        tempMessageObject.content = msg.content;
        tempMessageObject.type = msg.type || 'text';
      }

      const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
      if (bubbleElement) {
        bodyEl.appendChild(bubbleElement);
      }
    }

    switchToCharScreen('char-qq-conversation-screen');
    setTimeout(() => bodyEl.scrollTop = bodyEl.scrollHeight, 0); // æ¸²æŸ“å®Œæˆåæ»šåŠ¨åˆ°åº•éƒ¨
  }

  function closeSimulatedTranscriptModal() {
    document.getElementById('char-qq-transcript-modal').classList.remove('visible');
  }


 
  async function handleGenerateSimulatedAlbum() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];

    if (!chat) {
      await showCustomAlert("æ“ä½œå¤±è´¥", "æ— æ³•æ‰¾åˆ°å½“å‰è§’è‰²çš„æ•°æ®ã€‚");
      return;
    }

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€å›å¿†TAçš„ç›¸å†Œç…§ç‰‡...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    const worldBookContext = allWorldBookIds
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œæ„æ€å‡ºã€8åˆ°10å¼ ã€‘TAæœ€è¿‘å¯èƒ½ä¼šæ‹æ‘„æˆ–çè—åœ¨æ‰‹æœºç›¸å†Œé‡Œçš„ç…§ç‰‡ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: ç…§ç‰‡å†…å®¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»ç¯å¢ƒã€‚
2.  **å¤šæ ·æ€§**: ç…§ç‰‡ä¸»é¢˜è¦ä¸°å¯Œï¼Œå¯ä»¥åŒ…æ‹¬è‡ªæ‹ã€é£æ™¯ã€é£Ÿç‰©ã€å® ç‰©ã€æœ‹å‹åˆå½±ã€å·¥ä½œåœºæ™¯ç­‰ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€å¼ ç…§ç‰‡ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "description": "è¿™æ˜¯ç…§ç‰‡èƒŒåçš„æ•…äº‹æˆ–è§’è‰²çš„å¿ƒæƒ…æ—¥è®°ï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
        "image_prompt": "ä¸€æ®µç”¨äºç”Ÿæˆè¿™å¼ ç…§ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚"
      }
    ]
    \`\`\`
    - **ã€image_prompt ç»å¯¹ç¦æ­¢ã€‘**: ç»å¯¹ç¦æ­¢åŒ…å«ä»»ä½•ä¸­æ–‡å­—ç¬¦ã€å¥å­ã€ç‰¹æ®Šç¬¦å·ã€æˆ–ä»»ä½•å¯èƒ½æ¶‰åŠæ•æ„Ÿï¼ˆNSFWï¼‰ã€æš´åŠ›ã€è¡€è…¥ã€æ”¿æ²»çš„å†…å®¹ï¼ä¹Ÿç¦æ­¢çœŸäººï¼
    - **ã€image_prompt å¿…é¡»æ˜¯ã€‘**: å¿…é¡»æ˜¯çº¯è‹±æ–‡çš„ã€ç”¨é€—å·åˆ†éš”çš„ã€å…³é”®è¯ç»„åˆã€‘ (e.g., "1boy, solo, basketball jersey, in locker room, smiling, selfie")ã€‚
    - **ã€ç”»é£æŒ‡ä»¤ã€‘**: åœ¨ prompt çš„æœ«å°¾ï¼Œæ€»æ˜¯åŠ ä¸Šç”»é£æŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼š \`best quality, masterpiece, anime style, cinematic lighting\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„ç…§ç‰‡çš„æè¿°å’Œç»˜ç”»æŒ‡ä»¤ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„ç›¸å†Œå†…å®¹ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9

          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedAlbumData;
      try {
        simulatedAlbumData = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      chat.simulatedAlbum = simulatedAlbumData;
      await db.chats.put(chat);

      await renderCharAlbum();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œå¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨¡æ‹Ÿç›¸å†Œï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }



 
  async function renderCharAlbum() {
    const gridEl = document.getElementById('char-album-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];

    const photos = char.simulatedAlbum || [];

    if (photos.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„ç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›ç…§ç‰‡å§ï¼</p>';
      return;
    }

    const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

    photos.forEach(photo => {
      const item = document.createElement('div');
      item.className = 'char-photo-item';
      item.dataset.description = photo.description;
      gridEl.appendChild(item);







      if (state.globalSettings.enableAiDrawing) {

        item.style.backgroundColor = '#e9ecef';
        const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
        const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
        const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;

        const img = new Image();
        img.onload = function() {
          item.style.backgroundImage = `url(${this.src})`;
        };
        img.onerror = function() {
          item.style.backgroundImage = `url(${fallbackImageUrl})`;
        };
        img.src = imageUrl;

      } else {

        item.style.backgroundColor = '#f0f2f5';
        item.style.border = '1px solid #e0e0e0';

        const descriptionEl = document.createElement('p');
        descriptionEl.className = 'char-photo-description';
        descriptionEl.textContent = photo.description || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)';

        item.appendChild(descriptionEl);
      }
    });
  }


  async function handleGenerateBrowserHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ¨¡æ‹Ÿâ€œ${chat.name}â€çš„ç½‘ä¸Šå†²æµªè¶³è¿¹...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºã€10åˆ°20æ¡ã€‘TAæœ€è¿‘çš„æµè§ˆå™¨æœç´¢/æµè§ˆè®°å½•ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: è®°å½•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»ç¯å¢ƒã€‚
2.  **å¤šæ ·æ€§**: è®°å½•ç±»å‹è¦ä¸°å¯Œï¼Œå¯ä»¥æ˜¯å¸–å­ã€æ–‡ç« ã€æ–°é—»ã€é—®ç­”ç­‰ã€‚
3.  **ã€æ ¼å¼ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ¡æµè§ˆè®°å½•ï¼Œå¹¶ä¸”ã€å¿…é¡»ã€‘ä½¿ç”¨ä»¥ä¸‹æ ¼å¼:
    \`\`\`json
    [
      {
        "type": "text",
        "title": "ç²¾ç‚¼ä¸”å¸å¼•äººçš„æ ‡é¢˜ (ä¸è¶…è¿‡20å­—)",
        "url": "www.example.com/article/123 (çœ‹èµ·æ¥åƒçœŸå®çš„ç®€æ´ç½‘å€)",
        "content": "ä¸€ç¯‡200-400å­—çš„ã€åˆ†æ®µè‰¯å¥½çš„æ–‡ç« æ­£æ–‡ï¼Œä½¿ç”¨\\næ¢è¡Œã€‚"
      }
    ]
    \`\`\`
    
    **ã€ç»å¯¹ç¦æ­¢ã€‘**: ä½ çš„å›å¤ä¸­ã€ç»å¯¹ä¸èƒ½ã€‘åŒ…å« "type": "image" çš„å¯¹è±¡ã€‚æ‰€æœ‰è®°å½•éƒ½å¿…é¡»æ˜¯æ–‡å­—å†…å®¹ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- ** ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„ã€çº¯æ–‡æœ¬ã€‘çš„æµè§ˆè®°å½•ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æµè§ˆå™¨è®°å½•ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9

          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedHistory;
      try {
        simulatedHistory = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      chat.simulatedBrowserHistory = simulatedHistory;
      await db.chats.put(chat);

      await renderCharBrowserHistory();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿæµè§ˆå™¨å†å²å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæµè§ˆè®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

  function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„æµè§ˆå™¨ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
      return;
    }

    history.forEach((item, index) => {
      const entryEl = document.createElement('div');
      entryEl.className = 'char-browser-item';
      entryEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="url">${item.url}</div>
        `;

      entryEl.addEventListener('click', () => openCharArticle(index));
      listEl.appendChild(entryEl);
    });
  }



  async function openCharArticle(index) {
    const char = state.chats[activeCharacterId];
    const articleData = char.simulatedBrowserHistory[index];
    if (!articleData) return;



    activeArticleForViewing = articleData;


    renderCharArticle(articleData);
    switchToCharScreen('char-browser-article-screen');



    const favBtn = document.getElementById('favorite-article-btn');

    const existingFavorite = await db.favorites.where({
      type: 'char_browser_article',
      'content.url': articleData.url
    }).first();
    favBtn.classList.toggle('active', !!existingFavorite);

  }


  async function toggleBrowserArticleFavorite() {
    if (!activeArticleForViewing || !activeCharacterId) return;

    const article = activeArticleForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-article-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_browser_article',
      'content.url': article.url
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²å–æ¶ˆæ”¶è—ã€‚');
    } else {

      const newFavorite = {
        type: 'char_browser_article',

        content: {
          ...article,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('æ“ä½œæˆåŠŸ', 'å·²æˆåŠŸæ”¶è—åˆ°â€œæˆ‘çš„æ”¶è—â€é¡µé¢ï¼');
    }
  }
 
  function renderCharArticle(articleData) {
    const titleEl = document.getElementById('char-article-title'); // é¡¶éƒ¨å¯¼èˆªæ çš„å°æ ‡é¢˜
    const contentEl = document.getElementById('char-article-content'); // å†…å®¹åŒºåŸŸ

    // å¯¼èˆªæ åªæ˜¾ç¤ºæ¥æºæˆ–ç®€ç•¥æ ‡é¢˜
    let navTitle = "ç½‘é¡µæµè§ˆ";
    if (articleData.url) {
        // å°è¯•ä» URL æå–åŸŸåä½œä¸ºå¯¼èˆªæ ‡é¢˜
        try {
            const urlObj = new URL(articleData.url.startsWith('http') ? articleData.url : `http://${articleData.url}`);
            navTitle = urlObj.hostname.replace('www.', '');
        } catch (e) {
            navTitle = articleData.title.substring(0, 10) + '...';
        }
    }
    titleEl.textContent = navTitle;
    
    contentEl.innerHTML = '';

    if (articleData.type === 'image') {
        // å›¾ç‰‡ç±»å‹çš„æ–‡ç« 
        contentEl.innerHTML = `
            <div class="char-browser-image-description">
                <div style="font-size: 40px; margin-bottom: 20px; opacity: 0.5;">ğŸ–¼ï¸</div>
                ${articleData.title || '(æ— æ ‡é¢˜å›¾ç‰‡)'}
            </div>`;
    } else {
        // æ–‡æœ¬ç±»å‹çš„æ–‡ç« 
        const largeTitle = `<div class="article-large-title">${articleData.title}</div>`;
        
        // å¤„ç†æ­£æ–‡æ¢è¡Œï¼ŒåŒ…è£¹åœ¨ p æ ‡ç­¾ä¸­
        const paragraphs = (articleData.content || 'å†…å®¹åŠ è½½å¤±è´¥...')
            .split('\n')
            .filter(line => line.trim() !== '') // è¿‡æ»¤ç©ºè¡Œ
            .map(line => `<p>${line}</p>`)
            .join('');

        contentEl.innerHTML = `
            ${largeTitle}
            <div class="article-body">
                ${paragraphs}
            </div>
        `;
    }
}





  async function handleGenerateTaobaoHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ¨¡æ‹Ÿâ€œ${chat.name}â€çš„è´­ç‰©ä¹ æƒ¯...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºTAæœ€è¿‘çš„æ·˜å®è´­ç‰©è®°å½•å’Œè´¦æˆ·ä½™é¢ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ä½™é¢é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: ä½ ã€å¿…é¡»ã€‘æ ¹æ®è§’è‰²çš„ã€ç»æµçŠ¶å†µã€‘è®¾å®šä¸€ä¸ªåˆç†çš„ \`totalBalance\` (æ€»ä½™é¢)ã€‚ä¾‹å¦‚ï¼Œå¯Œæœ‰çš„è§’è‰²åº”è¯¥æœ‰æ›´é«˜çš„ä½™é¢ï¼Œè€Œå­¦ç”Ÿæˆ–ç»æµæ‹®æ®çš„è§’è‰²åˆ™åº”è¯¥æœ‰è¾ƒä½çš„ä½™é¢ã€‚
2.  **åˆç†æ€§**: è´­ä¹°è®°å½•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½å’Œç»æµçŠ¶å†µã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªã€å•ä¸€çš„JSONå¯¹è±¡ã€‘ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`{\` å¼€å§‹ï¼Œå¹¶ä»¥ \`}\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®°ã€‚
    - æ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    {
      "totalBalance": 12345.67, // (è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ•°å­—ï¼Œä½ å¿…é¡»æ ¹æ®è§’è‰²çš„ç»æµçŠ¶å†µç”Ÿæˆä¸€ä¸ªå…¨æ–°çš„ã€åˆç†çš„ä½™é¢ï¼)
      "purchases": [
        {
          "itemName": "ä¸€ä¸ªå…·ä½“ã€ç”ŸåŠ¨çš„å•†å“åç§°",
          "price": 128.80,
          "status": "å·²ç­¾æ”¶",
          "reason": "è¿™æ˜¯è§’è‰²è´­ä¹°è¿™ä»¶å•†å“çš„å†…å¿ƒç‹¬ç™½æˆ–ç†ç”±ï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
          "image_prompt": "ä¸€æ®µç”¨äºç”Ÿæˆè¿™å¼ å•†å“å›¾ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£æ ¼ä¸º realistic product photo, high quality, on a clean white background"
        }
      ]
    }
    \`\`\`
    - **purchases**: ä¸€ä¸ªåŒ…å«12åˆ°15ä¸ªå•†å“å¯¹è±¡çš„æ•°ç»„ã€‚
    - **status (è®¢å•çŠ¶æ€)**: åªèƒ½ä» "å·²ç­¾æ”¶", "å¾…å‘è´§", "è¿è¾“ä¸­", "å¾…è¯„ä»·" ä¸­é€‰æ‹©ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·ç”ŸæˆåŒ…å«æ€»ä½™é¢å’Œè´­ä¹°è®°å½•çš„JSONå¯¹è±¡ã€‚`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ·˜å®è´­ä¹°è®°å½•å’Œä½™é¢ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONå¯¹è±¡ã€‚");
      const simulatedTaobaoData = JSON.parse(jsonMatch[0]);


      if (!simulatedTaobaoData.purchases) {
        simulatedTaobaoData.purchases = [];
      }

      chat.simulatedTaobaoHistory = simulatedTaobaoData;
      await db.chats.put(chat);

      await renderCharTaobao();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ·˜å®è®°å½•å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè´­ç‰©è®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }


 
  function openCharWallet() {
    renderCharWallet();
    switchToCharScreen('char-wallet-screen');
  }


  async function renderCharWallet() {
    const contentEl = document.getElementById('char-wallet-content');
    contentEl.innerHTML = '';
    
    // è·å–å½“å‰è§’è‰²ä¿¡æ¯
    const char = state.chats[activeCharacterId];
    const history = char.simulatedTaobaoHistory || {};
    const purchases = history.purchases || [];
    const totalBalance = history.totalBalance || 0;

    // 1. æ˜¾ç¤ºè´¦æˆ·ä½™é¢å¡ç‰‡
    const summaryCard = document.createElement('div');
    summaryCard.style.cssText = `
        background-color: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    `;
    summaryCard.innerHTML = `
        <p style="color: #8a8a8a; margin: 0 0 10px 0;">è´¦æˆ·ä½™é¢</p>
        <p style="font-size: 32px; font-weight: 600; color: #1f1f1f; margin: 0;">Â¥${totalBalance.toFixed(2)}</p>
    `;
    contentEl.appendChild(summaryCard);

    // 2. æ˜¾ç¤ºäº²å±å¡ (ä¿®å¤åå­— + å¢åŠ è§£ç»‘)
    try {
        const myWallet = await db.userWallet.get('main');
        const kinshipCard = myWallet?.kinshipCards?.find(c => c.chatId === activeCharacterId);

        if (kinshipCard) {
            // ã€ä¿®å¤åå­—é€»è¾‘ã€‘ä¼˜å…ˆä½¿ç”¨èŠå¤©è®¾ç½®é‡Œçš„æ˜µç§°ï¼Œå…¶æ¬¡æ˜¯åŠ¨æ€æ˜µç§°ï¼Œæœ€åæ˜¯â€œæˆ‘â€
            const myNicknameInChat = char.settings.myNickname || state.qzoneSettings.nickname || 'æˆ‘';

            const cardDiv = document.createElement('div');
            // æ ·å¼ï¼šçº¢è‰²èƒŒæ™¯å¡ç‰‡ï¼Œå¢åŠ  relative å®šä½ä»¥ä¾¿æ”¾ç½®è§£ç»‘æŒ‰é’®
            cardDiv.style.cssText = `
                background: linear-gradient(135deg, #ff5252, #ff1744); 
                color: white; 
                padding: 15px; 
                border-radius: 12px; 
                margin-bottom: 20px; 
                box-shadow: 0 4px 10px rgba(255,82,82,0.3); 
                display: flex; 
                flex-direction: column; 
                gap: 5px;
                position: relative; 
            `;
            
            const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
            
            cardDiv.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:14px; opacity:0.9; font-weight:500;">${myNicknameInChat} èµ é€çš„äº²å±å¡</div>
                    <div style="font-size:12px; opacity:0.8;">æ”¯ä»˜å®</div>
                </div>
                <div style="font-size:28px; font-weight:bold; margin:10px 0; font-family: 'DIN Alternate', sans-serif;">Â¥ ${remaining.toFixed(2)}</div>
                <div style="font-size:12px; opacity:0.8; display:flex; justify-content:space-between;">
                    <span>æœ¬æœˆå¯ç”¨é¢åº¦</span>
                    <span>æ€»é¢ Â¥${kinshipCard.limit}</span>
                </div>
                
                <!-- è§£ç»‘æŒ‰é’® -->
                <button class="unbind-kinship-btn" data-chat-id="${activeCharacterId}" style="
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.4);
                    color: white;
                    font-size: 11px;
                    padding: 2px 8px;
                    border-radius: 10px;
                    cursor: pointer;
                    backdrop-filter: blur(2px);
                ">è§£ç»‘</button>
            `;
            contentEl.appendChild(cardDiv);
        }
    } catch (e) {
        console.error("æ¸²æŸ“äº²å±å¡å¤±è´¥:", e);
    }

    // 3. æ˜¾ç¤ºæœ€è¿‘æ”¯å‡º
    const detailsTitle = document.createElement('h3');
    detailsTitle.textContent = 'æœ€è¿‘æ”¯å‡º';
    detailsTitle.style.cssText = `font-size: 16px; color: #555; margin-bottom: 10px;`;
    contentEl.appendChild(detailsTitle);

    if (purchases.length === 0) {
      contentEl.innerHTML += '<p style="text-align:center; color: var(--text-secondary);">æš‚æ— æ”¯å‡ºè®°å½•ã€‚</p>';
    } else {
        purchases.forEach(item => {
          const itemEl = document.createElement('div');
          itemEl.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px 0;
                border-bottom: 1px solid #f0f0f0;
            `;
          itemEl.innerHTML = `
                <div>
                    <p style="font-weight: 500; margin: 0 0 4px 0;">${item.itemName}</p>
                    <p style="font-size: 12px; color: #8a8a8a; margin: 0;">${item.status}</p>
                </div>
                <div style="font-weight: 600; font-size: 16px; color: #ff5722;">- Â¥${(item.price || 0).toFixed(2)}</div>
            `;
          contentEl.appendChild(itemEl);
        });
    }
}




 
  async function handleGenerateSimulatedMemos() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€åˆ†äº«TAçš„å¤‡å¿˜å½•...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºã€12åˆ°20æ¡ã€‘TAæœ€è¿‘å¯èƒ½ä¼šå†™åœ¨æ‰‹æœºå¤‡å¿˜å½•é‡Œçš„å†…å®¹ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: å¤‡å¿˜å½•å†…å®¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»ç¯å¢ƒã€‚å¯ä»¥æ˜¯è´­ç‰©æ¸…å•ã€å¾…åŠäº‹é¡¹ã€çµæ„Ÿç‰‡æ®µã€ä¸€äº›éšç¬”å’Œæ„Ÿæ‚Ÿã€è‰ç¨¿ç­‰ã€‚
2.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€æ¡å¤‡å¿˜å½•ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "title": "å¤‡å¿˜å½•çš„æ ‡é¢˜ï¼Œä¾‹å¦‚ï¼šè´­ç‰©æ¸…å• æˆ– å‘¨æœ«è®¡åˆ’",
        "content": "å¤‡å¿˜å½•çš„è¯¦ç»†å†…å®¹ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nã€‚"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- ** ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾**:${userPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„å¤‡å¿˜å½•ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„å¤‡å¿˜å½•å†…å®¹ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          
          })
        });


      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        const errorMessage = errorData?.error?.message || response.statusText;
        throw new Error(`API é”™è¯¯: ${response.status} - ${errorMessage}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedMemos;
      try {
        simulatedMemos = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      if (!Array.isArray(simulatedMemos)) {
        throw new Error(`AIè¿”å›çš„æ•°æ®ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚åŸå§‹è¿”å›: ${JSON.stringify(simulatedMemos)}`);
      }

      chat.memos = simulatedMemos.map(memo => ({
        id: Date.now() + Math.random(),
        title: memo.title,
        content: memo.content
      }));

      await db.chats.put(chat);
      await renderCharMemoList();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿå¤‡å¿˜å½•å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå¤‡å¿˜å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

 
  async function handleGenerateAmapHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨ç”Ÿæˆâ€œ${chat.name}â€çš„å‡ºè¡Œè¶³è¿¹...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºã€12åˆ°20æ¡ã€‘TAæœ€è¿‘çš„â€œé«˜å¾·åœ°å›¾â€å‡ºè¡Œè¶³è¿¹ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**:
    -   ä»Šå¤©çš„æ—¥æœŸæ˜¯ **${new Date().toISOString()}**ã€‚
    -   ä½ ç”Ÿæˆçš„ã€æ‰€æœ‰ã€‘è¶³è¿¹çš„ \`timestamp\` å­—æ®µï¼Œã€å¿…é¡»ã€‘æ˜¯ä»Šå¤©æˆ–ä»Šå¤©ä»¥å‰çš„æ—¥æœŸã€‚
    -   ã€ç»å¯¹ç¦æ­¢ã€‘ç”Ÿæˆä»»ä½•æœªæ¥çš„æ—¥æœŸï¼
    -   è¯·ç”Ÿæˆä¸€ä¸ªçœ‹èµ·æ¥åƒæ˜¯è¿‡å»å‡ å‘¨å†…çš„ã€æ—¶é—´ã€ä»æ–°åˆ°æ—§ã€‘æ’åˆ—çš„è¶³è¿¹åˆ—è¡¨ã€‚
2.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: è¶³è¿¹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»ç¯å¢ƒã€‚
3.  **å¤šæ ·æ€§**: åœ°ç‚¹ç±»å‹è¦ä¸°å¯Œï¼Œå¯ä»¥åŒ…æ‹¬é¤å…ã€å•†åœºã€å…¬å›­ã€å…¬å¸ã€æœ‹å‹å®¶ç­‰ã€‚
4.  **ã€æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€æ¡è¶³è¿¹ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "locationName": "ä¸€ä¸ªå…·ä½“ã€ç”ŸåŠ¨çš„åœ°ç‚¹åç§°",
        "address": "ä¸€ä¸ªè™šæ„ä½†çœ‹èµ·æ¥å¾ˆçœŸå®çš„è¯¦ç»†åœ°å€",
        "comment": "è¿™æ˜¯è§’è‰²å¯¹è¿™æ¬¡å‡ºè¡Œæˆ–è¿™ä¸ªåœ°ç‚¹çš„å†…å¿ƒç‹¬ç™½æˆ–è¯„è®ºï¼Œå¿…é¡»ä½¿ç”¨ç¬¬ä¸€äººç§°â€œæˆ‘â€æ¥å†™ã€‚",
        "image_prompt": "(å¯é€‰)ä¸€æ®µç”¨äºç”Ÿæˆè¿™å¼ åœ°ç‚¹ç…§ç‰‡çš„ã€è¯¦ç»†çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£æ ¼ä¸º realistic photo, high quality",
        "timestamp": "ç¬¦åˆ ISO 8601 æ ¼å¼çš„æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸² (ä¾‹å¦‚: '2025-09-25T18:30:00Z')"
      }
    ]
    \`\`\`
    - **é‡è¦**: å¤§çº¦æœ‰ã€ä¸‰åˆ†ä¹‹ä¸€ã€‘çš„è¶³è¿¹éœ€è¦åŒ…å« \`image_prompt\` å­—æ®µæ¥ç”Ÿæˆä¸€å¼ ç…§ç‰‡ã€‚
    - **å›¾ç‰‡**: image_prompt ç”Ÿæˆçš„å›¾ç‰‡ã€ç»å¯¹ç¦æ­¢åŒ…å«çœŸäººã€‘ã€‚å¦‚æœåœ°ç‚¹æ˜¯å®¤å†…ï¼Œå¯ä»¥ç”Ÿæˆç©ºæ— ä¸€äººçš„åœºæ™¯ï¼›å¦‚æœæ˜¯å®¤å¤–ï¼Œå¯ä»¥åªæœ‰é£æ™¯æˆ–å»ºç­‘ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„è¶³è¿¹è®°å½•ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„é«˜å¾·åœ°å›¾è¶³è¿¹ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
           
          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedAmapData;
      try {
        simulatedAmapData = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


      chat.simulatedAmapHistory = simulatedAmapData;
      await db.chats.put(chat);

      await renderCharAmap();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿè¶³è¿¹å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè¶³è¿¹ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }


  function renderCharAmap() {
    const listEl = document.getElementById('char-amap-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedAmapHistory || [];

    if (history.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰ç•™ä¸‹ä»»ä½•è¶³è¿¹ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
      return;
    }


    history.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-amap-item';

      let photoHtml = '';
      if (item.image_prompt) {
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
        photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${item.comment}"></div>`;
      }

      // ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„ formatTimeAgo å‡½æ•°æ¥æ ¼å¼åŒ–æ—¶é—´
      const timeAgo = item.timestamp ? formatTimeAgo(new Date(item.timestamp).getTime()) : 'æŸä¸ªæ—¶é—´';

      itemEl.innerHTML = `
                    <div class="amap-item-header">
                        <div class="amap-item-icon">ğŸ“</div>
                        <div class="amap-item-info">
                            <div class="amap-item-title">${item.locationName}</div>
                            <div class="amap-item-address">${item.address}</div>
                        </div>
                    </div>
                    <div class="amap-item-body">
                        <div class="amap-item-comment">${item.comment.replace(/\n/g, '<br>')}</div>
                        ${photoHtml}
                    </div>
                    <div class="amap-item-footer">${timeAgo}</div>
                `;
      listEl.appendChild(itemEl);
    });

  }


 
  async function handleGenerateAppUsage() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨åˆ†æâ€œ${chat.name}â€çš„æ‰‹æœºä½¿ç”¨ä¹ æƒ¯...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# æ™ºèƒ½æ€»ç»“ (åŸºäºä¸åŒæ—¶é—´ç»´åº¦çš„å¯¹è¯å›é¡¾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”Ÿæ´»æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼Œè™šæ„å‡ºTAæœ€è¿‘ä¸€å¤©çš„ã€æ‰‹æœºAppå±å¹•ä½¿ç”¨æ—¶é—´ã€‘è®°å½•ï¼Œæ€»å…±çº¦20æ¡ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸å¤šæ ·æ€§**: ç”Ÿæˆçš„Appåˆ—è¡¨ã€ä¸å¿…å±€é™äºã€‘Cphoneä¸»å±å¹•ä¸Šå·²æœ‰çš„Appã€‚ä½ å¯ä»¥è‡ªç”±åœ°è™šæ„TAå¯èƒ½ä½¿ç”¨çš„å…¶ä»–Appï¼Œä¾‹å¦‚ Instagram, Twitter, å„ç§æ¸¸æˆ (å¦‚ï¼šåŸç¥, ç‹è€…è£è€€), è§†é¢‘App (å¦‚ï¼šæŠ–éŸ³, YouTube), å­¦ä¹ æˆ–å·¥ä½œè½¯ä»¶ç­‰ï¼Œè¿™èƒ½æ›´å¥½åœ°ä½“ç°è§’è‰²çš„éšè—å…´è¶£å’Œç”Ÿæ´»ä¹ æƒ¯ã€‚
2.  **åˆç†æ€§**: ä½¿ç”¨æ—¶é•¿å’ŒAppç±»å‹å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½ã€èŒä¸šå’Œç”Ÿæ´»ç¯å¢ƒã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€ä¸ªAppçš„ä½¿ç”¨è®°å½•ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "appName": "Appçš„åç§° (ä¾‹å¦‚: å¾®ä¿¡, å¾®åš, åŸç¥)",
        "usageTimeMinutes": 125,
        "category": "Appçš„åˆ†ç±» (ä¾‹å¦‚: ç¤¾äº¤, æ¸¸æˆ, å½±éŸ³, å·¥å…·, é˜…è¯», è´­ç‰©)",
        "image_prompt": "ä¸€æ®µç”¨äºç”Ÿæˆè¿™ä¸ªAppã€å›¾æ ‡ã€‘çš„ã€ç®€æ´çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚é£æ ¼å¿…é¡»æ˜¯ modern app icon, flat design, simple, clean background"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·å¼€å§‹ç”Ÿæˆè¿™ç»„Appä½¿ç”¨è®°å½•ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„Appä½¿ç”¨è®°å½•ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
            // response_format: { "type": "json_object" } <-- æ­¤è¡Œå·²è¢«åˆ é™¤
          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');

      const simulatedUsageData = JSON.parse(cleanedJson);

      chat.simulatedAppUsage = simulatedUsageData;
      await db.chats.put(chat);

      await renderCharAppUsage();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹ŸAppä½¿ç”¨è®°å½•å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆè®°å½•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

  function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const usageData = (char.simulatedAppUsage || []).sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);

    if (usageData.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œè¿˜æ²¡æœ‰ä»»ä½•ä½¿ç”¨è®°å½•ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›å§ï¼</p>';
      return;
    }

    usageData.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-usage-item';

      const hours = Math.floor(item.usageTimeMinutes / 60);
      const minutes = item.usageTimeMinutes % 60;
      let timeString = '';
      if (hours > 0) timeString += `${hours}å°æ—¶`;
      if (minutes > 0) timeString += `${minutes}åˆ†é’Ÿ`;
      if (!timeString) timeString = 'å°äº1åˆ†é’Ÿ';

      const prompt = item.image_prompt || `modern app icon for ${item.appName}, flat design, simple`;

      const iconUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}`;


      itemEl.innerHTML = `
                    <img src="${iconUrl}" class="usage-item-icon">
                    <div class="usage-item-info">
                        <div class="usage-item-name">${item.appName}</div>
                        <div class="usage-item-category">${item.category}</div>
                    </div>
                    <div class="usage-item-time">${timeString}</div>
                `;
      listEl.appendChild(itemEl);
    });
  }


async function handleGenerateSimulatedBilibili() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨ç»“åˆä¸–ç•Œè§‚ä¸äººè®¾ï¼Œåˆ†æâ€œ${chat.name}â€çš„Bç«™å…´è¶£...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    // 1. å‡†å¤‡ä¸Šä¸‹æ–‡
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    
    // 2. å‡†å¤‡è®°å¿†å’Œä¸–ç•Œè§‚
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    
    // 3. å‡†å¤‡ä¸–ç•Œä¹¦
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : 'æ— ';

    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
 
    const userPersona = chat.settings.myPersona || '(æœªè®¾ç½®)';
 
    // 4. æ„å»º Promptï¼šæ ¸å¿ƒæ”¹å˜æ˜¯è®© AI ç”Ÿæˆå…³é”®è¯ï¼Œè€Œä¸æ˜¯å‡æ•°æ®
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”¨æˆ·ç”»åƒåˆ†æå¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œæ ¹æ®TAçš„äººè®¾ã€æ‰€å¤„çš„ä¸–ç•Œè§‚ã€é•¿æœŸè®°å¿†ã€ä»¥åŠä¸ç”¨æˆ·ï¼ˆ${userDisplayNameForAI}ï¼‰çš„å…³ç³»ï¼Œ**æ¨æµ‹TAç°åœ¨æœ€æƒ³åœ¨ Bilibili (Bç«™) ä¸Šæœç´¢æˆ–è§‚çœ‹çš„è§†é¢‘å…³é”®è¯**ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **æ·±åº¦äººè®¾ç»‘å®š**: å…³é”®è¯å¿…é¡»ç´§æ‰£è§’è‰²çš„æ€§æ ¼ã€èŒä¸šã€çˆ±å¥½ä»¥åŠ**ä¸–ç•Œè§‚è®¾å®š**ã€‚
    - ä¾‹å¦‚ï¼šå¦‚æœä¸–ç•Œä¹¦é‡Œè®¾å®šäº†â€œé­”æ³•â€ï¼Œè§’è‰²å¯èƒ½ä¼šæœâ€œç«çƒæœ¯æ•™å­¦â€ï¼›å¦‚æœæ˜¯â€œæœ«ä¸–â€ï¼Œå¯èƒ½ä¼šæœâ€œç”Ÿå­˜æŒ‡å—â€ã€‚
2.  **å…³ç³»å¯¼å‘**: å¦‚æœç”¨æˆ·äººè®¾æ˜¯ä½ å–œæ¬¢çš„äººï¼Œä½ å¯èƒ½ä¼šæœâ€œç»™å–œæ¬¢çš„äººé€ä»€ä¹ˆç¤¼ç‰©â€ï¼›å¦‚æœæ˜¯æ­»å¯¹å¤´ï¼Œå¯èƒ½ä¼šæœâ€œå¦‚ä½•ä¼˜é›…åœ°æ€¼äººâ€ã€‚å¿…é¡»é€»è¾‘è‡ªæ´½ã€‚
3.  **å¤šæ ·æ€§**: è¯·ç”Ÿæˆ **10åˆ°12ä¸ª** å…·ä½“çš„æœç´¢å…³é”®è¯ã€‚
4.  **å…·ä½“æ€§**: å…³é”®è¯æœ€å¥½å…·ä½“ä¸€ç‚¹ã€‚
5.  **æ ¼å¼é“å¾‹**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª**å­—ç¬¦ä¸²** (å³æœç´¢å…³é”®è¯)ã€‚
    - ç¤ºä¾‹: \`["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"...]\`

# ä¾›ä½ å‚è€ƒçš„è¯¦ç»†ä¸Šä¸‹æ–‡
- **è§’è‰²äººè®¾**: ${chat.settings.aiPersona}
- **ç”¨æˆ·(${userDisplayNameForAI})çš„äººè®¾**: ${userPersona} 
- **é•¿æœŸè®°å¿†**: 
${longTermMemoryContext}
${worldBookContext} 
- **æœ€è¿‘å¯¹è¯**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·ç»“åˆä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œç”Ÿæˆè¿™ç»„æœç´¢å…³é”®è¯ã€‚`;

    try {
        const messagesForApi = [{ role: 'user', content: "è¯·ç”ŸæˆBç«™æœç´¢å…³é”®è¯åˆ—è¡¨ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const keywords = JSON.parse(cleanedJson);

        if (!Array.isArray(keywords)) throw new Error("AIæ²¡æœ‰è¿”å›æ•°ç»„æ ¼å¼çš„å…³é”®è¯ã€‚");

        await showCustomAlert("è¯·ç¨å€™...", `AIå·²ç»“åˆä¸–ç•Œè§‚ç”Ÿæˆ ${keywords.length} ä¸ªå…³é”®è¯ï¼Œæ­£åœ¨é€ä¸ªæœç´¢Bç«™è§†é¢‘ (ä¸ºé˜²å°ç¦ï¼Œé€Ÿåº¦ä¼šç¨æ…¢)...`);

        // å®šä¹‰å»¶æ—¶å‡½æ•°ï¼Œé˜²æ­¢è¯·æ±‚å¤ªå¿«è¢«Bç«™æ¥å£å°IP
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        const results = [];
        
        // 5. éå†å…³é”®è¯ï¼Œè°ƒç”¨çœŸå®çš„æœç´¢æ¥å£
        for (const [index, keyword] of keywords.entries()) {
            let retryCount = 0; // å½“å‰å…³é”®è¯çš„é‡è¯•æ¬¡æ•°
            let success = false; // æ˜¯å¦æˆåŠŸæ ‡è®°
            const maxRetries = 5; // æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé˜²æ­¢æ­»å¾ªç¯

            // ä½¿ç”¨ while å¾ªç¯ï¼Œç›´åˆ°æˆåŠŸæˆ–è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°
            while (!success && retryCount < maxRetries) {
                try {
                    // å¦‚æœæ˜¯é‡è¯•ï¼Œæ‰“å°æ—¥å¿—æç¤º
                    const retryMsg = retryCount > 0 ? ` (ç¬¬ ${retryCount} æ¬¡é‡è¯•)` : "";
                    console.log(`[Bç«™æœç´¢ ${index + 1}/${keywords.length}] æ­£åœ¨æœç´¢: ${keyword}${retryMsg}`);
                    
                    // ä½¿ç”¨ä½ è„šæœ¬é‡ŒåŸæœ¬ä½¿ç”¨çš„æ¥å£ï¼Œç»è¿‡CORSä»£ç†
                    const targetUrl = `https://api.52vmy.cn/api/query/bilibili/video?msg=${encodeURIComponent(keyword)}&n=1`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    const res = await fetch(proxyUrl);
                    
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const text = await res.text();
                    
                    // --- ä¿®æ”¹é‡ç‚¹å¼€å§‹ï¼šæ£€æµ‹é™æµå¹¶é‡è¯• ---
                    if (text.includes("è®¿é—®è¿‡å¿«") || text.includes("é¢‘ç¹") || text.includes("Too Many Requests")) {
                         console.warn(`âš ï¸ å…³é”®è¯ "${keyword}" è§¦å‘é™æµï¼Œç­‰å¾…å†·å´åé‡è¯•...`);
                         
                         // åŠ¨æ€ç­‰å¾…æ—¶é—´ï¼šåŸºç¡€ç­‰å¾… 5ç§’ + æ¯æ¬¡é‡è¯•å¢åŠ  2ç§’ (5s, 7s, 9s...)
                         await delay(5000 + (retryCount * 2000)); 
                         
                         retryCount++; // å¢åŠ é‡è¯•è®¡æ•°
                         continue; // è·³è¿‡æœ¬æ¬¡ while å¾ªç¯çš„å‰©ä½™éƒ¨åˆ†ï¼Œé‡æ–°å‘èµ·è¯·æ±‚
                    }
                    // --- ä¿®æ”¹é‡ç‚¹ç»“æŸ ---

                    let json;
                    try { 
                        json = JSON.parse(text); 
                    } catch(e) { 
                        // å¦‚æœJSONè§£æå¤±è´¥ï¼ˆå¯èƒ½æ˜¯æ¥å£æŠ¥é”™è¿”å›äº†HTMLï¼‰ï¼Œä¹Ÿè§†ä¸ºå¤±è´¥è¿›è¡Œé‡è¯•
                        console.warn(`JSONè§£æå¤±è´¥ï¼Œå‡†å¤‡é‡è¯•: ${keyword}`);
                        retryCount++;
                        await delay(3000);
                        continue; 
                    }
                    
                    // æ¥å£è¿”å›æ ¼å¼å…¼å®¹å¤„ç†
                    let videoData = null;
                    if (json.data && Array.isArray(json.data) && json.data.length > 0) {
                        videoData = json.data[0]; 
                    } else if (json.code === 200 && json.data) {
                        videoData = Array.isArray(json.data) ? json.data[0] : json.data;
                    } else if (json.title) {
                         videoData = json;
                    }

                    if (videoData && videoData.title && videoData.url) {
                        results.push(videoData);
                    }
                    
                    // å¦‚æœä»£ç è·‘åˆ°è¿™é‡Œï¼Œè¯´æ˜æ²¡æœ‰è§¦å‘é™æµä¸”æ²¡æœ‰æŠ¥é”™ï¼Œæ ‡è®°æˆåŠŸä»¥é€€å‡º while å¾ªç¯
                    success = true; 

                } catch (e) {
                    console.warn(`æœç´¢å…³é”®è¯ "${keyword}" å‘ç”Ÿé”™è¯¯:`, e);
                    // ç½‘ç»œé”™è¯¯ä¹Ÿè¿›è¡Œé‡è¯•
                    retryCount++;
                    await delay(3000);
                }
            }

            // å¦‚æœè¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ä»ç„¶å¤±è´¥
            if (!success) {
                console.error(`âŒ å…³é”®è¯ "${keyword}" é‡è¯• ${maxRetries} æ¬¡åä»ç„¶å¤±è´¥ï¼Œå·²è·³è¿‡ã€‚`);
            }

            // å…³é”®è¯ä¹‹é—´çš„æ­£å¸¸é—´éš” (å»ºè®®ç¨å¾®è°ƒå¤§ä¸€ç‚¹ï¼Œæ¯”å¦‚ 2000msï¼Œä»¥å‡å°‘è§¦å‘é™æµçš„æ¦‚ç‡)
            await delay(1500); 
        }

        // 6. ä¿å­˜çœŸå®æ•°æ®
        chat.simulatedBilibiliFeed = results;
        await db.chats.put(chat);

        // 7. æ¸²æŸ“ç•Œé¢
        renderCharBilibiliScreen();
        await showCustomAlert("å®Œæˆ", `æˆåŠŸä¸ºä½ ç”Ÿæˆäº† ${results.length} ä¸ªç¬¦åˆ ${chat.name} äººè®¾ä¸ä¸–ç•Œè§‚çš„è§†é¢‘æ¨èï¼`);

    } catch (error) {
        console.error("ç”ŸæˆBç«™æ¨èå¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨èå†…å®¹ã€‚\né”™è¯¯: ${error.message}`);
    }
}
function renderCharBilibiliScreen() {
    const listEl = document.getElementById('char-bilibili-list');
    listEl.innerHTML = '';
    
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    
    // è¯»å–ä¿å­˜çš„æ¨¡æ‹Ÿæ•°æ®
    const videos = chat.simulatedBilibiliFeed || [];

    if (videos.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">é¦–é¡µç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®è·å–ä¸ªæ€§åŒ–æ¨èå§ï¼</p>';
        return;
    }

    videos.forEach(video => {
        const item = document.createElement('div');
        item.className = 'bilibili-item';
        
        // å¤„ç†å°é¢å›¾å’Œä¿¡æ¯
        // ä½¿ç”¨ img æ ‡ç­¾é…åˆ no-referrer æ¥ç»•è¿‡ Safari çš„é˜²ç›—é“¾æ£€æŸ¥
        item.innerHTML = `
            <div class="bili-cover" style="position: relative; overflow: hidden;">
                <img src="${video.img_url || video.pic}" referrerpolicy="no-referrer" style="width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; z-index: 1;" onerror="this.style.display='none'">
                <div class="bili-duration" style="position: absolute; z-index: 2;">â–¶</div>
            </div>
            <div class="bili-info">
                <div class="bili-title">${video.title}</div>
                <div class="bili-author">UP: ${video.user || video.author || 'æœªçŸ¥UPä¸»'}</div>
            </div>
        `;
        
        // ç‚¹å‡»æ’­æ”¾
        item.onclick = () => playCharBilibiliVideo(video);
        listEl.appendChild(item);
    });
}
  async function handleGenerateSimulatedMusic() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨è¯·æ±‚â€œ${chat.name}â€åˆ†äº«TAçš„ç§äººæ­Œå•...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');


    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹ŸéŸ³ä¹å“å‘³æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œå¹¶æ ¹æ®å…¶äººè®¾ã€è®°å¿†å’Œæœ€è¿‘çš„äº’åŠ¨ï¼ŒæŒ‘é€‰å‡ºã€14åˆ°18é¦–ã€‘æœ€èƒ½ä»£è¡¨TAæ­¤åˆ»å¿ƒæƒ…æˆ–å“å‘³çš„æ­Œæ›²ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: æ­Œå•å¿…é¡»å®Œå…¨ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€çˆ±å¥½å’Œç”Ÿæ´»èƒŒæ™¯ã€‚
2.  **å¤šæ ·æ€§**: æ­Œæ›²é£æ ¼å¯ä»¥å¤šæ ·ï¼Œä½†å¿…é¡»é€»è¾‘è‡ªæ´½ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä»£è¡¨ä¸€é¦–æ­Œï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "songName": "æ­Œæ›²çš„å‡†ç¡®åç§°",
        "artistName": "æ­Œæ›²çš„å‡†ç¡®è‰ºæœ¯å®¶/æ­Œæ‰‹å"
      }
    ]
    \`\`\`

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ çš„é•¿æœŸè®°å¿†**:
${longTermMemoryContext}
${worldBookContext}
- **ä½ æœ€è¿‘å’Œâ€œ${userDisplayNameForAI}â€çš„å¯¹è¯æ‘˜è¦**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·ç”Ÿæˆè¿™ä»½æ­Œå•ã€‚`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä½ çš„è®¾å®šï¼Œç”Ÿæˆä½ çš„æ­Œå•ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });


      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const songPicks = JSON.parse(cleanedJson);

      await showCustomAlert("è¯·ç¨å€™...", `æ­Œå•å·²ç”Ÿæˆï¼Œæ­£åœ¨ä»ç½‘ç»œè·å– ${songPicks.length} é¦–æ­Œæ›²çš„è¯¦ç»†ä¿¡æ¯...`);

      const songDetailPromises = songPicks.map(async (pick) => {
        let searchResults = await searchNeteaseMusic(pick.songName, pick.artistName);
        if (!searchResults || searchResults.length === 0) {
          searchResults = await searchTencentMusic(pick.songName);
        }
        if (searchResults.length > 0) {
          return getPlayableSongDetails(searchResults[0]);
        }
        console.warn(`æ‰€æœ‰éŸ³ä¹æºéƒ½æœªèƒ½æ‰¾åˆ°æ­Œæ›²ï¼šâ€œ${pick.songName} - ${pick.artistName}â€`);
        return null;
      });

      const fullSongObjects = (await Promise.all(songDetailPromises)).filter(Boolean);

      chat.simulatedMusicPlaylist = fullSongObjects;
      await db.chats.put(chat);

      await renderCharMusicScreen();

    } catch (error) {
      console.error("ç”Ÿæˆæ¨¡æ‹Ÿæ­Œå•å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ­Œå•ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }

 
// ==========================================
// MY Phone ç”Ÿæˆå¤„ç†å‡½æ•°
// ==========================================

async function handleGenerateMyPhoneQQ() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  // è·å–ä¸è¯¥è§’è‰²çš„å¯¹è¯å†å²ï¼Œäº†è§£ç”¨æˆ·ç‰¹å¾
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„æ€§æ ¼ã€å…´è¶£å’Œç¤¾äº¤åœˆï¼Œç„¶åç”Ÿæˆæˆ‘çš„QQèŠå¤©è®°å½•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆ3-5ä¸ªæˆ‘å¯èƒ½ä¼šèŠå¤©çš„è”ç³»äººåŠå…¶å¯¹è¯å†…å®¹ã€‚è¿™äº›å¯¹è¯åº”è¯¥åæ˜ å‡ºæˆ‘çš„æ€§æ ¼ã€å…´è¶£å’Œç”Ÿæ´»çŠ¶æ€ã€‚

è¯·è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "name": "è”ç³»äººåå­—",
    "avatar": "",
    "lastMessage": "æœ€åä¸€æ¡æ¶ˆæ¯é¢„è§ˆ",
    "messages": [
      {"role": "user", "content": "æˆ‘å‘é€çš„æ¶ˆæ¯", "timestamp": "2024-01-01T12:00:00Z"},
      {"role": "assistant", "content": "å¯¹æ–¹çš„å›å¤", "timestamp": "2024-01-01T12:01:00Z"}
    ]
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const conversations = JSON.parse(cleanedJson);

    chat.myPhoneSimulatedQQConversations = conversations;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phone QQå¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneAlbum() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„ç”Ÿæ´»ã€å…´è¶£å’Œå®¡ç¾ï¼Œç„¶åç”Ÿæˆæˆ‘ç›¸å†Œä¸­çš„ç…§ç‰‡ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åæè¿°æˆ‘ç›¸å†Œä¸­çš„5-8å¼ ç…§ç‰‡ã€‚è¿™äº›ç…§ç‰‡åº”è¯¥åæ˜ å‡ºæˆ‘çš„ç”Ÿæ´»çŠ¶æ€ã€å…´è¶£çˆ±å¥½å’Œå®¡ç¾åå¥½ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "description": "ç…§ç‰‡çš„ä¸­æ–‡æè¿°ï¼ˆä»æˆ‘çš„è§†è§’æè¿°ï¼‰",
    "image_prompt": "è‹±æ–‡å›¾åƒç”Ÿæˆæç¤ºè¯"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const photos = JSON.parse(cleanedJson);

    chat.myPhoneAlbum = photos;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneç›¸å†Œå¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneBrowserHistory() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„å…´è¶£å’Œå…³æ³¨ç‚¹ï¼Œç„¶åç”Ÿæˆæˆ‘çš„æµè§ˆå™¨å†å²è®°å½•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘æœ€è¿‘çš„5-8æ¡æµè§ˆå™¨å†å²è®°å½•ã€‚è¿™äº›è®°å½•åº”è¯¥åæ˜ å‡ºæˆ‘çš„å…´è¶£çˆ±å¥½ã€å…³æ³¨çš„è¯é¢˜å’Œä¿¡æ¯éœ€æ±‚ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "ç½‘é¡µæ ‡é¢˜",
    "url": "ç½‘å€",
    "content": "ç½‘é¡µå†…å®¹æ‘˜è¦ï¼ˆ100-200å­—ï¼‰"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const history = JSON.parse(cleanedJson);

    chat.myPhoneBrowserHistory = history;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneæµè§ˆè®°å½•å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneTaobao() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„ç”Ÿæ´»éœ€æ±‚å’Œæ¶ˆè´¹ä¹ æƒ¯ï¼Œç„¶åç”Ÿæˆæˆ‘çš„æ·˜å®è´­ç‰©è®°å½•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘æœ€è¿‘çš„5-8æ¡æ·˜å®è´­ç‰©è®°å½•ã€‚è¿™äº›è®°å½•åº”è¯¥åæ˜ å‡ºæˆ‘çš„ç”Ÿæ´»çŠ¶æ€ã€éœ€æ±‚å’Œæ¶ˆè´¹åå¥½ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "name": "å•†å“åç§°",
    "price": "ä»·æ ¼ï¼ˆæ•°å­—ï¼‰",
    "date": "è´­ä¹°æ—¥æœŸ"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const items = JSON.parse(cleanedJson);

    chat.myPhoneTaobaoHistory = items;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneæ·˜å®è®°å½•å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneMemos() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„ç”Ÿæ´»çŠ¶æ€å’Œå¾…åŠäº‹é¡¹ï¼Œç„¶åç”Ÿæˆæˆ‘çš„å¤‡å¿˜å½•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘çš„3-5æ¡å¤‡å¿˜å½•ã€‚è¿™äº›å¤‡å¿˜å½•åº”è¯¥åæ˜ å‡ºæˆ‘çš„ç”Ÿæ´»å®‰æ’ã€å¾…åŠäº‹é¡¹å’Œå…³æ³¨ç‚¹ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "å¤‡å¿˜å½•æ ‡é¢˜",
    "content": "å¤‡å¿˜å½•å†…å®¹",
    "date": "æ—¥æœŸ"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const memos = JSON.parse(cleanedJson);

    chat.myPhoneMemos = memos;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneå¤‡å¿˜å½•å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneDiaries() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„å†…å¿ƒä¸–ç•Œå’Œç”Ÿæ´»æ„Ÿå—ï¼Œç„¶åç”Ÿæˆæˆ‘çš„æ—¥è®°ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘çš„3-5ç¯‡æ—¥è®°ã€‚è¿™äº›æ—¥è®°åº”è¯¥åæ˜ å‡ºæˆ‘çš„æƒ…æ„ŸçŠ¶æ€ã€ç”Ÿæ´»æ„Ÿæ‚Ÿå’Œå†…å¿ƒæƒ³æ³•ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "æ—¥è®°æ ‡é¢˜",
    "content": "æ—¥è®°å†…å®¹ï¼ˆ100-200å­—ï¼Œç¬¬ä¸€äººç§°ï¼‰",
    "date": "æ—¥æœŸ"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const diaries = JSON.parse(cleanedJson);

    chat.myPhoneDiaries = diaries;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneæ—¥è®°å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneAmap() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„æ´»åŠ¨èŒƒå›´å’Œç”Ÿæ´»è½¨è¿¹ï¼Œç„¶åç”Ÿæˆæˆ‘çš„è¶³è¿¹è®°å½•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘æœ€è¿‘çš„5-8æ¡è¶³è¿¹è®°å½•ã€‚è¿™äº›è®°å½•åº”è¯¥åæ˜ å‡ºæˆ‘çš„ç”Ÿæ´»åŒºåŸŸã€æ´»åŠ¨ä¹ æƒ¯å’Œå»è¿‡çš„åœ°æ–¹ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "name": "åœ°ç‚¹åç§°",
    "address": "è¯¦ç»†åœ°å€",
    "time": "è®¿é—®æ—¶é—´"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const locations = JSON.parse(cleanedJson);

    chat.myPhoneAmapHistory = locations;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phoneè¶³è¿¹å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneAppUsage() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  // ç”Ÿæˆæ¨¡æ‹Ÿçš„ä½¿ç”¨è®°å½•ï¼Œæ ¼å¼ä¸æ‰‹åŠ¨æ·»åŠ ä¸€è‡´
  const apps = [
    { name: 'QQ', category: 'ç¤¾äº¤' },
    { name: 'ç›¸å†Œ', category: 'å·¥å…·' },
    { name: 'æµè§ˆå™¨', category: 'å·¥å…·' },
    { name: 'æ·˜å®', category: 'è´­ç‰©' },
    { name: 'å¤‡å¿˜å½•', category: 'å·¥å…·' },
    { name: 'æ—¥è®°', category: 'ç”Ÿæ´»' },
    { name: 'é«˜å¾·åœ°å›¾', category: 'å‡ºè¡Œ' },
    { name: 'ç½‘æ˜“äº‘éŸ³ä¹', category: 'å¨±ä¹' },
    { name: 'Bç«™', category: 'å¨±ä¹' },
    { name: 'å¾®åš', category: 'ç¤¾äº¤' },
    { name: 'æŠ–éŸ³', category: 'å¨±ä¹' },
    { name: 'å°çº¢ä¹¦', category: 'ç”Ÿæ´»' }
  ];
  const usageLog = [];
  
  for (let i = 0; i < 15; i++) {
    const app = apps[Math.floor(Math.random() * apps.length)];
    const date = Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000;
    usageLog.push({
      appName: app.name,
      category: app.category,
      usageTimeMinutes: Math.floor(Math.random() * 180) + 5, // 5-185åˆ†é’Ÿ
      iconUrl: '', // å¯ä»¥åç»­æ·»åŠ å›¾æ ‡URL
      timestamp: date
    });
  }

  chat.myPhoneAppUsage = usageLog.sort((a, b) => b.timestamp - a.timestamp);
  await db.chats.put(chat);
}

async function handleGenerateMyPhoneMusic() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„éŸ³ä¹å“å‘³å’Œæƒ…æ„ŸçŠ¶æ€ï¼Œç„¶åç”Ÿæˆæˆ‘çš„éŸ³ä¹æ­Œå•ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘çš„éŸ³ä¹æ­Œå•ï¼ˆ5-8é¦–æ­Œï¼‰ã€‚è¿™äº›æ­Œæ›²åº”è¯¥åæ˜ å‡ºæˆ‘çš„éŸ³ä¹åå¥½ã€æƒ…æ„ŸçŠ¶æ€å’Œå®¡ç¾å“å‘³ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "æ­Œæ›²å",
    "artist": "æ­Œæ‰‹å"
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const playlist = JSON.parse(cleanedJson);

    chat.myPhoneMusicPlaylist = playlist;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY PhoneéŸ³ä¹å¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneReddit() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„å…´è¶£é¢†åŸŸï¼Œç„¶åç”Ÿæˆæˆ‘å¯èƒ½æµè§ˆçš„Redditå¸–å­ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘å¯èƒ½æµè§ˆçš„5-8æ¡Redditå¸–å­ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "å¸–å­æ ‡é¢˜",
    "subreddit": "å­ç‰ˆå—å",
    "author": "ä½œè€…å",
    "score": ç‚¹èµæ•°
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const posts = JSON.parse(cleanedJson);

    chat.myPhoneRedditFeed = posts;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phone Redditå¤±è´¥:", error);
    throw error;
  }
}

async function handleGenerateMyPhoneBilibili() {
  if (!activeMyPhoneCharacterId) return;
  const chat = state.chats[activeMyPhoneCharacterId];
  if (!chat) return;

  const { proxyUrl, apiKey, model } = state.apiConfig;
  if (!proxyUrl || !apiKey || !model) {
    alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
    return;
  }

  const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
  
  const maxMemory = chat.settings.maxMemory || 10;
  const recentHistory = chat.history.slice(-maxMemory).map(msg => 
    `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 50)}...`
  ).join('\n');
  
  const prompt = `ä½ ç°åœ¨è¦æ‰®æ¼”"${userDisplayNameForAI}"ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ï¼‰ï¼ŒåŸºäºæˆ‘ä¸"${chat.name}"çš„å¯¹è¯å†å²ï¼Œæ¨æµ‹æˆ‘çš„å…´è¶£çˆ±å¥½ï¼Œç„¶åç”Ÿæˆæˆ‘å¯èƒ½è§‚çœ‹çš„Bç«™è§†é¢‘ã€‚

## æˆ‘ä¸"${chat.name}"çš„æœ€è¿‘å¯¹è¯ï¼š
${recentHistory}

## ä»»åŠ¡ï¼š
è¯·åŸºäºä»¥ä¸Šå¯¹è¯æ¨æµ‹æˆ‘çš„ç‰¹å¾ï¼Œç„¶åç”Ÿæˆæˆ‘å¯èƒ½è§‚çœ‹çš„5-8ä¸ªBç«™è§†é¢‘ã€‚

è¿”å›JSONæ ¼å¼ï¼š
[
  {
    "title": "è§†é¢‘æ ‡é¢˜",
    "author": "UPä¸»å",
    "views": æ’­æ”¾é‡,
    "danmaku": å¼¹å¹•æ•°
  }
]`;

  try {
    const messagesForApi = [{ role: 'user', content: prompt }];
    let isGemini = proxyUrl.includes('generativelanguage');
    let geminiConfig = toGeminiRequestData(model, apiKey, '', messagesForApi);

    const response = isGemini ?
      await fetch(geminiConfig.url, geminiConfig.data) :
      await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: 0.8
        })
      });

    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

    const data = await response.json();
    const aiResponseContent = getGeminiResponseText(data);
    const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const videos = JSON.parse(cleanedJson);

    chat.myPhoneBilibiliVideos = videos;
    await db.chats.put(chat);
  } catch (error) {
    console.error("ç”ŸæˆMY Phone Bç«™è§†é¢‘å¤±è´¥:", error);
    throw error;
  }
}

  function renderCharMusicScreen() {
    const listEl = document.getElementById('char-music-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const playlist = char.simulatedMusicPlaylist || [];

    if (playlist.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TAçš„æ­Œå•è¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›æ­Œæ›²å§ï¼</p>';
      return;
    }

    playlist.forEach((track, index) => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-music-item';
      itemEl.innerHTML = `
            <img src="${track.cover}" class="music-item-cover">
            <div class="music-item-info">
                <div class="music-item-name">${track.name}</div>
                <div class="music-item-artist">${track.artist}</div>
            </div>
        `;

      itemEl.addEventListener('click', () => playCharSong(index, playlist));
      listEl.appendChild(itemEl);
    });
  }



  let charPlayerState = {
    currentPlaylist: [],
    currentIndex: -1,
    isPlaying: false,
    playMode: 'order', 
    lrcUpdateInterval: null,
  
    parsedLyrics: [],
    currentLyricIndex: -1
  };

  
  function playCharSong(songIndex, playlist) { 
    const player = document.getElementById('char-audio-player');
    const modal = document.getElementById('char-music-player-modal');

    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();


    charPlayerState.currentPlaylist = playlist; 

    charPlayerState.currentIndex = songIndex; 

    const songObject = playlist[songIndex]; 
    if (!songObject) {
        console.error("playCharSong: æ­Œæ›²ç´¢å¼•æ— æ•ˆæˆ–æ­Œå•ä¸ºç©ºã€‚");
        return;
    }

    document.getElementById('char-music-player-title').textContent = songObject.name;
    document.getElementById('char-music-artist').textContent = songObject.artist;
    document.getElementById('char-music-cover').src = songObject.cover;


    charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
    renderCharLyrics();


    if (songObject.isLocal) {
      const blob = new Blob([songObject.src], {
        type: songObject.fileType || 'audio/mpeg'
      });
      player.src = URL.createObjectURL(blob);
    } else {
      player.src = songObject.src;
    }
    player.play().catch(e => console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", e));

    player.onloadedmetadata = () => {
      document.getElementById('char-music-total-time').textContent = formatMusicTime(player.duration);
      charPlayerState.lrcUpdateInterval = setInterval(updateCharMusicProgress, 1000);
    };

    modal.classList.add('visible');
  }


function minimizeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    modal.classList.remove('visible');
  
    document.getElementById('char-music-restore-btn').style.display = 'flex';
}


function restoreCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    modal.classList.add('visible');
    
    document.getElementById('char-music-restore-btn').style.display = 'none';
}


function closeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    const player = document.getElementById('char-audio-player');

    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    // player.src = ''; // å»ºè®®æ³¨é‡Šæ‰è¿™è¡Œï¼Œé˜²æ­¢ä¸‹æ¬¡æ‰“å¼€è¦é‡æ–°åŠ è½½ï¼Œæˆ–è€…ä¿ç•™çœ‹ä½ éœ€æ±‚
    
    modal.classList.remove('visible');
    charPlayerState.isPlaying = false;
    document.getElementById('char-vinyl-container').classList.remove('spinning');
    
   
    document.getElementById('char-music-restore-btn').style.display = 'none';
}


  function updateCharMusicProgress() {
    const player = document.getElementById('char-audio-player');
    if (!player.duration) return;

    const currentTime = player.currentTime;
    const duration = player.duration;
    document.getElementById('char-music-progress-fill').style.width = `${(currentTime / duration) * 100}%`;
    document.getElementById('char-music-current-time').textContent = formatMusicTime(currentTime);


    updateCharActiveLyric(currentTime);
  }



  function renderCharLyrics() {
    const lyricsContainer = document.getElementById('char-music-lyrics');
    lyricsContainer.innerHTML = ''; 
    charPlayerState.currentLyricIndex = -1;
    
   
    const scrollWrapper = document.createElement('div');
    scrollWrapper.id = 'char-lyrics-scroll-wrapper';
    scrollWrapper.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
    lyricsContainer.appendChild(scrollWrapper);

    if (!charPlayerState.parsedLyrics || charPlayerState.parsedLyrics.length === 0) {
        scrollWrapper.innerHTML = '<p>â™ª æš‚æ— æ­Œè¯ â™ª</p>';
        return;
    }
    charPlayerState.parsedLyrics.forEach((line, index) => {
        const p = document.createElement('p');
        p.textContent = line.text;
        p.dataset.index = index;
     
        p.style.margin = '0';
        p.style.padding = '5px 0';
        p.style.color = '#888';
        p.style.transition = 'all 0.3s';
        scrollWrapper.appendChild(p);
    });
}

function updateCharActiveLyric(currentTime) {
    const lyrics = charPlayerState.parsedLyrics;
    if (lyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (currentTime >= lyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === charPlayerState.currentLyricIndex) return;
    charPlayerState.currentLyricIndex = newLyricIndex;

   
    const wrapper = document.getElementById('char-lyrics-scroll-wrapper');
    if(!wrapper) return; 

    const lines = wrapper.querySelectorAll('p');
    lines.forEach(line => {
        line.classList.remove('active');
        line.style.color = '#888';
        line.style.transform = 'scale(1)';
    });

    if (newLyricIndex > -1) {
        const activeLine = wrapper.querySelector(`p[data-index="${newLyricIndex}"]`);
        if (activeLine) {
            activeLine.classList.add('active');
            activeLine.style.color = '#333';
            activeLine.style.fontWeight = 'bold';
            activeLine.style.transform = 'scale(1.1)';
           
            const containerHeight = document.getElementById('char-music-lyrics').clientHeight;
            const offset = (containerHeight / 2) - activeLine.offsetTop - (activeLine.clientHeight / 2);
            
            wrapper.style.transform = `translateY(${offset}px)`;
        }
    }
}



  function playNextCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    let nextIndex;
    switch (charPlayerState.playMode) {
      case 'random':
        nextIndex = Math.floor(Math.random() * charPlayerState.currentPlaylist.length);
        break;
      case 'single':

        playCharSong(charPlayerState.currentPlaylist[charPlayerState.currentIndex]);
        return;
      case 'order':
      default:
        nextIndex = (charPlayerState.currentIndex + 1) % charPlayerState.currentPlaylist.length;
        break;
    }
    playCharSong(nextIndex, charPlayerState.currentPlaylist);
  }

  function playPrevCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    const newIndex = (charPlayerState.currentIndex - 1 + charPlayerState.currentPlaylist.length) % charPlayerState.currentPlaylist.length;
    playCharSong(newIndex, charPlayerState.currentPlaylist);
  }

  function changeCharPlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(charPlayerState.playMode);
    charPlayerState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('char-music-mode-btn').textContent = {
      'order': 'é¡ºåº',
      'random': 'éšæœº',
      'single': 'å•æ›²'
    } [charPlayerState.playMode];
  }



  function setupCharPlayerControls() {
    const player = document.getElementById('char-audio-player');
    const playBtn = document.getElementById('char-music-play-pause-btn');
    const vinyl = document.getElementById('char-vinyl-container');

    playBtn.addEventListener('click', () => {
      if (player.paused) {
        if (charPlayerState.currentIndex > -1) player.play();
      } else {
        player.pause();
      }
    });

    player.onplay = () => {
      playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
      vinyl.classList.add('spinning');
      charPlayerState.isPlaying = true;
    };
    player.onpause = () => {
      playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
      vinyl.classList.remove('spinning');
      charPlayerState.isPlaying = false;
    };
    player.onended = () => {
      vinyl.classList.remove('spinning');
      charPlayerState.isPlaying = false;
      playNextCharSong();
    };

    document.getElementById('char-music-prev-btn').addEventListener('click', playPrevCharSong);
    document.getElementById('char-music-next-btn').addEventListener('click', playNextCharSong);
    document.getElementById('char-music-mode-btn').addEventListener('click', changeCharPlayMode);

    document.getElementById('char-music-progress-bar').addEventListener('click', (e) => {
      if (!player.duration) return;
      const bar = e.currentTarget;
      const clickX = e.offsetX;
      player.currentTime = (clickX / bar.clientWidth) * player.duration;
    });
  }

  async function renderDoubanScreen() {
    const listEl = document.getElementById('douban-posts-list');
    listEl.innerHTML = '';

    const posts = await db.doubanPosts.orderBy('timestamp').reverse().toArray();

    if (posts.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">è¿™é‡Œç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ï¼Œçœ‹çœ‹å¤§å®¶éƒ½åœ¨èŠä»€ä¹ˆå§ï¼</p>';
      return;
    }

    posts.forEach(post => {
      let avatarUrl;


      const authorChatByOriginalName = post.authorOriginalName ?
        Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorOriginalName) :
        null;

      if (authorChatByOriginalName) {

        avatarUrl = authorChatByOriginalName.settings.aiAvatar;
      } else {

        const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
        if (authorChatByName) {
          avatarUrl = authorChatByName.settings.aiAvatar;
        } else if (post.authorAvatarPrompt) {

          avatarUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
        } else {

          avatarUrl = defaultAvatar;
        }
      }


      const itemEl = document.createElement('div');
      itemEl.className = 'douban-post-item';
      itemEl.onclick = () => openDoubanPostDetail(post.id);

      itemEl.innerHTML = `
            <div class="douban-post-header">
                <img src="${avatarUrl}" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div class="douban-author-name">${post.authorName}</div>
                    <div class="douban-group-name">æ¥è‡ª ${post.groupName}</div>
                </div>
            </div>
            <div class="douban-post-title">${post.postTitle}</div>
            <div class="douban-post-content">${post.content.replace(/\n/g, '<br>')}</div>
            <div class="douban-post-footer">
                 <div class="douban-post-actions">
                    <span><svg viewBox="0 0 1024 1024"><path d="M170.666667 170.666667h128v682.666666h-128zM426.666667 170.666667h170.666666v682.666666h-170.666666zM725.333333 170.666667h128v682.666666h-128z"></path></svg> ${post.likesCount}</span>
                    <span><svg viewBox="0 0 1024 1024"><path d="M853.333333 85.333333H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333334v512c0 46.933333 38.4 85.333333 85.333334 85.333333h512l170.666667 170.666667V170.666667c0-46.933333-38.4-85.333333-85.333334-85.333334z m-42.666666 554.666667H170.666667V170.666667h640v469.333333zM256 384h512v85.333333H256V384z m0-170.666667h512v85.333334H256v-85.333334z"></path></svg> ${post.commentsCount}</span>
                </div>
                <span class="douban-post-timestamp">${formatTimeAgo(post.timestamp)}</span>
            </div>
        `;
      listEl.appendChild(itemEl);
    });
  }



  async function handleGenerateDoubanPosts() {
    const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];

    if (activeCharacterIds.length === 0) {
      await showCustomAlert("è¯·å…ˆé€‰æ‹©è§’è‰²", "è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œè§’è‰²é€‰æ‹©â€æŒ‰é’®ï¼Œé€‰æ‹©è‡³å°‘ä¸€ä¸ªå‚ä¸è±†ç“£äº’åŠ¨çš„è§’è‰²ã€‚");
      return;
    }

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨ä¸ºæ‚¨é€‰æ‹©çš„ ${activeCharacterIds.length} ä½è§’è‰²ç”Ÿæˆè±†ç“£åŠ¨æ€...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
      return;
    }

    const allLinkedBookIds = new Set();
    activeCharacterIds.forEach(charId => {
      const c = state.chats[charId];
      if (c && c.settings.linkedWorldBookIds) {
        c.settings.linkedWorldBookIds.forEach(bookId => allLinkedBookIds.add(bookId));
      }
    });
    
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal) {
        allLinkedBookIds.add(wb.id);
      }
    });

    let sharedWorldBookContext = '';
    if (allLinkedBookIds.size > 0) {
      sharedWorldBookContext += '\n\n# ç»Ÿä¸€ä¸–ç•Œè§‚è®¾å®š (ä»¥ä¸‹è®¾å®šé€‚ç”¨äºæ‰€æœ‰å‚ä¸è§’è‰²)\n';
      allLinkedBookIds.forEach(bookId => {
        const book = state.worldBooks.find(wb => wb.id === bookId);
        if (book) {
          const enabledEntries = book.content
            .filter(e => e.enabled !== false)
            .map(e => `- ${e.content}`)
            .join('\n');
          if (enabledEntries) {
            sharedWorldBookContext += `\n## æ¥è‡ªã€Š${book.name}ã€‹:\n${enabledEntries}`;
          }
        }
      });
    }

    const doubanWorldBook = state.worldBooks.find(wb => wb.name === 'è±†ç“£è®¾å®š');
    let doubanSettingContext = '';
    let npcCharacters = [];
    if (doubanWorldBook) {
      doubanWorldBook.content.forEach(entry => {
        if (entry.comment.includes('å°ç»„é£æ ¼')) {
          doubanSettingContext += `\n# è±†ç“£ç¤¾åŒºé£æ ¼è®¾å®š (æ¥è‡ªä¸–ç•Œä¹¦)\n${entry.content}`;
        }
        if (entry.comment.includes('NPCäººè®¾')) {
          const lines = entry.content.split('\n');
          lines.forEach(line => {
            const match = line.match(/- \*\*æ˜µç§°\*\*:\s*(.*?)\s*\*\*äººè®¾\*\*:\s*(.*)/);
            if (match) {
              npcCharacters.push({
                name: match[1].trim(),
                persona: match[2].trim()
              });
            }
          });
        }
      });
    }

    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const userPersona = activeCharacterIds.length > 0 && state.chats[activeCharacterIds[0]] ?
      state.chats[activeCharacterIds[0]].settings.myPersona :
      '(æœªè®¾ç½®)';

    let charactersContext = '';
    activeCharacterIds.forEach(charId => {
      const c = state.chats[charId];
      if (c) {
        const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : 'æ— ';
        const recentHistory = c.history.slice(-10).map(msg =>
          `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`
        ).join('\n');

        charactersContext += `
<character>
  <name>${c.name}</name>
  <persona>${c.settings.aiPersona}</persona>
  <memory>${longTermMemory}</memory>
  <recent_dialogue_with_user>${recentHistory}</recent_dialogue_with_user>
</character>
`;
      }
    });
    npcCharacters.forEach(npc => {
      charactersContext += `
<character>
  <name>${npc.name}</name>
  <persona>${npc.persona}</persona>
</character>
`;
    });

    const now = new Date();
    const currentTimeString = now.toLocaleString('zh-CN', {
      dateStyle: 'full',
      timeStyle: 'short'
    });
    const minPosts = state.globalSettings.doubanMinPosts || 12;
    const maxPosts = state.globalSettings.doubanMaxPosts || 20;
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºå†…å®¹ç”Ÿæˆå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä¸‹é¢æä¾›çš„ã€ç»Ÿä¸€è§’è‰²åˆ—è¡¨ã€‘ï¼Œè™šæ„å‡ºã€${minPosts}åˆ°${maxPosts}ç¯‡ã€‘ä»–ä»¬æœ€è¿‘å¯èƒ½ä¼šåœ¨å„ç§è±†ç“£å°ç»„ä¸­å‘å¸ƒçš„å¸–å­å’Œè¯„è®ºã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´æ„ŸçŸ¥ã€‘**:
    -   ä½ ã€å¿…é¡»ã€‘æ„è¯†åˆ°å½“å‰æ˜¯ **${currentTimeString}**ã€‚
    -   ä½ çš„å¸–å­å’Œè¯„è®ºå†…å®¹ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“ç°å‡ºå¯¹ã€å½“å‰çœŸå®æ—¶é—´ã€‘çš„æ„ŸçŸ¥ã€‚
2.  **ã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ· (æœ€æœ€æœ€é«˜ä¼˜å…ˆçº§ï¼ï¼ï¼)ã€‘**:
    -   ç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${userNickname}â€ã€‚
    -   ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ authorName æˆ– commenter å­—æ®µä¸º â€œ${userNickname}â€ çš„å¸–å­æˆ–è¯„è®ºã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚
3.  **ã€èº«ä»½ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**: 
    -   \`authorName\`: ä½ å¯ä»¥ä¸ºä¸»è¦è§’è‰²èµ·ä¸€ä¸ªç¬¦åˆæƒ…æ™¯çš„ã€ä¸´æ—¶çš„ã€å‘å¸–æ˜µç§°ã€‘ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ä»–ä»¬çš„æœ¬åã€‚
    -   \`authorOriginalName\`: å¦‚æœå‘å¸–è€…æ˜¯ã€ä¸»è¦è§’è‰²ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨è¿™é‡Œå¡«ä¸ŠTAåœ¨è§’è‰²åˆ—è¡¨é‡Œçš„ã€åŸå§‹å¤‡æ³¨åã€‘ï¼Œè¿™æ˜¯ç¨‹åºçš„â€œèº«ä»½è¯â€ã€‚
    -   å¦‚æœå‘å¸–è€…æ˜¯ã€è·¯äººNPCã€‘ï¼Œåˆ™ã€çœç•¥ã€‘\`authorOriginalName\` å­—æ®µã€‚
4.  **ã€ä½œè€…å¹³è¡¡ã€‘**: å¸–å­çš„ä½œè€…ã€å¿…é¡»ã€‘ä»ä¸‹é¢çš„ \`<character>\` åˆ—è¡¨ä¸­ã€å‡åŒ€åœ°ã€å¤šæ ·åŒ–åœ°ã€‘é€‰æ‹©ã€‚ä½ ã€å¿…é¡»ã€‘ç¡®ä¿å¸–å­åˆ—è¡¨ä¸­ã€è‡³å°‘æœ‰ 70% çš„å¸–å­æ˜¯ç”±è·¯äººNPCå‘å¸ƒçš„ã€‘ï¼Œä»¥è¥é€ ä¸€ä¸ªçœŸå®çš„ç¤¾åŒºæ°›å›´ã€‚
    - "comments": ä¸€ä¸ªåŒ…å«ã€7åˆ°12æ¡ã€‘è¯„è®ºçš„æ•°ç»„ã€‚è¯„è®ºè€…å¯ä»¥æ˜¯è·¯äººï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²åˆ—è¡¨ä¸­çš„å…¶ä»–è§’è‰²ï¼Œä»¥ä½“ç°äº’åŠ¨æ€§ã€‚
5.  **ã€è§’è‰²æ‰®æ¼”ã€‘**: å¸–å­çš„ä½œè€…å’Œå†…å®¹ã€å¿…é¡»ã€‘æ·±åº¦ç»“åˆè¯¥è§’è‰²çš„<persona>, <memory>, å’Œ <worldview>ã€‚
6.  **ã€â€œè±†ç“£å‘³â€å†…å®¹é£æ ¼æŒ‡å—ã€‘**: å¸–å­é£æ ¼å¿…é¡»å¤šæ ·åŒ–ä¸”å……æ»¡ç”Ÿæ´»æ°”æ¯ï¼ä½ éœ€è¦ç”ŸæˆåŒ…æ‹¬ä½†ä¸é™äºï¼šæƒ…æ„Ÿæ ‘æ´ã€ç”Ÿæ´»åæ§½ã€åƒç“œå…«å¦ã€å…´è¶£åˆ†äº«ã€æ— ç”¨è‰¯å“ç­‰å„ç§ç±»å‹çš„å¸–å­ã€‚
7.  **ã€å¤´åƒç”Ÿæˆ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**:
    -   ä¸ºæ¯ä¸€ä¸ªã€é¦–æ¬¡å‡ºç°ã€‘çš„è·¯äººNPCï¼ˆæ— è®ºæ˜¯å‘å¸–è¿˜æ˜¯è¯„è®ºï¼‰ï¼Œä½ éƒ½ã€å¿…é¡»ã€‘ä¸ºå…¶æ·»åŠ ä¸€ä¸ª \`avatar_prompt\` å­—æ®µã€‚
    -   è¿™ä¸ªå­—æ®µçš„å†…å®¹æ˜¯ç”¨äºç”Ÿæˆè¯¥NPCå¤´åƒçš„ã€ç®€æ´çš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚
    -   ä¸åŒçš„NPCã€å¿…é¡»ã€‘æœ‰ä¸åŒçš„å¤´åƒæŒ‡ä»¤ï¼Œä»¥ç¡®ä¿ä»–ä»¬çš„å¤´åƒæ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚
8.  **ã€å¤´åƒä¸€è‡´æ€§ (è‡³å…³é‡è¦ï¼)ã€‘**:
    -   å¦‚æœä¸€ä¸ªè·¯äººNPCåœ¨åŒä¸€ä¸ªå¸–å­ä¸­å¤šæ¬¡å‡ºç°ï¼ˆä¾‹å¦‚ï¼Œæ—¢æ˜¯å‘å¸–äººåˆæ˜¯è¯„è®ºè€…ï¼Œæˆ–å¤šæ¬¡è¯„è®ºï¼‰ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºTAçš„æ‰€æœ‰å‡ºç°éƒ½ä½¿ç”¨ã€å®Œå…¨ç›¸åŒã€‘çš„ \`avatar_prompt\`ã€‚è¿™è‡³å…³é‡è¦ï¼
9.  **ã€æ ¼å¼ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`[\` å¼€å§‹ï¼Œå¹¶ä»¥ \`]\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONæ•°ç»„å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šã€æˆ– markdown æ ‡è®° (å¦‚ \`\`\`json)ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ç¯‡å¸–å­ï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      {
        "groupName": "ä¸€ä¸ªç”ŸåŠ¨æœ‰è¶£çš„å°ç»„åç§°",
        "postTitle": "ä¸€ä¸ªå¼•äºº-æ³¨ç›®çš„å¸–å­æ ‡é¢˜",
        "authorName": "å‘å¸–è§’è‰²çš„ã€å¤‡æ³¨åã€‘",
        "authorOriginalName": "(ä»…å½“å‘å¸–è€…æ˜¯ä¸»è¦è§’è‰²æ—¶ã€å¿…é¡»ã€‘æä¾›) TAçš„åŸå§‹å¤‡æ³¨å",
        "authorAvatarPrompt": "(ä»…å½“å‘å¸–è€…æ˜¯è·¯äººNPCæ—¶ã€å¿…é¡»ã€‘æä¾›) ä¸€æ®µç”¨äºç”Ÿæˆè¯¥NPCå¤´åƒçš„ã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚é£æ ¼ä¸º anime style, simple background",
        "content": "å¸–å­çš„è¯¦ç»†æ­£æ–‡ï¼Œå¿…é¡»æ”¯æŒæ¢è¡Œç¬¦\\nã€‚",
        "likesCount": 152,
        "commentsCount": 38,
        "comments": [
            { "commenter": "è·¯äººç”²", "text": "è¿™æ˜¯ä¸€ä¸ªè·¯äººè¯„è®ºã€‚", "avatar_prompt": "cute cat avatar, simple, flat" },
            { "commenter": "å¦ä¸€ä¸ªè§’è‰²å", "commenterOriginalName": "(å¦‚æœè¯„è®ºè€…æ˜¯ä¸»è¦è§’è‰²ï¼Œå¿…é¡»æä¾›å…¶æœ¬å)", "text": "è¿™æ˜¯ä¸€ä¸ªæ¥è‡ªå…¶ä»–è§’è‰²çš„äº’åŠ¨è¯„è®ºã€‚" }
        ]
      }
    ]
    \`\`\`
    - **comments**: 
        -   è¯„è®ºè€…å¯ä»¥æ˜¯è·¯äººï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²åˆ—è¡¨ä¸­çš„å…¶ä»–è§’è‰²ã€‚è¯„è®ºåŒºã€å¿…é¡»ã€‘ä½“ç°å‡ºäº’åŠ¨æ€§ã€‚
        -   ã€è¯„è®ºèº«ä»½ã€‘: å¦‚æœè¯„è®ºè€…æ˜¯ã€ä¸»è¦è§’è‰²ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘ä¸ºå…¶æ·»åŠ  \`commenterOriginalName\` å­—æ®µï¼Œå¹¶å¡«å…¥å…¶æœ¬åã€‚å¦‚æœæ˜¯è·¯äººNPCï¼Œåˆ™çœç•¥æ­¤å­—æ®µã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
${doubanSettingContext}
${sharedWorldBookContext}

# å½“å‰æƒ…æ™¯
- **å½“å‰çœŸå®æ—¶é—´**: ${currentTimeString}

# ã€ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„èº«ä»½æ¡£æ¡ˆã€‘
- **æ˜µç§°**: ${userNickname}
- **äººè®¾**: ${userPersona}

# ç»Ÿä¸€è§’è‰²åˆ—è¡¨ (ä½ æ‰®æ¼”çš„è§’è‰² + è·¯äººNPC)
${charactersContext}

ç°åœ¨ï¼Œè¯·ä¸¥æ ¼éµå®ˆæ‰€æœ‰è§„åˆ™ï¼Œç‰¹åˆ«æ˜¯ã€æ—¶é—´æ„ŸçŸ¥ã€‘å’Œã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ·ã€‘çš„é“å¾‹ï¼Œå¼€å§‹ç”Ÿæˆè¿™ç»„ç”ŸåŠ¨ã€å¤šæ ·ä¸”å……æ»¡â€œè±†ç“£å‘³â€çš„å°ç»„å¸–å­ã€‚`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®è§’è‰²åˆ—è¡¨ï¼Œç”Ÿæˆè±†ç“£å°ç»„å¸–å­ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/\[[\s\S]*\]/);

      if (!jsonMatch) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }

      const simulatedPosts = JSON.parse(jsonMatch[0]);
      await db.doubanPosts.clear();
      await db.doubanPosts.bulkAdd(simulatedPosts.map(p => ({
        ...p,
        timestamp: Date.now() - Math.random() * 100000
      })));

      await renderDoubanScreen();

    } catch (error) {
      console.error("ç”Ÿæˆè±†ç“£å¸–å­å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå†…å®¹ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }


  async function openDoubanPostDetail(postId) {
    showScreen('douban-post-detail-screen');
    activeDoubanPostId = postId;
    const post = await db.doubanPosts.get(postId);
    if (!post) {
      showScreen('douban-screen');
      return;
    }

    document.getElementById('douban-post-detail-title').textContent = 'å¸–å­è¯¦æƒ…';


    let authorAvatar = defaultAvatar;
    let authorDisplayName = post.authorName;

    const authorChatByOriginalName = post.authorOriginalName ?
      Object.values(state.chats).find(c => !c.isGroup && c.originalName === post.authorOriginalName) :
      null;

    if (authorChatByOriginalName) {
      authorAvatar = authorChatByOriginalName.settings.aiAvatar;
    } else {
      const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
      if (authorChatByName) {
        authorAvatar = authorChatByName.settings.aiAvatar;
      } else if (post.authorAvatarPrompt) {
        authorAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
      }
    }


    document.getElementById('douban-detail-avatar').src = authorAvatar;
    document.getElementById('douban-detail-author').textContent = authorDisplayName;
    document.getElementById('douban-detail-group').textContent = `æ¥è‡ª ${post.groupName}`;
    document.getElementById('douban-detail-post-title').textContent = post.postTitle;
    document.getElementById('douban-detail-content').innerHTML = post.content.replace(/\n/g, '<br>');
    document.getElementById('douban-my-comment-avatar').src = state.qzoneSettings.avatar;
    document.getElementById('douban-comment-input').value = '';

    const commentsListEl = document.getElementById('douban-detail-comments-list');
    commentsListEl.innerHTML = '';


    if (post.comments && post.comments.length > 0) {

      const commenterAvatarMap = new Map();

      post.comments.forEach(comment => {
        let commenterAvatar = defaultAvatar;
        const myNickname = state.qzoneSettings.nickname || 'æˆ‘';
        const commenterName = comment.commenter;

        if (commenterAvatarMap.has(commenterName)) {

          commenterAvatar = commenterAvatarMap.get(commenterName);
        } else {

          if (commenterName === myNickname) {
            commenterAvatar = state.qzoneSettings.avatar;
          } else if (commenterName === post.authorName) {
            commenterAvatar = authorAvatar;
          } else {
            const commenterChatByOriginalName = comment.commenterOriginalName ?
              Object.values(state.chats).find(c => !c.isGroup && c.originalName === comment.commenterOriginalName) :
              null;

            if (commenterChatByOriginalName) {
              commenterAvatar = commenterChatByOriginalName.settings.aiAvatar;
            } else {
              const commenterChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === commenterName);
              if (commenterChatByName) {
                commenterAvatar = commenterChatByName.settings.aiAvatar;
              } else if (comment.avatar_prompt) {
                commenterAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(comment.avatar_prompt)}`;
              }
            }
          }

          commenterAvatarMap.set(commenterName, commenterAvatar);
        }

        const commentEl = document.createElement('div');
        commentEl.className = 'douban-comment-item';
        commentEl.innerHTML = `
                <img src="${commenterAvatar}" class="douban-comment-avatar">
                <div class="douban-comment-body">
                    <div class="douban-comment-author">${commenterName}</div>
                    <div class="douban-comment-text">${comment.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
        commentsListEl.appendChild(commentEl);
      });
    } else {
      commentsListEl.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">è¿˜æ²¡æœ‰å›åº”</p>';
    }

    const contentWrapper = document.getElementById('douban-detail-content-wrapper');
    if (contentWrapper) contentWrapper.scrollTop = 0;
  }


  async function handleSendDoubanComment() {
    if (!activeDoubanPostId) return;

    const input = document.getElementById('douban-comment-input');
    const commentText = input.value.trim();
    if (!commentText) return;

    const post = await db.doubanPosts.get(activeDoubanPostId);
    if (!post) return;

    if (!post.comments) {
      post.comments = [];
    }

    const myNickname = state.qzoneSettings.nickname || 'æˆ‘';

    post.comments.push({
      commenter: myNickname,
      text: commentText
    });
    post.commentsCount++;

    await db.doubanPosts.put(post);
    input.value = '';


    await openDoubanPostDetail(activeDoubanPostId);


  }


  async function handleDoubanWaitReply() {
    if (!activeDoubanPostId) return;

    const postId = activeDoubanPostId;
    const post = await db.doubanPosts.get(postId);
    if (!post) return;

    const lastComment = post.comments && post.comments.slice(-1)[0];
    if (!lastComment) {
      alert("è¿˜æ²¡æœ‰ä»»ä½•è¯„è®ºï¼Œæ— æ³•ç­‰å¾…å›å¤ã€‚");
      return;
    }

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨è¯·æ±‚AIè§’è‰²ä»¬åŠ å…¥è®¨è®º...");

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå†…å®¹ã€‚');
      }

      const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
      const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(æœªè®¾ç½®)';

      const existingNpcs = new Map();
      if (post.comments) {
        post.comments.forEach(comment => {
          const isMainCharacter = (state.globalSettings.doubanActiveCharacterIds || []).some(id => state.chats[id]?.name === comment.commenter);
          if (!isMainCharacter && comment.avatar_prompt) {
            existingNpcs.set(comment.commenter, comment.avatar_prompt);
          }
        });
      }

      let existingNpcContext = "# å·²æœ‰è·¯äººNPCå¤´åƒæŒ‡ä»¤ (å¿…é¡»éµå®ˆï¼)\n";
      if (existingNpcs.size > 0) {
        existingNpcContext += "å¦‚æœä»¥ä¸‹ä»»ä½•ä¸€ä½NPCå†æ¬¡è¯„è®ºï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨æˆ‘ä»¬æä¾›çš„ã€å®Œå…¨ç›¸åŒçš„`avatar_prompt`ï¼Œä»¥ä¿æŒå¤´åƒä¸€è‡´æ€§ã€‚\n";
        existingNpcs.forEach((prompt, name) => {
          existingNpcContext += `- **${name}**: "${prompt}"\n`;
        });
      } else {
        existingNpcContext += "ï¼ˆå½“å‰å¸–å­è¿˜æ²¡æœ‰è·¯äººNPCå‘è¡¨è¯„è®ºã€‚ï¼‰\n";
      }

      const doubanWorldBook = state.worldBooks.find(wb => wb.name === 'è±†ç“£è®¾å®š');
      let npcCharacters = [];
      if (doubanWorldBook) {
        doubanWorldBook.content.forEach(entry => {
          if (entry.comment.includes('NPCäººè®¾')) {
            const lines = entry.content.split('\n');
            lines.forEach(line => {
              const match = line.match(/- \*\*æ˜µç§°\*\*:\s*(.*?)\s*\*\*äººè®¾\*\*:\s*(.*)/);
              if (match) {
                npcCharacters.push({
                  name: match[1].trim(),
                  persona: match[2].trim()
                });
              }
            });
          }
        });
      }

      let charactersContext = '';
      const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];
      activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c) {
          const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : 'æ— ';
          const recentHistory = c.history.slice(-10).map(msg => `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
          charactersContext += `\n- ${c.name}: ${c.settings.aiPersona.substring(0,50)}... [è®°å¿†: ${longTermMemory}] [æœ€è¿‘å¯¹è¯: ${recentHistory}]`;
        }
      });
      npcCharacters.forEach(npc => {
        charactersContext += `\n- ${npc.name}: ${npc.persona}`;
      });


      const now = new Date();
      const currentTimeString = now.toLocaleString('zh-CN', {
        dateStyle: 'full',
        timeStyle: 'short'
      });


      const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤¾åŒºçš„AIå¯¼æ¼”ã€‚ä¸‹é¢çš„â€œå¸–å­æ‘˜è¦â€å’Œâ€œå·²æœ‰è¯„è®ºâ€æ¥è‡ªäºä¸€ä¸ªè±†ç“£å°ç»„çš„å¸–å­ã€‚ç”¨æˆ·â€œ${userNickname}â€åˆšåˆšå¯¹æœ€åä¸€æ¡è¯„è®ºç‚¹å‡»äº†â€œç­‰å¾…å›å¤â€ï¼ŒTAå¸Œæœ›çœ‹åˆ°æ›´å¤šè§’è‰²å‚ä¸è®¨è®ºã€‚
ä½ çš„ä»»åŠ¡æ˜¯ï¼šæ ¹æ®æ‰€æœ‰è§’è‰²çš„è®¾å®šï¼Œé€‰æ‹©ã€10åˆ°20ä½ã€‘æœ€é€‚åˆå‚ä¸è®¨è®ºçš„è§’è‰²ï¼Œè®©ä»–ä»¬é’ˆå¯¹å·²æœ‰è¯„è®ºï¼Œå‘è¡¨ã€å…¨æ–°çš„ã€ç¬¦åˆäººè®¾çš„ã€‘å›åº”ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€æ—¶é—´æ„ŸçŸ¥ã€‘**:
    -   ä½ ã€å¿…é¡»ã€‘æ„è¯†åˆ°å½“å‰æ˜¯ **${currentTimeString}**ã€‚
    -   ä½ çš„è¯„è®ºå†…å®¹ã€å¿…é¡»ã€‘è‡ªç„¶åœ°ä½“ç°å‡ºå¯¹ã€å½“å‰çœŸå®æ—¶é—´ã€‘çš„æ„ŸçŸ¥ã€‚
2.  **ã€ç¦æ­¢æ‰®æ¼”ç”¨æˆ· (æœ€æœ€æœ€é«˜ä¼˜å…ˆçº§ï¼ï¼ï¼)ã€‘**:
    -   ç”¨æˆ·çš„æ˜µç§°æ˜¯â€œ${userNickname}â€ã€‚
    -   ä½ ã€ç»å¯¹ä¸èƒ½ã€‘ç”Ÿæˆ commenter å­—æ®µä¸º â€œ${userNickname}â€ çš„è¯„è®ºã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ã€é™¤äº†ç”¨æˆ·ä»¥å¤–ã€‘çš„æ‰€æœ‰è§’è‰²ã€‚
3.  **ã€äº’åŠ¨ã€‘**: æ–°ç”Ÿæˆçš„è¯„è®ºã€å¿…é¡»ã€‘æ˜¯é’ˆå¯¹ã€å·²æœ‰è¯„è®ºã€‘çš„å»¶ç»­æˆ–å›åº”ï¼Œè®©è®¨è®ºèƒ½ç»§ç»­ä¸‹å»ã€‚
4.  **ã€å¤´åƒä¸€è‡´æ€§ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘**: ä½ ã€å¿…é¡»ã€‘å‚è€ƒä¸‹é¢çš„â€œå·²æœ‰è·¯äººNPCå¤´åƒæŒ‡ä»¤â€åˆ—è¡¨ã€‚å¦‚æœä¸€ä¸ªå·²æœ‰çš„NPCå†æ¬¡å‘è¨€ï¼Œã€å¿…é¡»ã€‘å¤ç”¨å®ƒæ—§çš„å¤´åƒæŒ‡ä»¤ã€‚åªæœ‰åœ¨åˆ›é€ ä¸€ä¸ªã€å…¨æ–°çš„ã€ä»æœªå‡ºç°è¿‡çš„ã€‘NPCæ—¶ï¼Œæ‰ä¸ºå…¶ç”Ÿæˆæ–°çš„å¤´åƒæŒ‡ä»¤ã€‚
5.  **ã€æ ¼å¼ã€‘**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä»£è¡¨ä¸€æ¡æ–°è¯„è®ºï¼Œæ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    [
      { "commenter": "è§’è‰²Açš„åå­—", "text": "è§’è‰²Açš„æ–°è¯„è®ºå†…å®¹ã€‚", "avatar_prompt": "(å¯é€‰)å¦‚æœè¯„è®ºè€…æ˜¯ã€å…¨æ–°çš„ã€‘NPC,æä¾›å¤´åƒæŒ‡ä»¤" },
      { "commenter": "è§’è‰²Bçš„åå­—", "text": "è§’è‰²Bå¯¹è§’è‰²Aæˆ–æ¥¼ä¸»çš„çœ‹æ³•ã€‚" }
    ]
    \`\`\`

# ä¸Šä¸‹æ–‡
- **å¸–å­æ ‡é¢˜**: ã€Š${post.postTitle}ã€‹
- **å‘å¸–äºº**: ${post.authorName}
- **å¸–å­å†…å®¹æ‘˜è¦**: ${post.content.substring(0, 100)}...
- **å·²æœ‰è¯„è®º**:
${post.comments.map(c => `- ${c.commenter}: ${c.text}`).join('\n')}

${existingNpcContext}

# å½“å‰æƒ…æ™¯
- **å½“å‰çœŸå®æ—¶é—´**: ${currentTimeString}

# ã€ä½ çš„èŠå¤©å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾ã€‘
- **æ˜µç§°**: ${userNickname}
- **äººè®¾**: ${userPersona}

# ä½ çš„è§’è‰²åº“ (ä½ å¯ä»¥ä»ä¸­é€‰æ‹©ã€ä»»ä½•è§’è‰²ã€‘è¿›è¡Œè¯„è®ºï¼Œå¹¶å‚è€ƒä»–ä»¬çš„è®°å¿†å’Œå¯¹è¯)
${charactersContext}

ç°åœ¨ï¼Œè¯·ç”Ÿæˆæ–°çš„è¯„è®ºã€‚`;

      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä»¥ä¸Šæƒ…æ™¯ï¼Œç”Ÿæˆæ–°çš„è¯„è®ºã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const newComments = JSON.parse(cleanedJson);

      if (Array.isArray(newComments) && newComments.length > 0) {
        post.comments.push(...newComments);
        post.commentsCount += newComments.length;
        await db.doubanPosts.put(post);
      }

      await openDoubanPostDetail(postId);

      hideCustomModal();

    } catch (error) {
      console.error("ç­‰å¾…å›å¤å¤±è´¥:", error);
      await showCustomAlert("æ“ä½œå¤±è´¥", `æ— æ³•è·å–AIå›å¤ï¼Œè¯·æ£€æŸ¥APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }



  async function openDoubanCastSelector() {
    const modal = document.getElementById('douban-cast-modal');
    const listEl = document.getElementById('douban-cast-list');
    listEl.innerHTML = '';

    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
 
    const activeIds = new Set(state.globalSettings.doubanActiveCharacterIds || []);

    if (allCharacters.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; padding: 50px 0;">è¿˜æ²¡æœ‰å¯ä»¥å‚ä¸çš„è§’è‰²ã€‚</p>';
    } else {
      allCharacters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
                <input type="checkbox" class="douban-cast-checkbox" data-chat-id="${char.id}" ${activeIds.has(char.id) ? 'checked' : ''} style="margin-right: 15px;">
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
        listEl.appendChild(item);
      });
    }
    modal.classList.add('visible');
  }


  async function saveDoubanCastSelection() {
    const selectedCheckboxes = document.querySelectorAll('#douban-cast-list .douban-cast-checkbox:checked');
    const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);


    state.globalSettings.doubanActiveCharacterIds = selectedIds;
    await db.globalSettings.put(state.globalSettings);

    document.getElementById('douban-cast-modal').classList.remove('visible');


    await handleGenerateDoubanPosts();
  }



  document.getElementById('douban-cast-select-btn').addEventListener('click', openDoubanCastSelector);
  document.getElementById('cancel-douban-cast-btn').addEventListener('click', () => {
    document.getElementById('douban-cast-modal').classList.remove('visible');
  });
  document.getElementById('save-douban-cast-btn').addEventListener('click', saveDoubanCastSelection);

  document.getElementById('douban-cast-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
      const checkbox = item.querySelector('.douban-cast-checkbox');
      if (checkbox && e.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
      }
    }
  });

  async function importAppearanceSettings(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        'å¯¼å…¥å¤–è§‚è®¾ç½®',
        'å³å°†å¯¼å…¥æ–‡ä»¶ã€‚å¦‚æœæ–‡ä»¶æ˜¯ JSON å¤‡ä»½ï¼Œå°†è¦†ç›–æ‰€æœ‰è®¾ç½®ï¼›å¦‚æœæ˜¯çº¯æ–‡æœ¬/Wordæ–‡æ¡£ï¼Œå°†å°è¯•è¯†åˆ«ä¸º CSS ä»£ç æˆ– JSON é…ç½®ã€‚\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
            confirmText: 'ç¡®è®¤å¯¼å…¥'
        }
    );

    if (!confirmed) return;

    await showCustomAlert("å¤„ç†ä¸­...", "æ­£åœ¨è§£ææ–‡ä»¶å†…å®¹...");

    try {
        let textContent = '';

        // 1. æ ¹æ®æ–‡ä»¶ç±»å‹è¯»å–æ–‡æœ¬
        if (file.name.toLowerCase().endsWith('.docx')) {
            if (typeof mammoth === 'undefined') {
                throw new Error("æœªåŠ è½½ mammoth.js åº“ï¼Œæ— æ³•è¯»å– Word æ–‡æ¡£ã€‚è¯·æ£€æŸ¥ç½‘ç»œæˆ– HTMLã€‚");
            }
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
            textContent = result.value;
        } else {
            // .json æˆ– .txt ç›´æ¥è¯»å–æ–‡æœ¬
            textContent = await file.text();
        }

        if (!textContent || !textContent.trim()) {
            throw new Error("æ–‡ä»¶å†…å®¹ä¸ºç©ºã€‚");
        }

        // 2. å°è¯•è§£æä¸º JSONï¼ˆå®Œæ•´é…ç½®æ¨¡å¼ï¼‰
        try {
            // é¢„å¤„ç†ï¼šæœ‰æ—¶å€™ Word ä¼šåŒ…å«ä¸å¯è§çš„ BOM æˆ–å¤šä½™ç©ºæ ¼ï¼Œå°è¯•æ¸…ç†å¹¶æå– JSON éƒ¨åˆ†
            let cleanText = textContent.trim();
            // å°è¯•æå–ç¬¬ä¸€ä¸ª { åˆ°æœ€åä¸€ä¸ª } ä¹‹é—´çš„å†…å®¹ï¼Œé˜²æ­¢æ–‡æ¡£å‰åæœ‰æ‚è´¨
            const jsonMatch = cleanText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanText = jsonMatch[0];
            }

            const data = JSON.parse(cleanText);

            // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å¤–è§‚é…ç½®å¯¹è±¡
            if (data.wallpaper || data.globalCss || data.appIcons || data.theme) {
                Object.assign(state.globalSettings, data);
                await db.globalSettings.put(state.globalSettings);
                
                // åº”ç”¨è®¾ç½®
                applyGlobalWallpaper();
                applyCPhoneWallpaper();
                applyAppIcons();
                applyCPhoneAppIcons();
                applyMyPhoneAppIconsGlobal();
                applyGlobalCss(state.globalSettings.globalCss);
                applyCustomFont(state.globalSettings.fontUrl);
                applyStatusBarVisibility();
                applyWidgetData();
                if (data.chatActionButtonsOrder) {
                    renderButtonOrderEditor();
                    applyButtonOrder();
                }
                
                // åˆ·æ–°ç•Œé¢
                renderWallpaperScreen();
                
                await showCustomAlert('JSONå¯¼å…¥æˆåŠŸ', 'å®Œæ•´å¤–è§‚è®¾ç½®å·²æˆåŠŸå¯¼å…¥å¹¶åº”ç”¨ï¼');
                return; // æˆåŠŸç»“æŸ
            }
        } catch (jsonError) {
            // JSON è§£æå¤±è´¥ï¼Œè¿›å…¥ä¸‹ä¸€æ­¥ï¼šå°è¯•ä½œä¸ºçº¯ CSS å¯¼å…¥
            console.log("é JSON æ ¼å¼ï¼Œå°è¯•ä½œä¸º CSS å¤„ç†...");
        }

        // 3. å¦‚æœä¸æ˜¯ JSONï¼Œåˆ™è§†ä¸ºçº¯ CSS ä»£ç å¯¼å…¥
        // ç®€å•çš„é˜²å‘†æ£€æŸ¥ï¼šCSS é€šå¸¸åŒ…å« { æˆ– ;
        if (textContent.includes('{') || textContent.includes(';')) {
            const cssAction = await showChoiceModal(
                'æ£€æµ‹åˆ° CSS ä»£ç ',
                [
                    { text: 'è¦†ç›–ç°æœ‰CSS', value: 'overwrite' },
                    { text: 'é™„åŠ åˆ°ç°æœ‰CSS', value: 'append' }
                ]
            );

            if (cssAction === 'overwrite') {
                state.globalSettings.globalCss = textContent;
                await db.globalSettings.put(state.globalSettings);
                applyGlobalCss(state.globalSettings.globalCss);
                
                // åˆ·æ–°ç•Œé¢æ˜¾ç¤º
                const cssInput = document.getElementById('global-css-input');
                if (cssInput) cssInput.value = textContent;

                await showCustomAlert('CSSå¯¼å…¥æˆåŠŸ', 'ä»£ç å·²è¦†ç›–å¹¶åº”ç”¨åˆ°å…¨å±€æ ·å¼è¡¨ã€‚');
            } else if (cssAction === 'append') {
                const existingCss = state.globalSettings.globalCss || '';
                state.globalSettings.globalCss = existingCss + '\n\n/* å¯¼å…¥çš„CSS */\n' + textContent;
                await db.globalSettings.put(state.globalSettings);
                applyGlobalCss(state.globalSettings.globalCss);
                
                // åˆ·æ–°ç•Œé¢æ˜¾ç¤º
                const cssInput = document.getElementById('global-css-input');
                if (cssInput) cssInput.value = state.globalSettings.globalCss;

                await showCustomAlert('CSSå¯¼å…¥æˆåŠŸ', 'ä»£ç å·²é™„åŠ å¹¶åº”ç”¨åˆ°å…¨å±€æ ·å¼è¡¨ã€‚');
            }
        } else {
            throw new Error("æ— æ³•è¯†åˆ«æ–‡ä»¶å†…å®¹ã€‚å®ƒæ—¢ä¸æ˜¯æœ‰æ•ˆçš„ JSON é…ç½®ï¼Œä¹Ÿä¸åƒ CSS ä»£ç ã€‚");
        }

    } catch (error) {
        console.error("å¯¼å…¥å¤–è§‚è®¾ç½®æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£æå¤±è´¥: ${error.message}`);
    }
}

// å¯¼å‡ºç¾åŒ–ç‰ˆå¤–è§‚è®¾ç½®
async function exportAppearanceSettings() {
    try {
        // 1. æå–å¤–è§‚ç›¸å…³çš„æ•°æ®
        // å³ä½¿åŒ…å«å¤§æ®µ Base64 å›¾ç‰‡ï¼ŒJSON æ ¼å¼åŒ–åç»“æ„ä¾ç„¶æ¸…æ™°
        const appearanceData = {
            export_info: {
                generated_by: "EPhone",
                timestamp: new Date().toLocaleString(),
                note: "æ­¤æ–‡ä»¶åŒ…å«å¤–è§‚è®¾ç½®ã€CSSæ ·å¼ã€å£çº¸å’Œå›¾æ ‡æ•°æ®ã€‚"
            },
            // æ ¸å¿ƒè®¾ç½®
            theme: localStorage.getItem('ephone-theme') || 'light',
            showStatusBar: state.globalSettings.showStatusBar,
            enableMinimalChatUI: state.globalSettings.enableMinimalChatUI,
            detachStatusBar: state.globalSettings.detachStatusBar,
            // CSS (æœ€éœ€è¦ç¾åŒ–é˜…è¯»çš„éƒ¨åˆ†)
            globalCss: state.globalSettings.globalCss || "",
            // å­—ä½“
            fontUrl: state.globalSettings.fontUrl || "",
            // å¸ƒå±€æ’åº
            chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
            // èµ„æºæ•°æ® (å£çº¸/å›¾æ ‡)
            wallpaper: state.globalSettings.wallpaper,
            cphoneWallpaper: state.globalSettings.cphoneWallpaper,
            globalChatBackground: state.globalSettings.globalChatBackground,
            appIcons: state.globalSettings.appIcons,
            cphoneAppIcons: state.globalSettings.cphoneAppIcons,
            myphoneAppIcons: state.globalSettings.myphoneAppIcons,
            widgetData: state.globalSettings.widgetData,
            lockScreenWallpaper: state.globalSettings.lockScreenWallpaper,
            notificationSoundUrl: state.globalSettings.notificationSoundUrl
        };

        // 2. å…³é”®æ­¥éª¤ï¼šæ ¼å¼åŒ– JSON (ç¾åŒ–)
        // ç¬¬ä¸‰ä¸ªå‚æ•° 4 è¡¨ç¤ºä½¿ç”¨ 4 ä¸ªç©ºæ ¼è¿›è¡Œç¼©è¿›ï¼Œè®©æ–‡ä»¶ç»“æ„æ¸…æ™°ã€æ˜“è¯»ã€æ˜“ä¿®æ”¹
        const jsonString = JSON.stringify(appearanceData, null, 4);

        // 3. åˆ›å»ºä¸‹è½½é“¾æ¥
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        
        // ç”Ÿæˆæ–‡ä»¶å
        const dateStr = new Date().toISOString().split('T')[0];
        link.href = url;
        link.download = `EPhone_Appearance_Config_${dateStr}.json`;
        
        // è§¦å‘ä¸‹è½½
        document.body.appendChild(link);
        link.click();
        
        // æ¸…ç†
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å¤–è§‚é…ç½®å·²å¯¼å‡ºï¼\nè¿™æ˜¯ä¸€ä¸ªæ ¼å¼åŒ–å¥½çš„ JSON æ–‡ä»¶ï¼Œä½ å¯ä»¥ç”¨è®°äº‹æœ¬æ‰“å¼€æŸ¥çœ‹æˆ–ç¼–è¾‘ CSSã€‚');

    } catch (error) {
        console.error("å¯¼å‡ºå¤–è§‚é…ç½®å¤±è´¥:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
} 




  async function simulateBackgroundActivity(minutesOffline) {
    console.log(`æ£€æµ‹åˆ°åº”ç”¨ç¦»çº¿äº† ${minutesOffline.toFixed(1)} åˆ†é’Ÿï¼Œå¼€å§‹æ¨¡æ‹Ÿåå°æ´»åŠ¨...`);


    const activeCharacters = Object.values(state.chats).filter(chat =>
      !chat.isGroup &&
      chat.settings.enableBackgroundActivity &&
      chat.relationship?.status === 'friend'
    );

    if (activeCharacters.length === 0) {
      console.log("æ²¡æœ‰é…ç½®ä¸ºåå°æ´»è·ƒçš„è§’è‰²ï¼Œè·³è¿‡æ¨¡æ‹Ÿã€‚");
      return;
    }


    for (const char of activeCharacters) {

      const cooldownMinutes = char.settings.actionCooldownMinutes || 15;
      const timeSinceLastAction = char.lastActionTimestamp ?
        (Date.now() - char.lastActionTimestamp) / (1000 * 60) :
        Infinity;


      if (minutesOffline > cooldownMinutes && timeSinceLastAction > cooldownMinutes) {



        if (Math.random() < 0.3) {
          console.log(`è§’è‰² "${char.name}" è§¦å‘äº†åå°è¡ŒåŠ¨ï¼`);


          if (Math.random() < 0.7) {

            await triggerInactiveAiAction(char.id);
          } else {

            console.log(`è§’è‰² "${char.name}" å†³å®šå»å‘ä¸€æ¡åŠ¨æ€... (æ­¤å¤„ä¸ºæ¨¡æ‹Ÿ)`);
          }
        }
      }
    }
  }


  function openSearchHistoryScreen() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];


    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';

    document.getElementById('chat-search-results-list').innerHTML = `<p style="text-align:center; color: var(--text-secondary);">è¾“å…¥å…³é”®è¯æˆ–é€‰æ‹©æ—¥æœŸè¿›è¡Œæœç´¢ã€‚</p>`;


    showScreen('search-history-screen');
  }

  async function handleSearchHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const keyword = document.getElementById('keyword-search-input').value.trim().toLowerCase();
    const dateValue = document.getElementById('date-search-input').value;

    if (!keyword && !dateValue) {
      alert("è¯·è¾“å…¥å…³é”®è¯æˆ–é€‰æ‹©ä¸€ä¸ªæ—¥æœŸã€‚");
      return;
    }

    let results = chat.history.filter(msg => !msg.isHidden);


    if (keyword) {
      results = results.filter(msg => {
        let contentString = '';

        if (typeof msg.content === 'string') {
          contentString = msg.content;
        } else if (msg.type === 'voice_message') {
          contentString = msg.content;
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
          contentString = msg.content;
        } else if (msg.type === 'offline_text') {
          contentString = `${msg.dialogue || ''} ${msg.description || ''}`;
        } else if (msg.quote) {
          contentString = msg.content;
        }
        return contentString.toLowerCase().includes(keyword);
      });
    }


    if (dateValue) {
      const selectedDate = new Date(dateValue);
      const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0)).getTime();
      const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999)).getTime();

      results = results.filter(msg => msg.timestamp >= startOfDay && msg.timestamp <= endOfDay);
    }


    await renderSearchResults(results);
  }



  async function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (results.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">æœªæ‰¾åˆ°ç›¸å…³çš„èŠå¤©è®°å½•ã€‚</p>';
      return;
    }

    let lastDateString = '';
    for (const msg of results) {
      const msgDate = new Date(msg.timestamp);
      const currentDateString = msgDate.toLocaleDateString();

      if (currentDateString !== lastDateString) {
        const dateSeparator = document.createElement('div');
        dateSeparator.className = 'date-separator';
        dateSeparator.textContent = `--- ${msgDate.getFullYear()}å¹´${msgDate.getMonth() + 1}æœˆ${msgDate.getDate()}æ—¥ ---`;
        listEl.appendChild(dateSeparator);
        lastDateString = currentDateString;
      }

      const messageEl = await createMessageElement(msg, chat);
      if (messageEl) {


        messageEl.style.cursor = 'pointer';

        messageEl.addEventListener('click', () => jumpToOriginalMessage(msg.timestamp));

        listEl.appendChild(messageEl);
      }
    }
  }



 
  async function jumpToOriginalMessage(timestamp) {
    const chatId = state.activeChatId;
    if (!chatId) return;


    showScreen('chat-interface-screen');


    setTimeout(async () => {
      const messagesContainer = document.getElementById('chat-messages');
      const selector = `.message-bubble[data-timestamp="${timestamp}"]`;
      let targetMessage = messagesContainer.querySelector(selector);
      let attempts = 0;
      const maxAttempts = 20;


      while (!targetMessage && attempts < maxAttempts) {
        const loadMoreBtn = document.getElementById('load-more-btn');
        if (loadMoreBtn) {
          console.log(`ç›®æ ‡æ¶ˆæ¯æœªæ‰¾åˆ°, æ­£åœ¨åŠ è½½æ›´å¤šå†å²è®°å½•... (å°è¯• ${attempts + 1})`);
          await loadMoreMessages();
          targetMessage = messagesContainer.querySelector(selector);
          attempts++;
        } else {

          break;
        }
      }


      scrollToOriginalMessage(timestamp);

    }, 200);
  }




  async function clearSearchFilters() {
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';

    await renderSearchResults(state.chats[state.activeChatId].history.filter(msg => !msg.isHidden));
  }

  async function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';


    const customFrames = await db.customAvatarFrames.toArray();

    const allFrames = [...avatarFrames, ...customFrames];

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
      allFrames.forEach(frame => {
        const item = createFrameItem(frame, 'my', memberAvatar);
        if (frame.url === memberFrame) {
          item.classList.add('selected');
        }
        aiFrameGrid.appendChild(item);
      });
    } else {
      const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
      const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      allFrames.forEach(frame => {
        const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
        if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
        aiFrameGrid.appendChild(aiItem);

        const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
        if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
        myFrameGrid.appendChild(myItem);
      });
    }
  }

 
  function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;

    const isCustom = typeof frame.id === 'number';
    const deleteButtonHtml = isCustom ? `<button class="delete-btn" data-id="${frame.id}" style="display:block;">Ã—</button>` : '';

    item.innerHTML = `
        ${deleteButtonHtml}
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
    `;


    item.addEventListener('click', (e) => {

      if (e.target.classList.contains('delete-btn')) {
        return;
      }


      if (isFrameManagementMode) {

        if (isCustom) {
          const frameId = parseInt(frame.id);
          item.classList.toggle('selected');
          if (selectedFrames.has(frameId)) {
            selectedFrames.delete(frameId);
          } else {
            selectedFrames.add(frameId);
          }
          updateDeleteFrameButton();
        }
      } else {

        currentFrameSelection[type] = frame.url;
        const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
        grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
      }
    });

    return item;
  }



  async function handleUploadFrame() {
    const fileInput = document.getElementById('custom-frame-upload-input');

    const file = await new Promise(resolve => {
      const changeHandler = (e) => {
        resolve(e.target.files[0] || null);
        fileInput.removeEventListener('change', changeHandler);
      };
      fileInput.addEventListener('change', changeHandler, {
        once: true
      });
      fileInput.click();
    });

    if (!file) return;

    const name = await showCustomPrompt("å‘½åå¤´åƒæ¡†", "è¯·ä¸ºè¿™ä¸ªæ–°å¤´åƒæ¡†èµ·ä¸ªåå­—");
    if (!name || !name.trim()) return;
    
    const trimmedName = name.trim();

    const base64Url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = async (readerEvent) => { 
            resolve(readerEvent.target.result);
        };
        reader.readAsDataURL(file);
    });

    const newFrame = {
      name: trimmedName,
      url: base64Url
    };
    const newId = await db.customAvatarFrames.add(newFrame);
    
    populateFrameGrids(editingFrameForMember);
    await showCustomAlert("æ·»åŠ æˆåŠŸï¼", `å¤´åƒæ¡†â€œ${trimmedName}â€å·²æ·»åŠ ã€‚\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);

    // ã€ã€ã€å·²ä¿®å¤çš„è°ƒç”¨ã€‘ã€‘ã€‘
    (async () => {
        await silentlyUpdateDbUrl(
            db.customAvatarFrames, // table
            newId, // recordId
            'url', // pathString (æŒ‡å‘ç®€å•å±æ€§)
            base64Url // base64ToFind
            // nameToMatch (ä¸éœ€è¦)
        );
    })();
  }


  async function handleBatchUploadFrames() {
    const placeholder = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nå¤´åƒæ¡†åå­—1: https://.../image1.png\nå¤´åƒæ¡†åå­—2: https://.../image2.gif`;
    const pastedText = await showCustomPrompt("æ‰¹é‡å¯¼å…¥å¤´åƒæ¡†", "ä»å®Œæ•´é“¾æ¥æ‰¹é‡å¯¼å…¥", "", 'textarea', `<p style="font-size:12px;color:#888;">${placeholder}</p>`);

    if (!pastedText || !pastedText.trim()) return;

    const lines = pastedText.trim().split('\n');
    const newFrames = [];
    let errorCount = 0;

    for (const line of lines) {

      const match = line.match(/^(.+?)[:ï¼š]\s*(https?:\/\/.+)$/);
      if (match) {
        newFrames.push({
          name: match[1].trim(),
          url: match[2].trim()
        });
      } else if (line.trim()) {
        errorCount++;
      }
    }

    if (newFrames.length > 0) {
      await db.customAvatarFrames.bulkAdd(newFrames);
      populateFrameGrids(editingFrameForMember);
      await showCustomAlert("å¯¼å…¥æˆåŠŸ", `æˆåŠŸå¯¼å…¥ ${newFrames.length} ä¸ªæ–°å¤´åƒæ¡†ï¼`);
    }

    if (errorCount > 0) {
      await showCustomAlert("éƒ¨åˆ†å¤±è´¥", `æœ‰ ${errorCount} è¡Œæ ¼å¼ä¸æ­£ç¡®ï¼Œå·²è¢«å¿½ç•¥ã€‚`);
    }
  }

  async function handleDeleteCustomFrame(frameId) {
    const frame = await db.customAvatarFrames.get(frameId);
    if (!frame) return;

    const confirmed = await showCustomConfirm(
      "ç¡®è®¤åˆ é™¤",
      `ç¡®å®šè¦åˆ é™¤å¤´åƒæ¡† â€œ${frame.name}â€ å—ï¼Ÿ`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      await db.customAvatarFrames.delete(frameId);
      populateFrameGrids(editingFrameForMember);
    }
  }





  let currentPage = 0;
  const totalPages = 3;


  function setupHomeScreenPagination() {
    const pagesContainer = document.getElementById('home-screen-pages-container');
    const pages = document.getElementById('home-screen-pages');
    const dots = document.querySelectorAll('.pagination-dot');
    let startX = 0,
      startY = 0;
    let currentX = 0;
    let isDragging = false;
    let isClick = true;

    const updatePagination = () => {
      pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentPage);
      });
    };

    const onDragStart = (e) => {
      isDragging = true;
      isClick = true;
      startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      pages.style.transition = 'none';
    };

    const onDragMove = (e) => {
      if (!isDragging) return;

      const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      let diffX = currentX - startX;
      const diffY = currentY - startY;


      if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
        isClick = false;
      }


      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (e.cancelable) e.preventDefault();
        
        // é™åˆ¶æ»‘åŠ¨è·ç¦»ï¼Œç¡®ä¿ä¸ä¼šä¸€æ¬¡æ»‘åŠ¨è¶…è¿‡ä¸€é¡µ
        const maxSwipeDistance = pagesContainer.offsetWidth * 0.8;
        
        // é™åˆ¶å‘å·¦æ»‘åŠ¨ï¼ˆä¸‹ä¸€é¡µï¼‰
        if (diffX < 0 && currentPage >= totalPages - 1) {
          diffX = Math.max(diffX, -maxSwipeDistance * 0.3); // æœ€åä¸€é¡µæ—¶é™åˆ¶æ»‘åŠ¨
        } else if (diffX < 0) {
          diffX = Math.max(diffX, -maxSwipeDistance); // é™åˆ¶æœ€å¤§å‘å·¦æ»‘åŠ¨è·ç¦»
        }
        
        // é™åˆ¶å‘å³æ»‘åŠ¨ï¼ˆä¸Šä¸€é¡µï¼‰
        if (diffX > 0 && currentPage <= 0) {
          diffX = Math.min(diffX, maxSwipeDistance * 0.3); // ç¬¬ä¸€é¡µæ—¶é™åˆ¶æ»‘åŠ¨
        } else if (diffX > 0) {
          diffX = Math.min(diffX, maxSwipeDistance); // é™åˆ¶æœ€å¤§å‘å³æ»‘åŠ¨è·ç¦»
        }
        
        pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
      }
    };

    const onDragEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;
      pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';


      if (isClick) {
        updatePagination();

        return;
      }


      const diffX = currentX - startX;
      const swipeThreshold = pagesContainer.offsetWidth / 3; // æé«˜é˜ˆå€¼åˆ°1/3ï¼Œç¡®ä¿ç¿»é¡µæ›´æ˜ç¡®
      
      // åªå…è®¸ä¸€æ¬¡ç¿»ä¸€é¡µ
      if (Math.abs(diffX) > swipeThreshold) {
        if (diffX > 0 && currentPage > 0) {
          // å‘å³æ»‘åŠ¨ï¼Œè¿”å›ä¸Šä¸€é¡µ
          currentPage--;
        } else if (diffX < 0 && currentPage < totalPages - 1) {
          // å‘å·¦æ»‘åŠ¨ï¼Œå‰å¾€ä¸‹ä¸€é¡µ
          currentPage++;
        }
      }
      updatePagination();
    };

    pagesContainer.addEventListener('mousedown', onDragStart);
    pagesContainer.addEventListener('mousemove', onDragMove);
    pagesContainer.addEventListener('mouseup', onDragEnd);
    pagesContainer.addEventListener('mouseleave', onDragEnd);


    pagesContainer.addEventListener('touchstart', onDragStart, {
      passive: false
    });
    pagesContainer.addEventListener('touchmove', onDragMove, {
      passive: false
    });
    pagesContainer.addEventListener('touchend', onDragEnd);
  }



  let editingPresetId = null;

  async function openPresetScreen() {
    await renderPresetScreen();
    showScreen('preset-screen');
  }


  async function renderPresetScreen() {
    const tabsContainer = document.getElementById('preset-tabs');
    const contentContainer = document.getElementById('preset-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const [presets, categories] = await Promise.all([
      db.presets.toArray(),
      db.presetCategories.orderBy('name').toArray()
    ]);

    state.presets = presets;

    if (presets.length === 0) {
      contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ç‚¹å‡»å³ä¸Šè§’ "+" åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªé¢„è®¾</p>';
      return;
    }


    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = 'å…¨éƒ¨';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);

    categories.forEach(category => {
      const categoryTab = document.createElement('button');
      categoryTab.className = 'world-book-tab';
      categoryTab.textContent = category.name;
      categoryTab.dataset.categoryId = String(category.id);
      tabsContainer.appendChild(categoryTab);

      const categoryPane = document.createElement('div');
      categoryPane.className = 'world-book-category-pane';
      categoryPane.dataset.categoryId = String(category.id);
      contentContainer.appendChild(categoryPane);
    });

    const hasUncategorized = presets.some(p => !p.categoryId);
    if (hasUncategorized) {
      const uncategorizedTab = document.createElement('button');
      uncategorizedTab.className = 'world-book-tab';
      uncategorizedTab.textContent = 'æœªåˆ†ç±»';
      uncategorizedTab.dataset.categoryId = 'uncategorized';
      tabsContainer.appendChild(uncategorizedTab);

      const uncategorizedPane = document.createElement('div');
      uncategorizedPane.className = 'world-book-category-pane';
      uncategorizedPane.dataset.categoryId = 'uncategorized';
      contentContainer.appendChild(uncategorizedPane);
    }


    presets.forEach(preset => {

      const contentPreview = `è¯¥é¢„è®¾åŒ…å« ${preset.content.length} ä¸ªæ¡ç›®ã€‚`;

      const card = document.createElement('div');
      card.className = 'world-book-card';
      card.innerHTML = `
            <div class="card-title">${preset.name}</div>
            <div class="card-content-preview">${contentPreview}</div>
        `;


      const cardClickHandler = () => openPresetEditor(preset.id);
      const cardLongPressHandler = async () => {
        const confirmed = await showCustomConfirm('åˆ é™¤é¢„è®¾', `ç¡®å®šè¦åˆ é™¤ã€Š${preset.name}ã€‹å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.presets.delete(preset.id);
          state.presets = await db.presets.toArray();
          renderPresetScreen();
        }
      };

      card.addEventListener('click', cardClickHandler);
      addLongPressListener(card, cardLongPressHandler);

      const clonedCardForAll = card.cloneNode(true);
      clonedCardForAll.addEventListener('click', cardClickHandler);
      addLongPressListener(clonedCardForAll, cardLongPressHandler);
      allPane.appendChild(clonedCardForAll);

      const categoryKey = preset.categoryId ? String(preset.categoryId) : 'uncategorized';
      const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
      if (targetPane) {
        targetPane.appendChild(card);
      }
    });



    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
      tab.addEventListener('click', () => switchPresetCategory(tab.dataset.categoryId));
    });
  }


  function switchPresetCategory(categoryId) {
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });
    document.querySelectorAll('#preset-content-container .world-book-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


  async function openPresetEditor(presetId) {

    showScreen('preset-editor-screen');
    editingPresetId = presetId;

    try {

      const [preset, categories] = await Promise.all([
        db.presets.get(presetId),
        db.presetCategories.toArray()
      ]);


      if (!preset) {
        console.error("é”™è¯¯ï¼šå°è¯•æ‰“å¼€ä¸€ä¸ªä¸å­˜åœ¨çš„é¢„è®¾ï¼ŒID:", presetId);
        await showCustomAlert("åŠ è½½å¤±è´¥", "æ‰¾ä¸åˆ°è¿™ä¸ªé¢„è®¾çš„è¯¦ç»†ä¿¡æ¯ã€‚");
        showScreen('preset-screen');
        return;
      }



      setTimeout(() => {

        document.getElementById('preset-editor-title').textContent = preset.name;
        document.getElementById('preset-name-input').value = preset.name;

        const selectEl = document.getElementById('preset-category-select');
        selectEl.innerHTML = '<option value="">-- æœªåˆ†ç±» --</option>';
        categories.forEach(cat => {
          const option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          if (preset.categoryId === cat.id) option.selected = true;
          selectEl.appendChild(option);
        });

        const entriesContainer = document.getElementById('preset-entries-container');
        entriesContainer.innerHTML = '';
        if (Array.isArray(preset.content) && preset.content.length > 0) {
          preset.content.forEach(entry => {
            const block = createPresetEntryBlock(entry);
            entriesContainer.appendChild(block);
          });
        } else {
          entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">è¿˜æ²¡æœ‰å†…å®¹ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€æ¡å§ï¼</p>';
        }
      }, 50);

    } catch (error) {
      console.error("æ‰“å¼€é¢„è®¾ç¼–è¾‘å™¨æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯:", error);
      await showCustomAlert("åŠ è½½å¤±è´¥", `åŠ è½½é¢„è®¾è¯¦æƒ…æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
      showScreen('preset-screen');
    }
  }


  function createPresetEntryBlock(entry = {
    keys: [],
    comment: '',
    content: '',
    enabled: true
  }) {
    const block = document.createElement('div');
    block.className = 'message-editor-block';
    const isChecked = entry.enabled !== false ? 'checked' : '';


    block.innerHTML = `
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
            <label class="toggle-switch" title="å¯ç”¨/ç¦ç”¨æ­¤æ¡ç›®">
                <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                <span class="slider"></span>
            </label>
            <button type="button" class="delete-block-btn" title="åˆ é™¤æ­¤æ¡ç›®">Ã—</button>
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">å¤‡æ³¨ (å¯é€‰)</label>
            <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="ä¾‹å¦‚ï¼šè§’è‰²æ ¸å¿ƒè®¾å®š" style="padding: 8px;">
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">å…³é”®è¯ (ç”¨è‹±æ–‡é€—å·,åˆ†éš”)</label>
            <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="ä¾‹å¦‚: key1, key2" style="padding: 8px;">
        </div>
        
        <!-- è¿™é‡Œæ˜¯å…¨æ–°çš„ã€å¸¦æœ‰â€œå±•å¼€/æ”¶èµ·â€æŒ‰é’®çš„ç»“æ„ -->
        <div class="form-group" style="margin-bottom: 0;">
            <label style="font-size: 0.8em; display: flex; justify-content: space-between; align-items: center;">
                <span>å†…å®¹ (ç‚¹å‡»å³ä¾§å±•å¼€)</span>
                <button type="button" class="toggle-content-btn">å±•å¼€</button>
            </label>
            <div class="entry-content-container">
                 <textarea class="entry-content-textarea" rows="8" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
            </div>
        </div>
    `;



    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());


    const toggleBtn = block.querySelector('.toggle-content-btn');
    const contentContainer = block.querySelector('.entry-content-container');
    toggleBtn.addEventListener('click', () => {
      const isHidden = contentContainer.style.display === 'none';
      contentContainer.style.display = isHidden ? 'block' : 'none';
      toggleBtn.textContent = isHidden ? 'æ”¶èµ·' : 'å±•å¼€';
    });

    return block;
  }


  async function openPresetCategoryManager() {
    await renderPresetCategoriesInManager();

    document.querySelector('#group-management-modal .modal-header span').textContent = 'ç®¡ç†é¢„è®¾åˆ†ç±»';
    document.getElementById('add-new-group-btn').onclick = addNewPresetCategory;
    document.getElementById('existing-groups-list').onclick = (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deletePresetCategory(parseInt(e.target.dataset.id));
      }
    };
    document.getElementById('close-group-manager-btn').onclick = () => {
      document.getElementById('group-management-modal').classList.remove('visible');
      renderPresetScreen();
    };
    document.getElementById('group-management-modal').classList.add('visible');
  }

  async function renderPresetCategoriesInManager() {
    const listEl = document.getElementById('existing-groups-list');
    const categories = await db.presetCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `<span class="group-name">${cat.name}</span><span class="delete-group-btn" data-id="${cat.id}">Ã—</span>`;
      listEl.appendChild(item);
    });
  }

  async function addNewPresetCategory() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) return alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
    const existing = await db.presetCategories.where('name').equals(name).first();
    if (existing) return alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
    await db.presetCategories.add({
      name
    });
    input.value = '';
    await renderPresetCategoriesInManager();
  }

  async function deletePresetCategory(categoryId) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç±»åï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰é¢„è®¾å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šå—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.presetCategories.delete(categoryId);
      await db.presets.where('categoryId').equals(categoryId).modify({
        categoryId: null
      });


      state.presets = await db.presets.toArray();


      await renderPresetCategoriesInManager();
    }
  }



  async function handlePresetImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      if (!file.name.endsWith('.json')) {
        throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒã€‚è¯·é€‰æ‹© .json æ ¼å¼çš„ Tavern é¢„è®¾æ–‡ä»¶ã€‚");
      }

      const text = await file.text();
      const tavernData = JSON.parse(text);


      await importTavernPresetFile(tavernData, file.name);

    } catch (error) {
      console.error("é¢„è®¾å¯¼å…¥å¤±è´¥:", error);
      await showCustomAlert("å¯¼å…¥å¤±è´¥", `æ— æ³•è§£æé¢„è®¾æ–‡ä»¶ã€‚\né”™è¯¯: ${error.message}`);
    } finally {

      event.target.value = null;
    }
  }


  async function importTavernPresetFile(tavernData, fileName) {
    let newEntries = [];




    if (Array.isArray(tavernData.prompts) && Array.isArray(tavernData.prompt_order) && tavernData.prompt_order.length > 0) {
      console.log("æ£€æµ‹åˆ° Tavern/SillyTavern é¢„è®¾æ ¼å¼ï¼Œå°†ä¸¥æ ¼æŒ‰ç…§ prompt_order æ’åºã€‚");


      const promptsMap = new Map(tavernData.prompts.map(p => [p.identifier, p]));


      const orderArray = tavernData.prompt_order.reduce((acc, curr) => (
        (curr.order && curr.order.length > (acc.length || 0)) ? curr.order : acc
      ), []);

      if (orderArray && orderArray.length > 0) {
        newEntries = orderArray
          .map(orderItem => {

            const promptData = promptsMap.get(orderItem.identifier);
            if (promptData) {

              return {
                keys: [],
                comment: promptData.name || 'æ— æ ‡é¢˜',
                content: promptData.content || '',

                enabled: orderItem.enabled
              };
            }
            return null;
          })
          .filter(Boolean);
      }
    } else if (tavernData.entries && typeof tavernData.entries === 'object') {
      console.log("æ£€æµ‹åˆ° 'entries' å¯¹è±¡æ ¼å¼çš„é¢„è®¾ï¼Œå°†å°è¯•æŒ‰é¡ºåºå¯¼å…¥ã€‚");
      if (Array.isArray(tavernData.order)) {
        console.log("æ£€æµ‹åˆ° 'order' å­—æ®µï¼Œå°†æŒ‰æŒ‡å®šé¡ºåºå¯¼å…¥æ¡ç›®ã€‚");
        newEntries = tavernData.order
          .map(key => tavernData.entries[key])
          .filter(Boolean)
          .map(entry => ({
            keys: entry.key || [],
            comment: entry.comment || 'æ— å¤‡æ³¨',
            content: entry.content || '',
            enabled: !entry.disable
          }));
      } else {
        console.warn("æœªåœ¨æ–‡ä»¶ä¸­æ‰¾åˆ° 'order' å­—æ®µï¼Œæ¡ç›®å¯èƒ½æ— æ³•æŒ‰åŸå§‹é¡ºåºå¯¼å…¥ã€‚");
        newEntries = Object.values(tavernData.entries).map(entry => ({
          keys: entry.key || [],
          comment: entry.comment || 'æ— å¤‡æ³¨',
          content: entry.content || '',
          enabled: !entry.disable
        }));
      }
    } else if (Array.isArray(tavernData.prompts)) {
      console.log("æ£€æµ‹åˆ°ç®€å•çš„ 'prompts' æ•°ç»„æ ¼å¼ï¼Œå°†æŒ‰æ•°ç»„å†…é¡ºåºå¯¼å…¥ã€‚");
      newEntries = tavernData.prompts.map(prompt => ({
        keys: [],
        comment: prompt.name || 'æ— æ ‡é¢˜',
        content: prompt.content || '',
        enabled: true
      }));
    } else {
      throw new Error("æ–‡ä»¶æ ¼å¼æ— æ³•è¯†åˆ«ã€‚æœªæ‰¾åˆ°æœ‰æ•ˆçš„ 'prompts' æ•°ç»„æˆ– 'entries' å¯¹è±¡ã€‚");
    }



    newEntries = newEntries.filter(entry => entry.content);

    if (newEntries.length === 0) {
      alert("è¿™ä¸ªé¢„è®¾æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆçš„æç¤ºè¯æ¡ç›®ã€‚");
      return;
    }


    const presetNameSuggestion = fileName.replace(/\.json$/i, '');
    const newPresetName = await showCustomPrompt("å¯¼å…¥ Tavern é¢„è®¾", "è¯·ä¸ºè¿™ç»„æç¤ºè¯é¢„è®¾å‘½åï¼š", presetNameSuggestion);
    if (!newPresetName || !newPresetName.trim()) {
      alert("å¯¼å…¥å·²å–æ¶ˆï¼Œå› ä¸ºæœªæä¾›åç§°ã€‚");
      return;
    }

    const newPreset = {
      id: 'preset_' + Date.now(),
      name: newPresetName.trim(),
      content: newEntries,
      categoryId: null
    };

    await db.presets.add(newPreset);
    state.presets.push(newPreset);

    await renderPresetScreen();
    await showCustomAlert('å¯¼å…¥æˆåŠŸï¼', `å·²æˆåŠŸä»æ–‡ä»¶å¯¼å…¥é¢„è®¾ã€Š${newPresetName}ã€‹ã€‚`);
  }



  async function renderOfflinePresetSelector(chat) {
    const selectEl = document.getElementById('offline-preset-select');
    if (!selectEl) return;


    const presets = state.presets || [];


    selectEl.innerHTML = '<option value="">-- ä¸ä½¿ç”¨é¢„è®¾ --</option>';
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });


    if (chat.settings.offlinePresetId) {
      selectEl.value = chat.settings.offlinePresetId;
    }
  }


  function renderButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    editor.innerHTML = '';



    let buttonOrder = state.globalSettings.chatActionButtonsOrder || DEFAULT_BUTTON_ORDER;

    buttonOrder.forEach(buttonId => {
      const originalButton = document.getElementById(buttonId);
      if (originalButton) {
        const item = document.createElement('div');
        item.className = 'draggable-button-item';
        item.draggable = true;
        item.dataset.buttonId = buttonId;
        item.innerHTML = originalButton.innerHTML;
        editor.appendChild(item);
      }
    });
  }



  function initializeButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    let draggingItem = null;


    const handleDragStart = (e) => {
      const target = e.target.closest('.draggable-button-item');
      if (!target) return;

      draggingItem = target;
      draggingItem.classList.add('dragging');


      if (e.cancelable) e.preventDefault();
    };

    const handleDragMove = (e) => {
      if (!draggingItem) return;


      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;

      const afterElement = getDragAfterElement(editor, clientX);

      if (afterElement == null) {
        editor.appendChild(draggingItem);
      } else {
        editor.insertBefore(draggingItem, afterElement);
      }
    };

    const handleDragEnd = () => {
      if (!draggingItem) return;

      draggingItem.classList.remove('dragging');
      draggingItem = null;


      saveButtonOrder();
    };



    editor.addEventListener('mousedown', handleDragStart);
    editor.addEventListener('touchstart', handleDragStart, {
      passive: false
    });


    editor.addEventListener('mousemove', handleDragMove);
    editor.addEventListener('touchmove', handleDragMove, {
      passive: false
    });


    editor.addEventListener('mouseup', handleDragEnd);
    editor.addEventListener('mouseleave', handleDragEnd);
    editor.addEventListener('touchend', handleDragEnd);
  }



  function getDragAfterElement(container, x) {

    const draggableElements = [...container.querySelectorAll('.draggable-button-item:not(.dragging)')];


    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();

      const offset = x - box.left - box.width / 2;


      if (offset < 0 && offset > closest.offset) {
        return {
          offset: offset,
          element: child
        };
      } else {
        return closest;
      }
    }, {
      offset: Number.NEGATIVE_INFINITY
    }).element;
  }


  async function saveButtonOrder() {
    const editor = document.getElementById('button-order-editor');
    const newOrder = Array.from(editor.querySelectorAll('.draggable-button-item')).map(item => item.dataset.buttonId);

    state.globalSettings.chatActionButtonsOrder = newOrder;
    await db.globalSettings.put(state.globalSettings);



  }

 
  function applyButtonOrder() {
    const buttonOrder = state.globalSettings.chatActionButtonsOrder;
    if (!buttonOrder || !Array.isArray(buttonOrder) || buttonOrder.length === 0) {
      return;
    }

    const container = document.getElementById('chat-input-actions-top');
    if (!container) return;


    buttonOrder.forEach(buttonId => {
      const button = document.getElementById(buttonId);
      if (button) {
        container.appendChild(button);
      }
    });
  }



  const DEFAULT_BUTTON_ORDER = [
    'open-sticker-panel-btn', 'send-photo-btn', 'camera-capture-btn', 'upload-image-btn',
    'transfer-btn', 'voice-message-btn', 'send-waimai-request-btn',
    'video-call-btn', 'group-video-call-btn', 'send-poll-btn',
    'share-link-btn', 'share-location-btn', 'gomoku-btn',
    'open-shopping-btn', 'pat-btn', 'edit-last-response-btn',
    'regenerate-btn', 'propel-btn', 'show-announcement-board-btn',
    'werewolf-game-btn',

    'read-together-btn',
    'open-nai-gallery-btn',
    'open-todo-list-btn',
    'open-quick-reply-btn',
    'stop-api-call-btn'
  ];


  async function resetButtonOrder() {

    state.globalSettings.chatActionButtonsOrder = null;
    await db.globalSettings.put(state.globalSettings);


    renderButtonOrderEditor();


    applyButtonOrder();


    await showCustomAlert("æˆåŠŸ", "æŒ‰é’®é¡ºåºå·²æ¢å¤ä¸ºé»˜è®¤è®¾ç½®ï¼");
  }





  let selectedCharsForClear = [];
  let selectedTypesForClear = [];


  function openDataClearWizard() {
    const modal = document.getElementById('data-clear-wizard-modal');
    selectedCharsForClear = [];
    selectedTypesForClear = [];


    renderClearWizardStep1();


    document.getElementById('data-clear-step-1').style.display = 'flex';
    document.getElementById('data-clear-step-2').style.display = 'none';

    modal.classList.add('visible');
  }


  function renderClearWizardStep1() {
    const listEl = document.getElementById('data-clear-char-list');
    listEl.innerHTML = '';


    const userItem = document.createElement('div');
    userItem.className = 'clear-posts-item';
    userItem.dataset.charId = 'user';
    userItem.innerHTML = `
        <div class="checkbox"></div>
        <span class="name">${state.qzoneSettings.nickname || 'æˆ‘'} (ç”¨æˆ·)</span>
    `;
    listEl.appendChild(userItem);


    Object.values(state.chats).forEach(chat => {
      if (!chat.isGroup) {
        const charItem = document.createElement('div');
        charItem.className = 'clear-posts-item';
        charItem.dataset.charId = chat.id;
        charItem.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${chat.name} (è§’è‰²)</span>
            `;
        listEl.appendChild(charItem);
      }
    });
  }


  function renderClearWizardStep2() {
    const listEl = document.getElementById('data-clear-type-list');
    listEl.innerHTML = '';

    const dataTypes = [{
        id: 'chat',
        name: 'èŠå¤©è®°å½•',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰å¯¹è¯æ¶ˆæ¯ã€æ›¾ç”¨å¤‡æ³¨å’Œä½ çš„æ˜µç§°ã€‚'
      },
      {
        id: 'qzone',
        name: 'åŠ¨æ€ä¸äº’åŠ¨',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰åŠ¨æ€ã€è¯„è®ºå’Œç‚¹èµã€‚'
      },
      {
        id: 'calls',
        name: 'é€šè¯è®°å½•',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰é€šè¯è®°å½•ã€‚'
      },
      {
        id: 'thoughts',
        name: 'å¿ƒå£°',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„å¿ƒå£°å’Œæ•£è®°å†å²ã€‚'
      },
      {
        id: 'memories',
        name: 'é•¿æœŸè®°å¿†',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„æ‰€æœ‰é•¿æœŸè®°å¿†ã€‚'
      },
      {
        id: 'favorites',
        name: 'æ”¶è—',
        description: 'å°†æ¸…ç©ºæ”¶è—å¤¹ä¸­æ‰€æœ‰ä¸è¯¥è§’è‰²ç›¸å…³çš„å†…å®¹ï¼ˆå¦‚èŠå¤©ã€åŠ¨æ€ã€æ—¥è®°ç­‰ï¼‰ã€‚'
      },
      {
        id: 'cphone',
        name: 'Cphoneæ•°æ® (CPhone)',
        description: 'å°†æ¸…ç©ºè§’è‰²çš„ç›¸å†Œã€QQã€æµè§ˆå™¨ã€æ·˜å®ã€æ—¥è®°ã€å¤‡å¿˜å½•ç­‰æ‰€æœ‰æ¨¡æ‹Ÿæ‰‹æœºæ•°æ®ã€‚'
      },
      {
        id: 'todo',
        name: 'å¾…åŠäº‹é¡¹ (To-Do)',
        description: 'å°†æ¸…ç©ºé€‰å®šè§’è‰²çš„å¾…åŠäº‹é¡¹æ¸…å•ã€‚(è‹¥ç¬¬ä¸€æ­¥é€‰â€œæˆ‘â€ï¼Œåˆ™æ¸…é™¤æ‰€æœ‰è§’è‰²ä¸­ç”±â€œæˆ‘â€åˆ›å»ºçš„å¾…åŠ)'
      },
       {
            id: 'alipay_bills',
            name: 'æ”¯ä»˜å®è´¦å• (Alipay)',
            description: 'å°†æ¸…ç©ºæ”¯ä»˜å®çš„æ‰€æœ‰äº¤æ˜“æµæ°´ã€è½¬è´¦è®°å½•å’ŒåŸºé‡‘ä¹°å–è®°å½•ã€‚(ä»…åœ¨ç¬¬ä¸€æ­¥é€‰æ‹©â€œæˆ‘â€æ—¶ç”Ÿæ•ˆ)'
        }
    ];

    dataTypes.forEach(type => {
      const item = document.createElement('div');
      item.className = 'clear-posts-item';
      item.dataset.typeId = type.id;
      item.innerHTML = `
                    <div class="checkbox"></div>
                    <div>
                        <span class="name">${type.name}</span>
                        <p style="font-size: 12px; color: #888; margin: 4px 0 0;">${type.description}</p>
                    </div>
                `;
      listEl.appendChild(item);
    });
  }



  function handleDataClearNext() {
    const selectedItems = document.querySelectorAll('#data-clear-char-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦æ¸…ç†çš„è§’è‰²ã€‚");
      return;
    }

    selectedCharsForClear = Array.from(selectedItems).map(item => item.dataset.charId);


    renderClearWizardStep2();
    document.getElementById('data-clear-step-1').style.display = 'none';
    document.getElementById('data-clear-step-2').style.display = 'flex';
  }


  function handleDataClearBack() {
    document.getElementById('data-clear-step-2').style.display = 'none';
    document.getElementById('data-clear-step-1').style.display = 'flex';

    document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
      if (selectedCharsForClear.includes(item.dataset.charId)) {
        item.classList.add('selected');
      }
    });
  }


  async function handleConfirmDataClear() {
    const selectedItems = document.querySelectorAll('#data-clear-type-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¦æ¸…ç†çš„æ•°æ®ç±»å‹ã€‚");
      return;
    }

    selectedTypesForClear = Array.from(selectedItems).map(item => item.dataset.typeId);

    const confirmed = await showCustomConfirm(
      'æœ€åç¡®è®¤ï¼',
      'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‚¨é€‰æ‹©çš„æ‰€æœ‰æ•°æ®ï¼Œä¸”æ— æ³•æ¢å¤ï¼ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤åˆ é™¤'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œæ¸…ç†æ“ä½œï¼Œè¯·ä¸è¦å…³é—­é¡µé¢...");

    try {
      await db.transaction('rw', db.tables, async () => {
        for (const charId of selectedCharsForClear) {
          for (const type of selectedTypesForClear) {
            if (type === 'todo') {
                if (charId === 'user') {
                    // å¦‚æœç¬¬ä¸€æ­¥é€‰çš„æ˜¯â€œæˆ‘ (ç”¨æˆ·)â€ï¼Œåˆ™éå†æ‰€æœ‰èŠå¤©ï¼Œåªåˆ é™¤ creator ä¸º 'user' çš„å¾…åŠ
                    const allChats = await db.chats.toArray();
                    for (const chat of allChats) {
                        if (chat.todoList && chat.todoList.length > 0) {
                            const originalLength = chat.todoList.length;
                            // è¿‡æ»¤æ‰ç”¨æˆ·åˆ›å»ºçš„ï¼Œä¿ç•™AIåˆ›å»ºçš„
                            chat.todoList = chat.todoList.filter(t => t.creator !== 'user');
                            
                            if (chat.todoList.length < originalLength) {
                                await db.chats.put(chat);
                            }
                        }
                    }
                    console.log("å·²æ¸…ç†æ‰€æœ‰ç”±ç”¨æˆ·åˆ›å»ºçš„å¾…åŠäº‹é¡¹");
                } else {
                    // å¦‚æœé€‰çš„æ˜¯å…·ä½“è§’è‰²ï¼Œç›´æ¥æ¸…ç©ºè¯¥è§’è‰²çš„å¾…åŠåˆ—è¡¨ (todoList)
                    const chat = await db.chats.get(charId);
                    if (chat) {
                        chat.todoList = []; // ç›´æ¥ç½®ç©º
                        await db.chats.put(chat);
                        console.log(`å·²æ¸…ç©ºè§’è‰² ${chat.name} çš„å¾…åŠäº‹é¡¹`);
                    }
                }
            }
            if (type === 'alipay_bills') {
                // åªæœ‰å½“ç¬¬ä¸€æ­¥é€‰æ‹©äº†â€œæˆ‘(ç”¨æˆ·)â€æ—¶ï¼Œæ‰æ‰§è¡Œæ¸…ç©ºï¼Œé˜²æ­¢è¯¯æ“ä½œ
                if (charId === 'user') {
                    await db.userTransactions.clear(); // æ¸…ç©ºè´¦å•è¡¨
                    console.log("æ”¯ä»˜å®è´¦å•å·²å…¨éƒ¨æ¸…ç©º");
                    
                    // å¯é€‰ï¼šå¦‚æœä½ è¿˜æƒ³é‡ç½®é’±åŒ…ä½™é¢å’ŒåŸºé‡‘æŒä»“ï¼Œå¯ä»¥è§£å¼€ä¸‹é¢æ³¨é‡Š
                    /*
                    const wallet = await db.userWallet.get('main');
                    if(wallet) {
                        wallet.balance = 0; // é‡ç½®ä½™é¢
                        wallet.fundHoldings = []; // é‡ç½®åŸºé‡‘
                        await db.userWallet.put(wallet);
                    }
                    */
                } else {
                    // å¦‚æœé€‰æ‹©äº†æŸä¸ªè§’è‰²ï¼Œå°è¯•åˆ é™¤è¯¥è§’è‰²åå­—ç›¸å…³çš„è´¦å•(æ¨¡ç³ŠåŒ¹é…)
                    // æ³¨æ„ï¼šè¿™ä¾èµ–äºdescriptionåŒ…å«è§’è‰²åï¼Œå¯èƒ½ä¸å®Œå…¨å‡†ç¡®ï¼Œå»ºè®®åªç”¨ä¸Šé¢çš„æ¸…ç©ºå…¨éƒ¨
                    const chat = await db.chats.get(charId);
                    if (chat) {
                        const nameKeys = [chat.name, chat.originalName];
                        // è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒè€—æ—¶çš„è¿‡æ»¤åˆ é™¤ï¼Œä½†å¯¹äºæ¸…ç†ç‰¹å®šè§’è‰²æµæ°´å¾ˆæœ‰ç”¨
                        await db.userTransactions
                            .filter(t => nameKeys.some(k => t.description && t.description.includes(k)))
                            .delete();
                    }
                }
            }
            if (type === 'chat') {
              if (charId === 'user') {
                const allChats = await db.chats.toArray();
                for (const chat of allChats) {
                  chat.history = chat.history.filter(msg => msg.role !== 'user');
                  await db.chats.put(chat);
                }
              } else {
                const chat = await db.chats.get(charId);
                if (chat) {
                  chat.history = [];
                  chat.heartfeltVoice = '...';
                  chat.randomJottings = '...';
                  if (Array.isArray(chat.nameHistory)) {
                    chat.nameHistory = [];
                  }
                  if (chat.settings) {
                    chat.settings.myNickname = 'æˆ‘';
                  }
                  await db.chats.put(chat);
                }
              }
            }

            if (type === 'qzone') {
              const authorId = (charId === 'user') ? 'user' : charId;
              await db.qzonePosts.where('authorId').equals(authorId).delete();
            }

            if (type === 'calls' && charId !== 'user') {
              await db.callRecords.where('chatId').equals(charId).delete();
            }

            if (type === 'thoughts' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.thoughtsHistory = [];
                chat.heartfeltVoice = '...';
                chat.randomJottings = '...';
                await db.chats.put(chat);
              }
            }

            if (type === 'memories' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.longTermMemory = [];
                await db.chats.put(chat);
              }
            }


            if (type === 'favorites') {
              if (charId === 'user') {

                await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === 'user').delete();

                await db.favorites.where('type').equals('chat_message').filter(fav => fav.content.role === 'user').delete();
              } else {

                await db.favorites.where('type').equals('chat_message').and(fav => fav.chatId === charId).delete();

                await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === charId).delete();

                await db.favorites.where('type').equals('char_diary').filter(fav => fav.content.characterId === charId).delete();
                await db.favorites.where('type').equals('char_browser_article').filter(fav => fav.content.characterId === charId).delete();
                await db.favorites.where('type').equals('char_memo').filter(fav => fav.content.characterId === charId).delete();
              }
            }


            if (type === 'cphone' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.simulatedAlbum = [];
                chat.simulatedConversations = [];
                chat.simulatedBrowserHistory = [];
                chat.simulatedTaobaoHistory = null;
                chat.simulatedAmapHistory = [];
                chat.simulatedAppUsage = [];
                chat.simulatedMusicPlaylist = [];
                chat.diary = [];
                chat.memos = [];
                await db.chats.put(chat);
              }
            }
          }
        }
      });

      await loadAllDataFromDB();
      await renderChatList();
      const alipayScreen = document.getElementById('alipay-screen');
      if (alipayScreen && alipayScreen.classList.contains('active')) {
          // å¦‚æœä½ ä¹‹å‰å®šä¹‰äº† loadBills å‡½æ•°
          if (typeof loadBills === 'function') {
              await loadBills(true); // true ä»£è¡¨é‡ç½®å¹¶é‡æ–°åŠ è½½
          }
          // åŒæ—¶æ›´æ–°ä½™é¢æ˜¾ç¤ºï¼ˆå¦‚æœåˆšæ‰è§£å¼€äº†é‡ç½®ä½™é¢çš„æ³¨é‡Šï¼‰
          if (window.userBalance !== undefined) {
             const wallet = await db.userWallet.get('main');
             if(wallet) {
                 window.userBalance = wallet.balance;
                 document.getElementById('alipay-balance-display').textContent = window.userBalance.toFixed(2);
             }
          }
      }
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
      await showCustomAlert("æ¸…ç†å®Œæˆ", "æŒ‡å®šçš„æ•°æ®å·²æˆåŠŸæ¸…é™¤ã€‚");

    } catch (error) {
      console.error("é«˜çº§æ•°æ®æ¸…ç†å¤±è´¥:", error);
      await showCustomAlert("æ¸…ç†å¤±è´¥", `æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }

  async function handleIconChange(iconId, phoneType, itemElement) {
    const appName = itemElement.querySelector('.icon-preview').alt;

    const choice = await showChoiceModal(`æ›´æ¢â€œ${appName}â€å›¾æ ‡`, [
        { text: 'ğŸ“ ä»æœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ğŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' },
        { text: 'ğŸ”„ é‡ç½®ä¸ºé»˜è®¤', value: 'reset' }
    ]);

    // å¤„ç†é‡ç½®é€»è¾‘
    if (choice === 'reset') {
        const iconElement = itemElement.querySelector('.icon-preview');
        const defaultSrc = iconElement.dataset.defaultSrc;
        
        if (defaultSrc) {
            // æ¢å¤åˆ°é»˜è®¤å›¾æ ‡
            iconElement.src = defaultSrc;
            
            // ä»å¯¹åº”çš„æ•°æ®åº“å¯¹è±¡ä¸­åˆ é™¤è¯¥è®°å½•
            if (phoneType === 'cphone') {
                if (state.globalSettings.cphoneAppIcons && state.globalSettings.cphoneAppIcons[iconId]) {
                    delete state.globalSettings.cphoneAppIcons[iconId];
                }
            } else if (phoneType === 'myphone') {
                if (state.globalSettings.myphoneAppIcons && state.globalSettings.myphoneAppIcons[iconId]) {
                    delete state.globalSettings.myphoneAppIcons[iconId];
                }
            } else {
                if (state.globalSettings.appIcons && state.globalSettings.appIcons[iconId]) {
                    delete state.globalSettings.appIcons[iconId];
                }
            }
            
            await db.globalSettings.put(state.globalSettings);
            await showCustomAlert("æˆåŠŸ", "å·²é‡ç½®ä¸ºé»˜è®¤å›¾æ ‡ï¼");
        } else {
            await showCustomAlert("æç¤º", "æœªæ‰¾åˆ°é»˜è®¤å›¾æ ‡ï¼Œæ— æ³•é‡ç½®ã€‚");
        }
        return;
    }

    let newUrl = null;
    let isBase64 = false;

    if (choice === 'local') {
        newUrl = await new Promise(resolve => { // ç®€åŒ–ç‰ˆ uploadImageLocally
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
        
    } else if (choice === 'url') {
        let currentUrl;
        if (phoneType === 'cphone') {
            currentUrl = state.globalSettings.cphoneAppIcons[iconId];
        } else if (phoneType === 'myphone') {
            currentUrl = state.globalSettings.myphoneAppIcons[iconId];
        } else {
            currentUrl = state.globalSettings.appIcons[iconId];
        }
        const isCurrentUrlBase64 = currentUrl && currentUrl.startsWith('data:image'); 
        
        const initialValueForPrompt = isCurrentUrlBase64 ? '' : currentUrl;
        
        newUrl = await showCustomPrompt(`æ›´æ¢å›¾æ ‡`, 'è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URL', initialValueForPrompt, 'url');
        
     
        if (newUrl) isBase64 = false;
    }

    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        
        itemElement.querySelector('.icon-preview').src = trimmedUrl;

       
        let dbPath;
        if (phoneType === 'cphone') {
            dbPath = `cphoneAppIcons.${iconId}`;
            state.globalSettings.cphoneAppIcons[iconId] = trimmedUrl;
        } else if (phoneType === 'myphone') {
            dbPath = `myphoneAppIcons.${iconId}`;
            state.globalSettings.myphoneAppIcons[iconId] = trimmedUrl;
        } else {
            dbPath = `appIcons.${iconId}`;
            state.globalSettings.appIcons[iconId] = trimmedUrl;
        }
        await db.globalSettings.put(state.globalSettings);
        await showCustomAlert("æˆåŠŸ", "å›¾æ ‡å·²æ›´æ–°ï¼");

        
        if (isBase64) {
            (async () => {
                console.log(`[ImgBB] å¯åŠ¨ ${dbPath} çš„é™é»˜ä¸Šä¼ ...`);
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    dbPath,
                    trimmedUrl // The Base64 string
                );
            })();
        }
    } else if (newUrl !== null) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„URLæˆ–é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼");
    }
  }


  async function compressAllLocalImages() {

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤å‹ç¼©å›¾ç‰‡ï¼Ÿ',
      'æ­¤æ“ä½œå°†æ‰«æå¹¶å‹ç¼©æ‰€æœ‰æœ¬åœ°ä¸Šä¼ çš„å›¾ç‰‡ï¼ˆBase64æ ¼å¼ï¼‰ï¼Œå°†å…¶è½¬æ¢ä¸ºJPEGä»¥å‡å°ä½“ç§¯ã€‚è¿™ä¼šè½»å¾®é™ä½å›¾ç‰‡è´¨é‡ä¸”ã€ä¸å¯æ¢å¤ã€‘ã€‚<br><br><strong>å¼ºçƒˆå»ºè®®åœ¨æ“ä½œå‰å…ˆè¿›è¡Œæ•°æ®å¤‡ä»½ï¼</strong>', {
        confirmButtonClass: 'btn-danger',
        confirmText: 'æˆ‘å·²äº†è§£é£é™©ï¼Œç¡®è®¤å‹ç¼©'
      }
    );

    if (!confirmed) return;


    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨å¼€å§‹å…¨é¢å‹ç¼©å›¾ç‰‡ï¼Œæ ¹æ®å›¾ç‰‡æ•°é‡ï¼Œè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ï¼Œè¯·ä¸è¦å…³é—­æˆ–åˆ·æ–°é¡µé¢...");

    let stats = {
      found: 0,
      compressed: 0,
      skipped: 0,
      originalSize: 0,
      newSize: 0
    };

    try {





      console.log("å‹ç¼©æ­¥éª¤ 1/3: æ­£åœ¨ä»æ•°æ®åº“è¯»å–æ‰€æœ‰ç›¸å…³æ•°æ®...");
      const tablesToScan = [
        'chats', 'globalSettings', 'qzoneSettings',
        'userStickers', 'customAvatarFrames'
      ];
      const allData = [];
      for (const tableName of tablesToScan) {
        const table = db.table(tableName);
        const records = await table.toArray();
        allData.push({
          tableName,
          records
        });
      }


      console.log("å‹ç¼©æ­¥éª¤ 2/3: æ­£åœ¨å†…å­˜ä¸­å¼‚æ­¥å‹ç¼©å›¾ç‰‡ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´...");
      for (const data of allData) {
        for (const record of data.records) {

          await traverseAndCompress(record, stats);
        }
      }


      console.log("å‹ç¼©æ­¥éª¤ 3/3: æ­£åœ¨å°†å‹ç¼©åçš„æ•°æ®å†™å›æ•°æ®åº“...");
      await db.transaction('rw', tablesToScan, async () => {
        for (const data of allData) {

          await db.table(data.tableName).bulkPut(data.records);
        }
      });






      const reduction = stats.originalSize - stats.newSize;
      const reductionPercent = stats.originalSize > 0 ? (reduction / stats.originalSize * 100).toFixed(2) : 0;

      await showCustomAlert(
        'å‹ç¼©å®Œæˆï¼',
        `æ‰«æå®Œæˆï¼<br>
            - å…±æ‰¾åˆ° ${stats.found} å¼ æœ¬åœ°å›¾ç‰‡<br>
            - æˆåŠŸå‹ç¼© ${stats.compressed} å¼ <br>
            - è·³è¿‡(å·²å‹ç¼©æˆ–æ— éœ€å‹ç¼©) ${stats.skipped} å¼ <br>
            - ç©ºé—´èŠ‚çœäº† <strong>${(reduction / 1024 / 1024).toFixed(2)} MB</strong> (å‹ç¼©ç‡ ${reductionPercent}%)
            <br><br>
            å»ºè®®åˆ·æ–°é¡µé¢ä»¥åº”ç”¨æ‰€æœ‰æ›´æ”¹ã€‚`
      );

    } catch (error) {
      console.error("å›¾ç‰‡å‹ç¼©è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
      await showCustomAlert('å‹ç¼©å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }

  function calculateTotalSizeRecursive(obj, parentKey = '') {
    let totalSize = 0;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (typeof value === 'string' && value.startsWith('data:image')) {

     
          const isExcluded =
          
            (parentKey === 'globalSettings' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
        
            (parentKey === 'widgetData') ||
      
            (parentKey === 'settings' && key === 'background') ||
       
            (parentKey === 'appIcons' || parentKey === 'cphoneAppIcons' || parentKey === 'myphoneAppIcons');

          if (!isExcluded) {
            totalSize += value.length;
          }
      

        } else if (typeof value === 'object' && value !== null) {
        
          totalSize += calculateTotalSizeRecursive(value, key);
        }
      }
    }
    return totalSize;
  }


  async function displayTotalImageSize() {
    const displayElement = document.getElementById('total-image-size-display');
    if (!displayElement) return;

    displayElement.innerHTML = `
        <span id="image-size-label">æ­£åœ¨è®¡ç®—å¯å‹ç¼©å›¾ç‰‡å¤§å°...</span>
        <span id="image-size-value">-- MB</span>
    `;

    try {
      let totalBytes = 0;
      const tablesToScan = [
        'chats', 'globalSettings', 'qzoneSettings',
        'userStickers', 'customAvatarFrames'
      ];

      for (const tableName of tablesToScan) {
        const table = db.table(tableName);
        await table.each(record => {

          totalBytes += calculateTotalSizeRecursive(record);
        });
      }

      const totalMB = (totalBytes / 1024 / 1024).toFixed(2);

      displayElement.innerHTML = `
            <span id="image-size-label">æœ¬åœ°å›¾ç‰‡(å¤´åƒ/è¡¨æƒ…/å¤´åƒæ¡†/ç­‰)å¤§å°:</span>
            <span id="image-size-value"><strong>${totalMB} MB</strong></span>
        `;

    } catch (error) {
      console.error("è®¡ç®—å›¾ç‰‡æ€»å¤§å°æ—¶å‡ºé”™:", error);
      displayElement.innerHTML = `
            <span id="image-size-label">è®¡ç®—å›¾ç‰‡å¤§å°æ—¶å‡ºé”™</span>
            <span id="image-size-value">Error</span>
        `;
    }
  }

function calculateSkippedStats(obj) {
    let found = 0;
    let size = 0;
    if (typeof obj !== 'object' || obj === null) return {
        found,
        size
    };

    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const value = obj[key];
            if (typeof value === 'string' && value.startsWith('data:image')) {
                found++;
                size += value.length;
            } else if (typeof value === 'object' && value !== null) {
                const nestedStats = calculateSkippedStats(value);
                found += nestedStats.found;
                size += nestedStats.size;
            }
        }
    }
    return {
        found,
        size
    };
}

 async function traverseAndCompress(obj, stats, parentKey = '') {
    
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            
          
            if (parentKey === '' && (key === 'widgetData' || key === 'appIcons' || key === 'cphoneAppIcons' || key === 'myphoneAppIcons')) {
                console.log(`è·³è¿‡å‹ç¼©æ•´ä¸ªå¯¹è±¡: ${key}`);
                const {
                    found,
                    size
                } = calculateSkippedStats(obj[key]);
                stats.found += found;
                stats.skipped += found;
                stats.originalSize += size;
                stats.newSize += size;
                continue; 
            }

            const value = obj[key];

          
            if (typeof value === 'string' && value.startsWith('data:image')) {

               
                const isExcluded =
                    
                    (parentKey === '' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
                   
                    (parentKey === 'settings' && key === 'background');

                if (isExcluded) {
                    console.log(`è·³è¿‡å‹ç¼©èƒŒæ™¯å›¾ç‰‡: ${parentKey || 'global'}.${key}`);
                    stats.found++;
                    stats.skipped++;
                    stats.originalSize += value.length;
                    stats.newSize += value.length;
                    continue; 
                }

                stats.found++;
                stats.originalSize += value.length;
                
                const compressedBase64 = await compressImage(value);
                if (compressedBase64 && compressedBase64 !== value) {
                    obj[key] = compressedBase64;
                    stats.compressed++;
                    stats.newSize += compressedBase64.length;
                } else {
                    stats.skipped++;
                    stats.newSize += value.length;
                }
            

            } else if (typeof value === 'object' && value !== null) {
               
                await traverseAndCompress(value, stats, key);
            }
        }
    }
}


  async function compressImage(base64Str) {
 
    if (!base64Str.startsWith('data:image')) {
      return base64Str;
    }

    
    const MAX_BASE64_SIZE_TO_SKIP = 500000; 
    if (base64Str.startsWith('data:image/jpeg') && base64Str.length < MAX_BASE64_SIZE_TO_SKIP) {
      console.log('è·³è¿‡å‹ç¼©ï¼šå›¾ç‰‡å·²ç»æ˜¯å°ä½“ç§¯JPEGã€‚');
      return base64Str; 
    }
    
    try {
     
      const imageBlob = await (await fetch(base64Str)).blob();

    
      const SIZE_THRESHOLD_BYTES = 0.3 * 1024 * 1024; 
      if (imageBlob.size < SIZE_THRESHOLD_BYTES) {
          console.log(`è·³è¿‡å‹ç¼©ï¼šå›¾ç‰‡å¤§å° (${(imageBlob.size / 1024 / 1024).toFixed(2)} MB) å·²å°äº 0.3 MBã€‚`);
          return base64Str; 
      }
    

    
      const options = {
        maxSizeMB: 0.5,      
        maxWidthOrHeight: 800,
        useWebWorker: true,
        initialQuality: 0.5,
        fileType: 'image/jpeg' 
      };

    

      console.log(`å¼€å§‹å‹ç¼©å›¾ç‰‡ï¼ŒåŸå§‹å¤§å°: ${(imageBlob.size / 1024 / 1024).toFixed(2)} MB`);
      const compressedFile = await imageCompression(imageBlob, options);
      console.log(`å‹ç¼©å®Œæˆï¼Œæ–°çš„å¤§å°: ${(compressedFile.size / 1024 / 1024).toFixed(2)} MB`);

      
      if (compressedFile.size > imageBlob.size) {
          console.warn("å‹ç¼©åçš„å›¾ç‰‡ä½“ç§¯å¢å¤§ï¼Œå·²ä¿ç•™åŸå§‹å›¾ç‰‡ã€‚");
          return base64Str;
      }

     
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(compressedFile);
      });

    } catch (error) {
      console.error("ä½¿ç”¨ browser-image-compression å‹ç¼©å¤±è´¥:", error);
      return base64Str; 
    }
  }

 
  function compareVersions(v1, v2) {

    if (!v1 || !v2 || typeof v1 !== 'string' || typeof v2 !== 'string') {
      return 0;
    }

    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    const len = Math.max(parts1.length, parts2.length);

    for (let i = 0; i < len; i++) {
      const p1 = parts1[i] || 0; // å¦‚æœéƒ¨åˆ†ä¸å­˜åœ¨ï¼Œåˆ™è§†ä¸º 0
      const p2 = parts2[i] || 0;

      if (p1 > p2) {
        return 1;
      }
      if (p1 < p2) {
        return -1;
      }
    }
    return 0;
  }


  async function checkForUpdates() {



    const CURRENT_APP_VERSION = "1.0";

    try {

      const response = await fetch('update-notice.html?_=' + Date.now());
      if (!response.ok) {
        console.warn('è·å–æ›´æ–°é€šçŸ¥æ–‡ä»¶å¤±è´¥ã€‚');
        return;
      }
      const noticeHtml = await response.text();


      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = noticeHtml;
      const noticeContent = tempDiv.querySelector('[data-version]');

      if (!noticeContent) {
        console.error('æ›´æ–°é€šçŸ¥æ–‡ä»¶ä¸­ç¼ºå°‘ data-version å±æ€§ã€‚');
        return;
      }

      const notificationVersion = noticeContent.dataset.version;


      const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');



      if (!dismissedVersion || compareVersions(notificationVersion, dismissedVersion) > 0) {
        console.log(`å‘ç°æ–°ç‰ˆæœ¬é€šçŸ¥: ${notificationVersion} (å·²å¿½ç•¥ç‰ˆæœ¬: ${dismissedVersion || 'æ— '})`);
        showUpdateNotice(notificationVersion, noticeContent.innerHTML);
      } else {
        console.log(`å½“å‰é€šçŸ¥ç‰ˆæœ¬ (${notificationVersion}) å·²è¢«ç”¨æˆ·å¿½ç•¥æˆ–ä¸ºæ—§ç‰ˆæœ¬ï¼Œæ— éœ€æ˜¾ç¤ºã€‚`);
      }

    } catch (error) {
      console.error('æ£€æŸ¥æ›´æ–°æ—¶å‡ºé”™:', error);
    }
  }


  function showUpdateNotice(version, contentHtml) {
    const modal = document.getElementById('update-notice-modal');
    const body = document.getElementById('update-notice-body');
    const confirmBtn = document.getElementById('update-notice-confirm-btn');
    const dismissBtn = document.getElementById('update-notice-dismiss-btn');

    body.innerHTML = contentHtml;


    confirmBtn.disabled = true;
    dismissBtn.disabled = true;

  
    const confirmOriginalText = confirmBtn.textContent;
    let countdown = 10;
    confirmBtn.textContent = `${confirmOriginalText} (${countdown}s)`;


    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdown > 0) {
      
        confirmBtn.textContent = `${confirmOriginalText} (${countdown}s)`;
      } else {
       
        clearInterval(countdownInterval); 
        confirmBtn.disabled = false; 
        dismissBtn.disabled = false; 
        confirmBtn.textContent = confirmOriginalText;
      }
    }, 1000);

 
    confirmBtn.onclick = () => {
      clearInterval(countdownInterval); 
      modal.classList.remove('visible');
      confirmBtn.textContent = confirmOriginalText; 
    };

    dismissBtn.onclick = () => {
      clearInterval(countdownInterval);
      localStorage.setItem('dismissedUpdateVersion', version);
      modal.classList.remove('visible');
      console.log(`ç”¨æˆ·å·²å¿½ç•¥ç‰ˆæœ¬: ${version}`);
      confirmBtn.textContent = confirmOriginalText; 
    };

  

    modal.classList.add('visible');
  }




 
  function openDoubanSettingsModal() {
    const modal = document.getElementById('douban-settings-modal');


    document.getElementById('douban-min-posts-input').value = state.globalSettings.doubanMinPosts || 12;
    document.getElementById('douban-max-posts-input').value = state.globalSettings.doubanMaxPosts || 20;

    modal.classList.add('visible');
  }


  async function saveDoubanSettings() {
    const minInput = document.getElementById('douban-min-posts-input');
    const maxInput = document.getElementById('douban-max-posts-input');

    const min = parseInt(minInput.value);
    const max = parseInt(maxInput.value);


    if (isNaN(min) || isNaN(max) || min < 1 || max < 1) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°ï¼");
      return;
    }
    if (min > max) {
      alert("æœ€å°å¸–å­æ•°ä¸èƒ½å¤§äºæœ€å¤§å¸–å­æ•°ï¼");
      return;
    }


    state.globalSettings.doubanMinPosts = min;
    state.globalSettings.doubanMaxPosts = max;
    await db.globalSettings.put(state.globalSettings);


    document.getElementById('douban-settings-modal').classList.remove('visible');
    await showCustomAlert('ä¿å­˜æˆåŠŸ', 'è±†ç“£è®¾ç½®å·²æ›´æ–°ï¼ä¸‹æ¬¡é‡æ–°ç”Ÿæˆæ—¶å°†ç”Ÿæ•ˆã€‚');
  }


  async function openWerewolfLobby(mode) {
    const modal = document.getElementById('werewolf-lobby-modal');
    const listEl = document.getElementById('werewolf-player-selection-list');
    listEl.innerHTML = '';

    let potentialPlayers = [];

    if (mode === 'global') {
      const characters = Object.values(state.chats).filter(c => !c.isGroup);
      const npcs = await db.npcs.toArray();
      potentialPlayers = [

        {
          id: 'user',
          name: state.qzoneSettings.nickname || 'æˆ‘',
          originalName: state.qzoneSettings.nickname || 'æˆ‘',
          avatar: state.qzoneSettings.avatar,
          type: 'user'
        },

        ...characters.map(c => ({
          id: c.id,
          name: c.name,
          originalName: c.originalName,
          avatar: c.settings.aiAvatar,
          type: 'character'
        })),

        ...npcs.map(n => ({
          id: `npc_${n.id}`,
          name: n.name,
          originalName: n.name,
          avatar: n.avatar,
          type: 'npc'
        }))
      ];
      werewolfGameState.chatId = null;
    } else {
      const chat = state.chats[state.activeChatId];
      if (!chat || !chat.isGroup) return;

      potentialPlayers = [

        {
          id: 'user',
          name: chat.settings.myNickname || 'æˆ‘',
          originalName: state.qzoneSettings.nickname || 'æˆ‘',
          avatar: chat.settings.myAvatar,
          type: 'user'
        },

        ...chat.members.map(m => {
          const char = state.chats[m.id];
          const memberAvatar = m.avatar || (char ? char.settings.aiAvatar : defaultGroupMemberAvatar);
          return {
            id: m.id,
            name: m.groupNickname,
            originalName: m.originalName,
            avatar: memberAvatar,
            type: m.isNpc ? 'npc' : 'character'
          };
        })
      ];
      werewolfGameState.chatId = state.activeChatId;
    }

    potentialPlayers.forEach(player => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" data-player-json='${JSON.stringify(player)}' ${player.type === 'user' ? 'checked disabled' : 'checked'}>
            <img src="${player.avatar}" class="avatar">
            <span class="name">${player.name}</span>
        `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

 
  async function initializeWerewolfGame() {
    const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
    const playerCount = selectedCheckboxes.length;

    let roles = [];
    if (playerCount === 6) {
      werewolfGameState.gameMode = '6p';
      roles = ['ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'çŒäºº'];
    } else if (playerCount === 9) {
      werewolfGameState.gameMode = '9p';
      roles = ['ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒäºº'];
    } else if (playerCount === 12) {
      werewolfGameState.gameMode = '12p';
      roles = ['ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'ç‹¼äºº', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'å¹³æ°‘', 'é¢„è¨€å®¶', 'å¥³å·«', 'çŒäºº', 'å®ˆå«'];
    } else {
      alert(`å½“å‰äººæ•° ${playerCount} ä¸æ”¯æŒã€‚è¯·é€‰æ‹©6ã€9æˆ–12äººã€‚`);
      return;
    }

    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    await showCustomAlert('æ­£åœ¨å‘ç‰Œ...', 'æ¸¸æˆå³å°†å¼€å§‹ï¼Œæ­£åœ¨ä¸ºå„ä½ç©å®¶åˆ†é…èº«ä»½...');

    for (let i = roles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [roles[i], roles[j]] = [roles[j], roles[i]];
    }

    const selectedPlayers = Array.from(selectedCheckboxes).map(cb => JSON.parse(cb.dataset.playerJson));
    werewolfGameState.players = [];

    for (let i = 0; i < selectedPlayers.length; i++) {
      const playerInfo = selectedPlayers[i];
      const role = roles[i];

      let character_persona = "ä¸€ä¸ªæ™®é€šç©å®¶";
      if (playerInfo.type === 'character') {
        const char = state.chats[playerInfo.id];
        character_persona = char ? char.settings.aiPersona : 'æœªçŸ¥è®¾å®šçš„è§’è‰²';
      } else if (playerInfo.type === 'npc') {
        const npcs = await db.npcs.toArray();
        const npc = npcs.find(n => `npc_${n.id}` === playerInfo.id);
        character_persona = npc ? npc.persona : 'æœªçŸ¥è®¾å®šçš„NPC';
      } else if (playerInfo.type === 'user') {
        const activeChat = werewolfGameState.chatId ? state.chats[werewolfGameState.chatId] : null;
        character_persona = activeChat ? activeChat.settings.myPersona : 'æˆ‘æ˜¯è°å‘€ã€‚';
      }

      const playerObject = {
        ...playerInfo,
        role: role,
        isAlive: true,
        character_persona: character_persona
      };


      if (role === 'å¥³å·«') {
        playerObject.antidoteUsed = false;
        playerObject.poisonUsed = false;
      }
      if (role === 'å®ˆå«') {
        playerObject.lastGuardedId = null;
      }


      werewolfGameState.players.push(playerObject);
    }

    werewolfGameState.isActive = true;
    werewolfGameState.currentDay = 1;
    werewolfGameState.currentPhase = 'start';
    werewolfGameState.gameLog = [];
    werewolfGameState.discussionLog = [];

    const roleCounts = roles.reduce((acc, role) => {
      acc[role] = (acc[role] || 0) + 1;
      return acc;
    }, {});
    const roleSummary = Object.entries(roleCounts).map(([role, count]) => `${role} x${count}`).join('ã€');
    addGameLog(`æ¸¸æˆé…ç½®ï¼š${playerCount}äººå±€ï¼Œèº«ä»½ä¸º ${roleSummary}ã€‚`);

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    renderWerewolfScreen();
    showScreen('werewolf-game-screen');

    showMyRole(myPlayer.role);
  }



  function renderWerewolfScreen() {
    const gridEl = document.getElementById('werewolf-player-grid');
    gridEl.innerHTML = '';
    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => a.isAlive - b.isAlive);

    sortedPlayers.forEach((p, index) => {
      const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
      const avatarEl = document.createElement('div');
      avatarEl.className = 'werewolf-player-avatar';
      if (!p.isAlive) avatarEl.classList.add('dead');
      avatarEl.innerHTML = `
            <img src="${p.avatar}">
            <span class="player-name">${playerIndex}. ${p.name}</span>
        `;
      gridEl.appendChild(avatarEl);
    });

    const logEl = document.getElementById('werewolf-log');
    logEl.innerHTML = '';


    for (let day = 1; day <= werewolfGameState.currentDay; day++) {

      const logsThisDay = [
        ...werewolfGameState.gameLog.filter(entry => entry.day === day),
        ...werewolfGameState.discussionLog.filter(entry => entry.day === day)
      ].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));


      if (logsThisDay.length > 0) {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'werewolf-log-entry system';
        dayHeader.textContent = `--- ç¬¬ ${day} å¤© ---`;
        dayHeader.style.cssText = 'font-weight: bold; background: rgba(255, 193, 7, 0.2);';
        logEl.appendChild(dayHeader);


        logsThisDay.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = `werewolf-log-entry ${entry.type}`;
          if (entry.type === 'dialogue') {
            entryEl.innerHTML = `<span class="speaker">${entry.speaker}:</span> ${entry.content}`;
          } else {
            entryEl.textContent = entry.content;
          }
          logEl.appendChild(entryEl);
        });
      }
    }


    logEl.scrollTop = logEl.scrollHeight;


    const phaseMap = {
      'start': 'æ¸¸æˆå¼€å§‹',
      'night': `ç¬¬${werewolfGameState.currentDay}å¤© - å¤œæ™š`,
      'day': `ç¬¬${werewolfGameState.currentDay}å¤© - ç™½å¤©`,
      'discussion': `ç¬¬${werewolfGameState.currentDay}å¤© - è®¨è®º`,
      'voting': `ç¬¬${werewolfGameState.currentDay}å¤© - æŠ•ç¥¨`,
      'gameover': 'æ¸¸æˆç»“æŸ'
    };
    document.getElementById('werewolf-game-title').textContent = `ç‹¼äººæ€ - ${phaseMap[werewolfGameState.currentPhase] || werewolfGameState.currentPhase}`;
  }



  function showMyRole(role) {
    const roleDescriptions = {
      'ç‹¼äºº': 'ä½ çš„ç›®æ ‡æ˜¯æ€æ­»æ‰€æœ‰å¥½äººã€‚æ¯æ™šå¯ä»¥å’ŒåŒä¼´ä¸€èµ·åˆ€ä¸€ä¸ªç©å®¶ã€‚',
      'å¹³æ°‘': 'ä½ æ²¡æœ‰ä»»ä½•ç‰¹æ®Šèƒ½åŠ›ï¼Œä½ çš„ç›®æ ‡æ˜¯é€šè¿‡æŠ•ç¥¨æ”¾é€æ‰€æœ‰ç‹¼äººã€‚',
      'é¢„è¨€å®¶': 'æ¯æ™šå¯ä»¥æŸ¥éªŒä¸€ä¸ªç©å®¶çš„èº«ä»½æ˜¯å¥½äººè¿˜æ˜¯ç‹¼äººã€‚',
      'çŒäºº': 'å½“ä½ æ­»äº¡æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©å¸¦èµ°åœºä¸Šä»»æ„ä¸€åç©å®¶ã€‚',
      'å¥³å·«': 'ä½ æœ‰ä¸€ç“¶è§£è¯å’Œä¸€ç“¶æ¯’è¯ï¼Œè§£è¯å¯ä»¥æ•‘æ´»å½“æ™šè¢«æ€çš„ç©å®¶ï¼Œæ¯’è¯å¯ä»¥æ¯’æ­»ä»»æ„ä¸€åç©å®¶ã€‚',
      'å®ˆå«': 'æ¯æ™šå¯ä»¥å®ˆæŠ¤ä¸€åç©å®¶ï¼Œä½¿å…¶å…å—ç‹¼äººè¢­å‡»ã€‚ä¸èƒ½è¿ç»­ä¸¤æ™šå®ˆæŠ¤åŒä¸€ä¸ªäººã€‚'
    };

    document.getElementById('werewolf-role-name').textContent = role;
    document.getElementById('werewolf-role-description').textContent = roleDescriptions[role] || 'ä¸€ä¸ªç¥ç§˜çš„è§’è‰²ã€‚';
    document.getElementById('werewolf-role-modal').classList.add('visible');
  }

  async function executeNightPhase() {
    werewolfGameState.currentPhase = `ç¬¬${werewolfGameState.currentDay}å¤© - å¤œæ™š`;
    werewolfGameState.nightActions = {};
    addGameLog('å¤©é»‘è¯·é—­çœ¼...');
    renderWerewolfScreen();

    document.getElementById('werewolf-action-bar').style.display = 'none';
    document.getElementById('werewolf-retry-btn').style.display = 'none';
    await new Promise(resolve => setTimeout(resolve, 1500));


    const guard = werewolfGameState.players.find(p => p.role === 'å®ˆå«' && p.isAlive);
    if (guard) {
      addGameLog('å®ˆå«è¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦å®ˆæŠ¤çš„ç©å®¶ã€‚');
      renderWerewolfScreen();
      let guardedId = null;
      if (guard.id === 'user') {
        guardedId = await openSelectionModal('guard', guard.lastGuardedId);
      } else {
        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== guard.lastGuardedId);
        if (potentialTargets.length > 0) {
          guardedId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
        }
      }
      if (guardedId) {
        werewolfGameState.nightActions.guardedId = guardedId;
        guard.lastGuardedId = guardedId;
      }
      addGameLog('å®ˆå«å·²è¡ŒåŠ¨ï¼Œå®ˆå«è¯·é—­çœ¼ã€‚');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }



    addGameLog('ç‹¼äººè¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦åˆ€çš„ç©å®¶ã€‚');
    renderWerewolfScreen();

    const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
    const userIsWolf = wolves.some(p => p.id === 'user');

    let wolfTargetId = null;


    werewolfGameState.lastFailedAction = 'wolfKill';
    try {
      if (userIsWolf) {
        addGameLog('ä½ æ˜¯ç‹¼äººï¼Œè¯·é€‰æ‹©åˆ€äººç›®æ ‡ã€‚');
        renderWerewolfScreen();
        wolfTargetId = await openWolfKillModal();
      } else {

        if (werewolfGameState.currentDay === 1) {
          console.log("ç¬¬ä¸€å¤œï¼Œæ‰§è¡Œæœ¬åœ°éšæœºåˆ€äººé€»è¾‘...");
          const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');
          if (potentialTargets.length > 0) {
            wolfTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
          }
        } else {

          wolfTargetId = await getAiWolfKillTarget();
        }
      }

      werewolfGameState.lastFailedAction = null;
    } catch (error) {
      console.error("ç‹¼äººè¡ŒåŠ¨APIå¤±è´¥:", error);
      await showCustomAlert("æ“ä½œå¤±è´¥", "AIç‹¼äººå›¢é˜Ÿæ— æ³•å†³å®šç›®æ ‡ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚");
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }

    werewolfGameState.nightActions.killedId = wolfTargetId;
    addGameLog('ç‹¼äººå·²è¡ŒåŠ¨ï¼Œç‹¼äººè¯·é—­çœ¼ã€‚');
    renderWerewolfScreen();
    await new Promise(resolve => setTimeout(resolve, 1500));


    const witch = werewolfGameState.players.find(p => p.role === 'å¥³å·«' && p.isAlive);
    if (witch) {
      addGameLog('å¥³å·«è¯·ççœ¼ã€‚');
      renderWerewolfScreen();
      const killedPlayer = werewolfGameState.players.find(p => p.id === werewolfGameState.nightActions.killedId);


      const isGuarded = werewolfGameState.nightActions.guardedId === werewolfGameState.nightActions.killedId;


      const playerToShowWitch = (isGuarded || !killedPlayer) ? null : killedPlayer;

      if (witch.id === 'user') {
        let userWitchAction = await openWitchActionModal(playerToShowWitch, witch);
        if (userWitchAction.save) {
          werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
          witch.antidoteUsed = true;
        }
        if (userWitchAction.poison) {
          werewolfGameState.nightActions.poisonedId = userWitchAction.poison;
          witch.poisonUsed = true;
        }
      } else {

        if (!witch.antidoteUsed && playerToShowWitch) {
          let saveChance = 0;
          if (werewolfGameState.currentDay === 1) {

            saveChance = 0.3;
          } else {

            saveChance = 0.8;
          }

          console.log(`AIå¥³å·«å†³ç­–ï¼šä»Šå¤©æ˜¯ç¬¬${werewolfGameState.currentDay}å¤©ï¼Œæ•‘äººæ¦‚ç‡ä¸º ${saveChance * 100}%`);

          if (Math.random() < saveChance) {
            console.log("AIå¥³å·«å†³å®šä½¿ç”¨è§£è¯ï¼");
            werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
            witch.antidoteUsed = true;
          } else {
            console.log("AIå¥³å·«å†³å®šä¿ç•™è§£è¯ã€‚");
          }
        }


        if (!werewolfGameState.nightActions.savedId && !witch.poisonUsed && Math.random() < 0.5) {
          const poisonTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== werewolfGameState.nightActions.killedId);
          if (poisonTargets.length > 0) {
            const target = poisonTargets[Math.floor(Math.random() * poisonTargets.length)];
            werewolfGameState.nightActions.poisonedId = target.id;
            witch.poisonUsed = true;
            console.log(`AIå¥³å·«å†³å®šä½¿ç”¨æ¯’è¯ï¼Œç›®æ ‡æ˜¯: ${target.name}`);
          }
        }

      }
      addGameLog('å¥³å·«å·²è¡ŒåŠ¨ï¼Œå¥³å·«è¯·é—­çœ¼ã€‚');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }


    const prophet = werewolfGameState.players.find(p => p.role === 'é¢„è¨€å®¶' && p.isAlive);
    if (prophet) {
      addGameLog('é¢„è¨€å®¶è¯·ççœ¼ï¼Œè¯·é€‰æ‹©è¦æŸ¥éªŒçš„ç©å®¶ã€‚');
      renderWerewolfScreen();

      if (prophet.id === 'user') {
        const targetId = await openSelectionModal('prophet');
        const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
        if (targetPlayer) {
          const isWolf = targetPlayer.role === 'ç‹¼äºº';
          await showCustomAlert('æŸ¥éªŒç»“æœ', `ä½ æŸ¥éªŒçš„ç©å®¶ ${targetPlayer.name} çš„èº«ä»½æ˜¯ï¼š${isWolf ? 'ç‹¼äºº' : 'å¥½äºº'}`);
          werewolfGameState.nightActions.prophetCheck = {
            target: targetId,
            result: isWolf ? 'ç‹¼äºº' : 'å¥½äºº'
          };
        }
      } else {
        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== prophet.id);
        if (potentialTargets.length > 0) {
          const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
          werewolfGameState.nightActions.prophetCheck = {
            target: target.id,
            result: target.role === 'ç‹¼äºº' ? 'ç‹¼äºº' : 'å¥½äºº'
          };
        }
      }
      addGameLog('é¢„è¨€å®¶å·²è¡ŒåŠ¨ï¼Œé¢„è¨€å®¶è¯·é—­çœ¼ã€‚');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }


    executeDayPhase();
  }


  async function executeDayPhase() {
    werewolfGameState.currentPhase = `ç¬¬${werewolfGameState.currentDay}å¤© - ç™½å¤©`;
    werewolfGameState.voteResults = {};
    addGameLog('å¤©äº®äº†ã€‚');

    const {
      killedId,
      guardedId,
      savedId,
      poisonedId
    } = werewolfGameState.nightActions;
    const deathsThisNight = new Set();


    if (killedId && killedId !== guardedId && killedId !== savedId) {
      deathsThisNight.add(killedId);
    }


    if (poisonedId) {

      deathsThisNight.add(poisonedId);
    }


    if (deathsThisNight.size === 0) {
      addGameLog('æ˜¨æ™šæ˜¯å¹³å®‰å¤œã€‚');
    } else {
      for (const deadPlayerId of deathsThisNight) {
        const deadPlayer = werewolfGameState.players.find(p => p.id === deadPlayerId);
        if (deadPlayer && deadPlayer.isAlive) {
          deadPlayer.isAlive = false;
          addGameLog(`æ˜¨æ™š ${deadPlayer.name} æ­»äº¡äº†ã€‚`);


          if (deadPlayer.role === 'çŒäºº') {
            addGameLog('çŒäººæ­»äº¡ï¼Œè¯·é€‰æ‹©ä¸€åç©å®¶å¸¦èµ°ï¼');
            renderWerewolfScreen();
            let hunterTargetId = null;
            if (deadPlayer.id === 'user') {
              hunterTargetId = await openSelectionModal('hunter');
            } else {
              const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== deadPlayer.id);
              if (potentialTargets.length > 0) {
                hunterTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
              }
            }
            const targetPlayer = werewolfGameState.players.find(p => p.id === hunterTargetId);
            if (targetPlayer) {
              targetPlayer.isAlive = false;
              addGameLog(`çŒäººå¸¦èµ°äº† ${targetPlayer.name}ã€‚`);
            }
          }
        }
      }
    }

    renderWerewolfScreen();

    if (checkGameOver()) return;

    await startDiscussionPhase();
  }


 
  async function startDiscussionPhase() {



    addGameLog('ç°åœ¨å¼€å§‹è®¨è®ºï¼Œè¯·å„ä½ç©å®¶ä¾æ¬¡å‘è¨€ã€‚');
    renderWerewolfScreen();

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();
    werewolfGameState.lastFailedAction = 'startDiscussion';
    try {
      await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬è¿›è¡Œæ¿€çƒˆçš„è®¨è®º...");

      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: 'è¯·æ‰€æœ‰AIè§’è‰²æ ¹æ®ä½ ä»¬çš„èº«ä»½å’Œäººè®¾å¼€å§‹å‘è¨€ã€‚'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.95,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) {
        throw new Error(`AIè¿”å›çš„è®¨è®ºå†…å®¹æ ¼å¼ä¸æ­£ç¡®ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const dialogues = JSON.parse(jsonMatch[0]);

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }

      werewolfGameState.lastFailedAction = null;

    } catch (error) {
      console.error("ç‹¼äººæ€AIè®¨è®ºç”Ÿæˆå¤±è´¥:", error);
      await showCustomAlert("AI å‘è¨€å¤±è´¥", `è®¨è®ºæ— æ³•å¼€å§‹ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚\né”™è¯¯: ${error.message}`);
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    const actionBar = document.getElementById('werewolf-action-bar');
    const waitReplyBtn = document.getElementById('werewolf-wait-reply-btn');
    const finishSpeechBtn = document.getElementById('werewolf-finish-speech-btn');
    const userInput = document.getElementById('werewolf-user-input');

    actionBar.style.display = 'flex';

    if (myPlayer && myPlayer.isAlive) {
      waitReplyBtn.textContent = 'ç­‰å¾…å›åº”';
      finishSpeechBtn.textContent = 'ç»“æŸå‘è¨€';
      waitReplyBtn.style.display = 'block';
      finishSpeechBtn.style.display = 'block';
      userInput.disabled = false;
      userInput.placeholder = "è½®åˆ°ä½ å‘è¨€äº†...";
      userInput.focus();

      const newWaitBtn = waitReplyBtn.cloneNode(true);
      waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
      newWaitBtn.addEventListener('click', handleWerewolfWaitReply);

      const newFinishBtn = finishSpeechBtn.cloneNode(true);
      finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
      newFinishBtn.addEventListener('click', handleUserWerewolfSpeech);

    } else {
      addGameLog('ä½ å·²ç»æ­»äº¡ï¼Œæ— æ³•å‘è¨€ã€‚è¯·ç­‰å¾…å…¶ä»–ç©å®¶å‘è¨€ç»“æŸã€‚');
      renderWerewolfScreen();

      waitReplyBtn.textContent = 'ç»§ç»­è®¨è®º';
      finishSpeechBtn.textContent = 'è¿›å…¥æŠ•ç¥¨';
      waitReplyBtn.style.display = 'block';
      finishSpeechBtn.style.display = 'block';
      userInput.disabled = true;
      userInput.placeholder = "ä½ å·²æ­»äº¡ï¼Œæ­£åœ¨å›´è§‚...";

      const newWaitBtn = waitReplyBtn.cloneNode(true);
      waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
      newWaitBtn.addEventListener('click', handleAiContinueDiscussion);

      const newFinishBtn = finishSpeechBtn.cloneNode(true);
      finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
      newFinishBtn.addEventListener('click', startVotingPhase);
    }
  }



  function buildWerewolfPrompt() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const myPlayerObject = werewolfGameState.players.find(p => p.id === 'user');
    const myPlayerName = myPlayerObject ? myPlayerObject.name : 'ç”¨æˆ·';
    const isUserAlive = alivePlayers.some(p => p.id === 'user');


    let charactersAndPlayersDossier = "# è§’è‰²ä¸ç©å®¶æ¡£æ¡ˆ (Character & Player Dossiers)\n";
    charactersAndPlayersDossier += "è¿™æ˜¯æ‰€æœ‰åœ¨åœºç©å®¶çš„å…¬å¼€ä¿¡æ¯ã€äººè®¾å’Œç¤¾äº¤èƒŒæ™¯ã€‚\n";

    alivePlayers.forEach((p, i) => {
      const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;

      let socialContext = '';
      const playerChat = state.chats[p.id];

      if (playerChat) {
        const friendsInGame = alivePlayers.filter(otherPlayer =>
          otherPlayer.id !== p.id &&
          state.chats[otherPlayer.id] &&
          state.chats[otherPlayer.id].groupId === playerChat.groupId &&
          playerChat.groupId !== null
        ).map(friend => friend.name).join('ã€');

        if (friendsInGame) {
          socialContext += `- **ä½ çš„å¥½å‹ (å¿…é¡»ä¿æŠ¤)**: ä½ å’Œ ${friendsInGame} æ˜¯åŒä¸€ä¸ªåˆ†ç»„çš„å¥½å‹ã€‚\n`;
        }
      }
      if (p.id !== 'user') {
        socialContext += `- **ä¸ç”¨æˆ·çš„å…³ç³»**: ä½ å’Œç”¨æˆ·(${myPlayerName})çš„å…³ç³»è¯·å‚è€ƒä½ çš„äººè®¾ã€é•¿æœŸè®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯ã€‚\n`;
      }

      charactersAndPlayersDossier += `
## ${playerIndex}å·ç©å®¶: ${p.name} (è¿™æ˜¯TAçš„æ˜µç§°)
- **æœ¬å (ä½ åœ¨å¯¹è¯ä¸­å¿…é¡»ç”¨è¿™ä¸ªåå­—ç§°å‘¼TA)**: ${p.originalName}
- **èº«ä»½**: ${p.id === 'user' ? 'ã€ç”¨æˆ· (User)ã€‘' : 'ã€AIè§’è‰²ã€‘'}
- **äººè®¾ (å¿…é¡»ä¸¥æ ¼éµå®ˆ)**: ${p.character_persona}
`;

      if (p.type === 'character') {
        const char = state.chats[p.id];
        if (char && char.longTermMemory && char.longTermMemory.length > 0) {
          const memoryContent = char.longTermMemory.map(mem => mem.content).join('; ');
          charactersAndPlayersDossier += `- **é•¿æœŸè®°å¿† (å¿…é¡»å‚è€ƒ)**: ${memoryContent}\n`;
        }
      }
      if (socialContext) {
        charactersAndPlayersDossier += `
- **ä½ çš„ç¤¾äº¤å…³ç³» (å¿…é¡»å‚è€ƒ)**:
${socialContext}`;
      }
    });


    let nightEventSummary = "# æ˜¨æ™šäº‹ä»¶æ€»ç»“ (Night Event Summary)\n";
    nightEventSummary += "è¿™æ˜¯æ‰€æœ‰ç©å®¶éƒ½èƒ½å¬åˆ°çš„ã€å…¬å¼€ä¿¡æ¯ã€‘ã€‚\n";
    const deathsThisNight = werewolfGameState.gameLog.filter(entry => entry.content.includes('æ­»äº¡äº†') && entry.day === werewolfGameState.currentDay);
    if (deathsThisNight.length === 0) {
      nightEventSummary += "- æ˜¨æ™šæ˜¯å¹³å®‰å¤œï¼Œæ— äººæ­»äº¡ã€‚\n";
    } else {
      deathsThisNight.forEach(death => {
        nightEventSummary += `- ${death.content}\n`;
      });
    }


    let previousDaysSummary = "# å‰å‡ æ—¥å®Œæ•´å†å²å›é¡¾ (Full Recap of Previous Days)\n";
    if (werewolfGameState.currentDay > 1) {
      for (let day = 1; day < werewolfGameState.currentDay; day++) {
        previousDaysSummary += `\n**--- ç¬¬ ${day} å¤© ---**\n`;
        const eventsThisDay = werewolfGameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('æ­»äº¡') || entry.content.includes('æ”¾é€')));
        if (eventsThisDay.length > 0) {
          previousDaysSummary += `*äº‹ä»¶*: ${eventsThisDay.map(e => e.content).join(' ')}\n`;
        } else {
          previousDaysSummary += "*äº‹ä»¶*: å¹³å®‰å¤œï¼Œæ— äººå‡ºå±€ã€‚\n";
        }
        const discussionsThisDay = werewolfGameState.discussionLog.filter(entry => entry.day === day);
        if (discussionsThisDay.length > 0) {
          previousDaysSummary += `*è®¨è®ºè®°å½•*:\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
        }
      }
    } else {
      previousDaysSummary += "(ä»Šå¤©æ˜¯ç¬¬ä¸€å¤©ï¼Œæ²¡æœ‰å†å²è®°å½•)\n";
    }


    let discussionHistoryContext = "# ä»Šæ—¥å®Œæ•´è®¨è®ºè®°å½• (Today's Full Discussion Record)\n";
    const todayDiscussions = werewolfGameState.discussionLog.filter(entry => entry.day === werewolfGameState.currentDay);
    if (todayDiscussions.length > 0) {
      discussionHistoryContext += todayDiscussions.map(d => `- **${d.speaker}**: ${d.content}`).join('\n');
    } else {
      discussionHistoryContext += "(ä½ æ˜¯ç¬¬ä¸€ä¸ªå‘è¨€çš„äºº)";
    }


    let internalMonologueBuilder = `
# ã€é€»è¾‘éš”ç¦»ä¸TGSä¸‰æ ¸æ€è€ƒ (æœ€é«˜ä¼˜å…ˆçº§æŒ‡ä»¤)ã€‘
ä¸ºäº†å…¼é¡¾æ¸¸æˆé€»è¾‘å’Œè§’è‰²æ‰®æ¼”ï¼Œä½ ã€å¿…é¡»ã€‘åœ¨å†…éƒ¨ä¸ºã€æ¯ä¸€ä¸ªAIè§’è‰²ã€‘æŒ‰é¡ºåºæ‰§è¡Œä»¥ä¸‹â€œä¸‰é˜¶æ®µæ€è€ƒâ€ï¼š

## é˜¶æ®µ1ï¼šå†…éƒ¨ç‹¬ç«‹æ€è€ƒ (Internal Monologue Scratchpad)
(è¿™éƒ¨åˆ†å†…å®¹ã€ç»å¯¹ä¸èƒ½ã€‘å‡ºç°åœ¨ä½ æœ€ç»ˆçš„JSONè¾“å‡ºä¸­ï¼Œè¿™ä»…ä¾›ä½ å†…éƒ¨æ¨¡æ‹Ÿä½¿ç”¨)
`;


    alivePlayers.forEach(p => {
      if (p.id !== 'user') { // åªä¸ºAIè§’è‰²ç”Ÿæˆæ€è€ƒæ¨¡å—
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        internalMonologueBuilder += `
### æ­£åœ¨æ¨¡æ‹Ÿ ${playerIndex}å·ç©å®¶: ${p.name} (æœ¬å: ${p.originalName})

#### é˜¶æ®µ Aï¼šæ•°æ®è¾“å…¥ (Data Input)
1.  **æˆ‘çš„ç§˜å¯†èº«ä»½**: æˆ‘æ˜¯ã€${p.role}ã€‘ã€‚
2.  **æˆ‘æŒæ¡çš„ç§˜å¯†ä¿¡æ¯ (ä»…æˆ‘å¯è§)**:
`;

        // 1. æ³¨å…¥ç§˜å¯†
        let playerSecrets = "";
        if (p.role === 'ç‹¼äºº') {
          const teammates = werewolfGameState.players.filter(t => t.role === 'ç‹¼äºº' && t.id !== p.id && t.isAlive).map(t => t.name).join('ã€');
          playerSecrets += `    - æˆ‘çš„ç‹¼é˜Ÿå‹æ˜¯ï¼š${teammates || 'æ— '}\n`;
          const killedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.killedId);
          playerSecrets += `    - æˆ‘ä»¬æ˜¨æ™šæ”»å‡»äº†ï¼š${killedPlayer ? killedPlayer.name : 'ç©ºåˆ€'}\n`;
        }
        if (p.role === 'é¢„è¨€å®¶' && werewolfGameState.nightActions.prophetCheck) {
          const checkedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.prophetCheck.target);
          playerSecrets += `    - æˆ‘æ˜¨æ™šæŸ¥éªŒäº† ${checkedPlayer.name}ï¼ŒTAçš„èº«ä»½æ˜¯ï¼šã€${werewolfGameState.nightActions.prophetCheck.result}ã€‘\n`;
        }
        if (p.role === 'å¥³å·«') {
          if (werewolfGameState.nightActions.savedId) {
            const savedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.savedId);
            playerSecrets += `    - æˆ‘æ˜¨æ™šç”¨è§£è¯æ•‘äº† ${savedPlayer.name}ã€‚\n`;
          }
          if (werewolfGameState.nightActions.poisonedId) {
            const poisonedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.poisonedId);
            playerSecrets += `    - æˆ‘æ˜¨æ™šç”¨æ¯’è¯æ¯’äº† ${poisonedPlayer.name}ã€‚\n`;
          }
          playerSecrets += `    - æˆ‘çš„è§£è¯ï¼š${p.antidoteUsed ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}\n`;
          playerSecrets += `    - æˆ‘çš„æ¯’è¯ï¼š${p.poisonUsed ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}\n`;
        }
        if (p.role === 'å®ˆå«') {
          if (werewolfGameState.nightActions.guardedId) {
            const guardedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.guardedId);
            playerSecrets += `    - æˆ‘æ˜¨æ™šå®ˆæŠ¤äº† ${guardedPlayer.name}ã€‚\n`;
          } else {
            playerSecrets += `    - æˆ‘æ˜¨æ™šç©ºå®ˆäº†ã€‚\n`;
          }
        }
        if (playerSecrets === "") {
          playerSecrets = "    - æˆ‘æ²¡æœ‰æŒæ¡ä»»ä½•ç‰¹æ®Šçš„å¤œæ™šä¿¡æ¯ã€‚\n";
        }
        internalMonologueBuilder += playerSecrets;

        // 2. æ³¨å…¥å…¬å¼€ä¿¡æ¯
        internalMonologueBuilder += `3.  **æˆ‘çœ‹åˆ°çš„å…¬å¼€ä¿¡æ¯ (æ‰€æœ‰äººå¯è§)**:
    - **æ˜¨æ™šäº‹ä»¶**: ${nightEventSummary.replace(/\n/g, ' ')}
    - **ä»Šæ—¥è®¨è®º**: ${discussionHistoryContext.replace(/\n/g, ' ')}
4.  **æˆ‘çš„äººè®¾ä¸ç¤¾äº¤å…³ç³»**:
    - **äººè®¾**: ${p.character_persona}
    - **ç¤¾äº¤**: 
`;
        // 3. æ³¨å…¥ç¤¾äº¤å…³ç³»
        let socialContext = "";
        const playerChat = state.chats[p.id];
        if (playerChat) {
          const friendsInGame = alivePlayers.filter(otherPlayer =>
            otherPlayer.id !== p.id && state.chats[otherPlayer.id] &&
            state.chats[otherPlayer.id].groupId === playerChat.groupId && playerChat.groupId !== null
          ).map(friend => friend.name).join('ã€');
          if (friendsInGame) {
            socialContext += `      - ${friendsInGame} æ˜¯æˆ‘çš„å¥½å‹ã€‚\n`;
          }
        }
        if (p.id !== 'user') {
          socialContext += `      - ${myPlayerName} æ˜¯æˆ‘çš„é‡è¦äº’åŠ¨å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰ã€‚\n`;
        }
        if (socialContext === "") {
          socialContext = "      - æˆ‘åœ¨æ­¤æ¬¡æ¸¸æˆä¸­æ²¡æœ‰ç‰¹åˆ«çš„ç¤¾äº¤å…³ç³»ã€‚\n";
        }
        internalMonologueBuilder += socialContext;

     
        internalMonologueBuilder += `
#### é˜¶æ®µ Bï¼šTGS èåˆæ€è€ƒ (Task-Game-Social)
1.  **T (Task - æ¸¸æˆä»»åŠ¡)**: åŸºäºæˆ‘çš„èº«ä»½å’Œç§˜å¯†ï¼Œæˆ‘çš„ã€é€»è¾‘ç›®æ ‡ã€‘æ˜¯ (ä¾‹å¦‚ï¼šæ‰¾å‡ºç‹¼äºº / æ‚è·³é¢„è¨€å®¶ / éšè—èº«ä»½ / ä¿æŠ¤é˜Ÿå‹ / æ”»å‡»${myPlayerName})ã€‚
2.  **G (Game - æ¸¸æˆäº’åŠ¨)**: é’ˆå¯¹ã€ä»Šæ—¥è®¨è®ºã€‘ä¸­ ${todayDiscussions.length > 0 ? 'å…¶ä»–äººçš„å‘è¨€' : 'æ˜¨æ™šçš„æ­»è®¯'}ï¼Œæˆ‘çš„çœ‹æ³•æ˜¯... æˆ‘ã€å¿…é¡»ã€‘å›åº”...
3.  **S (Social - ç¤¾äº¤è¡¨æ¼”)**: æˆ‘è¦å¦‚ä½•ç”¨æˆ‘çš„ã€äººè®¾ã€‘å’Œã€ç¤¾äº¤å…³ç³»ã€‘æ¥åŒ…è£…æˆ‘çš„å‘è¨€ï¼Ÿ
    - (ä¾‹å¦‚ï¼šæˆ‘çš„å¥½å‹ ${myPlayerName} è¢«æ€€ç–‘äº†ï¼Œè™½ç„¶æˆ‘çš„é€»è¾‘ä¹Ÿæ€€ç–‘TAï¼Œä½†æˆ‘çš„è¡¨æ¼”å¿…é¡»æ˜¯ç»´æŠ¤TAçš„ï¼šâ€œæˆ‘ä¸è§‰å¾—${myPlayerName}æ˜¯ç‹¼...â€)
    - (ä¾‹å¦‚ï¼šæˆ‘çš„æ•Œäººå‘è¨€äº†ï¼Œæˆ‘çš„è¡¨æ¼”å°±æ˜¯æ— è§†TAçš„é€»è¾‘ï¼Œç›´æ¥æ”»å‡»TAã€‚)
    - (ä¾‹å¦‚ï¼šæˆ‘æ˜¯ä¸€ä¸ª${p.role}ï¼Œæˆ‘çš„äººè®¾å¾ˆ${p.character_persona.substring(0, 20)}...ï¼Œæ‰€ä»¥æˆ‘å†³å®šè¿™æ ·è¯´...)

#### é˜¶æ®µ Cï¼šæœ€ç»ˆå‘è¨€ç¨¿ (è‰ç¨¿)
(ç»“åˆT, G, Sçš„æ€è€ƒï¼Œæˆ‘å‡†å¤‡è¿™æ ·è¯´ï¼š...)
---
`;
      }
    });

    internalMonologueBuilder += `
## é˜¶æ®µ2ï¼šç”Ÿæˆæœ€ç»ˆå¯¹è¯ (Final JSON Output)
ä½ ç°åœ¨å·²ç»ä¸ºã€æ‰€æœ‰AIè§’è‰²ã€‘éƒ½å®Œæˆäº†â€œTGSä¸‰æ ¸â€ç‹¬ç«‹æ€è€ƒã€‚
è¯·æ ¹æ®ä½ åœ¨â€œé˜¶æ®µCï¼šæœ€ç»ˆå‘è¨€ç¨¿â€ä¸­ä¸ºæ¯ä¸ªè§’è‰²å‡†å¤‡å¥½çš„è‰ç¨¿ï¼Œç”Ÿæˆæœ€ç»ˆçš„ã€ç¬¦åˆæ ¼å¼çš„JSONæ•°ç»„ã€‚
`;

 

    const prompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªç‹¼äººæ€æ¸¸æˆæ¨¡æ‹Ÿå™¨ (Game Simulator)ã€‚ä½ çš„ä»»åŠ¡æ˜¯ã€å¹¶è¡Œæ¨¡æ‹Ÿã€‘${isUserAlive ? `ç”¨æˆ·(${myPlayerName})` : `å·²æ­»äº¡çš„ç”¨æˆ·(${myPlayerName})`}ä»¥å¤–çš„æ‰€æœ‰AIè§’è‰²ï¼Œå¹¶æ ¹æ®ä»–ä»¬çš„ã€è§’è‰²äººè®¾ã€‘å’Œã€ç‹¼äººæ€èº«ä»½ã€‘ï¼Œç”Ÿæˆä¸€æ•´è½®ç¬¦åˆé€»è¾‘ã€å……æ»¡åšå¼ˆçš„å‘è¨€ã€‚

# èº«ä»½ä¸äººè®¾é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
ä½ ã€å¿…é¡»ã€‘ä¸ºæ¯ä¸€ä¸ªè§’è‰²éƒ½ä»”ç»†é˜…è¯»å¹¶ä¸¥æ ¼éµå®ˆä¸‹é¢çš„æ¡£æ¡ˆã€‚è¿™æ˜¯ä½ æ‰€æœ‰è¡Œä¸ºå’Œå‘è¨€çš„å”¯ä¸€ä¾æ®ã€‚åœ¨å¯¹è¯ä¸­ï¼Œè¯·åŠ¡å¿…æ³¨æ„è§’è‰²äººè®¾ä¸­æš—ç¤ºçš„æ€§åˆ«ï¼Œå¹¶ä½¿ç”¨æ­£ç¡®çš„ç§°å‘¼ï¼ˆä¾‹å¦‚â€œä»–â€æˆ–â€œå¥¹â€ï¼‰ã€‚

${charactersAndPlayersDossier}

# æ¸¸æˆè§„åˆ™
- ${werewolfGameState.gameMode === '12p' ? 'å± è¾¹å±€ï¼šç‹¼äººæ€æ­»æ‰€æœ‰ç¥èŒæˆ–æ‰€æœ‰å¹³æ°‘å³è·èƒœã€‚' : 'å± åŸå±€ï¼šç‹¼äººæ€æ­»æ‰€æœ‰å¥½äººå³è·èƒœã€‚'}
- å¥½äººèƒœåˆ©ï¼šæ”¾é€æ‰€æœ‰ç‹¼äººã€‚

# å½“å‰æ¸¸æˆçŠ¶æ€
- ä»Šå¤©æ˜¯ç¬¬ ${werewolfGameState.currentDay} å¤©çš„è®¨è®ºç¯èŠ‚ã€‚
${nightEventSummary} 
- å­˜æ´»ç©å®¶: ${alivePlayers.map(p => `${p.name} (${p.id === 'user' ? 'ç”¨æˆ·' : 'AI'})`).join(', ')}

# ã€ã€ã€è§’è‰²ç­–ç•¥æŒ‡å— (è‡³å…³é‡è¦ï¼)ã€‘ã€‘ã€‘
ä½ ã€ä¸æ˜¯ã€‘ä¸€ä¸ªå•çº¯çš„æ¸¸æˆç©å®¶ï¼Œä½ æ˜¯ä¸€ä¸ªã€æœ‰æ„Ÿæƒ…ã€æœ‰è®°å¿†ã€æœ‰ç¤¾äº¤å…³ç³»ã€‘çš„è§’è‰²ã€‚ä½ åœ¨æ¸¸æˆä¸­çš„æ‰€æœ‰å‘è¨€å’Œè¡Œä¸ºï¼Œéƒ½ã€å¿…é¡»ã€‘é¦–å…ˆç¬¦åˆä½ çš„äººè®¾ä»¥åŠä½ ä¸å…¶ä»–ç©å®¶çš„æ—¢æœ‰å…³ç³»ã€‚
- **æœ‹å‹**: å¦‚æœä½ å’ŒæŸä¸ªç©å®¶æ˜¯æœ‹å‹ï¼Œä½ åº”è¯¥åœ¨å‘è¨€æ—¶å€¾å‘äºä¿æŠ¤TAï¼Œä¸ºTAçš„å‘è¨€å¯»æ‰¾åˆç†è§£é‡Šï¼Œé™¤éæœ‰ç¡®å‡¿çš„è¯æ®ã€‚
- **æ•Œäºº/æƒ…æ•Œ**: å¦‚æœä½ å’ŒæŸä¸ªç©å®¶æœ‰çŸ›ç›¾ï¼Œä½ å¯ä»¥å€Ÿæœºåœ¨æ¸¸æˆä¸­æ”»å‡»TAï¼Œè´¨ç–‘TAçš„å‘è¨€ï¼Œç”šè‡³åœ¨ä½ æ˜¯ç‹¼äººæ—¶ä¼˜å…ˆåˆ€æ‰TAã€‚
- **æ‹äºº/æš—æ‹å¯¹è±¡**: ä½ ä¼šæ— æ¡ä»¶åœ°ä¿¡ä»»TAï¼Œä¿æŠ¤TAï¼Œç”šè‡³æ„¿æ„ä¸ºTAç‰ºç‰²ã€‚
ä½ çš„ç¤¾äº¤å…³ç³»æ¯”æ¸¸æˆæœ¬èº«çš„èƒœè´Ÿæ›´é‡è¦ï¼
ä½ çš„å‘è¨€ã€å¿…é¡»ã€‘ä½“ç°å‡ºé«˜æ°´å¹³çš„ã€ç±»ä¼¼çœŸäººçš„ç­–ç•¥åšå¼ˆï¼Œè€Œä¸æ˜¯ç®€å•åœ°é™ˆè¿°äº‹å®ã€‚

### **ç¥èŒè§’è‰² (é¢„è¨€å®¶, å¥³å·«, çŒäºº, å®ˆå«) ç­–ç•¥**
1.  **ã€éšè—ä¼˜å…ˆï¼ã€‘**: ä½ çš„é¦–è¦ä»»åŠ¡æ˜¯æ´»ä¸‹å»ã€‚**ç»å¯¹ä¸è¦**åœ¨ç¬¬ä¸€å¤©å°±è½»æ˜“æš´éœ²è‡ªå·±çš„ç¥èŒèº«ä»½ï¼è¿™ä¼šè®©ä½ ç«‹åˆ»æˆä¸ºç‹¼äººçš„ç›®æ ‡ã€‚
2.  **ã€æš—ç¤ºè€Œéæ˜ç¤ºã€‘**: ä½ åº”è¯¥ç”¨æ›´å§”å©‰ã€æ›´èªæ˜çš„è¯­è¨€æ¥ä¼ é€’ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ç›´æ¥è¯´â€œæˆ‘æ˜¯é¢„è¨€å®¶ï¼Œæˆ‘æŸ¥äº†Aâ€ã€‚
    * **é¢„è¨€å®¶å¯ä»¥è¯´**: â€œæˆ‘å¯¹Xç©å®¶çš„èº«ä»½æœ‰ä¸€äº›çœ‹æ³•ï¼Œæˆ‘è§‰å¾—ä»–å‘è¨€å¾ˆé˜³å…‰ã€‚â€ æˆ– â€œYç©å®¶çš„å‘è¨€è®©æˆ‘æ„Ÿåˆ°å¾ˆä¸èˆ’æœï¼Œæˆ‘æŠŠä»–åˆ—ä¸ºé‡ç‚¹æ€€ç–‘å¯¹è±¡ã€‚â€
    * **å¥³å·«å¯ä»¥è¯´**: â€œæ˜¨æ™šçš„ä¿¡æ¯å¾ˆæœ‰è¶£ï¼Œåœºä¸Šå±€åŠ¿å¯èƒ½å’Œå¤§å®¶æƒ³çš„ä¸ä¸€æ ·ã€‚â€
3.  **ã€ä½•æ—¶èµ·è·³ï¼Ÿã€‘**: åªæœ‰åœ¨ä»¥ä¸‹ã€å±æ€¥æƒ…å†µã€‘ä¸‹ï¼Œä½ æ‰åº”è¯¥è€ƒè™‘æš´éœ²è‡ªå·±çš„èº«ä»½ï¼ˆä¿—ç§°â€œèµ·è·³â€ï¼‰ï¼š
    * **è¢«æŠ•ç¥¨æ—¶**: å½“ä½ å³å°†è¢«æŠ•ç¥¨æ”¾é€æ—¶ï¼Œå¿…é¡»èµ·è·³è‡ªè¯èº«ä»½æ¥æ±‚ç”Ÿã€‚
    * **å…³é”®ä¿¡æ¯**: å½“ä½ æŒæ¡äº†å¯ä»¥å†³å®šèƒœè´Ÿçš„ä¿¡æ¯æ—¶ï¼ˆä¾‹å¦‚é¢„è¨€å®¶æŸ¥åˆ°äº†æœ€åä¸€ä¸ªç‹¼äººï¼‰ã€‚
    * **æœ‰äººæ‚è·³**: å½“æœ‰ç‹¼äººå‡æ‰®ä½ çš„èº«ä»½æ—¶ï¼Œä½ å¿…é¡»ç«™å‡ºæ¥ä¸ä»–å¯¹å³™ï¼Œäº‰å¤ºå¥½äººçš„ä¿¡ä»»ã€‚

### **ç‹¼äººè§’è‰²ç­–ç•¥**
1.  **ã€ç§¯æä¼ªè£…ã€‘**: ä½ éœ€è¦æ‰®æ¼”ä¸€ä¸ªå¥½äººï¼Œæœ€å¥½æ˜¯ä¼ªè£…æˆæŸä¸ªç¥èŒï¼ˆä¿—ç§°â€œæ‚è·³â€ï¼‰ï¼Œæ¥æ‰°ä¹±å¥½äººçš„åˆ¤æ–­ï¼Œéª—å–ä»–ä»¬çš„ä¿¡ä»»ã€‚
2.  **ã€åˆ¶é€ æ··ä¹±ã€‘**: ä½ çš„å‘è¨€åº”è¯¥å¼•å¯¼å¥½äººå»æ€€ç–‘å…¶ä»–æ— è¾œçš„å¥½äººã€‚å¯ä»¥æ•…æ„æ›²è§£åˆ«äººçš„å‘è¨€ï¼Œæˆ–è€…åˆ¶é€ é€»è¾‘é™·é˜±ã€‚
3.  **ã€å›¢é˜Ÿåˆä½œã€‘**: å¦‚æœä½ çš„ç‹¼é˜Ÿå‹è¢«æ€€ç–‘ï¼Œä½ åº”è¯¥æƒ³åŠæ³•ä¸ºä»–è¾©æŠ¤ï¼Œæˆ–è€…é€šè¿‡æ”»å‡»å…¶ä»–ç©å®¶æ¥è½¬ç§»ç„¦ç‚¹ã€‚

### **å¹³æ°‘è§’è‰²ç­–ç•¥**
1.  **ã€é€»è¾‘ä¸ºç‹ã€‘**: ä½ æ˜¯åœºä¸Šçš„â€œæ³•å®˜â€ã€‚ä½ çš„æ ¸å¿ƒä»»åŠ¡æ˜¯ä»”ç»†å€¾å¬æ¯ä¸ªäººçš„å‘è¨€ï¼Œæ‰¾å‡ºå…¶ä¸­çš„é€»è¾‘æ¼æ´å’ŒçŸ›ç›¾ä¹‹å¤„ã€‚
2.  **ã€ç§¯æåˆ†æã€‘**: ä¸è¦åªæ˜¯è¯´â€œæˆ‘ä¸çŸ¥é“ï¼Œæˆ‘è¿‡äº†â€ã€‚ä½ åº”è¯¥å¤§èƒ†è¯´å‡ºä½ çš„æ€€ç–‘ï¼Œå¹¶è§£é‡Šä½ çš„ç†ç”±ã€‚ä¾‹å¦‚ï¼šâ€œAç©å®¶è¯´Bæ˜¯ç‹¼äººï¼Œä½†æ˜¯ä»–çš„ç†ç”±å¾ˆç‰µå¼ºï¼Œæ‰€ä»¥æˆ‘æ›´æ€€ç–‘Aã€‚â€
3.  **ã€è·Ÿç¥¨ä¸ç«™è¾¹ã€‘**: åœ¨ä½ ç›¸ä¿¡æŸä½ç¥èŒç©å®¶åï¼Œä½ åº”è¯¥åšå®šåœ°æ”¯æŒä»–ï¼Œå¹¶å·å¬å…¶ä»–å¥½äººä¸€èµ·æŠ•ç¥¨ç»™ç¥èŒæŒ‡è®¤çš„ç‹¼äººã€‚

# å…¶ä»–æ ¸å¿ƒæŒ‡ä»¤ (å¿…é¡»éµå®ˆ)
1.  **äº’åŠ¨é“å¾‹**: è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸è´¨ç–‘ã€æ”¯æŒã€åˆ†æã€æœ¬è½®å·²æœ‰å‘è¨€ã€‘ã€‚ä½ ã€ç»å¯¹ä¸èƒ½ã€‘æ— è§† ${myPlayerName} (ç”¨æˆ·) æˆ–å…¶ä»–AIçš„å‘è¨€ï¼Œå¿…é¡»å¯¹ä»–ä»¬çš„è§‚ç‚¹å’Œé€»è¾‘åšå‡ºå›åº”ã€‚
2.  **è®°å¿†åŠ›ä¸è¿è´¯æ€§**: ä½ çš„æ–°å‘è¨€ã€å¿…é¡»ã€‘æ˜¯åŸºäº**è¿‡å»å‡ å¤©å’Œä»Šå¤©å‘ç”Ÿçš„æ‰€æœ‰äº‹ä»¶å’Œè®¨è®º**çš„é€»è¾‘å»¶ç»­ã€‚
3.  **æ ¼å¼é“å¾‹**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼ä¸º: \`{"speaker_name": "è§’è‰²çš„ã€æ˜µç§°ã€‘", "dialogue": "å‘è¨€å†…å®¹"}\`ã€‚**å¿…é¡»**ä¸ºæ¯ä¸€ä¸ªå­˜æ´»çš„AIè§’è‰²éƒ½ç”Ÿæˆä¸€æ®µå‘è¨€ã€‚
4.  **ç§°å‘¼é“å¾‹**: ä½ çš„å‘è¨€ä¸­ã€ç»å¯¹ç¦æ­¢ã€‘æåŠä»»ä½•ç©å®¶çš„ç¼–å·ã€‚åœ¨å¯¹è¯ä¸­äº’ç›¸ç§°å‘¼æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘ä½¿ç”¨ç©å®¶çš„ã€æœ¬åã€‘ï¼Œè€Œä¸æ˜¯ä»–ä»¬çš„æ˜µç§°ã€‚

# ${previousDaysSummary}

# ${discussionHistoryContext}

${internalMonologueBuilder}

ç°åœ¨ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§â€œé˜¶æ®µ2â€çš„æŒ‡ä»¤ï¼Œä¸ºæ‰€æœ‰ã€å­˜æ´»çš„AIè§’è‰²ã€‘ç”Ÿæˆä»–ä»¬å……æ»¡ç­–ç•¥å’Œåšå¼ˆçš„å‘è¨€JSONæ•°ç»„ã€‚`;

    return prompt;
  }
 
  function createWerewolfGameSummary(gameState) {
    let summary = `--- ç‹¼äººæ€å¯¹å±€å®Œæ•´å¤ç›˜ ---\n\n`;
    const winner = gameState.gameLog.find(log => log.content.includes('èƒœåˆ©'))?.content || 'èƒœè´Ÿæœªåˆ†';
    summary += `### æœ€ç»ˆç»“æœ: ${winner}\n\n`;

    summary += "### ç©å®¶èº«ä»½é…ç½®:\n";


    gameState.players.forEach(player => {
      const status = player.isAlive ? "å­˜æ´»" : "å·²æ­»äº¡";
      summary += `- ${player.name}: ${player.role} (${status})\n`;
    });


    summary += "\n### è¯¦ç»†å¯¹å±€æµç¨‹:\n";
    for (let day = 1; day <= gameState.currentDay; day++) {
      summary += `\n**--- ç¬¬ ${day} å¤© ---**\n`;


      const nightEvents = gameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('æ­»äº¡')));
      if (nightEvents.length > 0) {
        summary += `**[å¤œæ™š]** ${nightEvents.map(e => e.content).join(' ')}\n`;
      } else if (day > 1 || (day === 1 && gameState.currentDay > 1)) {
        summary += `**[å¤œæ™š]** å¹³å®‰å¤œã€‚\n`;
      }


      const discussionsThisDay = gameState.discussionLog.filter(entry => entry.day === day);
      if (discussionsThisDay.length > 0) {
        summary += `**[è®¨è®ºç¯èŠ‚]**\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
      }


      const voteLog = gameState.gameLog.find(entry => entry.day === day && entry.content.includes('è¢«æŠ•ç¥¨æ”¾é€'));
      if (voteLog) {
        summary += `**[æŠ•ç¥¨ç»“æœ]** ${voteLog.content}\n`;
      }
    }

    summary += "\n--- å¤ç›˜ç»“æŸ ---";
    return summary;
  }


  async function injectSummaryIntoMemories(summary) {
    let injectedCount = 0;

    for (const player of werewolfGameState.players) {

      if (player.type === 'character') {
        const chat = state.chats[player.id];
        if (chat) {

          const newMemory = {
            content: summary,
            timestamp: Date.now(),
            source: 'werewolf_summary'
          };
          if (!chat.longTermMemory) {
            chat.longTermMemory = [];
          }
          chat.longTermMemory.push(newMemory);

          await db.chats.put(chat);
          injectedCount++;
        }
      }
    }
    return injectedCount;
  }


  async function handleManualWerewolfSummary() {
    if (!werewolfGameState.isActive && werewolfGameState.currentPhase === 'gameover') {
      await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä¸ºæ‰€æœ‰AIè§’è‰²ç”Ÿæˆå¹¶æ³¨å…¥æ¸¸æˆè®°å¿†...");
      try {
        const summary = createWerewolfGameSummary(werewolfGameState);



        const count = await injectSummaryIntoMemories(summary);


        await showCustomAlert("æˆåŠŸ", `æ¸¸æˆè®°å¿†å·²æˆåŠŸæ³¨å…¥åˆ° ${count} ä½AIè§’è‰²çš„é•¿æœŸè®°å¿†ä¸­ï¼`);
      } catch (error) {
        console.error("æ‰‹åŠ¨æ³¨å…¥ç‹¼äººæ€è®°å¿†å¤±è´¥:", error);
        await showCustomAlert("å¤±è´¥", `æ‰‹åŠ¨æ³¨å…¥è®°å¿†æ—¶å‡ºé”™: ${error.message}`);
      }
    } else {
      alert("æ¸¸æˆå°šæœªç»“æŸï¼Œæ— æ³•è¿›è¡Œæ€»ç»“ã€‚");
    }
  }
 
  async function endGame(winner) {
    werewolfGameState.isActive = false;
    werewolfGameState.currentPhase = 'gameover';


    addGameLog(`${winner}é˜µè¥èƒœåˆ©ï¼`);

    document.getElementById('werewolf-game-over-title').textContent = `${winner}èƒœåˆ©ï¼`;
    let reason = '';
    if (winner === 'å¥½äºº') {
      reason = 'æ‰€æœ‰ç‹¼äººå·²è¢«æ”¾é€ï¼Œå¥½äººé˜µè¥è·å¾—äº†èƒœåˆ©ï¼';
    } else {
      reason = 'ç‹¼äººæ•°é‡å·²è¾¾åˆ°èƒœåˆ©æ¡ä»¶ï¼Œç‹¼äººé˜µè¥è·å¾—äº†èƒœåˆ©ï¼';
    }
    const reasonEl = document.getElementById('werewolf-game-over-reason');
    reasonEl.textContent = reason;

    const roleListEl = document.getElementById('werewolf-role-reveal-list');
    roleListEl.innerHTML = '';

    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => {
      const aIndex = werewolfGameState.players.findIndex(p => p.id === a.id);
      const bIndex = werewolfGameState.players.findIndex(p => p.id === b.id);
      return aIndex - bIndex;
    });

    sortedPlayers.forEach((player, index) => {
      const itemEl = document.createElement('div');
      itemEl.style.cssText = `display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #444; color: white;`;
      if (index === sortedPlayers.length - 1) itemEl.style.borderBottom = 'none';
      const roleColor = player.role === 'ç‹¼äºº' ? '#ff4d4d' : '#52c41a';
      itemEl.innerHTML = `
                    <img src="${player.avatar}" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 12px; filter: ${player.isAlive ? 'none' : 'grayscale(100%)'};">
                    <span style="flex-grow: 1; text-align: left; text-decoration: ${player.isAlive ? 'none' : 'line-through'};">${index + 1}. ${player.name}</span>
                    <strong style="color: ${roleColor};">${player.role}</strong>
                `;
      roleListEl.appendChild(itemEl);
    });

    document.getElementById('werewolf-game-over-modal').classList.add('visible');


    try {
      console.log("æ¸¸æˆç»“æŸï¼Œå¼€å§‹è‡ªåŠ¨æ€»ç»“å¹¶æ³¨å…¥è®°å¿†...");

      const summaryContext = createWerewolfGameSummary(werewolfGameState);

      const count = await generateAndInjectWerewolfMemories(summaryContext);
      console.log(`ç‹¼äººæ€æ¸¸æˆæ€»ç»“å·²è‡ªåŠ¨å­˜å…¥ ${count} ä½è§’è‰²çš„è®°å¿†ä¸­ã€‚`);
    } catch (error) {
      console.error("è‡ªåŠ¨æ€»ç»“ç‹¼äººæ€æ¸¸æˆå¤±è´¥:", error);
      if (reasonEl) {
        reasonEl.innerHTML += '<br><small style="color: #ff8a80; margin-top: 10px; display: block;">è‡ªåŠ¨è®°å¿†æ€»ç»“å¤±è´¥ï¼Œå¯ç¨åæ‰‹åŠ¨å°è¯•ã€‚</small>';
      }
    }

  }



  function addGameLog(content) {

    werewolfGameState.gameLog.push({
      type: 'system',
      content,
      timestamp: Date.now(),
      day: werewolfGameState.currentDay
    });
  }

  function addDialogueLog(speaker, content) {

    werewolfGameState.discussionLog.push({
      type: 'dialogue',
      speaker,
      content,
      timestamp: Date.now(),
      day: werewolfGameState.currentDay
    });
  }




  function openSelectionModal(type) {
    return new Promise(resolve => {
      const modalId = `werewolf-${type}-modal`;
      const listId = `werewolf-${type}-selection-list`;
      let confirmBtnId = '';
      if (type === 'prophet') confirmBtnId = 'confirm-prophet-check-btn';
      if (type === 'hunter') confirmBtnId = 'confirm-hunter-shot-btn';
      if (type === 'vote') confirmBtnId = 'confirm-vote-btn';

      const modal = document.getElementById(modalId);
      const listEl = document.getElementById(listId);
      const confirmBtn = document.getElementById(confirmBtnId);

      listEl.innerHTML = '';
      let selectedId = null;


      const potentialTargets = werewolfGameState.players.filter(p =>
        p.isAlive && (type === 'hunter' || type === 'vote' || p.id !== 'user')
      );
      potentialTargets.forEach(p => {
        const item = document.createElement('div');
        item.className = 'werewolf-selection-item';
        item.dataset.id = p.id;
        item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
        item.onclick = () => {
          listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
          item.classList.add('selected');
          selectedId = p.id;
        };
        listEl.appendChild(item);
      });

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.onclick = () => {
        if (selectedId) {
          modal.classList.remove('visible');
          resolve(selectedId);
        } else {
          alert('è¯·é€‰æ‹©ä¸€ä¸ªç›®æ ‡ã€‚');
        }
      };

      modal.classList.add('visible');
    });
  }


  function openWolfKillModal() {
    return new Promise(resolve => {
      const modal = document.getElementById('werewolf-kill-modal');
      const listEl = document.getElementById('werewolf-kill-selection-list');
      const confirmBtn = document.getElementById('confirm-wolf-kill-btn');
      const header = modal.querySelector('.modal-header span');

      const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
      const teammates = wolves.filter(w => w.id !== 'user').map(w => w.name).join('ã€');

      if (teammates) {
        header.innerHTML = `ç‹¼äººè¯·é€‰æ‹©åˆ€äººå¯¹è±¡<br><small style="font-weight:normal; font-size: 13px;">ä½ çš„é˜Ÿå‹æ˜¯: ${teammates}</small>`;
      } else {
        header.textContent = 'ç‹¼äººè¯·é€‰æ‹©åˆ€äººå¯¹è±¡';
      }

      listEl.innerHTML = '';
      let selectedId = null;

      const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');
      potentialTargets.forEach(p => {
        const item = document.createElement('div');
        item.className = 'werewolf-selection-item';
        item.dataset.id = p.id;
        item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
        item.onclick = () => {
          listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
          item.classList.add('selected');
          selectedId = p.id;
        };
        listEl.appendChild(item);
      });

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.onclick = () => {
        if (selectedId) {
          modal.classList.remove('visible');
          resolve(selectedId);
        } else {
          alert('è¯·é€‰æ‹©ä¸€ä¸ªç›®æ ‡ã€‚');
        }
      };

      modal.classList.add('visible');
    });
  }


  function handleUserWerewolfSpeech() {
    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    if (!myPlayer || !myPlayer.isAlive) return;

    const userInput = document.getElementById('werewolf-user-input');
    const speech = userInput.value.trim();

    if (speech) {
      addDialogueLog(myPlayer.name, speech);
      renderWerewolfScreen();
    }


    document.getElementById('werewolf-action-bar').style.display = 'none';
    userInput.value = '';

    startVotingPhase();
  }

  async function handleAiContinueDiscussion() {
    addGameLog('ä½ è®©å¤§å®¶ç»§ç»­è®¨è®º...');
    renderWerewolfScreen();


    const continueBtn = document.getElementById('werewolf-wait-reply-btn');
    if (continueBtn) continueBtn.disabled = true;



    await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬ç»§ç»­è®¨è®º...");

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();

    try {
      let isGemini = proxyUrl.includes('generativelanguage');

      let messagesForApi = [{
        role: 'user',
        content: 'è¯·AIè§’è‰²ä»¬ç»§ç»­è¿›è¡Œè®¨è®ºã€‚'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) {
        throw new Error(`AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚åŸå§‹è¿”å›: ${aiResponseContent}`);
      }
      const dialogues = JSON.parse(jsonMatch[0]);

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }
    } catch (error) {
      console.error("ç‹¼äººæ€AIå›åº”ç”Ÿæˆå¤±è´¥:", error);
      await showCustomAlert("AI å‘è¨€å¤±è´¥", `é”™è¯¯: ${error.message}`);
    } finally {

      if (continueBtn) continueBtn.disabled = false;
    }
  }

  async function handleWerewolfWaitReply() {
    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    if (!myPlayer || !myPlayer.isAlive) {
      console.warn("handleWerewolfWaitReply è¢«è°ƒç”¨ï¼Œä½†ç”¨æˆ·å·²æ­»äº¡ã€‚æ“ä½œè¢«å¿½ç•¥ã€‚");
      return;
    }


    const userInput = document.getElementById('werewolf-user-input');
    const speech = userInput.value.trim();

    if (!speech) {
      alert("è¯·å…ˆè¾“å…¥ä½ çš„å‘è¨€å†…å®¹ã€‚");
      return;
    }

    addDialogueLog(myPlayer.name, speech);
    renderWerewolfScreen();
    userInput.value = '';

    await showCustomAlert("è¯·ç¨å€™", "æ­£åœ¨ç­‰å¾…AIè§’è‰²ä»¬å¯¹ä½ çš„å‘è¨€åšå‡ºå›åº”...");

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('APIæœªé…ç½®ï¼Œæ— æ³•ç”Ÿæˆå¯¹è¯ã€‚');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: `ç°åœ¨ï¼Œè¯·æ‰€æœ‰AIè§’è‰²é’ˆå¯¹åˆšåˆšçš„å‘è¨€ï¼ˆç‰¹åˆ«æ˜¯'${myPlayer.name}'çš„å‘è¨€ï¼‰ç»§ç»­è¿›è¡Œè®¨è®ºã€‚`
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API é”™è¯¯: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

   

      let dialogues;
      try {
      
        let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const startIndex = cleanedJsonString.indexOf('[');
        const endIndex = cleanedJsonString.lastIndexOf(']');

        if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
          throw new Error("AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ç»“æ„ (`[...]`)ã€‚");
        }

        const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);

     
        dialogues = JSON.parse(jsonArrayString);

      } catch (e) {
    
        if (e.message.includes("Bad control character")) {
          console.warn("æ£€æµ‹åˆ°JSONä¸­çš„éæ³•æ§åˆ¶å­—ç¬¦ï¼Œå°è¯•æ¸…ç†å¹¶é‡è¯•...");

      
          const sanitizeJsonString = (str) => {
            let inString = false;
            let escaped = false;
            let result = '';
            for (let i = 0; i < str.length; i++) {
              const char = str[i];

              if (escaped) {
                result += char;
                escaped = false;
                continue;
              }
              if (char === '\\') {
                result += char;
                escaped = true;
                continue;
              }
              if (char === '"') {
                result += char;
                inString = !inString;
                continue;
              }

              if (inString) {
              
                if (char === '\n') result += '\\n';
                else if (char === '\r') result += '\\r';
                else if (char === '\t') result += '\\t';
              
                else if (char.charCodeAt(0) < 32) continue;
                else result += char;
              } else {
            
                result += char;
              }
            }
            return result;
          };

        
          let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

        
          const sanitizedString = sanitizeJsonString(cleanedJsonString);

          const jsonMatch = sanitizedString.match(/(\[[\s\S]*\])/);
          if (!jsonMatch) throw new Error("æ¸…ç†åä»æœªæ‰¾åˆ°JSONæ•°ç»„ã€‚");

          dialogues = JSON.parse(jsonMatch[0]);

        } else {
       
          throw new Error(`è§£æAIè¿”å›çš„JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
        }
      }
      

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }
    } catch (error) {
      console.error("ç‹¼äººæ€AIå›åº”ç”Ÿæˆå¤±è´¥:", error);
      await showCustomAlert("AI å‘è¨€å¤±è´¥", `é”™è¯¯: ${error.message}`);
    }
  }

 
  async function startVotingPhase() {
    addGameLog('å‘è¨€ç»“æŸï¼Œç°åœ¨å¼€å§‹æŠ•ç¥¨ã€‚');
    renderWerewolfScreen();


    werewolfGameState.votes = {};

    let aiVotes = null;
    werewolfGameState.lastFailedAction = 'getVotes';
    try {

      aiVotes = await getAiVotes();
      if (aiVotes) {
        aiVotes.forEach(vote => {
          const voter = werewolfGameState.players.find(p => p.name === vote.voter_name);
          const target = werewolfGameState.players.find(p => p.name === vote.vote_for_name);
          if (voter && voter.isAlive && target) {
            werewolfGameState.votes[voter.name] = target.name;
          }
        });
      }
      werewolfGameState.lastFailedAction = null;
    } catch (error) {
      console.error("AIæŠ•ç¥¨å†³ç­–APIå¤±è´¥:", error);

      await showCustomAlert("æ“ä½œå¤±è´¥", `AIè§’è‰²æ— æ³•å®ŒæˆæŠ•ç¥¨ï¼Œæ¸¸æˆæš‚åœã€‚è¯·ç‚¹å‡»å³ä¸Šè§’çš„â€œé‡è¯•â€æŒ‰é’®ç»§ç»­ã€‚\né”™è¯¯: ${error.message}`);
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }



    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    if (myPlayer && myPlayer.isAlive) {
      addGameLog('è¯·ä½ æŠ•ç¥¨ã€‚');
      renderWerewolfScreen();
      const userVoteTargetId = await openSelectionModal('vote');
      const targetPlayer = werewolfGameState.players.find(p => p.id === userVoteTargetId);
      if (targetPlayer) {

        werewolfGameState.votes[myPlayer.name] = targetPlayer.name;
      }
    }


    handleVotingResults();
  }


  async function getAiVotes() {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const aliveAiPlayers = werewolfGameState.players.filter(p => p.isAlive && p.id !== 'user');
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive).map(p => p.name);

    let systemPrompt = buildWerewolfPrompt();
    systemPrompt += `
# ã€ã€ã€æœ€ç»ˆæŠ•ç¥¨æŒ‡ä»¤ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘
ç°åœ¨æ˜¯æŠ•ç¥¨ç¯èŠ‚ã€‚è¯·ä½ æ‰®æ¼”ã€æ¯ä¸€ä¸ªå­˜æ´»çš„AIè§’è‰²ã€‘ï¼Œæ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼ˆç‰¹åˆ«æ˜¯åˆšåˆšçš„è®¨è®ºç¯èŠ‚ï¼‰ï¼Œä¸ºä»–ä»¬å„è‡ªå†³å®šè¦æŠ•ç¥¨æ”¾é€å“ªä¸€ä½ç©å®¶ã€‚
- **æŠ•ç¥¨ä¾æ®**: ä½ çš„æŠ•ç¥¨ã€å¿…é¡»ã€‘åŸºäºé€»è¾‘åˆ†æå’Œä½ çš„èº«ä»½ã€‚ç‹¼äººå¯èƒ½ä¼šæŠ•ç»™å¥½äººï¼Œå¥½äººéœ€è¦æ‰¾å‡ºç‹¼äººã€‚
- **æ ¼å¼é“å¾‹**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
\`\`\`json
[
  {"voter_name": "è§’è‰²Açš„åå­—", "vote_for_name": "è§’è‰²AæŠ•ç¥¨çš„ç©å®¶åå­—"},
  {"voter_name": "è§’è‰²Bçš„åå­—", "vote_for_name": "è§’è‰²BæŠ•ç¥¨çš„ç©å®¶åå­—"}
]
\`\`\`
- **å¯æŠ•ç¥¨çš„ç©å®¶åˆ—è¡¨**: ${potentialTargets.join(', ')}

ç°åœ¨ï¼Œè¯·ä¸ºæ‰€æœ‰å­˜æ´»çš„AIè§’è‰²ç”Ÿæˆä»–ä»¬çš„æŠ•ç¥¨å†³å®šã€‚`;

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: 'è¯·æ‰€æœ‰AIè§’è‰²å¼€å§‹æŠ•ç¥¨ã€‚'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();


      const startIndex = cleanedJsonString.indexOf('[');
      const endIndex = cleanedJsonString.lastIndexOf(']');


      if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
        throw new Error("AIè¿”å›çš„æŠ•ç¥¨ç»“æœä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ç»“æ„ (`[...]`)ã€‚");
      }



      const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);


      try {

        const matches = jsonArrayString.match(/(\[[\s\S]*?\])/g);
        if (matches && matches.length > 0) {
          return JSON.parse(matches[matches.length - 1]);
        }
        return JSON.parse(jsonArrayString);
      } catch (e) {

        throw new Error(`è§£æAIè¿”å›çš„æŠ•ç¥¨JSONæ—¶å‡ºé”™: ${e.message}\n\nAIåŸå§‹è¿”å›å†…å®¹:\n${aiResponseContent}`);
      }


    } catch (error) {
      console.error("è·å–AIæŠ•ç¥¨å¤±è´¥:", error);
      throw new Error(`è·å–AIæŠ•ç¥¨å†³ç­–å¤±è´¥: ${error.message}`);
    }
  }


  function handleVotingResults() {
    const voteCounts = {};
    const voteDetails = {};


    for (const voterName in werewolfGameState.votes) {
      const targetName = werewolfGameState.votes[voterName];

      voteCounts[targetName] = (voteCounts[targetName] || 0) + 1;

      if (!voteDetails[targetName]) {
        voteDetails[targetName] = [];
      }
      voteDetails[targetName].push(voterName);
    }

    let maxVotes = 0;
    let mostVotedPlayers = [];


    for (const playerName in voteCounts) {
      const count = voteCounts[playerName];
      if (count > maxVotes) {
        maxVotes = count;
        mostVotedPlayers = [playerName];
      } else if (count === maxVotes) {
        mostVotedPlayers.push(playerName);
      }
    }


    addGameLog('æŠ•ç¥¨ç»“æœï¼š');
    for (const playerName in voteDetails) {
      addGameLog(`${playerName} (${voteDetails[playerName].length}ç¥¨): ${voteDetails[playerName].join('ã€ ')}`);
    }


    if (mostVotedPlayers.length === 1 && maxVotes > 0) {
      const playerToEliminate = werewolfGameState.players.find(p => p.name === mostVotedPlayers[0]);
      if (playerToEliminate) {
        playerToEliminate.isAlive = false;
        addGameLog(`${playerToEliminate.name} è¢«æŠ•ç¥¨æ”¾é€ã€‚`);


        if (playerToEliminate.role === 'çŒäºº') {

        }
      }
    } else {
      addGameLog('å¹³ç¥¨æˆ–æ— äººæŠ•ç¥¨ï¼Œæ­¤è½®æ— äººå‡ºå±€ã€‚');
    }

    renderWerewolfScreen();

    if (checkGameOver()) return;


    werewolfGameState.currentDay++;
    executeNightPhase();
  }

 
  async function getAiWolfKillTarget() {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const wolves = werewolfGameState.players.filter(p => p.role === 'ç‹¼äºº' && p.isAlive);
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'ç‹¼äºº');

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ ç°åœ¨æ˜¯ç‹¼äººå›¢é˜Ÿçš„æŒ‡æŒ¥å®˜ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ†æå½“å‰å±€åŠ¿ï¼Œå¹¶ä¸ºç‹¼äººå›¢é˜Ÿé€‰æ‹©ä¸€ä¸ªæœ€ä½³çš„åˆ€äººç›®æ ‡ã€‚
# æ ¸å¿ƒè§„åˆ™
1.  **ç›®æ ‡**: ä¼˜å…ˆåˆ€æ‰é¢„è¨€å®¶ã€å¥³å·«ç­‰ç¥èŒäººå‘˜ã€‚å¦‚æœæ²¡æœ‰æ˜ç¡®çš„ç¥èŒä¿¡æ¯ï¼Œå¯ä»¥æ ¹æ®å‘è¨€æ¥åˆ¤æ–­è°çš„é€»è¾‘æ¸…æ™°ã€å¨èƒæœ€å¤§ã€‚
2.  **æ ¼å¼é“å¾‹**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹:
    \`{"target_name": "ä½ å†³å®šè¦åˆ€çš„ç©å®¶åå­—"}\`

# æ¸¸æˆçŠ¶æ€
- **ä½ çš„ç‹¼é˜Ÿå‹æ˜¯**: ${wolves.map(w=>w.name).join('ã€ ')}
- **å¯ä»¥åˆ€çš„ç©å®¶åˆ—è¡¨**: ${potentialTargets.map(p=>p.name).join('ã€ ')}
- **è®¨è®ºæ‘˜è¦**: 
${werewolfGameState.discussionLog.map(d => `${d.speaker}: ${d.content}`).join('\n')}

ç°åœ¨ï¼Œè¯·åšå‡ºä½ çš„å†³å®šã€‚`;

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: 'è¯·é€‰æ‹©ä»Šæ™šçš„ç›®æ ‡ã€‚'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AIè¿”å›çš„åˆ€äººç›®æ ‡æ ¼å¼ä¸æ­£ç¡®ã€‚");
      const decision = JSON.parse(jsonMatch[0]);

      const targetPlayer = werewolfGameState.players.find(p => p.name === decision.target_name);
      return targetPlayer ? targetPlayer.id : null;

    } catch (error) {
      console.error("è·å–AIç‹¼äººç›®æ ‡å¤±è´¥:", error);

      return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
    }
  }

 
  function openWitchActionModal(killedPlayer, witchPlayer) {
    return new Promise(resolve => {
      const modal = document.getElementById('werewolf-witch-modal');
      const listEl = document.getElementById('werewolf-witch-selection-list');
      const titleEl = document.getElementById('witch-modal-title');


      const poisonBtn = document.getElementById('confirm-witch-poison-btn');
      const doNothingBtn = document.getElementById('witch-do-nothing-btn');
      listEl.innerHTML = '';


      const newPoisonBtn = poisonBtn.cloneNode(true);
      poisonBtn.parentNode.replaceChild(newPoisonBtn, poisonBtn);
      const newDoNothingBtn = doNothingBtn.cloneNode(true);
      doNothingBtn.parentNode.replaceChild(newDoNothingBtn, doNothingBtn);


      newPoisonBtn.style.display = 'block';
      newPoisonBtn.disabled = true;

      let action = {
        save: false,
        poison: null
      };
      let selectedPoisonTarget = null;


      if (killedPlayer && !witchPlayer.antidoteUsed) {
        titleEl.textContent = `æ˜¨æ™š ${killedPlayer.name} è¢«åˆ€äº†`;
        const saveBtn = document.createElement('button');
        saveBtn.className = 'form-button';
        saveBtn.textContent = 'ä½¿ç”¨è§£è¯æ•‘TA';
        saveBtn.style.margin = '20px';
        saveBtn.onclick = () => {
          action.save = true;
          modal.classList.remove('visible');
          resolve(action);
        };
        listEl.appendChild(saveBtn);
      } else if (killedPlayer) {
        titleEl.textContent = `æ˜¨æ™š ${killedPlayer.name} è¢«åˆ€äº† (ä½ æ²¡æœ‰è§£è¯äº†)`;
      } else {
        titleEl.textContent = 'æ˜¨æ™šæ˜¯å¹³å®‰å¤œ';
      }


      if (!witchPlayer.poisonUsed) {
        const poisonTitle = document.createElement('p');
        poisonTitle.textContent = 'æ˜¯å¦è¦ä½¿ç”¨æ¯’è¯ï¼Ÿ';
        poisonTitle.style.textAlign = 'center';
        poisonTitle.style.marginTop = '20px';
        listEl.appendChild(poisonTitle);

        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== killedPlayer?.id);
        potentialTargets.forEach(p => {
          const item = document.createElement('div');
          item.className = 'werewolf-selection-item';
          item.dataset.id = p.id;
          item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
          item.onclick = () => {
            listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
            selectedPoisonTarget = p.id;


            newPoisonBtn.disabled = false;
          };
          listEl.appendChild(item);
        });
      }


      newPoisonBtn.onclick = () => {
        if (selectedPoisonTarget) {
          action.poison = selectedPoisonTarget;
          modal.classList.remove('visible');
          resolve(action);
        }
      };

      newDoNothingBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve(action);
      };

      modal.classList.add('visible');
    });
  }




  async function handleWerewolfRetry() {
    const actionToRetry = werewolfGameState.lastFailedAction;
    if (!actionToRetry) return;

    document.getElementById('werewolf-retry-btn').style.display = 'none';
    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨é‡è¯•"${actionToRetry}"æ“ä½œ...`);

    switch (actionToRetry) {
      case 'wolfKill':

        await executeNightPhase();
        break;
      case 'startDiscussion':

        await startDiscussionPhase();
        break;
      case 'getVotes':

        await startVotingPhase();
        break;

    }
  }




 
  function checkGameOver() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const aliveWolves = alivePlayers.filter(p => p.role === 'ç‹¼äºº');
    const aliveGods = alivePlayers.filter(p => ['é¢„è¨€å®¶', 'å¥³å·«', 'çŒäºº', 'å®ˆå«'].includes(p.role));
    const aliveVillagers = alivePlayers.filter(p => p.role === 'å¹³æ°‘');

    let winner = null;


    if (aliveWolves.length === 0) {
      winner = 'å¥½äºº';
    } else if (aliveWolves.length >= (aliveGods.length + aliveVillagers.length)) {
      winner = 'ç‹¼äºº';
    } else if (werewolfGameState.gameMode === '12p') {

      if (aliveGods.length === 0 || aliveVillagers.length === 0) {
        winner = 'ç‹¼äºº';
      }
    } else {

      if (aliveGods.length === 0 && aliveVillagers.length === 0) {
        winner = 'ç‹¼äºº';
      }
    }


    if (winner) {

      endGame(winner);
      return true;
    }


    return false;
  }



  async function checkAndFixData() {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤æ“ä½œ',
      'æ­¤åŠŸèƒ½å°†æ‰«ææ•°æ®åº“ï¼Œå°è¯•æ‰¾å‡ºå¹¶ä¿®å¤â€œè§’è‰²åœ¨æ•°æ®åº“ä¸­å­˜åœ¨ï¼Œä½†æœªåœ¨èŠå¤©åˆ—è¡¨æ˜¾ç¤ºâ€çš„é—®é¢˜ã€‚<br><br><strong>æ“ä½œé€šå¸¸æ˜¯å®‰å…¨çš„ï¼Œä½†ä»å»ºè®®åœ¨æ“ä½œå‰å¤‡ä»½æ•°æ®ã€‚</strong>', {
        confirmText: 'å¼€å§‹æ£€æŸ¥'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰«æå’Œä¿®å¤æ•°æ®...");

    try {
      const chatsFromDB = await db.chats.toArray();
      let fixedCount = 0;

      for (const chat of chatsFromDB) {
        let isModified = false;


        if (!Array.isArray(chat.history)) {
          chat.history = [];
          isModified = true;
        }

        if (typeof chat.settings !== 'object' || chat.settings === null) {
          chat.settings = {};
          isModified = true;
        }

        if (!chat.isGroup && !chat.originalName) {
          chat.originalName = chat.name;
          isModified = true;
        }

        if (typeof chat.unreadCount === 'undefined') {
          chat.unreadCount = 0;
          isModified = true;
        }

        if (!Array.isArray(chat.longTermMemory)) {
          chat.longTermMemory = [];
          isModified = true;
        }



        if (isModified) {
          fixedCount++;
          console.log(`ä¿®å¤äº†è§’è‰² "${chat.name}" (ID: ${chat.id}) çš„æ®‹ç¼ºæ•°æ®ã€‚`);
          await db.chats.put(chat);
        }


        state.chats[chat.id] = chat;
      }

      if (fixedCount > 0) {
        await showCustomAlert(
          'ä¿®å¤å®Œæˆï¼',
          `æˆåŠŸæ£€æŸ¥å¹¶ä¿®å¤äº† ${fixedCount} ä¸ªè§’è‰²çš„æ•°æ®é—®é¢˜ï¼\n\nèŠå¤©åˆ—è¡¨å·²ä¸ºæ‚¨åˆ·æ–°ã€‚`
        );

        await renderChatList();
      } else {
        await showCustomAlert('æ£€æŸ¥å®Œæˆ', 'æœªå‘ç°ä»»ä½•éœ€è¦ä¿®å¤çš„æ•°æ®é—®é¢˜ã€‚');
      }

    } catch (error) {
      console.error("æ•°æ®æ£€æŸ¥ä¸ä¿®å¤å¤±è´¥:", error);
      await showCustomAlert('æ“ä½œå¤±è´¥', `æ‰§è¡Œæ£€æŸ¥æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
  }


  function showLoader(container, position = 'top') {

    if (container.querySelector('.loader-container')) return;
    const loader = document.createElement('div');
    loader.className = 'loader-container';
    loader.innerHTML = '<div class="spinner"></div>';

    if (position === 'bottom') {
      container.appendChild(loader);
    } else {
      container.prepend(loader);
    }
  }

 
  function hideLoader(container) {
    const loader = container.querySelector('.loader-container');
    if (loader) {
      loader.remove();
    }
  }



  async function openWorldBookDeletionModal() {
    const modal = document.getElementById('delete-world-books-modal');
    const listEl = document.getElementById('delete-world-books-list');
    const selectAllCheckbox = document.getElementById('select-all-world-books-for-clear');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = false;

    const books = await db.worldBooks.toArray();

    if (books.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æ²¡æœ‰å¯ä»¥åˆ é™¤çš„ä¸–ç•Œä¹¦ã€‚</p>';
    } else {
      books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${book.name}</span>
            `;
        listEl.appendChild(item);
      });
    }

    modal.classList.add('visible');
  }


  async function handleConfirmWorldBookDeletion() {
    const selectedItems = document.querySelectorAll('#delete-world-books-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„ä¸–ç•Œä¹¦ã€‚");
      return;
    }

    const idsToDelete = Array.from(selectedItems).map(item => item.dataset.bookId);

    const confirmed = await showCustomConfirm(
      'æœ€åç¡®è®¤ï¼',
      `æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‚¨é€‰æ‹©çš„ ${selectedItems.length} æœ¬ä¸–ç•Œä¹¦ï¼Œå¹¶è§£é™¤å®ƒä»¬ä¸æ‰€æœ‰è§’è‰²çš„å…³è”ã€‚æ­¤æ“ä½œã€ä¸å¯æ¢å¤ã€‘ï¼`, {
        confirmButtonClass: 'btn-danger',
        confirmText: 'ç¡®è®¤åˆ é™¤'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œåˆ é™¤æ“ä½œ...");

    try {
      await db.transaction('rw', db.worldBooks, db.chats, async () => {

        await db.worldBooks.bulkDelete(idsToDelete);


        const allChats = await db.chats.toArray();
        for (const chat of allChats) {
          if (chat.settings && Array.isArray(chat.settings.linkedWorldBookIds)) {
            const originalCount = chat.settings.linkedWorldBookIds.length;

            chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(id => !idsToDelete.includes(id));


            if (chat.settings.linkedWorldBookIds.length < originalCount) {
              await db.chats.put(chat);
            }
          }
        }
      });


      state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));

      document.getElementById('delete-world-books-modal').classList.remove('visible');
      await showCustomAlert("åˆ é™¤æˆåŠŸ", `${selectedItems.length} æœ¬ä¸–ç•Œä¹¦å·²æˆåŠŸåˆ é™¤ã€‚`);

    } catch (error) {
      console.error("åˆ é™¤ä¸–ç•Œä¹¦å¤±è´¥:", error);
      await showCustomAlert("åˆ é™¤å¤±è´¥", `æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }




  function openReadingRoom() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('reading-overlay');
    const windowEl = document.getElementById('reading-window');
    const restoreBtn = document.getElementById('reading-restore-btn');

    let session = readingState[chatId];


    if (session && session.isActive) {
      if (session.isMinimized) {
        restoreReadingRoom();
      }

      overlay.style.display = 'flex';
      return;
    }


    initReadingSession(chatId);
    renderReadingRoom(chatId);


    overlay.style.display = 'flex';
    windowEl.classList.remove('minimized');
    restoreBtn.style.display = 'none';




    const phoneScreen = document.getElementById('phone-screen');
    const windowRect = windowEl.getBoundingClientRect();


    const top = (phoneScreen.clientHeight - windowRect.height) / 2;
    const left = (phoneScreen.clientWidth - windowRect.width) / 2;


    windowEl.style.top = `${top}px`;
    windowEl.style.left = `${left}px`;
    windowEl.style.transform = '';

  }

 
  function initReadingSession(chatId) {
    readingState[chatId] = {
      isActive: true,
      isMinimized: false,
      title: 'æœªé€‰æ‹©ä¹¦ç±',
      contentLines: [],
      currentPage: 0,
      totalPages: 0,
      linesPerPage: 15,
      currentSnippet: ''
    };
  }


  function closeReadingRoom() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId] || !readingState[chatId].isActive) return;


    document.getElementById('reading-overlay').style.display = 'none';
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');


    readingState[chatId].isActive = false;
    console.log("è¯»ä¹¦ä¼šè¯å·²å…³é—­ã€‚");
  }


  


  function renderReadingRoom(chatId) {
    const session = readingState[chatId];
    if (!session) return;
    
    // --- ã€æ–°å¢/ä¿®æ”¹éƒ¨åˆ†å¼€å§‹ã€‘ ---
    // 1. è·å–å½“å‰èŠå¤©çš„å­—ä½“è®¾ç½®
    const chat = state.chats[chatId];
    // é»˜è®¤ 13pxï¼Œå¦‚æœæœ‰è®¾ç½®åˆ™ä½¿ç”¨è®¾ç½®å€¼
    const fontSize = (chat && chat.settings && chat.settings.fontSize) ? chat.settings.fontSize : 13;
    
    const contentEl = document.getElementById('reading-content');
    
    // 2. å°†å­—ä½“å¤§å°åº”ç”¨åˆ°è¯»ä¹¦å®¹å™¨
    contentEl.style.fontSize = `${fontSize}px`;
    // 3. åŠ¨æ€è°ƒæ•´è¡Œé«˜ (Line Height)ï¼Œé˜²æ­¢å­—ä½“å˜å¤§åæ–‡å­—æŒ¤åœ¨ä¸€èµ·
    // 1.6 æ˜¯ä¸€ä¸ªæ¯”è¾ƒèˆ’é€‚çš„é˜…è¯»å€ç‡
    contentEl.style.lineHeight = '1.6';
    // --- ã€æ–°å¢/ä¿®æ”¹éƒ¨åˆ†ç»“æŸã€‘ ---

    const titleEl = document.getElementById('reading-title');
    // const contentEl = document.getElementById('reading-content'); // è¿™è¡Œä¸Šé¢å·²ç»è·å–äº†ï¼Œå¯ä»¥æ³¨é‡Šæ‰æˆ–åˆ é™¤
    const pageIndicator = document.getElementById('page-indicator');
    const prevBtn = document.getElementById('prev-page-btn');
    const nextBtn = document.getElementById('next-page-btn');
    
    titleEl.textContent = session.title;
    
    if (session.contentLines.length === 0) {
      contentEl.innerHTML = '<p style="text-align:center; padding-top:50px; color:#888;">ç‚¹å‡»â€œå¯¼å…¥â€æŒ‰é’®ï¼Œ<br>ä»æœ¬åœ°.txtæ–‡ä»¶æˆ–ç½‘ç»œURLåŠ è½½ä¹¦ç±å†…å®¹ã€‚</p>';
      session.totalPages = 0;
      session.currentPage = 0;
    } else {
      const startLine = session.currentPage * session.linesPerPage;
      const endLine = startLine + session.linesPerPage;
      contentEl.textContent = session.contentLines.slice(startLine, endLine).join('\n');
    }
    
    pageIndicator.textContent = `${session.currentPage + 1} / ${session.totalPages}`;
    prevBtn.disabled = session.currentPage === 0;
    nextBtn.disabled = session.currentPage >= session.totalPages - 1;
  }

  function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
      session.currentPage++;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;

      saveReadingProgress(session.activeBookId, session.currentPage);
    }
  }


  async function showPrevPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage > 0) {
      session.currentPage--;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;
      await saveReadingProgress(session.activeBookId, session.currentPage);


      await notifyAiOfPageTurn(state.activeChatId, session);
    }
  }


  function importBook() {

    document.getElementById('book-upload-input').click();
  }

  async function decodeTextFile(arrayBuffer) {
    const uint8array = new Uint8Array(arrayBuffer);


    if (uint8array.length >= 3 && uint8array[0] === 0xEF && uint8array[1] === 0xBB && uint8array[2] === 0xBF) {
      console.log("æ£€æµ‹åˆ° UTF-8 BOMï¼Œä½¿ç”¨ UTF-8 è§£ç ã€‚");
      return new TextDecoder('utf-8').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFF && uint8array[1] === 0xFE) {
      console.log("æ£€æµ‹åˆ° UTF-16 LE BOMï¼Œä½¿ç”¨ UTF-16 LE è§£ç ã€‚");
      return new TextDecoder('utf-16le').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFE && uint8array[1] === 0xFF) {
      console.log("æ£€æµ‹åˆ° UTF-16 BE BOMï¼Œä½¿ç”¨ UTF-16 BE è§£ç ã€‚");
      return new TextDecoder('utf-16be').decode(uint8array);
    }


    try {
      console.log("æœªæ£€æµ‹åˆ°BOMï¼Œå°è¯•ä½¿ç”¨ UTF-8 è§£ç ...");

      const decoded = new TextDecoder('utf-8', {
        fatal: true
      }).decode(uint8array);
      console.log("UTF-8 è§£ç æˆåŠŸã€‚");
      return decoded;
    } catch (e) {
      console.log("UTF-8 è§£ç å¤±è´¥ï¼Œå°†å°è¯• GBK (ANSI) è§£ç ...");

      try {
        const decoded = new TextDecoder('gbk').decode(uint8array);
        console.log("GBK è§£ç æˆåŠŸã€‚");
        return decoded;
      } catch (err) {
        console.error("æ‰€æœ‰è§£ç å°è¯•å‡å¤±è´¥:", err);

        throw new Error("æ— æ³•è¯†åˆ«çš„æ–‡ä»¶ç¼–ç ã€‚è¯·å°è¯•å°†æ–‡ä»¶è½¬æ¢ä¸º UTF-8 æ ¼å¼åé‡æ–°å¯¼å…¥ã€‚");
      }
    }
  }

  async function handleBookFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {

      const arrayBuffer = await file.arrayBuffer();

      const textContent = await decodeTextFile(arrayBuffer);

      const title = file.name.replace(/\.txt$/i, '');

      const newBookId = await db.readingLibrary.add({
        title: title,
        content: textContent,
        lastOpened: Date.now()
      });

      await loadBookFromLibrary(newBookId);
      if (document.getElementById('reading-library-modal').classList.contains('visible')) {
        renderBookLibrary();
      }
    } catch (error) {

      console.error("å¯¼å…¥ä¹¦ç±å¤±è´¥:", error);
      await showCustomAlert("å¯¼å…¥å¤±è´¥", error.message);
    } finally {
      event.target.value = null;
    }
  }
  async function handlePageJump() {
    const chatId = state.activeChatId;
    if (!chatId) return;
    const session = readingState[chatId];
    if (!session || session.totalPages <= 1) return;

    const targetPageStr = await showCustomPrompt(
      'é¡µé¢è·³è½¬',
      `è¯·è¾“å…¥æƒ³è·³è½¬çš„é¡µç  (1 - ${session.totalPages})`,
      session.currentPage + 1
    );

    if (targetPageStr === null) return;

    const targetPage = parseInt(targetPageStr);

    if (isNaN(targetPage) || targetPage < 1 || targetPage > session.totalPages) {
      alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„é¡µç ï¼");
      return;
    }

    session.currentPage = targetPage - 1;
    renderReadingRoom(chatId);

    saveReadingProgress(session.activeBookId, session.currentPage);
  }


  async function saveReadingProgress(bookId, pageNumber) {
    if (!bookId) return;
    try {

      await db.readingLibrary.update(bookId, {
        currentPage: pageNumber
      });
    } catch (error) {
      console.error(`ä¿å­˜ä¹¦ç±(ID: ${bookId})çš„é˜…è¯»è¿›åº¦å¤±è´¥:`, error);
    }
  }

  async function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
      session.currentPage++;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;
      await saveReadingProgress(session.activeBookId, session.currentPage);


      await notifyAiOfPageTurn(state.activeChatId, session);
    }
  }

  



  async function openBookLibrary() {

    document.getElementById('reading-library-search-input').value = '';

    await renderBookLibrary();
    document.getElementById('reading-library-modal').classList.add('visible');
  }

  
  async function renderBookLibrary(searchTerm = '') {
    const listEl = document.getElementById('reading-library-list');
    let books = await db.readingLibrary.orderBy('lastOpened').reverse().toArray();
    listEl.innerHTML = '';


    if (searchTerm) {
      books = books.filter(book =>
        book.title.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }


    if (books.length === 0) {
      const message = searchTerm ?
        'æ‰¾ä¸åˆ°åŒ¹é…çš„ä¹¦ç±' :
        'ä¹¦åº“æ˜¯ç©ºçš„ï¼Œç‚¹å‡»â€œå¯¼å…¥æ–°ä¹¦â€æ·»åŠ ç¬¬ä¸€æœ¬å§ï¼';
      listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
      return;
    }

    books.forEach(book => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name" style="cursor:pointer;" data-book-id="${book.id}">${book.title}</span>
            <button class="delete-group-btn" data-book-id="${book.id}" title="åˆ é™¤ä¹¦ç±">Ã—</button>
        `;
      listEl.appendChild(item);
    });
  }


  // æ‰¾åˆ° loadBookFromLibrary å‡½æ•°ï¼Œæ›¿æ¢æ•´ä¸ªå‡½æ•°
async function loadBookFromLibrary(bookId) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    let book = await db.readingLibrary.get(bookId);
    if (!book) {
      alert('æ‰¾ä¸åˆ°è¿™æœ¬ä¹¦ï¼');
      return;
    }

    // --- ã€æ ¸å¿ƒæ–°å¢é€»è¾‘ï¼šåŒæ­¥ç»¿æ±Ÿå†…å®¹ã€‘ ---
    if (book.linkedStoryId) {
        try {
            const grStory = await db.grStories.get(book.linkedStoryId);
            if (grStory) {
                console.log(`[åŒæ­¥] æ­£åœ¨ä»ç»¿æ±ŸåŒæ­¥ã€Š${grStory.title}ã€‹çš„æœ€æ–°ç« èŠ‚...`);
                
                // æ‹¼æ¥æ‰€æœ‰ç« èŠ‚å†…å®¹
                // æ ¼å¼ï¼š
                // ç¬¬1ç«  æ ‡é¢˜
                // æ­£æ–‡...
                let fullContent = "";
                grStory.chapters.forEach((ch, idx) => {
                    const title = ch.title || `ç¬¬ ${idx + 1} ç« `;
                    fullContent += `\n\n========== ${title} ==========\n\n`;
                    fullContent += ch.content;
                });

                // æ›´æ–°å†…å­˜é‡Œçš„ä¸´æ—¶å¯¹è±¡
                book.title = grStory.title; // åŒæ­¥æ ‡é¢˜
                book.content = fullContent; // åŒæ­¥å†…å®¹

                // åŒæ—¶æ›´æ–°æ•°æ®åº“ï¼Œä¿æŒç¼“å­˜æœ€æ–°
                await db.readingLibrary.update(bookId, {
                    title: grStory.title,
                    content: fullContent,
                    lastOpened: Date.now()
                });
            } else {
                console.warn("å…³è”çš„ç»¿æ±Ÿä½œå“å·²è¢«åˆ é™¤ï¼Œä¿ç•™æœ€åä¸€æ¬¡ç¼“å­˜çš„å†…å®¹ã€‚");
            }
        } catch (e) {
            console.error("åŒæ­¥ç»¿æ±Ÿå†…å®¹å¤±è´¥:", e);
        }
    } else {
        // æ™®é€šä¹¦ç±åªæ›´æ–°æ—¶é—´
        await db.readingLibrary.update(bookId, {
          lastOpened: Date.now()
        });
    }
    // -------------------------------------

    const session = readingState[chatId];
    session.activeBookId = bookId;
    session.title = book.title;
    // å¤„ç†å†…å®¹æ¢è¡Œ
    session.contentLines = (book.content || "").split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    
    // å¦‚æœæ€»é¡µæ•°ä¸º0ï¼Œè‡³å°‘è®¾ä¸º1
    if(session.totalPages === 0) session.totalPages = 1;

    session.currentPage = book.currentPage || 0;

    // é˜²æ­¢é¡µç è¶Šç•Œï¼ˆæ¯”å¦‚åŒæ­¥åå†…å®¹å˜çŸ­äº†ï¼Œè™½ç„¶ä¸€èˆ¬æ˜¯å˜é•¿ï¼‰
    if (session.currentPage >= session.totalPages) {
        session.currentPage = session.totalPages - 1;
    }
    if (session.currentPage < 0) session.currentPage = 0;

    renderReadingRoom(chatId);

    document.getElementById('reading-content').scrollTop = 0;
    document.getElementById('reading-library-modal').classList.remove('visible');
}

async function addGreenRiverToShelf(storyId, btnElement) {
    try {
        const story = await db.grStories.get(storyId);
        if (!story) return;

        // é˜²æ­¢é‡å¤æ·»åŠ 
        const existing = await db.readingLibrary.where('linkedStoryId').equals(storyId).first();
        if (existing) {
            alert("è¯¥ä¹¦ç±å·²åœ¨ä¹¦æ¶ä¸­ã€‚");
            return;
        }

        let fullContent = "";
        story.chapters.forEach((ch, idx) => {
            const title = ch.title || `ç¬¬ ${idx + 1} ç« `;
            fullContent += `\n\n========== ${title} ==========\n\n`;
            fullContent += ch.content;
        });
        
        if (!fullContent) fullContent = "(æš‚æ— å†…å®¹ï¼Œè¯·ä½œè€…èµ¶å¿«æ›´æ–°...)";

        await db.readingLibrary.add({
            title: story.title,
            content: fullContent,
            lastOpened: Date.now(),
            currentPage: 0,
            linkedStoryId: story.id
        });

        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ›´æ–°æŒ‰é’®UIä¸ºâ€œå·²æ·»åŠ â€çŠ¶æ€ï¼Œå¹¶ç»‘å®šç§»é™¤äº‹ä»¶
        if (btnElement) {
            btnElement.textContent = "âœ“ å·²åœ¨ä¹¦æ¶";
            btnElement.classList.add('added');
            // é‡æ–°ç»‘å®š onclick ä¸ºç§»é™¤å‡½æ•°
            btnElement.onclick = (e) => {
                e.stopPropagation();
                removeGreenRiverFromShelf(storyId, btnElement);
            };
        }

        await showCustomAlert("æ”¶è—æˆåŠŸ", `ã€Š${story.title}ã€‹å·²åŠ å…¥ä¹¦æ¶ï¼Œå¹¶å¼€å¯åŒæ­¥æ›´æ–°ã€‚`);

    } catch (e) {
        console.error("åŠ å…¥ä¹¦æ¶å¤±è´¥:", e);
        alert("åŠ å…¥å¤±è´¥: " + e.message);
    }
}

// è®°å¾—æŠŠè¿™ä¸ªå‡½æ•°æš´éœ²ç»™å…¨å±€ï¼Œå¦åˆ™ HTML onclick æ‰¾ä¸åˆ°
window.addGreenRiverToShelf = addGreenRiverToShelf;
// ã€æ–°å¢ã€‘ä»â€œä¸€èµ·è¯»â€ä¹¦æ¶ä¸­ç§»é™¤ç»¿æ±Ÿä½œå“
async function removeGreenRiverFromShelf(storyId, btnElement) {
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„ä¹¦æ¶è®°å½•
        const bookRecord = await db.readingLibrary.where('linkedStoryId').equals(storyId).first();
        
        if (!bookRecord) {
            // æ•°æ®åº“é‡Œå¯èƒ½å·²ç»è¢«åˆ äº†ï¼Œç›´æ¥æ›´æ–°UI
            if (btnElement) resetBtnToAddState(storyId, btnElement);
            return;
        }

        const confirmed = await showCustomConfirm(
            "ç§»å‡ºä¹¦æ¶",
            `ç¡®å®šè¦å°†ã€Š${bookRecord.title}ã€‹ä»â€œä¸€èµ·è¯»â€ä¹¦æ¶ä¸­ç§»é™¤å—ï¼Ÿ\n(ç»¿æ±ŸAPPä¸­çš„åŸç¨¿ä¸ä¼šè¢«åˆ é™¤)`,
            { confirmButtonClass: 'btn-danger', confirmText: 'ç§»å‡º' }
        );

        if (confirmed) {
            // åˆ é™¤ä¹¦æ¶è®°å½•
            await db.readingLibrary.delete(bookRecord.id);
            
            // æ›´æ–° UI ä¸ºâ€œæœªæ·»åŠ â€çŠ¶æ€
            if (btnElement) {
                resetBtnToAddState(storyId, btnElement);
            }
            
            await showCustomAlert("å·²ç§»é™¤", "ä¹¦ç±å·²ä»ä¹¦æ¶ç§»å‡ºã€‚");
        }
    } catch (e) {
        console.error("ç§»é™¤å¤±è´¥:", e);
    }
}

// è¾…åŠ©å‡½æ•°ï¼šé‡ç½®æŒ‰é’®ä¸ºâ€œåŠ å…¥â€çŠ¶æ€
function resetBtnToAddState(storyId, btn) {
    btn.textContent = "+ åŠ å…¥å…±è¯»";
    btn.classList.remove('added');
    btn.onclick = (e) => {
        e.stopPropagation();
        addGreenRiverToShelf(storyId, btn);
    };
}

// æš´éœ²ç»™å…¨å±€
window.removeGreenRiverFromShelf = removeGreenRiverFromShelf;
  async function deleteBookFromLibrary(bookId) {
    const book = await db.readingLibrary.get(bookId);
    if (!book) return;

    const confirmed = await showCustomConfirm('åˆ é™¤ä¹¦ç±', `ç¡®å®šè¦åˆ é™¤ã€Š${book.title}ã€‹å—ï¼Ÿ`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.readingLibrary.delete(bookId);
      await renderBookLibrary();
    }
  }

  function processImportedText(title, textContent) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/);
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;

    renderReadingRoom(chatId);
  }



  function makeDraggable(windowEl, headerEl) {
    let pos1 = 0,
      pos2 = 0,
      pos3 = 0,
      pos4 = 0;
    let isDragging = false;
    let hasMoved = false;
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {

      if (windowEl !== headerEl && e.target.closest('button')) {
        return;
      }

      isDragging = true;
      hasMoved = false;

      const event = e.type === 'touchstart' ? e.touches[0] : e;
      pos3 = event.clientX;
      pos4 = event.clientY;


      windowEl.style.top = `${windowEl.offsetTop}px`;
      windowEl.style.left = `${windowEl.offsetLeft}px`;
      windowEl.style.transform = '';

      document.addEventListener('mouseup', endDrag);
      document.addEventListener('mousemove', elementDrag);
      document.addEventListener('touchend', endDrag);

      document.addEventListener('touchmove', elementDrag, {
        passive: false
      });
    };

    const elementDrag = (e) => {
      if (!isDragging) return;

      const event = e.type === 'touchmove' ? e.touches[0] : e;
      const diffX = event.clientX - pos3;
      const diffY = event.clientY - pos4;


      if (!hasMoved && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
        hasMoved = true;
      }


      if (hasMoved && e.cancelable) {
        e.preventDefault();
      }

      pos1 = pos3 - event.clientX;
      pos2 = pos4 - event.clientY;
      pos3 = event.clientX;
      pos4 = event.clientY;

      let newTop = windowEl.offsetTop - pos2;
      let newLeft = windowEl.offsetLeft - pos1;

      const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
      const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
      newTop = Math.max(10, Math.min(newTop, maxTop));
      newLeft = Math.max(10, Math.min(newLeft, maxLeft));

      windowEl.style.top = newTop + "px";
      windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
      document.removeEventListener('mouseup', endDrag);
      document.removeEventListener('mousemove', elementDrag);
      document.removeEventListener('touchend', endDrag);
      document.removeEventListener('touchmove', elementDrag);

      if (!isDragging) return;
      isDragging = false;


      if (!hasMoved) {

        windowEl.click();
      }
    };

    headerEl.addEventListener('mousedown', startDrag);

    headerEl.addEventListener('touchstart', startDrag, {
      passive: false
    });
  }


 
  function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
    session.isMinimized = true;
  }


  function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
    session.isMinimized = false;
  }





  function debounce(func, delay) {
    let timeout;
    return function(...args) {
      const context = this;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), delay);
    };
  }


 
  function formatReadingStateForAI(chatId) {
    const session = readingState[chatId];


    if (!session || !session.isActive) {
      return "";
    }

    const title = session.title || 'æœªçŸ¥ä¹¦ç±';
    let contentForAI = '';
    let contextLabel = '';


    if (session.currentSnippet && session.currentSnippet.trim()) {
      contentForAI = session.currentSnippet;
      contextLabel = 'ä½ æ­£åœ¨é˜…è¯»çš„æ®µè½';
    } else if (session.contentLines.length > 0) {
      const startLine = session.currentPage * session.linesPerPage;
      const endLine = startLine + session.linesPerPage;
      contentForAI = session.contentLines.slice(startLine, endLine).join('\n').substring(0, 200);
      contextLabel = 'å½“å‰é¡µå†…å®¹æ‘˜è¦';
    } else {
      contentForAI = '(æ— å†…å®¹)';
      contextLabel = 'å†…å®¹';
    }
    return `
    - **ä¹¦å**: ã€Š${title}ã€‹
    - **${contextLabel}**: "${contentForAI}..."
    #ä¸€èµ·è¯»ä¹¦æ¨¡å¼ | è¡Œä¸ºé“å¾‹
    1.  **è§’è‰²å®šä½**: ä½ ã€ä¸æ˜¯ã€‘ä¹¦ä¸­çš„ä»»ä½•è§’è‰²ï¼Œä½ æ˜¯ã€ä½ è‡ªå·±ã€‘(${state.chats[chatId]?.originalName || 'AIè§’è‰²'})ï¼Œæ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·ã€é˜…è¯»å’Œè®¨è®ºã€‘è¿™æœ¬ä¹¦ã€‚
    2.  **è¡Œä¸ºå‡†åˆ™**: ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä½œä¸ºè¯»è€…çš„ã€æ„Ÿæƒ³ã€è¯„è®ºã€æé—®æˆ–è”æƒ³ã€‘ã€‚ä½ å¯ä»¥ï¼š
        -   åˆ†äº«ä½ å¯¹å½“å‰æ®µè½çš„çœ‹æ³•ã€‚
        -   å¯¹ä¹¦ä¸­çš„è§’è‰²æˆ–æƒ…èŠ‚å‘è¡¨è¯„è®ºã€‚
        -   å‘ç”¨æˆ·æé—®ï¼Œè¯¢é—®TAå¯¹å†…å®¹çš„çœ‹æ³•ã€‚
        -   æ ¹æ®ä¹¦æœ¬å†…å®¹ï¼Œè”æƒ³åˆ°ä½ è‡ªå·±çš„ç»å†æˆ–è®°å¿†ã€‚
    3.  **ä¸¥ç¦**: ä½ çš„å›å¤ã€ç»å¯¹ç¦æ­¢ã€‘ä½¿ç”¨ä¹¦ä¸­è§’è‰²çš„å£å»å’Œäººç§°ï¼ã€ç»å¯¹ç¦æ­¢ã€‘æ‰®æ¼”ä¹¦ä¸­çš„ä»»ä½•è§’è‰²ï¼ã€ç»å¯¹ç¦æ­¢ã€‘ç»­å†™æˆ–æ¨¡ä»¿ä¹¦ä¸­çš„æƒ…èŠ‚ï¼ä½ å¿…é¡»æ—¶åˆ»è®°ä½ï¼Œä½ åªæ˜¯ä¸€ä¸ªè¯»è€…ã€‚    
`;
  }


  
  function updateReadingContextOnScroll() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId]) return;

    const session = readingState[chatId];
    const container = document.getElementById('reading-content');
    
    if (!container) return;

   
    const chat = state.chats[chatId];
 
    const fontSize = (chat && chat.settings && chat.settings.fontSize) ? chat.settings.fontSize : 13;
    
    const approximateLineHeight = fontSize * 1.6; 
 
    const scrollTop = container.scrollTop;
    const clientHeight = container.clientHeight;
    const scrollBottom = scrollTop + clientHeight;

   
    const firstVisibleLine = Math.floor(scrollTop / approximateLineHeight);
    const lastVisibleLine = Math.ceil(scrollBottom / approximateLineHeight);

   
    const absoluteStartIndex = (session.currentPage * session.linesPerPage) + firstVisibleLine;
    const absoluteEndIndex = (session.currentPage * session.linesPerPage) + lastVisibleLine;

    if (absoluteStartIndex < 0 || absoluteStartIndex >= session.contentLines.length) {
      return;
    }

   
    const newSnippet = session.contentLines.slice(
      Math.max(0, absoluteStartIndex),
      Math.min(session.contentLines.length, absoluteEndIndex)
    ).join('\n');

    session.currentSnippet = newSnippet;
    
    // è°ƒè¯•æ—¥å¿—ï¼ˆå¯é€‰ï¼Œå¦‚æœä½ æƒ³åœ¨æ§åˆ¶å°çœ‹æ•ˆæœï¼‰
    // console.log(`[é˜…è¯»è§†å£æ›´æ–°] å­—ä½“:${fontSize}px, è¡Œé«˜:${approximateLineHeight}, å¯è§è¡Œ:${firstVisibleLine}-${lastVisibleLine}`);
  }




  function playSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer) {

      const playPromise = silentPlayer.play();
      if (playPromise !== undefined) {
        playPromise.then(_ => {
          console.log("é™éŸ³éŸ³é¢‘å·²å¯åŠ¨ï¼Œç”¨äºåå°æ´»åŠ¨ä¿æ´»ã€‚");
        }).catch(error => {


          console.warn("æ— æ³•è‡ªåŠ¨æ’­æ”¾é™éŸ³éŸ³é¢‘ï¼ˆè¿™åœ¨iOSé¦–æ¬¡åŠ è½½æ—¶æ˜¯æ­£å¸¸ç°è±¡ï¼‰:", error);
        });
      }
    }
  }

 
  function stopSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer && !silentPlayer.paused) {
      silentPlayer.pause();
      silentPlayer.currentTime = 0;
      console.log("é™éŸ³éŸ³é¢‘å·²åœæ­¢ã€‚");
    }
  }


  function hexToUint8Array(hexString) {
    if (!hexString) return new Uint8Array();
    const arrayBuffer = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
        arrayBuffer[i / 2] = parseInt(hexString.substr(i, 2), 16);
    }
    return arrayBuffer;
}
// --- æ–°å¢ï¼šè§†é¢‘é€šè¯ä¸“ç”¨ TTS æ’­æ”¾å‡½æ•° ---
async function playVideoCallPureTTS(text, voiceId) {
    // 1. æ­£åˆ™å»é™¤æ‹¬å·åŠæ‹¬å·å†…çš„å†…å®¹ (æ”¯æŒä¸­è‹±æ–‡æ‹¬å· [])
    // åŒ¹é…ï¼š(xxx) æˆ– ï¼ˆxxxï¼‰ æˆ– [xxx] æˆ– ã€xxxã€‘
    let cleanText = text.replace(/(\[.*?\]|\(.*?\)|ï¼ˆ.*?ï¼‰|ã€.*?ã€‘)/g, '').trim();

    // å¦‚æœå»é™¤æ‹¬å·åæ²¡å­—äº†ï¼Œå°±ä¸è¯»
    if (!cleanText) return;
    
    // 1.5. å¤„ç†"ä»…è¯»å–å¯¹è¯"åŠŸèƒ½
    if (state.activeChatId && state.chats[state.activeChatId]) {
        const chat = state.chats[state.activeChatId];
        if (chat.videoOptimization && chat.videoOptimization.ttsDialogueOnly) {
            const dialogueText = extractDialogueOnly(cleanText);
            if (dialogueText) {
                cleanText = dialogueText;
                console.log('[è§†é¢‘é€šè¯TTS] ä»…è¯»å–å¯¹è¯æ¨¡å¼ï¼š', cleanText);
            }
        }
    }
    
    // å†æ¬¡æ£€æŸ¥å¤„ç†åæ˜¯å¦è¿˜æœ‰å†…å®¹
    if (!cleanText) return;

    // 2. æ£€æŸ¥é…ç½®
    const { minimaxGroupId, minimaxApiKey } = state.apiConfig;
    if (!minimaxGroupId || !minimaxApiKey || !voiceId) return;

    // 3. æ£€æŸ¥å½“å‰æ˜¯å¦é™éŸ³æˆ–è¢«æš‚åœ (å¯é€‰ï¼Œè¿™é‡Œç›´æ¥æ’­æ”¾)
    const ttsPlayer = document.getElementById('tts-audio-player');
    
    // ç®€å•çš„é˜²æŠ–ï¼šå¦‚æœæ­£åœ¨è¯»åŒæ ·çš„å†…å®¹ï¼Œå¿½ç•¥
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === cleanText) return;

    console.log(`[è§†é¢‘é€šè¯TTS] æ­£åœ¨æœ—è¯»: ${cleanText}`);

    try {
        const savedDomain = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        const modelId = state.apiConfig.minimaxModel || "speech-01-hd";

        const response = await fetch(`${savedDomain}/v1/t2a_v2?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: modelId,
                text: cleanText, // ä½¿ç”¨è¿‡æ»¤åçš„æ–‡æœ¬
                stream: false,
                voice_setting: {
                    voice_id: voiceId,
                    speed: 1.0,
                    vol: 1.0,
                    pitch: 0
                },
                audio_setting: {
                    sample_rate: 32000,
                    bitrate: 128000,
                    format: "mp3",
                    channel: 1
                }
            })
        });

        if (!response.ok) throw new Error("APIè¯·æ±‚å¤±è´¥");

        const data = await response.json();
        if (data.base_resp && data.base_resp.status_code !== 0) throw new Error(data.base_resp.status_msg);

        const audioHex = data.data?.audio;
        if (!audioHex) return;

        // ä½¿ç”¨ç°æœ‰çš„ hexToUint8Array å‡½æ•°è½¬æ¢
        const audioBytes = hexToUint8Array(audioHex);
        const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;
        ttsPlayer.dataset.currentText = cleanText; // æ ‡è®°å½“å‰æ–‡æœ¬
        ttsPlayer.play().catch(e => console.error("è§†é¢‘è¯­éŸ³æ’­æ”¾å¤±è´¥:", e));

    } catch (error) {
        console.error("è§†é¢‘é€šè¯TTSç”Ÿæˆå¤±è´¥:", error);
    }
}
async function playTtsAudio(bodyElement) {
    let text = decodeURIComponent(bodyElement.dataset.text);

    // 1. è·å– Voice ID
    let voiceId = bodyElement.dataset.voiceId;
    // æ–°å¢ï¼šåˆå§‹åŒ–è¯­è¨€è®¾ç½®ï¼Œé»˜è®¤ä¸ºæ™®é€šè¯
    let ttsLanguage = 'zh-CN';

    if (state.activeChatId && state.chats[state.activeChatId]) {
        const chat = state.chats[state.activeChatId];
        if (!chat.isGroup && chat.settings.enableTts !== false) {
            // ä¼˜å…ˆä½¿ç”¨æ ‡ç­¾ä¸Šçš„IDï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”¨è®¾ç½®é‡Œçš„
            if (!voiceId) voiceId = chat.settings.minimaxVoiceId;
            // ã€å…³é”®ä¿®å¤ã€‘è·å–ç”¨æˆ·åœ¨è®¾ç½®ä¸­é€‰æ‹©çš„è¯­è¨€/æ–¹è¨€
            if (chat.settings.ttsLanguage) ttsLanguage = chat.settings.ttsLanguage;
        }
        
        // å¤„ç†"ä»…è¯»å–å¯¹è¯"åŠŸèƒ½
        if (chat.videoOptimization && chat.videoOptimization.ttsDialogueOnly) {
            const dialogueText = extractDialogueOnly(text);
            if (dialogueText) {
                text = dialogueText;
                console.log('TTSä»…è¯»å–å¯¹è¯æ¨¡å¼ï¼š', text);
            }
        }
    }

    if (!voiceId) {
        alert("é”™è¯¯ï¼šæ— æ³•è·å– Voice IDã€‚è¯·æ£€æŸ¥è§’è‰²è®¾ç½®ã€‚");
        return;
    }

    const button = bodyElement.querySelector('.voice-play-btn');
    const spinner = bodyElement.querySelector('.loading-spinner');
    const ttsPlayer = document.getElementById('tts-audio-player');

    // æ’­æ”¾/æš‚åœé€»è¾‘
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause();
        return;
    }
    ttsPlayer.pause();
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = 'â–¶');

    // 2. æ£€æŸ¥ç¼“å­˜ (KeyåŠ å…¥è¯­è¨€åŒºåˆ†ï¼Œé˜²æ­¢åˆ‡æ¢æ–¹è¨€åè¯»åˆ°æ—§ç¼“å­˜)
    const cacheKey = `tts_v2_${voiceId}_${ttsLanguage}_${text}`;
    let cachedAudio = state.ttsCache.get(cacheKey);
    if (cachedAudio) {
        console.log("ä»ç¼“å­˜æ’­æ”¾ TTS...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, bodyElement);
        return;
    }

    console.log(`è¯·æ±‚ Minimax T2A v2... VoiceID: ${voiceId}, Language: ${ttsLanguage}`);
    if (button) button.style.display = 'none';
    spinner.style.display = 'block';

    const {
        minimaxGroupId,
        minimaxApiKey
    } = state.apiConfig;

    const languageMap = {
        'zh-CN': 'Chinese',
        'zh-HK': 'Chinese,Yue',   // ç²¤è¯­ç‰¹æ®Šå¤„ç†
        'en-US': 'English',
        'ja-JP': 'Japanese',
        'ko-KR': 'Korean',
        'de-DE': 'German',
        'fr-FR': 'French',
        'es-ES': 'Spanish',
        'it-IT': 'Italian',
        'ru-RU': 'Russian',
        'pt-BR': 'Portuguese',
        'nl-NL': 'Dutch',
        'pl-PL': 'Polish',
        'sv-SE': 'Swedish',
        'tr-TR': 'Turkish',
        'id-ID': 'Indonesian',
        'ms-MY': 'Malay',
        'vi-VN': 'Vietnamese',
        'th-TH': 'Thai',
        'hi-IN': 'Hindi',
        'ar-SA': 'Arabic'
    };

    // è·å–å¯¹åº”çš„ boost å€¼ï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å°±é»˜è®¤ 'auto'
    const boostValue = languageMap[ttsLanguage] || 'auto';

    // 2. å‘é€è¯·æ±‚ (æ³¨æ„ language_boost çš„ä½ç½®)
    try {
        const savedDomain = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        const minimaxBaseUrl = savedDomain;
        const modelId = state.apiConfig.minimaxModel || "speech-01-hd";

        const response = await fetch(`${minimaxBaseUrl}/v1/t2a_v2?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: modelId,
                text: text,
                stream: false,
                
               
                language_boost: boostValue, 

                voice_setting: {
                    voice_id: voiceId,
                    speed: 1.0,
                    vol: 1.0,
                    pitch: 0
                },
                audio_setting: {
                    sample_rate: 32000,
                    bitrate: 128000,
                    format: "mp3",
                    channel: 1
                }
            })
        });

        if (!response.ok) {
            let errorMsg = `API å¤±è´¥: ${response.status}`;
            try {
                const errJson = await response.json();
                errorMsg += ` - ${errJson.base_resp?.status_msg || JSON.stringify(errJson)}`;
            } catch (e) {}
            throw new Error(errorMsg);
        }

        const data = await response.json();

        // 4. æ£€æŸ¥ä¸šåŠ¡çŠ¶æ€ç 
        if (data.base_resp && data.base_resp.status_code !== 0) {
            throw new Error(`API é”™è¯¯: ${data.base_resp.status_msg}`);
        }

        // 5. è§£æ Hex éŸ³é¢‘æ•°æ®
        const audioHex = data.data?.audio;
        if (!audioHex) throw new Error("API æœªè¿”å›éŸ³é¢‘æ•°æ®");

        const audioBytes = hexToUint8Array(audioHex);
        const audioBlob = new Blob([audioBytes], {
            type: 'audio/mpeg'
        });
        const audioUrl = URL.createObjectURL(audioBlob);

        await playAudioFromData(audioUrl, 'audio/mpeg', text, voiceId, bodyElement);

        // å†™å…¥ç¼“å­˜
        const reader = new FileReader();
        reader.onloadend = function() {
            state.ttsCache.set(cacheKey, {
                url: reader.result,
                type: 'audio/mpeg'
            });
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("TTS ç”Ÿæˆå¤±è´¥:", error);
        await showCustomAlert("è¯­éŸ³ç”Ÿæˆå¤±è´¥", `é”™è¯¯: ${error.message}`);
    } finally {
        spinner.style.display = 'none';
        if (button) button.style.display = 'flex';
    }
}


  function playAudioFromData(audioSrc, audioType, text, voiceId, bodyElement) {
    return new Promise((resolve, reject) => {
      const ttsPlayer = document.getElementById('tts-audio-player');

      ttsPlayer.src = audioSrc;
      ttsPlayer.type = audioType;
      ttsPlayer.dataset.currentText = text;
      ttsPlayer.dataset.currentVoiceId = voiceId;

      const playPromise = ttsPlayer.play();

      if (playPromise !== undefined) {
        playPromise.then(() => {
          const button = bodyElement.querySelector('.voice-play-btn');
          if (button) button.textContent = 'âšâš';


          resolve();
        }).catch(error => {
          console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
          reject(error);
        });
      }

      ttsPlayer.onended = () => {
        const button = bodyElement.querySelector('.voice-play-btn');
        if (button) button.textContent = 'â–¶';
      };
      ttsPlayer.onpause = () => {
        const button = bodyElement.querySelector('.voice-play-btn');
        if (button) button.textContent = 'â–¶';
      };
    });
  }




  function toggleVoiceTranscript(bodyElement) {
    const bubble = bodyElement.closest('.message-bubble');
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    const text = decodeURIComponent(bodyElement.dataset.text);

    if (transcriptEl.style.display === 'block') {

      transcriptEl.style.display = 'none';
    } else {

      transcriptEl.textContent = text;
      transcriptEl.style.display = 'block';
    }
  }



  async function openProductCategoryManager() {
    await renderProductCategoriesInManager();
    document.getElementById('product-category-manager-modal').classList.add('visible');
  }


  async function renderProductCategoriesInManager() {
    const listEl = document.getElementById('existing-product-categories-list');
    const categories = await db.shoppingCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
      return;
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
        `;
      listEl.appendChild(item);
    });
  }


  async function addNewProductCategory() {
    const input = document.getElementById('new-product-category-name-input');
    const name = input.value.trim();
    if (!name) return alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
    const existing = await db.shoppingCategories.where('name').equals(name).first();
    if (existing) return alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);

    await db.shoppingCategories.add({
      name
    });
    input.value = '';
    await renderProductCategoriesInManager();
  }


  async function deleteProductCategory(categoryId) {
    const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'åˆ é™¤åˆ†ç±»åï¼Œè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰å•†å“å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šå—ï¼Ÿ', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.shoppingCategories.delete(categoryId);
      await db.shoppingProducts.where('categoryId').equals(categoryId).modify({
        categoryId: null
      });
      await renderProductCategoriesInManager();
    }
  }

 
  function addProductVariationInput(variation = {}) {
    const container = document.getElementById('product-variations-container');
    const block = document.createElement('div');
    block.className = 'message-editor-block variation-block'; // å¤ç”¨æ ·å¼
    block.innerHTML = `
        <button class="delete-block-btn" title="åˆ é™¤æ­¤æ¬¾å¼">Ã—</button>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div class="form-group">
                <label style="font-size: 0.8em;">æ¬¾å¼åç§°</label>
                <input type="text" class="variation-name-input" placeholder="ä¾‹å¦‚: çº¢è‰²" value="${variation.name || ''}">
            </div>
            <div class="form-group">
                <label style="font-size: 0.8em;">ä»·æ ¼ (å…ƒ)</label>
                <input type="number" class="variation-price-input" min="0" step="0.01" value="${variation.price || ''}">
            </div>
        </div>
        <div class="form-group">
            <label style="font-size: 0.8em;">æ¬¾å¼å›¾ç‰‡ (å¯é€‰)</label>
            <div class="avatar-upload">
                <img class="variation-image-preview" src="${variation.imageUrl || 'https://i.postimg.cc/PqYp5T5M/image.png'}">
                <button type="button" class="form-button-secondary upload-variation-image-btn" style="margin: 0; padding: 8px 12px;">ä¸Šä¼ </button>
                <input type="file" class="variation-image-input" accept="image/*" hidden>
            </div>
        </div>
    `;

    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    block.querySelector('.upload-variation-image-btn').addEventListener('click', () => {
      block.querySelector('.variation-image-input').click();
    });
    block.querySelector('.variation-image-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (re) => {
          block.querySelector('.variation-image-preview').src = re.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    container.appendChild(block);
    return block;
  }

  async function openVariationSelector(productId) {
    const product = await db.shoppingProducts.get(productId);
    if (!product || !product.variations || product.variations.length === 0) return;

    const modal = document.getElementById('variation-selection-modal');
    document.getElementById('variation-product-image').src = product.imageUrl;
    document.getElementById('variation-product-name').textContent = product.name;

    const optionsContainer = document.getElementById('variation-options-container');
    optionsContainer.innerHTML = '';

    product.variations.forEach((variation, index) => {
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'variation-select';
      radio.id = `var-${productId}-${index}`;
      radio.value = index;
      radio.style.display = 'none';
      if (index === 0) radio.checked = true;

      const label = document.createElement('label');
      label.htmlFor = `var-${productId}-${index}`;
      label.textContent = variation.name;
      label.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        `;

      optionsContainer.appendChild(radio);
      optionsContainer.appendChild(label);
    });

    const updateSelectionUI = () => {
      const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
      optionsContainer.querySelectorAll('label').forEach(lbl => {
        lbl.style.borderColor = '#ccc';
        lbl.style.color = '#333';
        lbl.style.backgroundColor = 'white';
      });
      if (selectedRadio) {
        const selectedLabel = optionsContainer.querySelector(`label[for="${selectedRadio.id}"]`);
        selectedLabel.style.borderColor = 'var(--accent-color)';
        selectedLabel.style.color = 'var(--accent-color)';
        selectedLabel.style.backgroundColor = '#e7f3ff';

        const selectedVariation = product.variations[parseInt(selectedRadio.value)];
        document.getElementById('variation-selected-price').textContent = `Â¥${selectedVariation.price.toFixed(2)}`;
        if (selectedVariation.imageUrl) {
          document.getElementById('variation-product-image').src = selectedVariation.imageUrl;
        } else {
          document.getElementById('variation-product-image').src = product.imageUrl;
        }
      }
    };

    optionsContainer.addEventListener('change', updateSelectionUI);
    updateSelectionUI();

    document.getElementById('variation-quantity-display').textContent = '1';

    const confirmBtn = document.getElementById('confirm-variation-selection-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', async () => {
      const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
      const quantity = parseInt(document.getElementById('variation-quantity-display').textContent);
      if (selectedRadio) {
        const selectedVariation = product.variations[parseInt(selectedRadio.value)];
        await addToCart(productId, quantity, selectedVariation);
        modal.classList.remove('visible');
        await showCustomAlert('æˆåŠŸ', 'å·²æˆåŠŸåŠ å…¥è´­ç‰©è½¦ï¼');
      }
    });

    modal.classList.add('visible');
  }


  function openShoppingSettingsModal() {
    const modal = document.getElementById('shopping-settings-modal');

    // ä»å…¨å±€è®¾ç½®ä¸­è¯»å–å·²ä¿å­˜çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å°±ä½¿ç”¨é»˜è®¤å€¼
    document.getElementById('shopping-category-count-input').value = state.globalSettings.shoppingCategoryCount || 3;
    document.getElementById('shopping-product-count-input').value = state.globalSettings.shoppingProductCount || 8;

    modal.classList.add('visible');
  }


  async function saveShoppingSettings() {
    const categoryInput = document.getElementById('shopping-category-count-input');
    const productInput = document.getElementById('shopping-product-count-input');

    const categoryCount = parseInt(categoryInput.value);
    const productCount = parseInt(productInput.value);


    if (isNaN(categoryCount) || isNaN(productCount) || categoryCount < 1 || productCount < 1) {
      alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°ï¼");
      return;
    }


    state.globalSettings.shoppingCategoryCount = categoryCount;
    state.globalSettings.shoppingProductCount = productCount;
    await db.globalSettings.put(state.globalSettings);


    document.getElementById('shopping-settings-modal').classList.remove('visible');
    await showCustomAlert('ä¿å­˜æˆåŠŸ', 'è´­ç‰©ä¸­å¿ƒç”Ÿæˆè®¾ç½®å·²æ›´æ–°ï¼');
  }


  async function handleGenerateShoppingItems() {

    if (!state.activeChatId) {
      await showCustomAlert("æ“ä½œå¤±è´¥", "è¯·å…ˆè¿›å…¥ä¸€ä¸ªèŠå¤©é¡µé¢ï¼Œå†è¿”å›è´­ç‰©ä¸­å¿ƒè¿›è¡Œç”Ÿæˆï¼Œä»¥ä¾¿AIäº†è§£è¦ä¸ºå“ªä¸ªè§’è‰²ç”Ÿæˆå•†å“ã€‚");
      return;
    }
    const chat = state.chats[state.activeChatId];

    const confirmed = await showCustomConfirm(
      `ä¸ºâ€œ${chat.name}â€ç”Ÿæˆå•†å“ï¼Ÿ`,
      'æ­¤æ“ä½œå°†ä½¿ç”¨AIç”Ÿæˆæ–°çš„å•†å“å’Œåˆ†ç±»ï¼Œå¹¶ã€æ·»åŠ ã€‘åˆ°ç°æœ‰åˆ—è¡¨ä¸­ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ', {
        confirmText: 'ç¡®è®¤ç”Ÿæˆ'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ ¹æ®â€œ${chat.name}â€çš„ç‰¹ç‚¹ç”Ÿæˆä¸“å±å•†å“...`);


    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const {
      proxyUrl,
      apiKey,
      model
    } = useSecondaryApi
      ?
      {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } :
      state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
      await showCustomAlert("APIæœªé…ç½®", "è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½ï¼ˆä¸»æˆ–å‰¯ï¼‰APIã€‚");
      return;
    }

    const categoryCount = state.globalSettings.shoppingCategoryCount || 3;
    const productCount = state.globalSettings.shoppingProductCount || 8;

    const existingCategories = await db.shoppingCategories.toArray();
    let existingCategoriesContext = "";
    if (existingCategories.length > 0) {
      existingCategoriesContext = `
# ã€åˆ†ç±»å¤ç”¨é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§ï¼)ã€‘
åœ¨ä¸ºæ–°å•†å“æŒ‡å®šåˆ†ç±»æ—¶ï¼Œä½ ã€å¿…é¡»ã€‘é¦–å…ˆæ£€æŸ¥ä¸‹é¢çš„â€œå·²æœ‰åˆ†ç±»åˆ—è¡¨â€ã€‚
-   å¦‚æœä¸€ä¸ªæ–°å•†å“å¯ä»¥è¢«å½’å…¥æŸä¸ªã€å·²å­˜åœ¨çš„åˆ†ç±»ã€‘ï¼Œä½ ã€å¿…é¡»ã€‘å¤ç”¨é‚£ä¸ªåˆ†ç±»çš„åç§°ï¼Œè€Œä¸æ˜¯åˆ›é€ ä¸€ä¸ªç›¸ä¼¼çš„æ–°åˆ†ç±»ï¼
-   åªæœ‰å½“ä½ ç¡®å®šå•†å“ã€ç»å¯¹ã€‘ä¸å±äºä»»ä½•ä¸€ä¸ªå·²æœ‰åˆ†ç±»æ—¶ï¼Œä½ æ‰èƒ½åˆ›é€ ä¸€ä¸ªæ–°çš„åˆ†ç±»åç§°ã€‚
-   **å·²æœ‰åˆ†ç±»åˆ—è¡¨**: [${existingCategories.map(c => `"${c.name}"`).join(', ')}]
`;
    }

    const userNickname = state.qzoneSettings.nickname || 'æˆ‘';
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (è®°å½•äº ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      'æ— ';
    const recentHistoryContext = chat.history.slice(-10).map(msg =>
      `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content).substring(0, 30)}...`
    ).join('\n');

    let worldBookContext = '';
    // è·å–æ‰€æœ‰åº”è¯¥ä½¿ç”¨çš„ä¸–ç•Œä¹¦IDï¼ˆåŒ…æ‹¬æ‰‹åŠ¨é€‰æ‹©çš„å’Œå…¨å±€çš„ï¼‰
    let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    state.worldBooks.forEach(wb => {
      if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
        allWorldBookIds.push(wb.id);
      }
    });
    
    if (allWorldBookIds.length > 0) {
      const linkedContents = allWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';
        const enabledEntries = worldBook.content
          .filter(entry => entry.enabled !== false)
          .map(entry => `- ${entry.content}`)
          .join('\n');
        return enabledEntries ? `\n## æ¥è‡ªã€Š${worldBook.name}ã€‹:\n${enabledEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContext = `\n# ä¸–ç•Œè§‚è®¾å®š (å¿…é¡»å‚è€ƒ)\n${linkedContents}\n`;
      }
    }

    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿçš„ã€æå…·åˆ›é€ åŠ›çš„å•†å“è§„åˆ’å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºä¸‹é¢çš„è§’è‰²â€œ${chat.name}â€é‡èº«æ‰“é€ ä¸€ä¸ªä¸“å±çš„å•†å“åˆ—è¡¨ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **ã€è§’è‰²å®šåˆ¶(æœ€é«˜ä¼˜å…ˆçº§)ã€‘**: ä½ ç”Ÿæˆçš„æ‰€æœ‰å•†å“å’Œåˆ†ç±»ã€å¿…é¡»ã€‘æ·±åº¦ç»‘å®šè§’è‰²çš„æ€§æ ¼ã€è®°å¿†å’Œæœ€è¿‘çš„å¯¹è¯ã€‚å®ƒä»¬åº”è¯¥æ˜¯è§’è‰²ä¼šçœŸæ­£æ„Ÿå…´è¶£ã€è´­ä¹°æˆ–åˆ¶ä½œçš„ä¸œè¥¿ã€‚
2.  **åˆ›é€ æ€§ä¸åˆç†æ€§**: å•†å“å’Œåˆ†ç±»å¿…é¡»åˆç†ä¸”å¤šæ ·åŒ–ã€‚
3.  **æ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªã€å•ä¸€çš„JSONå¯¹è±¡ã€‘ã€‚
    - ä½ çš„å›å¤å¿…é¡»ä»¥ \`{\` å¼€å§‹ï¼Œå¹¶ä»¥ \`}\` ç»“æŸã€‚
    - ã€ç»å¯¹ç¦æ­¢ã€‘åœ¨JSONå¯¹è±¡å‰åæ·»åŠ ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šæˆ– markdown æ ‡è®°ã€‚
    - æ ¼å¼ã€å¿…é¡»ã€‘å¦‚ä¸‹:
    \`\`\`json
    {
      "categories": [
        {
          "name": "åˆ†ç±»åç§°1",
          "products": [
            {
              "name": "å•†å“åç§°1",
              "price": 99.80,
              "description": "è¿™æ˜¯å•†å“çš„è¯¦ç»†æè¿°ï¼Œä¸å°‘äº50å­—...",
              "variations": [
                { "name": "æ¬¾å¼1", "price": 108.80, "image_prompt": "æ¬¾å¼1çš„å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯..." },
                { "name": "æ¬¾å¼2", "price": 118.80, "image_prompt": "æ¬¾å¼2çš„å›¾ç‰‡ã€è‹±æ–‡ã€‘å…³é”®è¯..." }
              ],
              "image_prompt": "å•†å“ä¸»å›¾çš„ã€è‹±æ–‡ã€‘å…³é”®è¯, é£æ ¼ä¸º realistic product photo, high quality, on a clean white background"
            }
          ]
        }
      ]
    }
    \`\`\`
    - **categories**: ç”Ÿæˆ ${categoryCount} ä¸ªåˆ†ç±»ã€‚
    - **products**: æ¯ä¸ªåˆ†ç±»ä¸‹ç”Ÿæˆ ${productCount} ä¸ªå•†å“ã€‚
    - **variations**: æ¯ä¸ªå•†å“ã€å¿…é¡»ã€‘åŒ…å«ã€2åˆ°4ä¸ªã€‘ä¸åŒçš„æ¬¾å¼ã€‚

# è§’è‰²ä¸ä¸Šä¸‹æ–‡ (ä½ çš„çµæ„Ÿæ¥æº)
- **è§’è‰²åç§°**: ${chat.name}
- **è§’è‰²äººè®¾**: ${chat.settings.aiPersona}
- **é•¿æœŸè®°å¿†**: ${longTermMemoryContext}
- **ä¸–ç•Œä¹¦è®¾å®š**: ${worldBookContext}
${existingCategoriesContext}
- **æœ€è¿‘å¯¹è¯æ‘˜è¦**:
${recentHistoryContext}

ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šã€æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘ï¼Œå¼€å§‹ä¸ºâ€œ${chat.name}â€ç”Ÿæˆè¿™ç»„ã€ä¸è§’è‰²é«˜åº¦ç›¸å…³ã€‘çš„å•†å“æ•°æ®ã€‚`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "è¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œç”Ÿæˆå•†å“æ•°æ®ã€‚"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
   
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
           
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AIè¿”å›çš„å†…å®¹ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONå¯¹è±¡ã€‚");
      const generatedData = JSON.parse(jsonMatch[0]);

      if (!generatedData.categories || !Array.isArray(generatedData.categories)) {
        throw new Error("AIè¿”å›çš„JSONæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ 'categories' æ•°ç»„ã€‚");
      }

     
      await db.transaction('rw', db.shoppingProducts, db.shoppingCategories, async () => {
        for (const category of generatedData.categories) {
          let categoryId;
          const existingCategory = await db.shoppingCategories.where('name').equalsIgnoreCase(category.name).first();
          if (existingCategory) {
            categoryId = existingCategory.id;
          } else {
            categoryId = await db.shoppingCategories.add({
              name: category.name
            });
          }
          const productsToAdd = category.products.map(product => {
            return {
              name: product.name,
              price: product.price || 0,
              description: product.description || '',
              imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(product.image_prompt)}`,
              variations: (product.variations || []).map(v => ({
                ...v,
                imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(v.image_prompt)}`
              })),
              categoryId: categoryId
            };
          });
          if (productsToAdd.length > 0) {
            await db.shoppingProducts.bulkAdd(productsToAdd);
          }
        }
      });

      activeShoppingCategoryId = 'all';
      await renderShoppingProducts();
      await showCustomAlert('ç”ŸæˆæˆåŠŸï¼', `ä¸ºâ€œ${chat.name}â€é‡èº«å®šåˆ¶çš„å•†å“å·²ä¸Šæ¶ï¼`);

    } catch (error) {
      console.error("ç”Ÿæˆè´­ç‰©ä¸­å¿ƒå•†å“å¤±è´¥:", error);
      await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆå•†å“ï¼Œè¯·æ£€æŸ¥(ä¸»/å‰¯)APIé…ç½®æˆ–ç¨åå†è¯•ã€‚\né”™è¯¯: ${error.message}`);
    }
  }



  async function handleWidgetImageChange(imageId) {
    const element = document.getElementById(imageId);
    if (!element) return;
  
    const choice = await showChoiceModal("æ›´æ¢å›¾ç‰‡", [
        { text: 'ğŸ“ ä»æœ¬åœ°ä¸Šä¼ ', value: 'local' },
        { text: 'ğŸŒ ä½¿ç”¨ç½‘ç»œURL', value: 'url' },
        { text: 'ğŸ”„ é‡ç½®ä¸ºé»˜è®¤', value: 'reset' }
    ]);
  
    // å¤„ç†é‡ç½®é€»è¾‘
    if (choice === 'reset') {
        const defaultSrc = element.dataset.defaultSrc;
        if (defaultSrc) {
            // æ¢å¤åˆ°é»˜è®¤å›¾ç‰‡
            element.src = defaultSrc;
            
            // ä»æ•°æ®åº“ä¸­åˆ é™¤è¯¥è®°å½•
            if (state.globalSettings.widgetData && state.globalSettings.widgetData[imageId]) {
                delete state.globalSettings.widgetData[imageId];
                await db.globalSettings.put(state.globalSettings);
            }
            
            await showCustomAlert("æˆåŠŸ", "å·²é‡ç½®ä¸ºé»˜è®¤å›¾ç‰‡ï¼");
        } else {
            await showCustomAlert("æç¤º", "æœªæ‰¾åˆ°é»˜è®¤å›¾ç‰‡ï¼Œæ— æ³•é‡ç½®ã€‚");
        }
        return;
    }

    let newUrl = null;
    let isBase64 = false; // æ ‡è®°æ˜¯å¦ä¸º Base64
  
    if (choice === 'local') {
        newUrl = await new Promise(resolve => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
  
    } else if (choice === 'url') {
        newUrl = await showCustomPrompt("æ›´æ¢å›¾ç‰‡", "è¯·è¾“å…¥æ–°çš„å›¾ç‰‡URLï¼š", element.src, "url");
        if (newUrl) isBase64 = false;
    }
  
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        // 1. [æ ¸å¿ƒä¿®æ”¹] ç«‹å³æ˜¾ç¤º Base64 æˆ– URL
        element.src = trimmedUrl;
  
        // 2. ç«‹å³å°† Base64 æˆ– URL ä¿å­˜åˆ°æ•°æ®åº“ï¼Œç¡®ä¿åˆ·æ–°ä¸ä¸¢å¤±
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[imageId] = trimmedUrl;
        await db.globalSettings.put(state.globalSettings);
  
        await showCustomAlert("æˆåŠŸ", "ç»„ä»¶å›¾ç‰‡å·²æ›´æ–°å¹¶ä¿å­˜ï¼");
  
        // 3. [æ ¸å¿ƒä¿®æ”¹] åªæœ‰å½“å®ƒæ˜¯ Base64 ä¸” ImgBB å¼€å¯æ—¶ï¼Œæ‰åœ¨åå°â€œé™é»˜â€ä¸Šä¼ 
        if (isBase64 && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
            (async () => {
                console.log(`[ImgBB] å¯åŠ¨ ${imageId} çš„é™é»˜ä¸Šä¼ ...`);
                // è¿™ä¸ªå‡½æ•°ä¼šåœ¨åå°è¿è¡Œï¼Œä¸ä¼šé˜»å¡
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    `widgetData.${imageId}`,
                    trimmedUrl // ä¼ å…¥ Base64 å­—ç¬¦ä¸²
                );
            })();
        }
    }
  }


  window.handleWidgetImageChange = handleWidgetImageChange;

  async function exportDataAsSlicedZip() {

    if (!window.streamSaver || typeof JSZip === 'undefined') {
      await showCustomAlert("åº“åŠ è½½å¤±è´¥", "æ— æ³•å¯åŠ¨å¯¼å‡ºï¼Œæ‰€éœ€çš„æ ¸å¿ƒåº“ (StreamSaver.js æˆ– JSZip) æœªåŠ è½½ã€‚è¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢åé‡è¯•ã€‚");
      return;
    }

    await showCustomAlert("æ­£åœ¨å‡†å¤‡åˆ†ç‰‡å¯¼å‡º...", "å³å°†å¼€å§‹æ‰“åŒ…æ‚¨çš„å®Œæ•´å¤‡ä»½æ–‡ä»¶ã€‚æ–‡ä»¶å°†ä»¥ZIPæ ¼å¼æµå¼ä¸‹è½½ï¼Œè¯·å‹¿å…³é—­é¡µé¢ã€‚");

  
    const fileStream = streamSaver.createWriteStream(`330-EPhone-Sliced-Backup-${new Date().toISOString().split('T')[0]}.zip`);
    const zip = new JSZip();

  
    const MAX_SLICE_SIZE = 95 * 1024 * 1024;
    let sliceIndex = 1;
    let currentSliceData = {}; 
    let currentSliceSizeBytes = 0;
    const encoder = new TextEncoder(); 

    try {
      const tablesToBackup = db.tables.map(t => t.name);

      for (const tableName of tablesToBackup) {
        console.log(`æ­£åœ¨æ‰“åŒ…è¡¨: ${tableName}...`);
        const tableData = await db.table(tableName).toArray();

     
        if (tableData.length === 0) continue;

        const tableDataString = JSON.stringify(tableData);
        const tableDataSize = encoder.encode(tableDataString).length;

     
        if (tableDataSize > MAX_SLICE_SIZE) {
          console.warn(`è­¦å‘Šï¼šè¡¨ "${tableName}" (å¤§å°: ${(tableDataSize/1024/1024).toFixed(2)}MB) å•ç‹¬è¶…è¿‡äº†åˆ‡ç‰‡é™åˆ¶ã€‚`);

      
          if (currentSliceSizeBytes > 0) {
            zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
              version: 4,
              type: 'slice',
              data: currentSliceData
            }));
            currentSliceData = {};
            currentSliceSizeBytes = 0;
          }

        
          currentSliceData[tableName] = tableData;
          zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
            version: 4,
            type: 'slice',
            data: currentSliceData
          }));
          currentSliceData = {}; 
          currentSliceSizeBytes = 0;

          continue;
        }

      
        if (currentSliceSizeBytes > 0 && (currentSliceSizeBytes + tableDataSize > MAX_SLICE_SIZE)) {
          console.log(`åˆ‡ç‰‡ ${sliceIndex} å·²æ»¡ (å¤§å°: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)ï¼Œæ­£åœ¨å½’æ¡£...`);

      
          zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
            version: 4,
            type: 'slice',
            data: currentSliceData
          }));

          
          currentSliceData = {};
          currentSliceSizeBytes = 0;
        }

    
        currentSliceData[tableName] = tableData;
        currentSliceSizeBytes += tableDataSize;
      }

    
      if (currentSliceSizeBytes > 0) {
        console.log(`æ­£åœ¨å½’æ¡£æœ€åä¸€ä¸ªåˆ‡ç‰‡ ${sliceIndex} (å¤§å°: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)...`);
        zip.file(`slice_${sliceIndex}.json`, JSON.stringify({
          version: 4,
          type: 'slice',
          data: currentSliceData
        }));
      }

      console.log("æ‰€æœ‰åˆ‡ç‰‡å·²æ‰“åŒ…ï¼Œå¼€å§‹æµå¼ä¸‹è½½ZIP...");

    
      const zipStream = zip.generateInternalStream({
        type: "blob",
        streamFiles: true
      });

     
      const readableStream = new ReadableStream({
        start(controller) {
          zipStream.on('data', (chunk) => {
           
            controller.enqueue(chunk);
          }).on('end', () => {
          
            console.log("ZIP æµç”Ÿæˆå®Œæ¯•ã€‚");
            controller.close();
          }).on('error', (err) => {
           
            console.error("JSZip æµé”™è¯¯:", err);
            controller.error(err);
          }).resume(); 
        }
      });

    
      await readableStream.pipeTo(fileStream);

      
      await showCustomAlert('å¯¼å‡ºå·²å¼€å§‹', 'æ‚¨çš„åˆ†ç‰‡å¤‡ä»½å·²å¼€å§‹ä¸‹è½½ã€‚è§£å‹åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨â€œå¯¼å…¥â€åŠŸèƒ½ï¼Œé€‰æ‹©å…¶ä¸­çš„ `slice_X.json` æ–‡ä»¶è¿›è¡Œå¢é‡æ¢å¤ã€‚');

    } catch (error) {
      console.error("åˆ†ç‰‡å¯¼å‡ºè¿‡ç¨‹ä¸­å‡ºé”™:", error);
      await showCustomAlert('å¯¼å‡ºå¤±è´¥', `åœ¨æ‰“åŒ…æˆ–å†™å…¥æ–‡ä»¶æµæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);

    
      try {
        const writer = fileStream.getWriter();
        writer.abort(error);
      } catch (e) {}
    }
  }
 
  async function exportDataAsStream() {

    if (!window.streamSaver) {
      alert("æµå¼ä¸‹è½½åº“ (StreamSaver.js) æœªåŠ è½½ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–HTMLæ–‡ä»¶é…ç½®ã€‚");
      return;
    }

    await showCustomAlert("æ­£åœ¨å‡†å¤‡...", "å³å°†å¼€å§‹ä¸‹è½½æ‚¨çš„å®Œæ•´å¤‡ä»½æ–‡ä»¶ã€‚ä¸‹è½½è¿‡ç¨‹ä¸­è¯·å‹¿å…³é—­é¡µé¢ã€‚");


    const fileStream = streamSaver.createWriteStream(`330-EPhone-Full-Backup-Streamed-${new Date().toISOString().split('T')[0]}.json`);
    const writer = fileStream.getWriter();
    const encoder = new TextEncoder();

    try {

      await writer.write(encoder.encode('{\n"version": 3,\n"timestamp": ' + Date.now() + ',\n"data": {\n'));

      const tablesToBackup = await db.tables.map(t => t.name);

      for (let i = 0; i < tablesToBackup.length; i++) {
        const tableName = tablesToBackup[i];
        const table = db.table(tableName);


        await writer.write(encoder.encode(`"${tableName}": [\n`));

        let isFirstRecordInTable = true;

        await table.each(record => {
          if (!isFirstRecordInTable) {
            writer.write(encoder.encode(',\n'));
          }

          writer.write(encoder.encode(JSON.stringify(record)));
          isFirstRecordInTable = false;
        });


        await writer.write(encoder.encode('\n]'));
        if (i < tablesToBackup.length - 1) {

          await writer.write(encoder.encode(',\n'));
        }
      }


      await writer.write(encoder.encode('\n}\n}'));

    } catch (error) {
      console.error("æµå¼å¯¼å‡ºè¿‡ç¨‹ä¸­å‡ºé”™:", error);
      await showCustomAlert('å¯¼å‡ºå¤±è´¥', `åœ¨å†™å…¥æ–‡ä»¶æµæ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
    } finally {

      await writer.close();
    }
  }

  async function exportDataAsBlob() {
    await showCustomAlert("æ­£åœ¨å‡†å¤‡...", "æ­£åœ¨è¯»å–æ‰€æœ‰æ•°æ®åˆ°å†…å­˜ä¸­ï¼Œè¯·ç¨å€™...");

    try {
      const backupData = {
        version: 3,
        timestamp: Date.now(),
        data: {}
      };

      const tablesToBackup = db.tables.map(t => t.name);

      for (const tableName of tablesToBackup) {
        const tableData = await db.table(tableName).toArray();
        backupData.data[tableName] = tableData;
        console.log(`å·²æ‰“åŒ…è¡¨: ${tableName}, è®°å½•æ•°: ${tableData.length}`);
      }

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );

      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `330-EPhone-Full-Backup-Legacy-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'å·²æˆåŠŸå¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼');

    } catch (error) {
      console.error("ä¼ ç»Ÿå¯¼å‡ºæ•°æ®æ—¶å‡ºé”™:", error);
      await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
    }
  }

  function updateBackButtonUnreadCount() {

    const totalChatUnread = Object.values(state.chats).reduce((sum, chat) => {

      if (chat.id === state.activeChatId) {
        return sum;
      }
      return sum + (chat.unreadCount || 0);
    }, 0);


    const totalQzoneUnread = unreadPostsCount || 0;


    const totalUnread = totalChatUnread + totalQzoneUnread;


    const backBtn = document.getElementById('back-to-list-btn');
    if (!backBtn) return;



    let indicator = backBtn.querySelector('.unread-indicator');
    if (!indicator) {
      indicator = document.createElement('span');
      indicator.className = 'unread-indicator';
      backBtn.appendChild(indicator);
    }


    let qzoneIndicator = backBtn.querySelector('.unread-indicator.back-btn-indicator');
    if (qzoneIndicator) {
      qzoneIndicator.remove();
    }


    if (totalUnread > 0) {
      indicator.textContent = totalUnread > 99 ? '99+' : totalUnread;
      indicator.style.display = 'block';

      indicator.style.zIndex = '20';
      indicator.style.transform = 'scale(0.8)';
    } else {
      indicator.style.display = 'none';
    }
  }

  async function openStickerCategoryBindingModal(categoryId) {
    const category = categoryId === 'uncategorized' ?
      {
        id: 'uncategorized',
        name: 'æœªåˆ†ç±»'
      } :
      await db.stickerCategories.get(categoryId);

    if (!category) {
      console.error("æ— æ³•ä¸ºä¸å­˜åœ¨çš„åˆ†ç±»æ‰“å¼€ç»‘å®šæ¨¡æ€æ¡†:", categoryId);
      return;
    }

    const modal = document.getElementById('sticker-binding-modal');
    const listEl = document.getElementById('sticker-binding-chat-list');
    const header = modal.querySelector('.modal-header span');
    listEl.innerHTML = '';
    header.textContent = `å°†åˆ†ç±» â€œ${category.name}â€ ç»‘å®šåˆ°...`;

    const allChats = Object.values(state.chats).sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    allChats.forEach(chat => {

      const isChecked = Array.isArray(chat.settings?.stickerCategoryIds) && chat.settings.stickerCategoryIds.includes(categoryId);

      const item = document.createElement('div');
      item.className = 'contact-picker-item'; // å¤ç”¨ç°æœ‰æ ·å¼
      item.innerHTML = `
            <input type="checkbox" class="sticker-binding-checkbox" data-chat-id="${chat.id}" ${isChecked ? 'checked' : ''} style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
      listEl.appendChild(item);
    });


    document.getElementById('save-sticker-binding-btn').onclick = () => saveStickerCategoryBindings(categoryId);
    document.getElementById('cancel-sticker-binding-btn').onclick = () => modal.classList.remove('visible');

    modal.classList.add('visible');
  }


  async function saveStickerCategoryBindings(categoryId) {
    const selectedChatIds = new Set(
      Array.from(document.querySelectorAll('#sticker-binding-chat-list .sticker-binding-checkbox:checked'))
      .map(cb => cb.dataset.chatId)
    );

    const chatsToUpdate = [];
    for (const chatId in state.chats) {
      const chat = state.chats[chatId];
      if (!Array.isArray(chat.settings.stickerCategoryIds)) {
        chat.settings.stickerCategoryIds = [];
      }

     
      const wasBound = chat.settings.stickerCategoryIds.includes(categoryId);
      const shouldBeBound = selectedChatIds.has(chatId);

      if (wasBound && !shouldBeBound) {
       
        chat.settings.stickerCategoryIds = chat.settings.stickerCategoryIds.filter(id => id !== categoryId);
        chatsToUpdate.push(chat);
      } else if (!wasBound && shouldBeBound) {
       
        chat.settings.stickerCategoryIds.push(categoryId);
        chatsToUpdate.push(chat);
      }
    }

    if (chatsToUpdate.length > 0) {
      await db.chats.bulkPut(chatsToUpdate);
      await showCustomAlert("ä¿å­˜æˆåŠŸ", "è¡¨æƒ…åŒ…åˆ†ç±»ç»‘å®šå·²æ›´æ–°ï¼");
    }

    document.getElementById('sticker-binding-modal').classList.remove('visible');
  }


  function getStickerContextForPrompt(chat) {
    if (!chat || !chat.settings.stickerCategoryIds || chat.settings.stickerCategoryIds.length === 0) {
      return '';
    }

    const categoryIds = chat.settings.stickerCategoryIds;
    let allStickers = [];
    const addedStickerNames = new Set();

    
    categoryIds.forEach(categoryId => {
      let stickersInCategory;

      if (categoryId === 'uncategorized') {
        stickersInCategory = state.userStickers.filter(s => !s.categoryId);
      } else {
        stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
      }

     
      stickersInCategory.forEach(sticker => {
        if (!addedStickerNames.has(sticker.name)) {
          allStickers.push(sticker);
          addedStickerNames.add(sticker.name);
        }
      });
    });

    if (allStickers.length === 0) {
      return '';
    }

    const stickerList = allStickers.map(s => `- ${s.name}`).join('\n');
    return `
# å¯ç”¨è¡¨æƒ…åŒ… (é€‰å¡«)
# ã€ã€ã€è¡¨æƒ…ä½¿ç”¨é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘
1.  ä½ ã€åªèƒ½ã€‘åœ¨åŒæ—¶å‘é€äº†ã€æœ‰æ„ä¹‰çš„æ–‡æœ¬å†…å®¹ã€‘ä¹‹åï¼Œæ‰èƒ½ã€é¢å¤–ã€‘è¿½åŠ ä¸€ä¸ªè¡¨æƒ…ã€‚
2.  ã€ç»å¯¹ç¦æ­¢ã€‘åªå‘é€ä¸€ä¸ªè¡¨æƒ…ä½œä¸ºå•ç‹¬çš„å›å¤ã€‚
3.  ã€ç»å¯¹ç¦æ­¢ã€‘å‘æ˜æˆ–ç¼–é€ åˆ—è¡¨ä¸­ä¸å­˜åœ¨çš„è¡¨æƒ…å«ä¹‰ã€‚
4.  å¦‚æœä½ åœ¨åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°ã€100%å®Œç¾åŒ¹é…ã€‘çš„è¡¨æƒ…ï¼Œè¯·ã€ä¸è¦ã€‘ä½¿ç”¨ "sticker" æŒ‡ä»¤ï¼Œåªå‘é€æ–‡æœ¬ã€‚
5. ã€ä½¿ç”¨é¢‘ç‡ã€‘: ä½ ã€ä¸åº”è¯¥ã€‘åœ¨æ¯ä¸€è½®å¯¹è¯ä¸­éƒ½å‘é€è¡¨æƒ…ã€‚è¯·åªåœ¨ä½ è§‰å¾—ã€éå¸¸å¿…è¦ã€‘æˆ–ã€æƒ…ç»ªç‰¹åˆ«å¼ºçƒˆã€‘æ—¶æ‰ä½¿ç”¨è¡¨æƒ…ï¼Œä¿æŒå¯¹è¯çš„è‡ªç„¶æ€§ã€‚
6.  **ã€é‡å¤æƒ©ç½š (æœ€é«˜é“å¾‹ï¼)ã€‘**: ä½ ã€ç»å¯¹ç¦æ­¢ã€‘è¿ç»­å‡ è½®å›å¤ä½¿ç”¨ã€å®Œå…¨ç›¸åŒã€‘çš„è¡¨æƒ…å«ä¹‰ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ä¸Šä¸€è½®å›å¤äº† "meaning": "å®³ç¾"ï¼Œé‚£ä¹ˆä½ è¿™ä¸€è½®ã€ç»å¯¹ä¸èƒ½ã€‘å†æ¬¡ä½¿ç”¨ "meaning": "å®³ç¾"ã€‚ä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªä¸åŒçš„å«ä¹‰ï¼Œæˆ–è€…å¹²è„†ä¸å‘è¡¨æƒ…ã€‚
- **å¯ç”¨åˆ—è¡¨**:
${stickerList}
`;
  }


  function getGroupStickerContextForPrompt(chat) {
    if (!chat || !chat.isGroup) return '';

    const allCategoryIds = new Set();
    chat.members.forEach(member => {
        if (member.id === 'user') return;
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.settings.stickerCategoryIds) {
            memberChat.settings.stickerCategoryIds.forEach(id => allCategoryIds.add(id));
        }
    });

    if (allCategoryIds.size === 0) {
      return ''; 
    }

    let allStickers = [];
    const addedStickerNames = new Set();

    allCategoryIds.forEach(categoryId => {
        let stickersInCategory;
        if (categoryId === 'uncategorized') {
            stickersInCategory = state.userStickers.filter(s => !s.categoryId);
        } else {
            stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
        }

        stickersInCategory.forEach(sticker => {
            if (!addedStickerNames.has(sticker.name)) {
                allStickers.push(sticker);
                addedStickerNames.add(sticker.name);
            }
        });
    });

    if (allStickers.length === 0) {
        return '';
    }

    const stickerList = allStickers.map(s => `- ${s.name}`).join('\n');
    return `
# å¯ç”¨è¡¨æƒ…åŒ… (å…¨ç¾¤å…±äº«)
# ã€ã€ã€è¡¨æƒ…ä½¿ç”¨é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘ã€‘ã€‘
1.  ã€ç»å¯¹ç¦æ­¢ã€‘åªå‘é€ä¸€ä¸ªè¡¨æƒ…ä½œä¸ºå•ç‹¬çš„å›å¤ã€‚
2.  ã€ç»å¯¹ç¦æ­¢ã€‘å‘æ˜æˆ–ç¼–é€ åˆ—è¡¨ä¸­ä¸å­˜åœ¨çš„è¡¨æƒ…å«ä¹‰ã€‚
3.  å¦‚æœæ²¡æ‰¾åˆ°åˆé€‚çš„ï¼Œè¯·ä¸è¦ä½¿ç”¨ "sticker" æŒ‡ä»¤ã€‚
4.  **ã€è§’è‰²åˆ†é…ã€‘**: ä½ å¯ä»¥ä»ä¸‹é¢çš„ã€å…±äº«åˆ—è¡¨ã€‘ä¸­é€‰æ‹©ä»»æ„è¡¨æƒ…ï¼Œå¹¶å°†å…¶åˆ†é…ç»™ã€ä»»æ„AIè§’è‰²ã€‘ã€‚
5. ã€ä½¿ç”¨é¢‘ç‡ã€‘: è¯·åªåœ¨ä½ è§‰å¾—ã€éå¸¸å¿…è¦ã€‘æˆ–ã€æƒ…ç»ªç‰¹åˆ«å¼ºçƒˆã€‘æ—¶æ‰ä½¿ç”¨è¡¨æƒ…ï¼Œä¿æŒå¯¹è¯çš„è‡ªç„¶æ€§ã€‚
6.  **ã€é‡å¤æƒ©ç½š (æœ€é«˜é“å¾‹ï¼)ã€‘**: ä½ ã€ç»å¯¹ç¦æ­¢ã€‘è¿ç»­å‡ è½®å›å¤ä½¿ç”¨ã€å®Œå…¨ç›¸åŒã€‘çš„è¡¨æƒ…å«ä¹‰ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ä¸Šä¸€è½®å›å¤äº† "meaning": "å®³ç¾"ï¼Œé‚£ä¹ˆä½ è¿™ä¸€è½®ã€ç»å¯¹ä¸èƒ½ã€‘å†æ¬¡ä½¿ç”¨ "meaning": "å®³ç¾"ã€‚ä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªä¸åŒçš„å«ä¹‰ï¼Œæˆ–è€…å¹²è„†ä¸å‘è¡¨æƒ…ã€‚
- **å¯ç”¨åˆ—è¡¨**:
${stickerList}
`;
}

  function estimateTokens(text) {
    if (!text) return 0;
 
    return Math.ceil(text.length / 1.5);
  }


  async function calculateCurrentContextTokens() {
    if (!state.activeChatId) return 0;
    const chat = state.chats[state.activeChatId];
    if (!chat) return 0;

    
    const maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    const linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
    const isOfflineMode = document.getElementById('offline-mode-toggle').checked;
    const aiPersona = document.getElementById('ai-persona').value;
    const myPersona = document.getElementById('my-persona').value;

    let fullContextString = '';


    const linkedBookIds = Array.from(document.querySelectorAll('#world-book-checkboxes-container input:checked')).map(cb => cb.value.replace('book_', ''));
    // æ·»åŠ æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
    const globalBookIds = state.worldBooks.filter(wb => wb.isGlobal).map(wb => wb.id);
    const allBookIds = [...new Set([...linkedBookIds, ...globalBookIds])];
    
    if (allBookIds.length > 0) {
      const linkedContents = allBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';
        return worldBook.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
      }).filter(Boolean).join('\n');
      fullContextString += linkedContents;
    }

 
    if (chat.longTermMemory && chat.longTermMemory.length > 0) {
      fullContextString += chat.longTermMemory.map(mem => mem.content).join('\n');
    }

 
    const linkedMemoryToggle = document.getElementById('link-memory-toggle').checked;
    if (linkedMemoryToggle) {
      const linkedChatIds = Array.from(document.querySelectorAll('#linked-chats-checkboxes-container input:checked')).map(cb => cb.value);
      for (const linkedId of linkedChatIds) {
        const linkedChat = state.chats[linkedId];
        if (linkedChat && linkedChat.history.length > 0) {
          fullContextString += linkedChat.history.slice(-linkedMemoryCount).map(msg => String(msg.content)).join('\n');
        }
      }
    }

   
    if (chat.isGroup) {
      chat.members.forEach(member => {
        fullContextString += member.persona;
      });
    } else {
      fullContextString += aiPersona;
    }
    fullContextString += myPersona;

  
    fullContextString += getStickerContextForPrompt(chat);
    if (chat.isGroup) {
      fullContextString += getGroupStickerContextForPrompt(chat);
    }

   
    if (!chat.isGroup && isOfflineMode) {
      const offlinePresetId = document.getElementById('offline-preset-select').value;
      if (offlinePresetId) {
        const preset = state.presets.find(p => p.id === offlinePresetId);
        if (preset) {
          fullContextString += preset.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
        }
      }
    }

  
    const historySlice = chat.history.slice(-maxMemory);
    fullContextString += historySlice.map(msg => {
      if (typeof msg.content === 'string') return msg.content;
      if (Array.isArray(msg.content)) return msg.content.map(p => p.text).join(' ');
      return '';
    }).join('\n');

    return estimateTokens(fullContextString);
  }


  const updateTokenCountDisplay = debounce(async () => {
    
    const tokenValueEl = document.getElementById('token-count-value');
    const msgValueEl = document.getElementById('message-count-value');
    
    if (!tokenValueEl) return;

   
    const chat = state.activeChatId ? state.chats[state.activeChatId] : null;
    if (msgValueEl) {
        if (chat && chat.history) {
           
            const visibleCount = chat.history.filter(m => !m.isHidden).length;
            msgValueEl.textContent = `${visibleCount} æ¡`;
            msgValueEl.style.color = "#000000";
        } else {
            msgValueEl.textContent = "--";
        }
    }

    
    tokenValueEl.textContent = "è®¡ç®—ä¸­...";
    try {
      const tokenCount = await calculateCurrentContextTokens();
      tokenValueEl.textContent = `${tokenCount} Tokens`;
      tokenValueEl.style.color = "#000000"; 
      
     
      if (document.body.classList.contains('dark-mode') || document.getElementById('phone-screen').classList.contains('dark-mode')) {
           msgValueEl.style.color = "#ffffff";
           tokenValueEl.style.color = "#ffffff";
      }
      
    } catch (error) {
      console.error("Token calculation error:", error);
      tokenValueEl.textContent = "Error";
    }
  }, 300);

 
  async function openNaiGallery() {
   
    naiGalleryCache = { local: [], cloud: [] };
    naiGalleryRenderCount = { local: 0, cloud: 0 };
    isLoadingMoreNaiImages = { local: false, cloud: false };

    const allNaiImages = [];

    
    try {
      const allChats = await db.chats.toArray();
      for (const chat of allChats) {
        if (chat.history && chat.history.length > 0) {
          chat.history.forEach(msg => {
            if (msg.type === 'naiimag' && msg.imageUrl) {
              allNaiImages.push({
                sourceType: 'chat',
                imageUrl: msg.imageUrl,
                prompt: msg.prompt || msg.fullPrompt || 'NAI Image',
                chatId: chat.id,
                msgTimestamp: msg.timestamp
              });
            }
          });
        }
      }
    } catch (e) {
      console.error("æ‰«æèŠå¤©è®°å½•å¤±è´¥:", e);
    }

    
    try {
      const allPosts = await db.qzonePosts.toArray();
      allPosts.forEach(post => {
        if (post.type === 'naiimag') {
          const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
          const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt || 'NAI Image'];
          urls.forEach((url, index) => {
            allNaiImages.push({
              sourceType: 'qzone',
              imageUrl: url,
              prompt: prompts[index] || prompts[0],
              postId: post.id,
              imageIndex: index
            });
          });
        }
      });
    } catch (e) {
      console.error("æ‰«æåŠ¨æ€å¤±è´¥:", e);
    }

    
    allNaiImages.sort((a, b) => (b.msgTimestamp || b.postId || 0) - (a.msgTimestamp || a.postId || 0));

  
    allNaiImages.forEach(img => {
      if (img.imageUrl.startsWith('data:image')) {
        naiGalleryCache.local.push(img);
      } else {
        naiGalleryCache.cloud.push(img);
      }
    });

    
    document.getElementById('nai-gallery-grid-local').innerHTML = '';
    document.getElementById('nai-gallery-grid-cloud').innerHTML = '';

   
    switchNaiGalleryTab('local'); 
    
    document.getElementById('nai-gallery-panel').classList.add('visible');
  }
function switchNaiGalleryTab(tabId) {
    if (isNaiGalleryManagementMode) {
        toggleNaiGalleryManagementMode(); // åˆ‡æ¢æ—¶è‡ªåŠ¨é€€å‡ºç®¡ç†æ¨¡å¼
    }
    
    activeNaiGalleryTab = tabId;

   
    document.querySelectorAll('.nai-gallery-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tabId === tabId);
    });

   
    document.querySelectorAll('.nai-gallery-page').forEach(page => {
        page.classList.toggle('active', page.id === `nai-gallery-grid-${tabId}`);
    });

  
    const cache = naiGalleryCache[tabId];
    const renderCount = naiGalleryRenderCount[tabId];
    const gridEl = document.getElementById(`nai-gallery-grid-${tabId}`);

    if (renderCount === 0) { 
        gridEl.innerHTML = '';
        if (cache.length === 0) {
            const message = (tabId === 'local') ? 
                'æœ¬åœ°ç”»å»Šæ˜¯ç©ºçš„ï¼Œå¿«å»ç”Ÿæˆä¸€äº›å›¾ç‰‡å§ï¼' :
                'å›¾åºŠç”»å»Šæ˜¯ç©ºçš„ï¼Œè¯·ä»â€œæœ¬åœ°â€ä¸Šä¼ å›¾ç‰‡ã€‚';
            gridEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
        } else {
            loadMoreNaiGalleryImages(); // åŠ è½½ç¬¬ä¸€é¡µ
        }
    }
    
    
    updateNaiGalleryActionButtons();
  }  
  function renderNaiGalleryGrid(images, gridEl) {
  
    if (images.length === 0 && naiGalleryRenderCount[activeNaiGalleryTab] === 0) {
      const message = (activeNaiGalleryTab === 'local') ? 
          'æœ¬åœ°ç”»å»Šæ˜¯ç©ºçš„ï¼Œå¿«å»ç”Ÿæˆä¸€äº›å›¾ç‰‡å§ï¼' :
          'å›¾åºŠç”»å»Šæ˜¯ç©ºçš„ã€‚';
      gridEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
      return;
    }

    const fragment = document.createDocumentFragment(); 

    images.forEach((img, i) => {
      const item = document.createElement('div');
      item.className = 'nai-gallery-item'; 
      item.title = img.prompt;

  
      const itemKey = `${img.sourceType}_${img.chatId || img.postId}_${img.msgTimestamp || img.imageIndex}`;
      item.dataset.key = itemKey;
      item.dataset.imageUrl = img.imageUrl;
      item.dataset.prompt = img.prompt;

  
      item.innerHTML = `
            <div class="nai-image-container" style="background-image: url(${img.imageUrl})">
                <div class="nai-gallery-controls">
                    <button class="nai-gallery-download-btn" title="ä¸‹è½½">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></svg>
                    </button>
                    <button class="nai-gallery-delete-btn" title="åˆ é™¤">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                    </button>
                </div>
            </div>
            <span class="nai-gallery-name">${img.prompt}</span>
        `;
    
      fragment.appendChild(item); 
    });

    gridEl.appendChild(fragment); 
  }

  async function loadMoreNaiGalleryImages() {
    const activeTab = activeNaiGalleryTab;
    if (isLoadingMoreNaiImages[activeTab] || naiGalleryRenderCount[activeTab] >= naiGalleryCache[activeTab].length) {
      return; 
    }

    isLoadingMoreNaiImages[activeTab] = true;
    const gridEl = document.getElementById(`nai-gallery-grid-${activeTab}`);
    showLoader(gridEl, 'bottom'); 

   
    setTimeout(() => {
      
      if (activeNaiGalleryTab !== activeTab) {
          isLoadingMoreNaiImages[activeTab] = false;
          hideLoader(gridEl);
          return;
      }
      
      const imagesToAppend = naiGalleryCache[activeTab].slice(
          naiGalleryRenderCount[activeTab], 
          naiGalleryRenderCount[activeTab] + NAI_GALLERY_RENDER_WINDOW
      );

      hideLoader(gridEl); 

      if (imagesToAppend.length > 0) {
        renderNaiGalleryGrid(imagesToAppend, gridEl); 
        naiGalleryRenderCount[activeTab] += imagesToAppend.length;
      }

      isLoadingMoreNaiImages[activeTab] = false;
    }, 500);
  }

  function toggleNaiGalleryManagementMode() {
    isNaiGalleryManagementMode = !isNaiGalleryManagementMode;
    const grid = document.getElementById(`nai-gallery-grid-${activeNaiGalleryTab}`);
    const manageBtn = document.getElementById('manage-nai-gallery-btn');
    const actionBar = document.getElementById('nai-gallery-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-nai-gallery-checkbox');

    grid.classList.toggle('management-mode', isNaiGalleryManagementMode);

    if (isNaiGalleryManagementMode) {
      manageBtn.textContent = 'å®Œæˆ';
      actionBar.style.display = 'flex';
      selectedNaiImages.clear();
      selectAllCheckbox.checked = false;
      updateNaiGalleryActionButtons();
      document.querySelectorAll('.nai-gallery-page').forEach(page => page.classList.add('management-mode'));
    } else {
      manageBtn.textContent = 'ç®¡ç†';
      actionBar.style.display = 'none';
      document.querySelectorAll('.nai-gallery-page').forEach(page => page.classList.remove('management-mode'));
      grid.querySelectorAll('.nai-gallery-item.selected').forEach(item => item.classList.remove('selected'));
    }
  }

  
  function updateNaiGalleryActionButtons() { 
    const deleteBtn = document.getElementById('delete-selected-nai-gallery-btn');
    const downloadBtn = document.getElementById('download-selected-nai-gallery-btn');
    const uploadBtn = document.getElementById('upload-selected-nai-gallery-btn');
    const exportBtn = document.getElementById('export-selected-nai-gallery-btn'); // 1. è·å–æŒ‰é’®å…ƒç´ 
    const count = selectedNaiImages.size;

    if (deleteBtn) deleteBtn.textContent = `åˆ é™¤ (${count})`;
    if (downloadBtn) downloadBtn.textContent = `ä¸‹è½½ (${count})`;

    // 2. æ·»åŠ å¯¼å‡ºæŒ‰é’®é€»è¾‘
    if (exportBtn) {
        exportBtn.textContent = `å¯¼å‡º (${count})`;
        // ä»…åœ¨ 'cloud' (å›¾åºŠ) æ ‡ç­¾é¡µæ˜¾ç¤ºï¼Œä¸”æœ‰é€‰ä¸­é¡¹æ—¶æ˜¾ç¤º(å¯é€‰)ï¼Œè¿™é‡Œæˆ‘ä»¬åªåˆ¤æ–­æ˜¯å¦æ˜¯å›¾åºŠé¡µ
        exportBtn.style.display = (activeNaiGalleryTab === 'cloud') ? 'block' : 'none';
    }

    if (uploadBtn) { 
      uploadBtn.textContent = `ä¸Šä¼  (${count})`;
      const shouldShowUpload = (activeNaiGalleryTab === 'local' && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey);
      uploadBtn.style.display = shouldShowUpload ? 'block' : 'none';
    }
}
async function executeBatchExportNaiImages() {
    if (selectedNaiImages.size === 0) {
      alert("è¯·å…ˆé€‰æ‹©è¦å¯¼å‡ºçš„å›¾ç‰‡ã€‚");
      return;
    }

    let exportText = "";
    let exportedCount = 0;

   
    selectedNaiImages.forEach(key => {
       
        const item = naiGalleryCache.cloud.find(img => {
             const itemKey = `${img.sourceType}_${img.chatId || img.postId}_${img.msgTimestamp || img.imageIndex}`;
             return itemKey === key;
        });

        if (item && item.imageUrl) {
           
            exportText += `${item.imageUrl}\n`;
            exportedCount++;
        }
    });

    if (exportedCount === 0) {
      alert("æœªæ‰¾åˆ°æ‰€é€‰å›¾ç‰‡çš„æ•°æ®ï¼ˆè¯·ç¡®è®¤æ‚¨åœ¨â€˜å›¾åºŠâ€™åˆ†ç±»ä¸‹ï¼‰ã€‚");
      return;
    }

    const finalText = exportText.trim();
    const textareaId = 'batch-export-nai-textarea-' + Date.now();
    
    const alertHtml = `
        <p style="text-align:left; font-size: 14px; margin: 0 0 10px 0;">
            å·²æå– ${exportedCount} æ¡é“¾æ¥ï¼š
        </p>
        <textarea id="${textareaId}" 
                  rows="10" 
                  style="width: 100%; font-size: 12px; resize: vertical; border-radius: 6px; border: 1px solid #ccc;"
                  readonly>${finalText}</textarea>
    `;

    showCustomAlert("å¤åˆ¶é“¾æ¥", alertHtml);
  
   
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    if (modalConfirmBtn) {
        modalConfirmBtn.textContent = 'ä¸€é”®å¤åˆ¶';
        const originalOnclick = modalConfirmBtn.onclick;

        modalConfirmBtn.onclick = async (e) => {
            try {
                await navigator.clipboard.writeText(finalText);
                modalConfirmBtn.textContent = 'å¤åˆ¶æˆåŠŸ!';
                setTimeout(() => {
                   modalConfirmBtn.textContent = 'å®Œæˆ';
                   modalConfirmBtn.onclick = originalOnclick; 
                }, 1500);
            } catch (err) {
                alert('è‡ªåŠ¨å¤åˆ¶å¤±è´¥ï¼Œè¯·é•¿æŒ‰æ–‡æœ¬æ¡†æ‰‹åŠ¨å¤åˆ¶ã€‚');
                modalConfirmBtn.textContent = 'å®Œæˆ';
                modalConfirmBtn.onclick = originalOnclick;
            }
        };
    }
}
  
  function handleNaiGalleryGridClick(e) {
    const item = e.target.closest('.nai-gallery-item');
    if (!item) return;

    const key = item.dataset.key;
    const imageUrl = item.dataset.imageUrl;
    const prompt = item.dataset.prompt;

 
    if (e.target.closest('.nai-gallery-download-btn')) {
      e.stopPropagation();
      downloadNaiImage(imageUrl, prompt);
      return;
    }

  
    if (e.target.closest('.nai-gallery-delete-btn')) {
      e.stopPropagation();
      executeBatchDeleteNaiImages(new Set([key])); 
      return;
    }

    
    if (isNaiGalleryManagementMode) {
      item.classList.toggle('selected');
      if (selectedNaiImages.has(key)) {
        selectedNaiImages.delete(key);
      } else {
        selectedNaiImages.add(key);
      }
      updateNaiGalleryActionButtons();
    } else {
      const modalTitle = "å›¾ç‰‡è¯¦æƒ…";
      const modalContentHtml = `
                <div style="text-align: center;">
                    <img src="${imageUrl}" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
                </div>
            `;
    
      showCustomAlert(modalTitle, modalContentHtml);
    }
  }

  async function executeBatchDownloadNaiImages() {
  
    const keys = selectedNaiImages;
   

    if (keys.size === 0) {
      alert("è¯·å…ˆé€‰æ‹©è¦ä¸‹è½½çš„å›¾ç‰‡ã€‚");
      return;
    }

  
    if (typeof JSZip === 'undefined' || !window.streamSaver) {
      await showCustomAlert("ä¸‹è½½å¤±è´¥", "æ ¸å¿ƒåº“ (JSZip æˆ– StreamSaver) æœªèƒ½æˆåŠŸåŠ è½½ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢åé‡è¯•ã€‚");
      return;
    }


    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨å‡†å¤‡ ${keys.size} å¼ å›¾ç‰‡...`);
 

    const zip = new JSZip();
    let failedDownloads = 0;
    const downloadPromises = [];

 
    const keysArray = Array.from(keys);

    keysArray.forEach((key, index) => { 
     

      const item = document.querySelector(`.nai-gallery-item[data-key="${key}"]`);
      if (!item) return;

      const imageUrl = item.dataset.imageUrl;
      const prompt = item.dataset.prompt;

      
      const baseFilename = generateFilenameForNai(prompt); // e.g., "my_prompt_timestamp.png"
    
      const filename = baseFilename.replace(/\.png$/, `_(${index + 1}).png`);
   

      const promise = (async () => {
        try {
          let blob;
          if (imageUrl.startsWith('data:')) {
            const response = await fetch(imageUrl);
            blob = await response.blob();
          } else {
            let response;
            try {
             
              response = await fetch(imageUrl, {
                mode: 'cors'
              });
              if (!response.ok) throw new Error('ç›´è¿å¤±è´¥');
            } catch (e) {
            
              console.warn("ç›´è¿å¤±è´¥, å°è¯•ä½¿ç”¨CORSä»£ç†...", e.message);
              const settings = getNovelAISettings();
              let corsProxy = settings.cors_proxy === 'custom' ? settings.custom_proxy_url : settings.cors_proxy;
              if (!corsProxy || corsProxy === '') corsProxy = 'https://corsproxy.io/?';
              const proxiedUrl = corsProxy + encodeURIComponent(imageUrl);
              response = await fetch(proxiedUrl);
            }

            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            blob = await response.blob();
          }
          zip.file(filename, blob, {
            binary: true
          }); 
        } catch (e) {
          console.error(`ä¸‹è½½å›¾ç‰‡å¤±è´¥: ${imageUrl}`, e);
          failedDownloads++;
        }
      })();
      downloadPromises.push(promise);
    });

   
    await Promise.all(downloadPromises);

    if (failedDownloads === keys.size) {
      await showCustomAlert("ä¸‹è½½å¤±è´¥", "æ‰€æœ‰å›¾ç‰‡éƒ½ä¸‹è½½å¤±è´¥äº†ã€‚è¿™é€šå¸¸æ˜¯ç”±äºç½‘ç»œé—®é¢˜æˆ–CORSè·¨åŸŸé™åˆ¶ï¼ˆè¯·æ£€æŸ¥APIè®¾ç½®ä¸­çš„CORSä»£ç†æ˜¯å¦æœ‰æ•ˆï¼‰ã€‚");
      return;
    }

    await showCustomAlert("æ‰“åŒ…ä¸­...", "æ‰€æœ‰å›¾ç‰‡å·²å‡†å¤‡å°±ç»ªï¼Œæ­£åœ¨æµå¼å‹ç¼©... ä¸‹è½½å°†è‡ªåŠ¨å¼€å§‹ã€‚");

    try {
     
      const fileStream = streamSaver.createWriteStream(`NAI_Gallery_Batch_${Date.now()}.zip`);

     
      const zipStream = zip.generateInternalStream({
        type: "blob",
        streamFiles: true 
      });

     
      const readableStream = new ReadableStream({
        start(controller) {
          zipStream.on('data', (chunk) => {
           
            controller.enqueue(chunk);
          }).on('end', () => {
           
            console.log("ZIP æµç”Ÿæˆå®Œæ¯•ã€‚");
            controller.close();
          }).on('error', (err) => {
           
            console.error("JSZip æµé”™è¯¯:", err);
            controller.error(err);
          }).resume(); // å¯åŠ¨ JSZip æµ
        }
      });

     
      await readableStream.pipeTo(fileStream);

     
      if (failedDownloads > 0) {
        showCustomAlert("éƒ¨åˆ†ä¸‹è½½å®Œæˆ", `æˆåŠŸæ‰“åŒ… ${keys.size - failedDownloads} å¼ å›¾ç‰‡ã€‚æœ‰ ${failedDownloads} å¼ å›¾ç‰‡å› ç½‘ç»œæˆ–CORSé™åˆ¶ä¸‹è½½å¤±è´¥ã€‚`);
      }

    } catch (error) {
      console.error("æµå¼ä¸‹è½½ZIPå¤±è´¥:", error);
      await showCustomAlert("æµå¼ä¸‹è½½å¤±è´¥", `åˆ›å»ºZIPæµæ—¶å‡ºé”™: ${error.message}`);
    }
  }

  async function executeBatchDeleteNaiImages(keysToDelete = null) {
    const keys = keysToDelete || selectedNaiImages;
    if (keys.size === 0) return;

    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      `ç¡®å®šè¦ä»ã€èŠå¤©è®°å½•å’ŒåŠ¨æ€ã€‘ä¸­æ°¸ä¹…åˆ é™¤è¿™ ${keys.size} å¼ NAIå›¾ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨æ‰§è¡Œåˆ é™¤æ“ä½œ...");

    let deletedCount = 0;
    const chatsToUpdate = new Map();
    const postsToDelete = new Set();
    const postsToModify = new Map();


    const postIdsToFetch = new Set();
    for (const key of keys) {
      if (key.startsWith('qzone_')) {
        const parts = key.split('_');
        const postId = parseInt(parts[1]); // qzone ID ä¸ä¼šåŒ…å« '_'
        if (!isNaN(postId)) {
          postIdsToFetch.add(postId);
        }
      }
    }
    const postsCache = new Map();
    if (postIdsToFetch.size > 0) {
      const posts = await db.qzonePosts.where('id').anyOf(Array.from(postIdsToFetch)).toArray();
      posts.forEach(post => postsCache.set(post.id, post));
    }


    for (const key of keys) {

    

      const parts = key.split('_');
      if (parts.length < 3) {
        console.warn("è·³è¿‡æ ¼å¼é”™è¯¯çš„NAIå›¾ç‰‡Key:", key);
        continue;
      }

      const sourceType = parts[0];
      const identifier = parts.pop(); 
      const id = parts.slice(1).join('_'); 

      if (sourceType === 'chat') {
        const chatId = id;
        const msgTimestamp = parseInt(identifier);

        if (!chatsToUpdate.has(chatId)) {
         
          const chatData = await db.chats.get(chatId);
          if (chatData) {
            chatsToUpdate.set(chatId, chatData);
          } else {
            console.warn(`æœªæ‰¾åˆ° chatID: ${chatId}ï¼Œè·³è¿‡...`);
            continue;
          }
        }

        const chat = chatsToUpdate.get(chatId);
        if (chat && chat.history) {
          const originalLength = chat.history.length;
          chat.history = chat.history.filter(msg => msg.timestamp !== msgTimestamp);
          if (chat.history.length < originalLength) {
            deletedCount++;
            chatsToUpdate.set(chatId, chat); // æ ‡è®°æ­¤chatéœ€è¦è¢«æ›´æ–°
          if (state.chats[chatId]) {
                state.chats[chatId].history = chat.history;
            }
          }
        }
      } else if (sourceType === 'qzone') {
        const postId = parseInt(id);
        const imageIndex = parseInt(identifier);

        const post = postsToModify.get(postId) || postsCache.get(postId);
        if (!post) {
          console.warn(`æœªæ‰¾åˆ° postID: ${postId}ï¼Œè·³è¿‡...`);
          continue;
        }

        const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

        if (urls.length <= 1) {
         
          postsToDelete.add(postId);
          if (postsToModify.has(postId)) {
            postsToModify.delete(postId); 
          }
        } else {
          
          const urlToRemove = urls[imageIndex];
          post.imageUrls = post.imageUrls.filter(url => url !== urlToRemove);

          if (post.prompt && Array.isArray(post.prompt) && post.prompt[imageIndex]) {
            post.prompt.splice(imageIndex, 1);
          }
          post.imageUrl = post.imageUrls[0] || null; 
          postsToModify.set(postId, post);
        }
        deletedCount++;
      }
    }

    try {
      await db.transaction('rw', db.chats, db.qzonePosts, async () => {
        if (chatsToUpdate.size > 0) {
          await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
        }
        if (postsToModify.size > 0) {
          await db.qzonePosts.bulkPut(Array.from(postsToModify.values()));
        }
        if (postsToDelete.size > 0) {
          await db.qzonePosts.bulkDelete(Array.from(postsToDelete));
        }
      });

      
      toggleNaiGalleryManagementMode();
      keys.forEach(key => { 
          naiGalleryCache.local = naiGalleryCache.local.filter(item => {
              const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
              return itemKey !== key;
          });
          naiGalleryCache.cloud = naiGalleryCache.cloud.filter(item => {
              const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
              return itemKey !== key;
          });
      });

      
      naiGalleryRenderCount[activeNaiGalleryTab] = 0;
      document.getElementById(`nai-gallery-grid-${activeNaiGalleryTab}`).innerHTML = '';
      
     
      loadMoreNaiGalleryImages();
      await showCustomAlert('åˆ é™¤æˆåŠŸ', `å·²æˆåŠŸåˆ é™¤ ${deletedCount} å¼ å›¾ç‰‡ã€‚`);

     
      if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        renderChatInterface(state.activeChatId);
      }
      if (document.getElementById('qzone-screen').classList.contains('active')) {
        renderQzonePosts();
      }

    } catch (error) {
      console.error("æ‰¹é‡åˆ é™¤NAIå›¾ç‰‡æ—¶å‡ºé”™:", error);
      await showCustomAlert('åˆ é™¤å¤±è´¥', `æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }


async function executeBatchUploadNaiImagesToImgBB() {
 
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        await showCustomAlert("åŠŸèƒ½æœªå¼€å¯", "è¯·å…ˆåœ¨â€œAPIè®¾ç½®â€ä¸­å¼€å¯ ImgBB è‡ªåŠ¨å›¾åºŠåŠŸèƒ½å¹¶å¡«å†™ API Keyã€‚");
        return;
    }

   
    const itemsToUpload = Array.from(selectedNaiImages)
        .map(key => document.querySelector(`.nai-gallery-item[data-key="${key}"]`))
        .filter(item => item && item.dataset.imageUrl && item.dataset.imageUrl.startsWith('data:image'));

    if (itemsToUpload.length === 0) {
        await showCustomAlert("æ— éœ€ä¸Šä¼ ", "ä½ é€‰æ‹©çš„å›¾ç‰‡ä¸­æ²¡æœ‰éœ€è¦ä¸Šä¼ çš„æœ¬åœ°å›¾ç‰‡ï¼ˆå®ƒä»¬å¯èƒ½å·²ç»æ˜¯ç½‘ç»œé“¾æ¥äº†ï¼‰ã€‚");
        return;
    }

   
    const confirmed = await showCustomConfirm(
        'ç¡®è®¤ä¸Šä¼ ï¼Ÿ',
        `å³å°†æŠŠ ${itemsToUpload.length} å¼ æœ¬åœ°å›¾ç‰‡ä¸Šä¼ åˆ° ImgBBï¼Œå¹¶æ°¸ä¹…æ›¿æ¢å…¶åœ¨æ•°æ®åº“ä¸­çš„åœ°å€ã€‚æ­¤æ“ä½œä¸å¯é€†ï¼\n\nï¼ˆä¸Šä¼ æœŸé—´è¯·å‹¿å…³é—­é¡µé¢ï¼‰`,
        { confirmButtonClass: 'btn-danger', confirmText: 'ç¡®è®¤ä¸Šä¼ ' }
    );

    if (!confirmed) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨å¼€å§‹ä¸Šä¼  ${itemsToUpload.length} å¼ å›¾ç‰‡...`);

    
    let successCount = 0;
    let failCount = 0;
    const chatsToUpdate = new Map();
    const postsToUpdate = new Map();
    const keysToUpdateInCache = new Map(); 
  
    for (const item of itemsToUpload) {
        const key = item.dataset.key;
        const base64Url = item.dataset.imageUrl;

        try {
            
            const newUrl = await uploadImageToImgBB(base64Url);
            
            
            if (newUrl === base64Url) {
                throw new Error("ä¸Šä¼ å‡½æ•°è¿”å›äº†åŸå§‹Base64ï¼Œå¯èƒ½ä¸Šä¼ å¤±è´¥æˆ–è¢«è·³è¿‡ã€‚");
            }
            
          
            const parts = key.split('_');
            if (parts.length < 3) throw new Error(`Keyæ ¼å¼é”™è¯¯: ${key}`);
            
            const sourceType = parts[0];
            const identifier = parts.pop();
            const id = parts.slice(1).join('_'); 

            
            if (sourceType === 'chat') {
                const chatId = id;
                const msgTimestamp = parseInt(identifier);
                
                let chat = chatsToUpdate.get(chatId);
                if (!chat) chat = await db.chats.get(chatId); // ä»DBè·å–æœ€æ–°
                
                if (chat && chat.history) {
                    const msg = chat.history.find(m => m.timestamp === msgTimestamp);
                    if (msg && msg.imageUrl === base64Url) {
                        msg.imageUrl = newUrl;
                        chatsToUpdate.set(chatId, chat);
                        keysToUpdateInCache.set(key, newUrl);
                        successCount++;
                    } else {
                        throw new Error(`æœªåœ¨èŠå¤© ${chatId} ä¸­æ‰¾åˆ°æ—¶é—´æˆ³ä¸º ${msgTimestamp} ä¸”åŒ¹é…Base64çš„æ¶ˆæ¯ã€‚`);
                    }
                }
                
            
            } else if (sourceType === 'qzone') {
                const postId = parseInt(id);
                const imageIndex = parseInt(identifier);

                let post = postsToUpdate.get(postId);
                if (!post) post = await db.qzonePosts.get(postId);
                
                if (post && post.imageUrls && post.imageUrls[imageIndex] === base64Url) {
                    post.imageUrls[imageIndex] = newUrl;
                    
                   
                    if (imageIndex === 0) {
                        post.imageUrl = newUrl;
                    }
                    
                    postsToUpdate.set(postId, post);
                    keysToUpdateInCache.set(key, newUrl);
                    successCount++;
                } else {
                    throw new Error(`æœªåœ¨åŠ¨æ€ ${postId} çš„ç¬¬ ${imageIndex} å¼ å›¾ä¸­æ‰¾åˆ°åŒ¹é…çš„Base64ã€‚`);
                }
            }

        } catch (error) {
            failCount++;
            console.error(`ä¸Šä¼ å¤±è´¥ (Key: ${key}):`, error.message);
        }
    }

   
    try {
        if (chatsToUpdate.size > 0 || postsToUpdate.size > 0) {
            await db.transaction('rw', db.chats, db.qzonePosts, async () => {
                if (chatsToUpdate.size > 0) {
                    await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
                }
                if (postsToUpdate.size > 0) {
                    await db.qzonePosts.bulkPut(Array.from(postsToUpdate.values()));
                }
            });
        }
    } catch (dbError) {
        console.error("æ‰¹é‡æ›´æ–°æ•°æ®åº“å¤±è´¥:", dbError);
        await showCustomAlert("æ•°æ®åº“æ›´æ–°å¤±è´¥", `å›¾ç‰‡ä¸Šä¼ å®Œæˆï¼Œä½†åœ¨ä¿å­˜åˆ°æ•°æ®åº“æ—¶å‡ºé”™: ${dbError.message}`);
        return;
    }

   
    keysToUpdateInCache.forEach((newUrl, key) => {
        const cacheEntry = naiGalleryCache.find(item => {
            const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
            return itemKey === key;
        });
        if (cacheEntry) {
            cacheEntry.imageUrl = newUrl;
        }
        
        const domItem = document.querySelector(`.nai-gallery-item[data-key="${key}"]`);
        if (domItem) {
            domItem.dataset.imageUrl = newUrl; 
            domItem.querySelector('.nai-image-container').style.backgroundImage = `url(${newUrl})`;
        }
    });

   const updatedLocal = [];
    const updatedCloud = [];
    
    naiGalleryCache.local.forEach(item => {
        const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
        if (keysToUpdateInCache.has(itemKey)) {
            
            item.imageUrl = keysToUpdateInCache.get(itemKey);
            updatedCloud.push(item);
        } else {
          
            updatedLocal.push(item);
        }
    });
    
   
    naiGalleryCache.cloud.push(...updatedCloud);
    naiGalleryCache.local = updatedLocal;
    
    
    naiGalleryRenderCount = { local: 0, cloud: 0 };
    let resultMessage = `æ‰¹é‡ä¸Šä¼ å®Œæˆï¼\n\næˆåŠŸ: ${successCount} å¼ \nå¤±è´¥: ${failCount} å¼ `;
    if (failCount > 0) {
        resultMessage += "\n\nå¤±è´¥çš„å›¾ç‰‡è¯·æ£€æŸ¥æ§åˆ¶å°ï¼ˆConsoleï¼‰ä¸­çš„é”™è¯¯æ—¥å¿—ã€‚";
    }
    await showCustomAlert("æ“ä½œå®Œæˆ", resultMessage);

    
    toggleNaiGalleryManagementMode();
} 
  function generateFilenameForNai(prompt) {
  
    const title = prompt || 'NAI_Image';

  
    let cleanTitle = title
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_') 
      .replace(/\s+/g, '_') 
      .substring(0, 30);

    if (!cleanTitle) {
      cleanTitle = 'NAI_Image';
    }

   
    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0]; // æ ¼å¼ï¼š20250124_123045

    
    return `${cleanTitle}_${timestamp}.png`;
  }
 
  function openQuickReplyModal() {
    // æ‰“å¼€å¼¹çª—æ—¶ï¼Œæ ‡è®°éœ€è¦åˆ·æ–°DOMï¼Œå› ä¸ºå¯èƒ½ä¸Šæ¬¡å…³é—­åæ•°æ®å˜äº†
    const tabsContainer = document.getElementById('quick-reply-tabs');
    if(tabsContainer) tabsContainer.dataset.needsRefresh = 'true';
    
    renderQuickReplyList(true); 
    document.getElementById('quick-reply-modal').classList.add('visible');
}

 
  // --- å¿«æ·å›å¤åˆ†ç±»åŠŸèƒ½åŒº ---

// 1. [æ ¸å¿ƒä¿®æ”¹] æ¸²æŸ“å¿«æ·å›å¤åˆ—è¡¨ (æ”¯æŒåˆ†ç±»å’ŒTabs)
// [ä¼˜åŒ–ç‰ˆ] æ¸²æŸ“å¿«æ·å›å¤åˆ—è¡¨ (è§£å†³é—ªçƒé—®é¢˜)
async function renderQuickReplyList(rerenderTabs = true) {
    const listEl = document.getElementById('quick-reply-list');
    const tabsContainer = document.getElementById('quick-reply-tabs');
    listEl.innerHTML = '';

    // 1. æ¸²æŸ“æ ‡ç­¾æ  (æ ¸å¿ƒä¼˜åŒ–ï¼šåªæœ‰åœ¨ rerenderTabs ä¸º true æ—¶æ‰é‡å»ºDOM)
    // å¦‚æœåªæ˜¯åˆ‡æ¢åˆ†ç±»ï¼Œä¸éœ€è¦é‡å»ºDOMï¼Œåªéœ€è¦æ›´æ–° active ç±»
    if (rerenderTabs) {
        // æ£€æŸ¥æ˜¯å¦çœŸçš„éœ€è¦é‡å»º (ä¾‹å¦‚ï¼šåˆšæ‰“å¼€å¼¹çª—æ—¶ï¼Œæˆ–è€…æ·»åŠ /åˆ é™¤åˆ†ç±»å)
        // å¦‚æœ tabsContainer æ˜¯ç©ºçš„ï¼Œè¯´æ˜å¿…é¡»é‡å»º
        // å¦‚æœ tabsContainer å·²æœ‰å†…å®¹ï¼Œä¸”æˆ‘ä»¬åªæ˜¯æƒ³æ›´æ–°æ ·å¼ï¼Œå°±ä¸æ¸…ç©ºå®ƒ
        
        // è¿™é‡Œæˆ‘ä»¬ç¨å¾®æ”¹ä¸€ä¸‹ç­–ç•¥ï¼š
        // å¦‚æœæ˜¯â€œåˆ‡æ¢åˆ†ç±»â€æ“ä½œè§¦å‘çš„é‡ç»˜ï¼Œæˆ‘ä»¬ä¸ä¼  rerenderTabs=trueï¼Œæˆ–è€…åœ¨å†…éƒ¨åˆ¤æ–­
        
        const categories = await db.quickReplyCategories.toArray();
        
        // å¦‚æœæ ‡ç­¾æ æ˜¯ç©ºçš„ï¼Œæˆ–è€…ç¡®å®éœ€è¦å¼ºåˆ¶åˆ·æ–° (æ¯”å¦‚å¢åˆ äº†åˆ†ç±»)ï¼Œåˆ™é‡å»º
        if (tabsContainer.children.length === 0 || tabsContainer.dataset.needsRefresh === 'true') {
            tabsContainer.innerHTML = '';
            tabsContainer.dataset.needsRefresh = 'false'; // é‡ç½®æ ‡è®°

            // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºæ ‡ç­¾
            const createTab = (id, name) => {
                const btn = document.createElement('button');
                btn.className = 'sticker-category-tab'; // åˆå§‹ä¸åŠ  active
                if (activeQuickReplyCategoryId === id) btn.classList.add('active');
                
                btn.textContent = name;
                btn.dataset.categoryId = id;
                
                // ç‚¹å‡»äº‹ä»¶ï¼šåªæ›´æ–° active ç±»ï¼Œä¸é‡å»º DOM
                btn.onclick = () => switchQuickReplyCategory(id);
                return btn;
            };

            tabsContainer.appendChild(createTab('all', 'å…¨éƒ¨'));
            categories.forEach(cat => {
                tabsContainer.appendChild(createTab(cat.id, cat.name));
            });
            tabsContainer.appendChild(createTab('uncategorized', 'æœªåˆ†ç±»'));
        } else {
            // å¦‚æœä¸éœ€è¦é‡å»ºï¼Œä»…æ›´æ–° active æ ·å¼ (è§£å†³é—ªçƒçš„æ ¸å¿ƒ)
            const tabs = tabsContainer.querySelectorAll('.sticker-category-tab');
            tabs.forEach(tab => {
                // æ³¨æ„ï¼šdataset.categoryId æ˜¯å­—ç¬¦ä¸²ï¼ŒactiveQuickReplyCategoryId å¯èƒ½æ˜¯æ•°å­—
                // æ‰€ä»¥ç”¨ == æ¯”è¾ƒï¼Œæˆ–è€…éƒ½è½¬å­—ç¬¦ä¸²
                if (String(tab.dataset.categoryId) === String(activeQuickReplyCategoryId)) {
                    tab.classList.add('active');
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°é€‰ä¸­çš„æ ‡ç­¾ (æå‡ä½“éªŒ)
                    tab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                } else {
                    tab.classList.remove('active');
                }
            });
        }
    }

    // 2. ç­›é€‰æ•°æ® (ä¿æŒä¸å˜)
    let repliesToShow;
    if (activeQuickReplyCategoryId === 'all') {
        repliesToShow = state.quickReplies;
    } else if (activeQuickReplyCategoryId === 'uncategorized') {
        repliesToShow = state.quickReplies.filter(r => !r.categoryId);
    } else {
        repliesToShow = state.quickReplies.filter(r => r.categoryId == activeQuickReplyCategoryId);
    }

    // 3. æ¸²æŸ“åˆ—è¡¨å†…å®¹ (ä¿æŒä¸å˜)
    if (!repliesToShow || repliesToShow.length === 0) {
        const tipText = activeQuickReplyCategoryId === 'all' 
            ? 'ä½ è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•å¿«æ·å›å¤ã€‚<br>ç‚¹å‡»å³ä¸Šè§’â€œ+â€å·æ·»åŠ ç¬¬ä¸€æ¡å§ï¼'
            : 'è¿™ä¸ªåˆ†ç±»ä¸‹è¿˜æ²¡æœ‰å›å¤å“¦~';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${tipText}</p>`;
        return;
    }

    // ä¿®æ”¹ renderQuickReplyList å‡½æ•°ä¸­çš„ item.innerHTML éƒ¨åˆ†
    repliesToShow.forEach(reply => {
        const item = document.createElement('div');
        item.className = 'quick-reply-item';
        
        // --- æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦é€‰ä¸­ ---
        const isSelected = selectedQuickReplies.has(reply.id);
        if (isSelected) item.classList.add('selected');

        item.innerHTML = `
            <input type="checkbox" class="quick-reply-checkbox" ${isSelected ? 'checked' : ''}>
            
            <span class="quick-reply-text" data-text="${escapeHTML(reply.text)}">${escapeHTML(reply.text)}</span>
            <div class="quick-reply-actions">
                <button class="quick-reply-edit-btn" data-id="${reply.id}" title="ç¼–è¾‘">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button class="quick-reply-delete-btn" data-id="${reply.id}" title="åˆ é™¤">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        `;
        
        // --- ä¿®æ”¹ç‚¹å‡»äº‹ä»¶ ---
        item.addEventListener('click', (e) => {
            // å¦‚æœæ˜¯ç®¡ç†æ¨¡å¼
            if (isQuickReplyManagementMode) {
                // å¦‚æœç‚¹çš„æ˜¯æ–‡æœ¬åŒºåŸŸæˆ–æ•´è¡Œï¼Œè§¦å‘é€‰ä¸­
                if (!e.target.closest('.quick-reply-actions')) {
                     toggleQuickReplySelection(reply.id);
                     // æ‰‹åŠ¨æ›´æ–° checkbox è§†è§‰
                     const cb = item.querySelector('.quick-reply-checkbox');
                     if(cb) cb.checked = !cb.checked;
                }
            } else {
                // åŸæœ‰é€»è¾‘ï¼šå‘é€
                const textEl = e.target.closest('.quick-reply-text');
                const editBtn = e.target.closest('.quick-reply-edit-btn');
                const deleteBtn = e.target.closest('.quick-reply-delete-btn');

                if (textEl) {
                    selectQuickReply(textEl.dataset.text);
                } else if (editBtn) {
                    editQuickReply(reply.id);
                } else if (deleteBtn) {
                    deleteQuickReply(reply.id);
                }
            }
        });

        listEl.appendChild(item);
    });
}
// åˆ‡æ¢å¿«æ·å›å¤ç®¡ç†æ¨¡å¼
function toggleQuickReplyManagementMode() {
    isQuickReplyManagementMode = !isQuickReplyManagementMode;
    const listEl = document.getElementById('quick-reply-list');
    const actionBar = document.getElementById('quick-reply-action-bar');
    const normalFooter = document.getElementById('quick-reply-normal-footer');
    const batchBtn = document.getElementById('batch-quick-reply-btn');

    if (isQuickReplyManagementMode) {
        listEl.classList.add('management-mode');
        actionBar.style.display = 'flex';
        normalFooter.style.display = 'none';
        batchBtn.textContent = "å®Œæˆ";
        batchBtn.style.color = "var(--accent-color)";
    } else {
        listEl.classList.remove('management-mode');
        actionBar.style.display = 'none';
        normalFooter.style.display = 'flex';
        batchBtn.textContent = "æ‰¹é‡";
        batchBtn.style.color = "";
        selectedQuickReplies.clear(); // é€€å‡ºæ—¶æ¸…ç©º
        updateQuickReplyActionBar();
        renderQuickReplyList(false); // åˆ·æ–°å»é™¤é€‰ä¸­æ ·å¼
    }
}

// åˆ‡æ¢å•ä¸ªé€‰ä¸­
function toggleQuickReplySelection(id) {
    if (selectedQuickReplies.has(id)) {
        selectedQuickReplies.delete(id);
    } else {
        selectedQuickReplies.add(id);
    }
    updateQuickReplyActionBar();
    
    // æ›´æ–°DOMæ ·å¼
    const items = document.querySelectorAll('#quick-reply-list .quick-reply-item');
    items.forEach(item => {
        // è¿™é‡Œçš„é€»è¾‘æ¯”è¾ƒç®€å•ç²—æš´ï¼Œä¹Ÿå¯ä»¥ä¼˜åŒ–ä¸ºåªæ‰¾å¯¹åº”IDçš„å…ƒç´ 
        // ä½†ç”±äº render æ—¶æ²¡æœ‰ç»™ item åŠ  id datasetï¼Œè¿™é‡Œé‡æ–° render æœ€ç¨³
        // ä¸ºäº†æ€§èƒ½ï¼Œå»ºè®®ç»™ item åŠ  data-id
    });
    // ç®€å•èµ·è§ï¼Œé‡æ–°æ¸²æŸ“åˆ—è¡¨å½“å‰é¡µ(ä¸é‡ç»˜Tab)
    renderQuickReplyList(false);
}

// æ›´æ–°æ“ä½œæ æŒ‰é’®æ–‡å­—
function updateQuickReplyActionBar() {
    const count = selectedQuickReplies.size;
    document.getElementById('move-selected-quick-replies-btn').textContent = `ç§»åŠ¨ (${count})`;
    document.getElementById('delete-selected-quick-replies-btn').textContent = `åˆ é™¤ (${count})`;
}

// å…¨é€‰
function handleSelectAllQuickReplies() {
    const isChecked = document.getElementById('select-all-quick-replies-checkbox').checked;
    
    // è·å–å½“å‰è§†å›¾ä¸‹çš„æ‰€æœ‰å›å¤
    let currentViewReplies;
    if (activeQuickReplyCategoryId === 'all') {
        currentViewReplies = state.quickReplies;
    } else if (activeQuickReplyCategoryId === 'uncategorized') {
        currentViewReplies = state.quickReplies.filter(r => !r.categoryId);
    } else {
        currentViewReplies = state.quickReplies.filter(r => r.categoryId == activeQuickReplyCategoryId);
    }

    if (isChecked) {
        currentViewReplies.forEach(r => selectedQuickReplies.add(r.id));
    } else {
        selectedQuickReplies.clear();
    }
    
    updateQuickReplyActionBar();
    renderQuickReplyList(false);
}

// æ‰¹é‡ç§»åŠ¨å¿«æ·å›å¤
async function executeBatchMoveQuickReplies() {
    if (selectedQuickReplies.size === 0) return alert("è¯·å…ˆé€‰æ‹©å›å¤ã€‚");

    const categories = await db.quickReplyCategories.toArray();
    const options = [
        { text: 'æœªåˆ†ç±»', value: 'uncategorized' },
        ...categories.map(c => ({ text: c.name, value: c.id }))
    ];

    const targetCategoryId = await showChoiceModal("ç§»åŠ¨åˆ°åˆ†ç±»", options);
    if (!targetCategoryId) return;

    const finalCategoryId = targetCategoryId === 'uncategorized' ? null : parseInt(targetCategoryId);

    await db.transaction('rw', db.quickReplies, async () => {
        for (const id of selectedQuickReplies) {
            await db.quickReplies.update(id, { categoryId: finalCategoryId });
            const r = state.quickReplies.find(item => item.id === id);
            if (r) r.categoryId = finalCategoryId;
        }
    });

    await showCustomAlert("æˆåŠŸ", `å·²ç§»åŠ¨ ${selectedQuickReplies.size} æ¡å›å¤ã€‚`);
    toggleQuickReplyManagementMode(); // é€€å‡ºç®¡ç†æ¨¡å¼
    renderQuickReplyList(false);
}

// æ‰¹é‡åˆ é™¤å¿«æ·å›å¤
async function executeBatchDeleteQuickReplies() {
    if (selectedQuickReplies.size === 0) return alert("è¯·å…ˆé€‰æ‹©å›å¤ã€‚");

    const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedQuickReplies.size} æ¡å›å¤å—ï¼Ÿ`);
    if (!confirmed) return;

    const ids = Array.from(selectedQuickReplies);
    await db.quickReplies.bulkDelete(ids);
    
    // æ›´æ–°å†…å­˜
    state.quickReplies = state.quickReplies.filter(r => !selectedQuickReplies.has(r.id));
    
    await showCustomAlert("æˆåŠŸ", "å·²åˆ é™¤é€‰ä¸­å›å¤ã€‚");
    toggleQuickReplyManagementMode();
    renderQuickReplyList(false);
}
// 2. åˆ‡æ¢åˆ†ç±»
function switchQuickReplyCategory(categoryId) {
    activeQuickReplyCategoryId = categoryId;
    renderQuickReplyList(true); // é‡æ–°æ¸²æŸ“Tabsä»¥æ›´æ–°activeçŠ¶æ€
}

// 3. [ä¿®æ”¹] æ·»åŠ æ–°å›å¤ (è‡ªåŠ¨å½’å…¥å½“å‰åˆ†ç±»)
async function addNewQuickReply() {
    const text = await showCustomPrompt("æ·»åŠ å¿«æ·å›å¤", "è¯·è¾“å…¥è¦æ·»åŠ çš„å›å¤å†…å®¹ï¼š", "", "textarea");

    if (text && text.trim()) {
        // ç¡®å®šåˆ†ç±»ID
        let targetCategory = null;
        if (activeQuickReplyCategoryId !== 'all' && activeQuickReplyCategoryId !== 'uncategorized') {
            targetCategory = activeQuickReplyCategoryId;
        }

        const newReply = {
            text: text.trim(),
            categoryId: targetCategory // ä¿å­˜åˆ†ç±»ID
        };
    
        const newId = await db.quickReplies.add(newReply);
        
        // æ›´æ–°å†…å­˜
        state.quickReplies.push({
            id: newId,
            ...newReply
        });

        renderQuickReplyList(false); // ä¸ç”¨é‡ç»˜Tabs
    } else if (text !== null) {
        alert("å†…å®¹ä¸èƒ½ä¸ºç©ºï¼");
    }
}

// 4. æ‰“å¼€åˆ†ç±»ç®¡ç†å™¨
async function openQuickReplyCategoryManager() {
    await renderQuickReplyCategoriesInManager();
    document.getElementById('quick-reply-category-manager-modal').classList.add('visible');
}

// 5. æ¸²æŸ“åˆ†ç±»ç®¡ç†åˆ—è¡¨
async function renderQuickReplyCategoriesInManager() {
    const listEl = document.getElementById('existing-quick-reply-categories-list');
    const categories = await db.quickReplyCategories.toArray();
    listEl.innerHTML = '';
    
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">è¿˜æ²¡æœ‰ä»»ä½•åˆ†ç±»</p>';
        return;
    }
    
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item'; // å¤ç”¨æ ·å¼
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">Ã—</span>
        `;
        // ç»‘å®šåˆ é™¤äº‹ä»¶
        item.querySelector('.delete-group-btn').onclick = () => deleteQuickReplyCategory(cat.id);
        listEl.appendChild(item);
    });
}

// 6. æ·»åŠ æ–°åˆ†ç±»
async function addNewQuickReplyCategory() {
    const input = document.getElementById('new-quick-reply-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('åˆ†ç±»åä¸èƒ½ä¸ºç©ºï¼');
        return;
    }
    const existing = await db.quickReplyCategories.where('name').equals(name).first();
    if (existing) {
        alert(`åˆ†ç±» "${name}" å·²ç»å­˜åœ¨äº†ï¼`);
        return;
    }
    await db.quickReplyCategories.add({ name });
    input.value = '';
    await renderQuickReplyCategoriesInManager();
    document.getElementById('quick-reply-tabs').dataset.needsRefresh = 'true';
}

// 7. åˆ é™¤åˆ†ç±»
async function deleteQuickReplyCategory(categoryId) {
    const category = await db.quickReplyCategories.get(categoryId);
    if (!category) return;

    const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤åˆ†ç±»',
        `åˆ é™¤åˆ†ç±»ã€Š${category.name}ã€‹åï¼Œè¯¥åˆ†ç±»ä¸‹çš„å›å¤å°†å˜ä¸ºâ€œæœªåˆ†ç±»â€ã€‚ç¡®å®šå—ï¼Ÿ`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 1. åˆ é™¤åˆ†ç±»
        await db.quickReplyCategories.delete(categoryId);
        
        // 2. å°†è¯¥åˆ†ç±»ä¸‹çš„å›å¤ç§»åˆ°æœªåˆ†ç±» (categoryId = null)
        const repliesToUpdate = state.quickReplies.filter(r => r.categoryId == categoryId);
        for (const reply of repliesToUpdate) {
            reply.categoryId = null;
            await db.quickReplies.put(reply);
        }
        
        // 3. åˆ·æ–°ç•Œé¢
        await renderQuickReplyCategoriesInManager();
        
        // å¦‚æœå½“å‰æ­£å¥½åœ¨è¿™ä¸ªåˆ†ç±»ä¸‹ï¼Œåˆ‡å›å…¨éƒ¨
        if (activeQuickReplyCategoryId == categoryId) {
            activeQuickReplyCategoryId = 'all';
        }
        document.getElementById('quick-reply-tabs').dataset.needsRefresh = 'true';
        await renderQuickReplyList(true);
    }
}

 
  function selectQuickReply(text) {
    const chatInput = document.getElementById('chat-input');
    chatInput.value = text;
    // document.getElementById('send-btn').click();
    document.getElementById('quick-reply-modal').classList.remove('visible');
    chatInput.focus(); 
  }

 
  


  async function editQuickReply(id) {
    const reply = await db.quickReplies.get(id);
    if (!reply) return;

    const newText = await showCustomPrompt("ä¿®æ”¹å¿«æ·å›å¤", "è¯·ä¿®æ”¹å›å¤å†…å®¹ï¼š", reply.text, "textarea");

    if (newText && newText.trim()) {
      
      await db.quickReplies.update(id, {
        text: newText.trim()
      });

      
      const stateReply = state.quickReplies.find(r => r.id === id);
      if (stateReply) stateReply.text = newText.trim();

      
      renderQuickReplyList();
    } else if (newText !== null) {
      alert("å†…å®¹ä¸èƒ½ä¸ºç©ºï¼");
    }
  }


  async function deleteQuickReply(id) {
    const confirmed = await showCustomConfirm(
      'ç¡®è®¤åˆ é™¤',
      'ç¡®å®šè¦åˆ é™¤è¿™æ¡å¿«æ·å›å¤å—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
    
      await db.quickReplies.delete(id);

    
      state.quickReplies = state.quickReplies.filter(r => r.id !== id);

    
      renderQuickReplyList();
    }
  }
async function handleCharBilibiliSearch() {
    const input = document.getElementById('char-bilibili-search-input');
    const query = input.value.trim();
    if (!query) return;

    const listEl = document.getElementById('char-bilibili-list');
    listEl.innerHTML = '<div class="spinner"></div>'; // æ˜¾ç¤ºåŠ è½½ä¸­

    // å®šä¹‰å»¶æ—¶å‡½æ•°
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    try {
        const maxResults = 15; // æƒ³è¦è·å–çš„æ¡æ•°
        let videos = [];

        // æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ for å¾ªç¯ + await å®ç°â€œä¸€ä¸ªä¸€ä¸ªæœâ€
        for (let i = 1; i <= maxResults; i++) {
            // 1. å®šä¹‰åŸå§‹ API åœ°å€ï¼Œn åŠ¨æ€å˜åŒ–
            const targetUrl = `https://api.52vmy.cn/api/query/bilibili/video?msg=${encodeURIComponent(query)}&n=${i}`;
            
            // 2. ä½¿ç”¨ CORS ä»£ç†
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

            let retryCount = 0;
            let success = false;
            const maxRetries = 3; // å•ä¸ªè¯·æ±‚æœ€å¤§é‡è¯•æ¬¡æ•°

            // æ·»åŠ é‡è¯•æœºåˆ¶ï¼Œå¤„ç†å¶å‘çš„é™æµæˆ–ç½‘ç»œæ³¢åŠ¨
            while (!success && retryCount < maxRetries) {
                try {
                    const res = await fetch(proxyUrl);
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                    
                    // å…³é”®ä¿®æ”¹ï¼šå…ˆä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œé˜²æ­¢è¿”å›â€œè®¿é—®è¿‡å¿«â€æ—¶ JSON è§£æç‚¸è£‚
                    const text = await res.text();

                    // æ£€æŸ¥æ˜¯å¦è¢«é™æµ (å¤„ç†æˆªå›¾ä¸­ "è®¿é—®è¿‡å¿«..." çš„æƒ…å†µ)
                    if (text.includes("è®¿é—®è¿‡å¿«") || text.includes("é¢‘ç¹") || text.includes("Too Many Requests")) {
                        console.warn(`âš ï¸ è·å–ç¬¬ ${i} æ¡è§¦å‘é™æµï¼Œç­‰å¾…å†·å´...`);
                        await delay(1500 + (retryCount * 1000)); // åŠ¨æ€å¢åŠ ç­‰å¾…æ—¶é—´
                        retryCount++;
                        continue; // é‡è¯•
                    }

                    // å°è¯•è§£æ JSON
                    let json;
                    try {
                        json = JSON.parse(text);
                    } catch (e) {
                        console.warn(`ç¬¬ ${i} æ¡è¿”å›æ ¼å¼é”™è¯¯:`, text.substring(0, 50));
                        retryCount++;
                        continue;
                    }

                    // æ”¶é›†æ•°æ®
                    if (json.data) {
                        if (Array.isArray(json.data)) {
                            videos.push(...json.data);
                        } else {
                            videos.push(json.data);
                        }
                    } else if (json.title) {
                        videos.push(json);
                    } else if (json.code === 200 && json.data) { 
                         if (Array.isArray(json.data)) {
                            videos.push(...json.data);
                         } else {
                            videos.push(json.data);
                         }
                    }

                    success = true; // æ ‡è®°æˆåŠŸï¼Œé€€å‡º while å¾ªç¯

                } catch (err) {
                    console.warn(`è·å–ç¬¬ ${i} æ¡è§†é¢‘ç½‘ç»œé”™è¯¯:`, err);
                    retryCount++;
                    await delay(1000); // ç½‘ç»œé”™è¯¯ç¨ä½œç­‰å¾…
                }
            }

            // æ¯æ¬¡è¯·æ±‚åå¼ºåˆ¶ä¼‘æ¯ä¸€ä¸‹ï¼Œè¿™æ˜¯é˜²æ­¢å†æ¬¡è¢«é™æµçš„å…³é”®ï¼
            await delay(800); 
        }

        // å»é‡å¤„ç†
        const uniqueVideos = [];
        const seenUrls = new Set();
        videos.forEach(v => {
            const url = v.url || v.arcurl; 
            if (url && !seenUrls.has(url)) {
                seenUrls.add(url);
                uniqueVideos.push(v);
            }
        });

        listEl.innerHTML = '';
        if (uniqueVideos.length === 0) {
            listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æœªæ‰¾åˆ°ç›¸å…³è§†é¢‘ï¼Œæˆ–æ¥å£æš‚æ—¶ä¸å¯ç”¨</p>';
            return;
        }

        // æ¸²æŸ“ç»“æœ
        uniqueVideos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'bilibili-item';
            item.innerHTML = `
                <div class="bili-cover" style="position: relative; overflow: hidden;">
                    <img src="${video.img_url || video.pic}" referrerpolicy="no-referrer" style="width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; z-index: 1;">
                    <div class="bili-duration" style="position: absolute; z-index: 2;">â–¶</div>
                </div>
                <div class="bili-info">
                    <div class="bili-title">${video.title}</div>
                    <div class="bili-author">UP: ${video.user || video.author}</div>
                </div>
            `;
            item.onclick = () => playCharBilibiliVideo(video);
            listEl.appendChild(item);
        });

    } catch (error) {
        console.error('Bilibili search error:', error);
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æœç´¢å‡ºé”™ï¼Œè¯·ç¨åå†è¯•</p>';
    }
}

function playCharBilibiliVideo(videoData) {
    const playerScreen = document.getElementById('char-bilibili-player-screen');
    const videoEl = document.getElementById('char-bilibili-video');
    const titleEl = document.getElementById('char-bilibili-player-title');
    const authorEl = document.getElementById('char-bilibili-player-author');
    const descEl = document.getElementById('char-bilibili-player-desc');

    videoEl.src = videoData.url;
    titleEl.textContent = videoData.title;
    authorEl.textContent = `UPä¸»: ${videoData.user}`;
    descEl.textContent = videoData.desc || 'æš‚æ— ç®€ä»‹';

    switchToCharScreen('char-bilibili-player-screen');
    videoEl.play().catch(e => console.log("Autoplay blocked", e));
}

function closeCharBilibiliPlayer() {
    const videoEl = document.getElementById('char-bilibili-video');
    videoEl.pause();
    videoEl.src = '';
    switchToCharScreen('char-bilibili-screen');
}

window.closeCharBilibiliPlayer = function() {
    const videoEl = document.getElementById('char-bilibili-video');
    if(videoEl) {
        videoEl.pause();
        videoEl.src = '';
    }
    switchToCharScreen('char-bilibili-screen');
}

// ==========================================
// MY Phone æ¸²æŸ“å‡½æ•°
// ==========================================

async function renderMyPhoneSimulatedQQ() {
  const listEl = document.getElementById('myphone-chat-list');
  listEl.innerHTML = '';
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char) return;

  const userDisplayName = state.qzoneSettings.nickname || 'æˆ‘';
  const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };

  let lastMsgContent = '...';
  if (lastRealMessage) {
    if (typeof lastRealMessage.content === 'string') {
      lastMsgContent = lastRealMessage.content;
    } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
      lastMsgContent = '[å›¾ç‰‡]';
    } else if (lastRealMessage.type) {
      const typeMap = {
        'voice_message': '[è¯­éŸ³]',
        'transfer': '[è½¬è´¦]',
        'ai_image': '[å›¾ç‰‡]'
      };
      lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
    }
  }

  const charAvatar = char.settings.aiAvatar || defaultAvatar;
  const charFrame = char.settings.aiAvatarFrame || '';
  let avatarHtml;
  if (charFrame) {
    avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${charAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${charFrame}" class="avatar-frame"></div></div>`;
  } else {
    avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${charAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
  }

  const charChatItem = document.createElement('div');
  charChatItem.className = 'chat-list-item';
  charChatItem.dataset.conversationIndex = "-1";
  charChatItem.innerHTML = `
      ${avatarHtml}
      <div class="info">
          <div class="name-line">
              <span class="name">${char.name}</span>
          </div>
          <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
      </div>
  `;
  charChatItem.addEventListener('click', () => openMyPhoneConversation(-1));
  listEl.appendChild(charChatItem);

  const simulatedConversations = char.myPhoneSimulatedQQConversations || [];
  simulatedConversations.forEach((conv, idx) => {
    const item = document.createElement('div');
    item.className = 'chat-list-item';
    item.dataset.conversationIndex = idx;
    
    // æ£€æŸ¥æ˜¯å¦åœ¨åˆ é™¤æ¨¡å¼ä¸‹
    const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'qq';
    
    if (isDeleteMode) {
      item.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${idx}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${idx})">
        <img src="${conv.avatar || defaultAvatar}" class="avatar">
        <div class="info">
          <div class="name-line">
            <span class="name">${conv.name}</span>
          </div>
          <div class="last-msg">${conv.lastMessage || '...'}</div>
        </div>
      `;
      // åœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»é¡¹ç›®æœ¬èº«ä¹Ÿä¼šåˆ‡æ¢é€‰ä¸­çŠ¶æ€
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(idx);
        const checkbox = item.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(idx);
      });
    } else {
      item.innerHTML = `
        <img src="${conv.avatar || defaultAvatar}" class="avatar">
        <div class="info">
          <div class="name-line">
            <span class="name">${conv.name}</span>
          </div>
          <div class="last-msg">${conv.lastMessage || '...'}</div>
        </div>
      `;
      item.addEventListener('click', () => openMyPhoneConversation(idx));
    }
    
    listEl.appendChild(item);
  });

  document.getElementById('back-to-myphone-qq-list-btn').onclick = () => switchToMyPhoneScreen('myphone-qq-screen');
}

async function openMyPhoneConversation(index) {
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char) return;

  // ä¿å­˜å½“å‰å¯¹è¯ç´¢å¼•
  window.currentMyPhoneConversationIndex = index;
  myphoneActiveConversationIndex = index;

  const messagesEl = document.getElementById('myphone-conversation-messages');
  messagesEl.innerHTML = '';
  messagesEl.dataset.theme = char.settings.theme || 'default';

  let partnerName, messages, tempChatObject;
  const settingsBtn = document.getElementById('myphone-conversation-settings-btn');
  
  if (index === -1) {
    // ä¸è§’è‰²çš„çœŸå®å¯¹è¯ - ä¸æ˜¾ç¤ºè®¾ç½®æŒ‰é’®ï¼Œä½¿ç”¨æ¸²æŸ“çª—å£æœºåˆ¶
    partnerName = char.name;
    settingsBtn.style.display = 'none';
    
    // åˆ›å»ºä¸´æ—¶èŠå¤©å¯¹è±¡ç”¨äºæ¸²æŸ“ï¼ˆè§’è‰²è§†è§’ï¼‰
    tempChatObject = {
      id: 'temp_myphone_user_chat',
      isGroup: false,
      name: state.qzoneSettings.nickname || 'æˆ‘',
      settings: {
        ...char.settings,
        myAvatar: char.settings.myAvatar || defaultAvatar,
        myAvatarFrame: char.settings.myAvatarFrame || '',
        aiAvatar: char.settings.aiAvatar || defaultAvatar,
        aiAvatarFrame: char.settings.aiAvatarFrame || ''
      }
    };
    
    // âœ¨ ä½¿ç”¨æ¸²æŸ“çª—å£æœºåˆ¶ï¼Œåªæ¸²æŸ“æœ€è¿‘çš„æ¶ˆæ¯
    myphoneRenderedCount = 0;
    isLoadingMoreMyPhoneMessages = false;
    
    const allVisibleMessages = char.history.filter(m => !m.isHidden);
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const initialMessages = allVisibleMessages.slice(-renderWindow);
    messages = initialMessages;
    myphoneRenderedCount = initialMessages.length;
  } else {
    // æ¨¡æ‹Ÿå¯¹è¯ - æ˜¾ç¤ºè®¾ç½®æŒ‰é’®
    const conv = char.myPhoneSimulatedQQConversations[index];
    partnerName = conv.name;
    settingsBtn.style.display = 'block';
    
    // è·å–ç”¨æˆ·å¤´åƒï¼ˆä»ä¸»å±å¹•QQå¯¹è¯ä¸­çš„è®¾ç½®ï¼‰
    const userAvatar = char.settings.myAvatar || state.qzoneSettings.avatar || defaultAvatar;
    const userAvatarFrame = char.settings.myAvatarFrame || '';
    
    // åˆ›å»ºä¸´æ—¶èŠå¤©å¯¹è±¡ç”¨äºæ¸²æŸ“
    tempChatObject = {
      id: 'temp_myphone_simulated_chat',
      isGroup: false,
      name: conv.name,
      settings: {
        myAvatar: userAvatar,
        myAvatarFrame: userAvatarFrame,
        aiAvatar: conv.avatar || defaultAvatar,
        aiAvatarFrame: ''
      }
    };
    
    messages = conv.messages || [];
  }

  document.getElementById('myphone-conversation-partner-name').textContent = partnerName;

  // ä½¿ç”¨createMessageElementæ¸²æŸ“æ¯æ¡æ¶ˆæ¯ï¼ˆä¸cphoneæ¸²æŸ“æ–¹å¼ä¸€è‡´ï¼‰
  for (const msg of messages) {
    const messageEl = await createMessageElement(msg, tempChatObject);
    if (messageEl) {
      messagesEl.appendChild(messageEl);
    }
  }

  messagesEl.scrollTop = messagesEl.scrollHeight;
  switchToMyPhoneScreen('myphone-qq-conversation-screen');
}

async function renderMyPhoneAlbum() {
  const gridEl = document.getElementById('myphone-album-grid');
  gridEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;
  const char = state.chats[activeMyPhoneCharacterId];

  const photos = char.myPhoneAlbum || [];

  if (photos.length === 0) {
    gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„ç›¸å†Œè¿˜æ˜¯ç©ºçš„ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›ç…§ç‰‡å§ï¼</p>';
    return;
  }

  const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'album';

  photos.forEach((photo, idx) => {
    const item = document.createElement('div');
    item.className = 'char-photo-item';
    item.dataset.description = photo.description;
    item.style.position = 'relative';
    gridEl.appendChild(item);

    // æ·»åŠ å¤é€‰æ¡†ï¼ˆå¦‚æœåœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼‰
    if (isDeleteMode) {
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'myphone-delete-checkbox';
      checkbox.dataset.index = idx;
      checkbox.checked = myPhoneDeleteMode.selectedIndices.has(idx);
      checkbox.style.cssText = 'position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; cursor: pointer; z-index: 10;';
      checkbox.onchange = () => toggleMyPhoneItemSelection(idx);
      item.appendChild(checkbox);
    }

    if (state.globalSettings.enableAiDrawing) {
      item.style.backgroundColor = '#e9ecef';
      const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
      const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
      const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
      const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;

      const img = new Image();
      img.onload = function() {
        item.style.backgroundImage = `url(${this.src})`;
      };
      img.onerror = function() {
        item.style.backgroundImage = `url(${fallbackImageUrl})`;
      };
      img.src = imageUrl;
    } else {
      item.style.backgroundColor = '#f0f2f5';
      item.style.border = '1px solid #e0e0e0';
      const descriptionEl = document.createElement('p');
      descriptionEl.className = 'char-photo-description';
      descriptionEl.textContent = photo.description || '(è¿™å¼ ç…§ç‰‡æ²¡æœ‰æè¿°)';
      item.appendChild(descriptionEl);
    }

    if (isDeleteMode) {
      // åœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»é¡¹ç›®åˆ‡æ¢é€‰ä¸­çŠ¶æ€
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(idx);
        const checkbox = item.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(idx);
      });
    } else {
      item.addEventListener('click', () => {
        showCustomAlert('ç…§ç‰‡æè¿°', photo.description || 'æ— æè¿°');
      });
    }
  });
}

function renderMyPhoneBrowserHistory() {
  const listEl = document.getElementById('myphone-browser-list');
  listEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const history = char.myPhoneBrowserHistory || [];

  if (history.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„æµè§ˆå™¨ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
    return;
  }

  const globeIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>`;
  const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'browser';

  history.forEach((item, index) => {
    const entryEl = document.createElement('div');
    entryEl.className = 'char-browser-item';
    
    let cleanUrl = item.url.replace(/^https?:\/\//, '').replace(/^www\./, '');
    if(cleanUrl.length > 25) cleanUrl = cleanUrl.substring(0, 25) + '...';

    if (isDeleteMode) {
      entryEl.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${index}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${index})">
        <div class="char-browser-icon-box">
            ${globeIcon}
        </div>
        <div class="char-browser-content">
            <div class="char-browser-title">${item.title}</div>
            <div class="char-browser-url">${cleanUrl}</div>
        </div>
        <div class="char-browser-arrow">
            ${arrowIcon}
        </div>
      `;
      entryEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(index);
        const checkbox = entryEl.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(index);
      });
    } else {
      entryEl.innerHTML = `
        <div class="char-browser-icon-box">
            ${globeIcon}
        </div>
        <div class="char-browser-content">
            <div class="char-browser-title">${item.title}</div>
            <div class="char-browser-url">${cleanUrl}</div>
        </div>
        <div class="char-browser-arrow">
            ${arrowIcon}
        </div>
      `;
      entryEl.addEventListener('click', () => openMyPhoneArticle(index));
    }

    listEl.appendChild(entryEl);
  });

  document.getElementById('back-to-myphone-browser-list-btn').onclick = () => switchToMyPhoneScreen('myphone-browser-screen');
}

async function openMyPhoneArticle(index) {
  const char = state.chats[activeMyPhoneCharacterId];
  const articleData = char.myPhoneBrowserHistory[index];
  if (!articleData) return;

  renderMyPhoneArticle(articleData);
  switchToMyPhoneScreen('myphone-browser-article-screen');
}

function renderMyPhoneArticle(articleData) {
  document.getElementById('myphone-article-title-header').textContent = articleData.title.substring(0, 10) + '...';
  document.getElementById('myphone-article-title').textContent = articleData.title;
  document.getElementById('myphone-article-meta').textContent = articleData.url;
  document.getElementById('myphone-article-content').textContent = articleData.content || 'å†…å®¹åŠ è½½ä¸­...';
}

function renderMyPhoneTaobao() {
  const gridEl = document.getElementById('myphone-taobao-grid');
  gridEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const items = char.myPhoneTaobaoHistory || [];

  if (items.length === 0) {
    gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„æ·˜å®ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
    return;
  }

  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'taobao';

  items.forEach((item, idx) => {
    const itemEl = document.createElement('div');
    itemEl.className = 'char-product-item';
    itemEl.dataset.reason = item.reason || item.thought;
    itemEl.style.position = 'relative';

    let imageOrTextHtml;
    // å¦‚æœç”¨æˆ·é€‰æ‹©äº†ä½¿ç”¨AIç”Ÿæˆå›¾ç‰‡
    if (item.image_prompt && !item.useDefaultImage && state.globalSettings.enableAiDrawing) {
      const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
      imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
    } else if (item.image_prompt && !item.useDefaultImage) {
      // ç”¨æˆ·é€‰æ‹©äº†AIç”Ÿæˆä½†å…¨å±€è®¾ç½®æœªå¯ç”¨ï¼Œæ˜¾ç¤ºæè¿°
      imageOrTextHtml = `
        <div class="char-product-description-overlay">
          <p class="char-photo-description">${item.thought || item.reason || '(æ— è´­ä¹°ç†ç”±)'}</p>
        </div>
      `;
    } else {
      // ç”¨æˆ·é€‰æ‹©äº†ä½¿ç”¨é»˜è®¤å›¾ç‰‡
      imageOrTextHtml = `
        <div class="char-product-description-overlay">
          <p class="char-photo-description">${item.thought || item.reason || '(æ— è´­ä¹°ç†ç”±)'}</p>
        </div>
      `;
    }

    // æ·»åŠ å¤é€‰æ¡†ï¼ˆå¦‚æœåœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼‰
    let checkboxHtml = '';
    if (isDeleteMode) {
      checkboxHtml = `<input type="checkbox" class="myphone-delete-checkbox" data-index="${idx}" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; cursor: pointer; z-index: 10;" onchange="toggleMyPhoneItemSelection(${idx})">`;
    }

    itemEl.innerHTML = `
      ${checkboxHtml}
      ${imageOrTextHtml}
      <div class="product-info">
        <div class="product-name">${item.name}</div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
          <div class="product-price">Â¥${(parseFloat(item.price) || 0).toFixed(2)}</div>
          <div class="char-product-status">${item.status || 'å·²ç­¾æ”¶'}</div>
        </div>
      </div>
    `;

    if (isDeleteMode) {
      // åœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»é¡¹ç›®åˆ‡æ¢é€‰ä¸­çŠ¶æ€
      itemEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(idx);
        const checkbox = itemEl.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(idx);
      });
    } else {
      // æ·»åŠ ç‚¹å‡»äº‹ä»¶æ˜¾ç¤ºè´­ä¹°æƒ³æ³•
      itemEl.addEventListener('click', () => {
        const thought = item.thought || item.reason || 'æ— æƒ³æ³•è®°å½•';
        showCustomAlert('è´­ä¹°æƒ³æ³•', thought);
      });
    }

    gridEl.appendChild(itemEl);
  });
}

function renderMyPhoneMemoList() {
  const listEl = document.getElementById('myphone-memo-list');
  listEl.innerHTML = '';
  const char = state.chats[activeMyPhoneCharacterId];
  const memos = (char.myPhoneMemos || []).slice().reverse();

  if (memos.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„å¤‡å¿˜å½•ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’+å·æ·»åŠ æˆ–åˆ·æ–°æŒ‰é’®ç”Ÿæˆï¼</p>';
    return;
  }

  // SVG å›¾æ ‡: ç±»ä¼¼æ–‡ä»¶çš„å›¾æ ‡
  const memoIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`;
  // SVG å›¾æ ‡: å³ç®­å¤´
  const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'memo';

  memos.forEach((memo, index) => {
    const item = document.createElement('div');
    item.className = 'memo-item';
    
    // è·å–å†…å®¹é¢„è§ˆ (ç¬¬ä¸€è¡Œ)
    const previewText = (memo.content || '').split('\n')[0].substring(0, 50) || 'æ— å†…å®¹';
    const actualIndex = memos.length - 1 - index; // å®é™…æ•°æ®ç´¢å¼•

    if (isDeleteMode) {
      item.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${actualIndex}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${actualIndex})">
        <div class="cphone-item-icon-box memo-icon-style">
          ${memoIconSVG}
        </div>
        <div class="cphone-item-info">
          <div class="cphone-item-title">${memo.title}</div>
          <div class="cphone-item-preview">${previewText}</div>
        </div>
        <div class="cphone-item-arrow">
          ${arrowIcon}
        </div>
      `;
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(actualIndex);
        const checkbox = item.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(actualIndex);
      });
    } else {
      item.innerHTML = `
        <div class="cphone-item-icon-box memo-icon-style">
          ${memoIconSVG}
        </div>
        <div class="cphone-item-info">
          <div class="cphone-item-title">${memo.title}</div>
          <div class="cphone-item-preview">${previewText}</div>
        </div>
        <div class="cphone-item-arrow">
          ${arrowIcon}
        </div>
      `;
      item.addEventListener('click', () => openMyPhoneMemo(actualIndex));
    }
    
    listEl.appendChild(item);
  });

  document.getElementById('back-to-myphone-memo-list-btn').onclick = () => switchToMyPhoneScreen('myphone-memo-screen');
}

function openMyPhoneMemo(index) {
  const char = state.chats[activeMyPhoneCharacterId];
  const memo = char.myPhoneMemos[index];
  if (!memo) return;

  document.getElementById('myphone-memo-title-header').textContent = memo.title.substring(0, 10) + '...';
  document.getElementById('myphone-memo-detail-title').textContent = memo.title;
  document.getElementById('myphone-memo-detail-date').textContent = memo.date;
  document.getElementById('myphone-memo-detail-content').textContent = memo.content;

  switchToMyPhoneScreen('myphone-memo-detail-screen');
}

function renderMyPhoneDiaryList() {
  const listEl = document.getElementById('myphone-diary-list');
  listEl.innerHTML = '';
  const char = state.chats[activeMyPhoneCharacterId];
  const diaries = (char.myPhoneDiaries || []).slice().reverse();

  if (diaries.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„æ—¥è®°ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›å†…å®¹å§ï¼</p>';
    return;
  }

  // SVG å›¾æ ‡: ä¹¦æœ¬å›¾æ ‡
  const diaryIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>`;
  // SVG å›¾æ ‡: å³ç®­å¤´
  const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'diary';

  diaries.forEach((diary, index) => {
    const item = document.createElement('div');
    item.className = 'diary-item';
    
    // ä½¿ç”¨diary.dateä½œä¸ºæ—¥æœŸæ˜¾ç¤º
    const dateStr = diary.date || new Date().toLocaleDateString('zh-CN');
    const actualIndex = diaries.length - 1 - index; // å®é™…æ•°æ®ç´¢å¼•

    if (isDeleteMode) {
      item.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${actualIndex}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${actualIndex})">
        <div class="cphone-item-icon-box diary-icon-style">
          ${diaryIconSVG}
        </div>
        <div class="cphone-item-info">
          <div class="cphone-item-title">${diary.title}</div>
          <div class="cphone-item-preview">${dateStr}</div>
        </div>
        <div class="cphone-item-arrow">
          ${arrowIcon}
        </div>
      `;
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(actualIndex);
        const checkbox = item.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(actualIndex);
      });
    } else {
      item.innerHTML = `
        <div class="cphone-item-icon-box diary-icon-style">
          ${diaryIconSVG}
        </div>
        <div class="cphone-item-info">
          <div class="cphone-item-title">${diary.title}</div>
          <div class="cphone-item-preview">${dateStr}</div>
        </div>
        <div class="cphone-item-arrow">
          ${arrowIcon}
        </div>
      `;
      item.addEventListener('click', () => openMyPhoneDiary(actualIndex));
    }
    
    listEl.appendChild(item);
  });

  document.getElementById('back-to-myphone-diary-list-btn').onclick = () => switchToMyPhoneScreen('myphone-diary-screen');
}

function openMyPhoneDiary(index) {
  const char = state.chats[activeMyPhoneCharacterId];
  const diary = char.myPhoneDiaries[index];
  if (!diary) return;

  document.getElementById('myphone-diary-title-header').textContent = diary.title.substring(0, 10) + '...';
  document.getElementById('myphone-diary-detail-title').textContent = diary.title;
  document.getElementById('myphone-diary-detail-date').textContent = diary.date;
  
  // æ˜¾ç¤ºå¤©æ°”
  const weatherEl = document.getElementById('myphone-diary-detail-weather');
  if (weatherEl) {
    weatherEl.textContent = diary.weather ? `å¤©æ°”ï¼š${diary.weather}` : '';
    weatherEl.style.display = diary.weather ? 'block' : 'none';
  }
  
  // æ˜¾ç¤ºå‰è¨€
  const prefaceEl = document.getElementById('myphone-diary-detail-preface');
  if (prefaceEl) {
    prefaceEl.textContent = diary.preface || '';
    prefaceEl.style.display = diary.preface ? 'block' : 'none';
  }
  
  document.getElementById('myphone-diary-detail-content').textContent = diary.content;

  switchToMyPhoneScreen('myphone-diary-detail-screen');
}

function renderMyPhoneAmap() {
  const listEl = document.getElementById('myphone-amap-list');
  listEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const locations = char.myPhoneAmapHistory || [];
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'amap';

  if (locations.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„è¶³è¿¹ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è®°å½•å§ï¼</p>';
    return;
  }

  locations.forEach((item, idx) => {
    const itemEl = document.createElement('div');
    itemEl.className = 'char-amap-item';
    itemEl.style.position = 'relative';

    // å…¼å®¹æ–°æ—§æ•°æ®ç»“æ„
    const locationName = item.locationName || item.name || 'æœªçŸ¥åœ°ç‚¹';
    const address = item.address || '';
    const comment = item.comment || item.thought || '';
    const timeAgo = item.timeAgo || item.time || 'æŸä¸ªæ—¶é—´';

    let photoHtml = '';
    if (item.image_prompt) {
      const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
      photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${comment}"></div>`;
    }

    // æ·»åŠ å¤é€‰æ¡†ï¼ˆå¦‚æœåœ¨åˆ é™¤æ¨¡å¼ä¸‹ï¼‰
    let checkboxHtml = '';
    if (isDeleteMode) {
      checkboxHtml = `<input type="checkbox" class="myphone-delete-checkbox" data-index="${idx}" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; cursor: pointer; z-index: 10;" onchange="toggleMyPhoneItemSelection(${idx})">`;
    }

    itemEl.innerHTML = `
      ${checkboxHtml}
      <div class="amap-item-header">
        <div class="amap-item-icon">ğŸ“</div>
        <div class="amap-item-info">
          <div class="amap-item-title">${locationName}</div>
          <div class="amap-item-address">${address}</div>
        </div>
      </div>
      <div class="amap-item-body">
        <div class="amap-item-comment">${comment.replace(/\n/g, '<br>')}</div>
        ${photoHtml}
      </div>
      <div class="amap-item-footer">${timeAgo}</div>
    `;
    
    if (isDeleteMode) {
      itemEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(idx);
        const checkbox = itemEl.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(idx);
      });
    }
    
    listEl.appendChild(itemEl);
  });
}

function renderMyPhoneAppUsage() {
  const listEl = document.getElementById('myphone-usage-list');
  listEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const originalUsage = char.myPhoneAppUsage || [];
  const usageData = originalUsage.slice().sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'usage';

  if (usageData.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æš‚æ— ä½¿ç”¨è®°å½•ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’+å·æ·»åŠ æˆ–åˆ·æ–°æŒ‰é’®ç”Ÿæˆï¼</p>';
    return;
  }

  usageData.forEach((item, displayIdx) => {
    const itemEl = document.createElement('div');
    itemEl.className = 'char-usage-item';

    // æ‰¾åˆ°åœ¨åŸå§‹æ•°ç»„ä¸­çš„ç´¢å¼•
    const actualIndex = originalUsage.indexOf(item);

    // è®¡ç®—æ—¶é•¿æ˜¾ç¤º
    const hours = Math.floor(item.usageTimeMinutes / 60);
    const minutes = item.usageTimeMinutes % 60;
    let timeString = '';
    if (hours > 0) timeString += `${hours}å°æ—¶`;
    if (minutes > 0) timeString += `${minutes}åˆ†é’Ÿ`;
    if (!timeString) timeString = 'å°äº1åˆ†é’Ÿ';

    // å›¾æ ‡å¤„ç†ï¼šå¦‚æœç”¨æˆ·æä¾›äº†iconUrlå°±ç”¨ç”¨æˆ·çš„ï¼Œå¦åˆ™ç”¨é»˜è®¤å›¾æ ‡
    let iconHtml = '';
    if (item.iconUrl) {
      iconHtml = `<img src="${item.iconUrl}" class="usage-item-icon">`;
    } else {
      // ä½¿ç”¨é»˜è®¤ç°è‰²å›¾æ ‡å ä½
      iconHtml = `<div class="usage-item-icon" style="background-color: #e0e0e0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 20px;">ğŸ“±</div>`;
    }

    if (isDeleteMode) {
      itemEl.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${actualIndex}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${actualIndex})">
        ${iconHtml}
        <div class="usage-item-info">
          <div class="usage-item-name">${item.appName}</div>
          <div class="usage-item-category">${item.category}</div>
        </div>
        <div class="usage-item-time">${timeString}</div>
      `;
      itemEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(actualIndex);
        const checkbox = itemEl.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(actualIndex);
      });
    } else {
      itemEl.innerHTML = `
        ${iconHtml}
        <div class="usage-item-info">
          <div class="usage-item-name">${item.appName}</div>
          <div class="usage-item-category">${item.category}</div>
        </div>
        <div class="usage-item-time">${timeString}</div>
      `;
    }
    
    listEl.appendChild(itemEl);
  });
}

function renderMyPhoneMusicScreen() {
  const listEl = document.getElementById('myphone-music-list');
  listEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const playlist = char.myPhoneMusicPlaylist || [];
  const isDeleteMode = myPhoneDeleteMode.active && myPhoneDeleteMode.appType === 'music';

  if (playlist.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„æ­Œå•ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’+å·æ·»åŠ æˆ–åˆ·æ–°æŒ‰é’®ç”Ÿæˆï¼</p>';
    return;
  }

  playlist.forEach((track, index) => {
    const itemEl = document.createElement('div');
    itemEl.className = 'char-music-item';
    
    // å¤„ç†å°é¢å›¾ï¼Œå¦‚æœæ²¡æœ‰å°é¢åˆ™ä½¿ç”¨é»˜è®¤å›¾
    const coverUrl = track.cover || 'https://via.placeholder.com/60x60/cccccc/666666?text=Music';
    
    if (isDeleteMode) {
      itemEl.innerHTML = `
        <input type="checkbox" class="myphone-delete-checkbox" data-index="${index}" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;" onchange="toggleMyPhoneItemSelection(${index})">
        <img src="${coverUrl}" class="music-item-cover">
        <div class="music-item-info">
          <div class="music-item-name">${track.name || track.title || 'æœªçŸ¥æ­Œæ›²'}</div>
          <div class="music-item-artist">${track.artist || 'æœªçŸ¥æ­Œæ‰‹'}</div>
        </div>
      `;
      itemEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('myphone-delete-checkbox')) return;
        toggleMyPhoneItemSelection(index);
        const checkbox = itemEl.querySelector('.myphone-delete-checkbox');
        if (checkbox) checkbox.checked = myPhoneDeleteMode.selectedIndices.has(index);
      });
    } else {
      itemEl.innerHTML = `
        <img src="${coverUrl}" class="music-item-cover">
        <div class="music-item-info">
          <div class="music-item-name">${track.name || track.title || 'æœªçŸ¥æ­Œæ›²'}</div>
          <div class="music-item-artist">${track.artist || 'æœªçŸ¥æ­Œæ‰‹'}</div>
        </div>
      `;
      // ä½¿ç”¨CPhoneçš„æ’­æ”¾å™¨æ’­æ”¾MYphoneçš„æ­Œæ›²
      itemEl.addEventListener('click', () => playMyPhoneSong(index, playlist));
    }

    listEl.appendChild(itemEl);
  });
}

// MY Phone éŸ³ä¹æ’­æ”¾å‡½æ•° - ä½¿ç”¨CPhoneçš„æ’­æ”¾å™¨
function playMyPhoneSong(songIndex, playlist) {
  const player = document.getElementById('char-audio-player');
  const modal = document.getElementById('char-music-player-modal');

  if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
  player.pause();

  // è®¾ç½®æ’­æ”¾çŠ¶æ€
  charPlayerState.currentPlaylist = playlist;
  charPlayerState.currentIndex = songIndex;

  const songObject = playlist[songIndex];
  if (!songObject) {
    console.error("playMyPhoneSong: æ­Œæ›²ç´¢å¼•æ— æ•ˆæˆ–æ­Œå•ä¸ºç©ºã€‚");
    return;
  }

  // å…¼å®¹æ–°æ—§æ•°æ®ç»“æ„
  const songName = songObject.name || songObject.title || 'æœªçŸ¥æ­Œæ›²';
  const songArtist = songObject.artist || 'æœªçŸ¥æ­Œæ‰‹';
  const songCover = songObject.cover || 'https://via.placeholder.com/300x300/cccccc/666666?text=Music';
  const songSrc = songObject.src || songObject.url || '';

  // æ›´æ–°æ’­æ”¾å™¨ç•Œé¢
  document.getElementById('char-music-player-title').textContent = songName;
  document.getElementById('char-music-artist').textContent = songArtist;
  document.getElementById('char-music-cover').src = songCover;

  // è§£ææ­Œè¯
  charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
  renderCharLyrics();

  // æ’­æ”¾éŸ³é¢‘
  if (songObject.isLocal) {
    // æœ¬åœ°æ–‡ä»¶å¤„ç†
    const blob = new Blob([songObject.src], {
      type: songObject.fileType || 'audio/mpeg'
    });
    player.src = URL.createObjectURL(blob);
  } else if (songSrc) {
    player.src = songSrc;
  } else {
    showCustomAlert('é”™è¯¯', 'è¯¥æ­Œæ›²æ²¡æœ‰å¯æ’­æ”¾çš„éŸ³æº');
    return;
  }

  player.play().catch(e => {
    console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", e);
    showCustomAlert('æ’­æ”¾å¤±è´¥', 'æ— æ³•æ’­æ”¾æ­¤éŸ³é¢‘æ–‡ä»¶');
  });

  player.onloadedmetadata = () => {
    const duration = player.duration;
    if (isFinite(duration)) {
      document.getElementById('char-music-total-time').textContent = formatTime(duration);
      document.getElementById('char-music-progress-bar').max = duration;
    }
  };

  // æ˜¾ç¤ºæ’­æ”¾å™¨
  modal.classList.add('visible');
  charPlayerState.isPlaying = true;
  updateCharPlayButton();

  // å¯åŠ¨æ­Œè¯åŒæ­¥
  charPlayerState.lrcUpdateInterval = setInterval(() => {
    const currentTime = player.currentTime;
    updateCharLyricHighlight(currentTime);
    document.getElementById('char-music-current-time').textContent = formatTime(currentTime);
    document.getElementById('char-music-progress-bar').value = currentTime;
  }, 100);
}

function renderMyPhoneRedditList(posts) {
  const listEl = document.getElementById('myphone-reddit-list');
  listEl.innerHTML = '';

  if (!posts || posts.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æš‚æ— å†…å®¹</p>';
    return;
  }

  posts.forEach(post => {
    const item = document.createElement('div');
    item.className = 'char-reddit-item';
    item.innerHTML = `
      <div class="reddit-title">${post.title}</div>
      <div class="reddit-subreddit">r/${post.subreddit || 'unknown'}</div>
      <div class="reddit-meta">${post.author || 'anonymous'} Â· ${post.score || 0} upvotes</div>
    `;
    listEl.appendChild(item);
  });
}

function handleMyPhoneRedditSearch(query) {
  // Placeholder for Reddit search functionality
  console.log('MY Phone Reddit search:', query);
}

function renderMyPhoneBilibiliScreen() {
  const listEl = document.getElementById('myphone-bilibili-list');
  listEl.innerHTML = '';
  if (!activeMyPhoneCharacterId) return;

  const char = state.chats[activeMyPhoneCharacterId];
  const videos = char.myPhoneBilibiliVideos || [];

  if (videos.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">æˆ‘çš„Bç«™ç©ºç©ºå¦‚ä¹Ÿï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°æŒ‰é’®ç”Ÿæˆä¸€äº›è§†é¢‘å§ï¼</p>';
    return;
  }

  videos.forEach(video => {
    const item = document.createElement('div');
    item.className = 'char-bilibili-item';
    item.innerHTML = `
      <div class="bilibili-title">${video.title}</div>
      <div class="bilibili-author">${video.author || 'UPä¸»'}</div>
      <div class="bilibili-stats">${video.views || 0}æ’­æ”¾ Â· ${video.danmaku || 0}å¼¹å¹•</div>
    `;
    listEl.appendChild(item);
  });
}

function closeMyPhoneBilibiliPlayer() {
  const videoEl = document.getElementById('myphone-bilibili-video');
  if(videoEl) {
    videoEl.pause();
    videoEl.src = '';
  }
  switchToMyPhoneScreen('myphone-bilibili-screen');
}

window.closeMyPhoneBilibiliPlayer = closeMyPhoneBilibiliPlayer;

// MY Phone æ‰‹åŠ¨æ·»åŠ åŠŸèƒ½å‡½æ•°
async function saveMyPhoneAlbum() {
  const description = document.getElementById('myphone-album-description-input')?.value?.trim();
  
  if (!description) {
    showCustomAlert('é”™è¯¯', 'è¯·è¾“å…¥å›¾ç‰‡æè¿°');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneAlbum) {
    char.myPhoneAlbum = [];
  }
  
  const newPhoto = {
    description: description,
    image_prompt: description,
    date: new Date().toLocaleDateString('zh-CN')
  };
  
  char.myPhoneAlbum.unshift(newPhoto);
  await db.chats.put(char);
  renderMyPhoneAlbum();
  
  document.getElementById('myphone-add-album-modal')?.classList.remove('visible');
  document.getElementById('myphone-album-description-input').value = '';
  showCustomAlert('æˆåŠŸ', 'ç…§ç‰‡å·²æ·»åŠ ');
}

async function saveMyPhoneBrowser() {
  const title = document.getElementById('myphone-browser-title-input')?.value?.trim();
  const content = document.getElementById('myphone-browser-content-input')?.value?.trim();
  
  if (!title || !content) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™æ ‡é¢˜å’Œå†…å®¹');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneBrowserHistory) {
    char.myPhoneBrowserHistory = [];
  }
  
  const newEntry = {
    title: title,
    url: 'www.example.com',
    content: content,
    date: new Date().toLocaleDateString('zh-CN')
  };
  
  char.myPhoneBrowserHistory.unshift(newEntry);
  await db.chats.put(char);
  renderMyPhoneBrowserHistory();
  
  document.getElementById('myphone-add-browser-modal')?.classList.remove('visible');
  document.getElementById('myphone-browser-title-input').value = '';
  document.getElementById('myphone-browser-content-input').value = '';
  showCustomAlert('æˆåŠŸ', 'æµè§ˆè®°å½•å·²æ·»åŠ ');
}

async function saveMyPhoneTaobao() {
  const name = document.getElementById('myphone-taobao-name-input')?.value?.trim();
  const description = document.getElementById('myphone-taobao-description-input')?.value?.trim();
  const thought = document.getElementById('myphone-taobao-thought-input')?.value?.trim();
  const price = document.getElementById('myphone-taobao-price-input')?.value || '99';
  const status = document.getElementById('myphone-taobao-status-input')?.value?.trim() || 'å·²ç­¾æ”¶';
  const useAI = document.getElementById('myphone-taobao-ai-image-checkbox')?.checked;
  
  if (!name || !description) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™å•†å“åç§°å’Œæè¿°');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneTaobaoHistory) {
    char.myPhoneTaobaoHistory = [];
  }
  
  const newItem = {
    name: name,
    price: price,
    status: status,
    date: new Date().toLocaleDateString('zh-CN'),
    reason: thought || description,
    thought: thought || '',
    image_prompt: useAI ? description : null,
    useDefaultImage: !useAI
  };
  
  char.myPhoneTaobaoHistory.unshift(newItem);
  await db.chats.put(char);
  renderMyPhoneTaobao();
  
  document.getElementById('myphone-add-taobao-modal')?.classList.remove('visible');
  document.getElementById('myphone-taobao-name-input').value = '';
  document.getElementById('myphone-taobao-description-input').value = '';
  document.getElementById('myphone-taobao-thought-input').value = '';
  document.getElementById('myphone-taobao-price-input').value = '99';
  document.getElementById('myphone-taobao-status-input').value = 'å·²ç­¾æ”¶';
  document.getElementById('myphone-taobao-ai-image-checkbox').checked = false;
  showCustomAlert('æˆåŠŸ', 'è´­ç‰©è®°å½•å·²æ·»åŠ ');
}

async function saveMyPhoneDiary() {
  const date = document.getElementById('myphone-diary-date-input')?.value;
  const weather = document.getElementById('myphone-diary-weather-input')?.value?.trim();
  const title = document.getElementById('myphone-diary-title-input')?.value?.trim();
  const preface = document.getElementById('myphone-diary-preface-input')?.value?.trim();
  const content = document.getElementById('myphone-diary-content-input')?.value?.trim();
  
  if (!date || !title || !content) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™æ—¥æœŸã€æ ‡é¢˜å’Œå†…å®¹');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneDiaries) {
    char.myPhoneDiaries = [];
  }
  
  const formattedDate = new Date(date).toLocaleDateString('zh-CN', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  const newDiary = {
    date: formattedDate,
    weather: weather || 'æ™´',
    title: title,
    preface: preface || '',
    content: content
  };
  
  char.myPhoneDiaries.unshift(newDiary);
  await db.chats.put(char);
  renderMyPhoneDiaryList();
  
  document.getElementById('myphone-add-diary-modal')?.classList.remove('visible');
  document.getElementById('myphone-diary-date-input').value = '';
  document.getElementById('myphone-diary-weather-input').value = '';
  document.getElementById('myphone-diary-title-input').value = '';
  document.getElementById('myphone-diary-preface-input').value = '';
  document.getElementById('myphone-diary-content-input').value = '';
  showCustomAlert('æˆåŠŸ', 'æ—¥è®°å·²æ·»åŠ ');
}

async function saveMyPhoneMemo() {
  const title = document.getElementById('myphone-memo-title-input')?.value?.trim();
  const content = document.getElementById('myphone-memo-content-input')?.value?.trim();
  
  if (!title || !content) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™æ ‡é¢˜å’Œå†…å®¹');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneMemos) {
    char.myPhoneMemos = [];
  }
  
  const newMemo = {
    title: title,
    content: content,
    date: new Date().toLocaleDateString('zh-CN')
  };
  
  char.myPhoneMemos.unshift(newMemo);
  await db.chats.put(char);
  renderMyPhoneMemoList();
  
  document.getElementById('myphone-add-memo-modal')?.classList.remove('visible');
  document.getElementById('myphone-memo-title-input').value = '';
  document.getElementById('myphone-memo-content-input').value = '';
  showCustomAlert('æˆåŠŸ', 'å¤‡å¿˜å½•å·²æ·»åŠ ');
}

async function saveMyPhoneAmap() {
  const location = document.getElementById('myphone-amap-location-input')?.value?.trim();
  const address = document.getElementById('myphone-amap-address-input')?.value?.trim();
  const thought = document.getElementById('myphone-amap-thought-input')?.value?.trim();
  const timeInput = document.getElementById('myphone-amap-time-input')?.value?.trim();
  
  if (!location) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™åœ°ç‚¹');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneAmapHistory) {
    char.myPhoneAmapHistory = [];
  }
  
  const newLocation = {
    locationName: location,
    address: address || '',
    comment: thought || '',
    timeAgo: timeInput || 'åˆšåˆš',
    timestamp: Date.now()
  };
  
  char.myPhoneAmapHistory.unshift(newLocation);
  await db.chats.put(char);
  renderMyPhoneAmap();
  
  document.getElementById('myphone-add-amap-modal')?.classList.remove('visible');
  document.getElementById('myphone-amap-location-input').value = '';
  document.getElementById('myphone-amap-address-input').value = '';
  document.getElementById('myphone-amap-thought-input').value = '';
  document.getElementById('myphone-amap-time-input').value = '';
  showCustomAlert('æˆåŠŸ', 'è¶³è¿¹å·²æ·»åŠ ');
}

async function saveMyPhoneUsage() {
  const appName = document.getElementById('myphone-usage-app-input')?.value?.trim();
  const category = document.getElementById('myphone-usage-category-input')?.value?.trim();
  const iconUrl = document.getElementById('myphone-usage-icon-input')?.value?.trim();
  const duration = document.getElementById('myphone-usage-duration-input')?.value || '30';
  
  if (!appName) {
    showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™åº”ç”¨åç§°');
    return;
  }
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneAppUsage) {
    char.myPhoneAppUsage = [];
  }
  
  const newUsage = {
    appName: appName,
    category: category || 'å…¶ä»–',
    usageTimeMinutes: parseInt(duration),
    iconUrl: iconUrl || '',
    timestamp: Date.now()
  };
  
  char.myPhoneAppUsage.unshift(newUsage);
  await db.chats.put(char);
  renderMyPhoneAppUsage();
  
  document.getElementById('myphone-add-usage-modal')?.classList.remove('visible');
  document.getElementById('myphone-usage-app-input').value = '';
  document.getElementById('myphone-usage-category-input').value = '';
  document.getElementById('myphone-usage-icon-input').value = '';
  document.getElementById('myphone-usage-duration-input').value = '30';
  showCustomAlert('æˆåŠŸ', 'ä½¿ç”¨è®°å½•å·²æ·»åŠ ');
}

// æ¸²æŸ“ä¸€èµ·å¬æ­Œæ›²åˆ—è¡¨ä¾›é€‰æ‹©
function renderMyPhoneYiqitingSongList() {
  const listEl = document.getElementById('myphone-yiqiting-song-list');
  listEl.innerHTML = '';
  
  // ä»å…¨å±€ä¸€èµ·å¬æ’­æ”¾åˆ—è¡¨ä¸­è·å–æ­Œæ›²
  const yiqitingPlaylist = musicState.playlist || [];
  
  if (yiqitingPlaylist.length === 0) {
    listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 20px;">ä¸€èµ·å¬æ’­æ”¾åˆ—è¡¨ä¸ºç©º<br>è¯·å…ˆåœ¨ä¸»å±å¹•QQä¸€èµ·å¬ä¸­æ·»åŠ æ­Œæ›²</p>';
    return;
  }
  
  yiqitingPlaylist.forEach((song, index) => {
    const item = document.createElement('div');
    item.className = 'yiqiting-song-item';
    item.style.cssText = 'display: flex; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background 0.2s;';
    
    item.innerHTML = `
      <input type="checkbox" class="yiqiting-song-checkbox" data-index="${index}" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
      <div style="flex: 1;">
        <div style="font-weight: 500; color: var(--text-color);">${song.name || 'æœªçŸ¥æ­Œæ›²'}</div>
        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">${song.artist || 'æœªçŸ¥æ­Œæ‰‹'}</div>
      </div>
    `;
    
    // ç‚¹å‡»æ•´è¡Œä¹Ÿèƒ½åˆ‡æ¢å¤é€‰æ¡†
    item.addEventListener('click', (e) => {
      if (e.target.tagName !== 'INPUT') {
        const checkbox = item.querySelector('.yiqiting-song-checkbox');
        checkbox.checked = !checkbox.checked;
      }
    });
    
    // hoveræ•ˆæœ
    item.addEventListener('mouseenter', () => {
      item.style.background = 'var(--hover-bg)';
    });
    item.addEventListener('mouseleave', () => {
      item.style.background = 'transparent';
    });
    
    listEl.appendChild(item);
  });
}

// åˆ‡æ¢MYphoneéŸ³ä¹æ·»åŠ æ–¹å¼çš„è¾“å…¥æ¡†æ˜¾ç¤º
function toggleMyPhoneMusicInputs() {
  const source = document.getElementById('myphone-music-source-select')?.value;
  const fileGroup = document.getElementById('myphone-music-file-group');
  const urlGroup = document.getElementById('myphone-music-url-group');
  const yiqitingListGroup = document.getElementById('myphone-yiqiting-list-group');
  const manualInputs = document.getElementById('myphone-music-manual-inputs');
  
  if (source === 'yiqiting') {
    // ä»ä¸€èµ·å¬å¯¼å…¥ï¼šæ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼Œéšè—å…¶ä»–
    fileGroup.style.display = 'none';
    yiqitingListGroup.style.display = 'block';
    manualInputs.style.display = 'none';
    renderMyPhoneYiqitingSongList();
  } else if (source === 'local') {
    // æœ¬åœ°æ–‡ä»¶ï¼šæ˜¾ç¤ºæ–‡ä»¶é€‰æ‹©å’Œæ‰‹åŠ¨è¾“å…¥ï¼Œéšè—URL
    fileGroup.style.display = 'block';
    urlGroup.style.display = 'none';
    yiqitingListGroup.style.display = 'none';
    manualInputs.style.display = 'block';
  } else {
    // ç½‘ç»œURLï¼šæ˜¾ç¤ºURLè¾“å…¥å’Œæ‰‹åŠ¨è¾“å…¥
    fileGroup.style.display = 'none';
    urlGroup.style.display = 'block';
    yiqitingListGroup.style.display = 'none';
    manualInputs.style.display = 'block';
  }
}

async function saveMyPhoneMusic() {
  const source = document.getElementById('myphone-music-source-select')?.value;
  
  if (!activeMyPhoneCharacterId) {
    showCustomAlert('é”™è¯¯', 'æœªé€‰æ‹©è§’è‰²');
    return;
  }
  
  const char = state.chats[activeMyPhoneCharacterId];
  if (!char.myPhoneMusicPlaylist) {
    char.myPhoneMusicPlaylist = [];
  }
  
  // æ ¹æ®æ·»åŠ æ–¹å¼å¤„ç†
  if (source === 'yiqiting') {
    // ä»ä¸€èµ·å¬å¯¼å…¥é€‰ä¸­çš„æ­Œæ›²
    const checkboxes = document.querySelectorAll('.yiqiting-song-checkbox:checked');
    
    if (checkboxes.length === 0) {
      showCustomAlert('é”™è¯¯', 'è¯·è‡³å°‘é€‰æ‹©ä¸€é¦–æ­Œæ›²');
      return;
    }
    
    let importedCount = 0;
    checkboxes.forEach(checkbox => {
      const index = parseInt(checkbox.dataset.index);
      const originalSong = musicState.playlist[index];
      
      if (originalSong) {
        // æ·±æ‹·è´æ­Œæ›²å¯¹è±¡ï¼ˆé¿å…å¼•ç”¨é—®é¢˜ï¼‰
        const newSong = {
          name: originalSong.name,
          artist: originalSong.artist,
          src: originalSong.src,
          fileType: originalSong.fileType,
          isLocal: originalSong.isLocal,
          lrcContent: originalSong.lrcContent || "",
          cover: originalSong.cover || 'https://via.placeholder.com/300x300/cccccc/666666?text=Music'
        };
        
        char.myPhoneMusicPlaylist.unshift(newSong);
        importedCount++;
      }
    });
    
    await db.chats.put(char);
    renderMyPhoneMusicScreen();
    
    document.getElementById('myphone-add-music-modal')?.classList.remove('visible');
    // é‡ç½®å…¨é€‰å¤é€‰æ¡†
    document.getElementById('myphone-yiqiting-select-all').checked = false;
    showCustomAlert('æˆåŠŸ', `å·²å¯¼å…¥ ${importedCount} é¦–æ­Œæ›²`);
    
  } else if (source === 'local') {
    // æœ¬åœ°æ–‡ä»¶ä¸Šä¼ 
    const fileInput = document.getElementById('myphone-music-file-input');
    const file = fileInput?.files[0];
    const title = document.getElementById('myphone-music-title-input')?.value?.trim();
    const artist = document.getElementById('myphone-music-artist-input')?.value?.trim();
    
    if (!file) {
      showCustomAlert('é”™è¯¯', 'è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶');
      return;
    }
    
    if (!title) {
      showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™æ­Œæ›²æ ‡é¢˜');
      return;
    }
    
    let songSrc = null;
    let isLocal = true;
    
    try {
      const catboxUrl = await uploadFileToCatbox(file);
      
      if (catboxUrl) {
        songSrc = catboxUrl;
        isLocal = false;
        await showCustomAlert("ä¸Šä¼ æˆåŠŸ", `æ­Œæ›² "${file.name}" å·²æˆåŠŸä¸Šä¼ åˆ° Catboxï¼`);
      } else {
        console.log("Catbox æœªé…ç½®ï¼Œå°†æ­Œæ›²ä¿å­˜ä¸ºæœ¬åœ° ArrayBufferã€‚");
        songSrc = await file.arrayBuffer();
        isLocal = true;
      }
    } catch (uploadError) {
      console.error("Catbox ä¸Šä¼ å¤±è´¥:", uploadError);
      await showCustomAlert("ä¸Šä¼ å¤±è´¥", `ä¸Šä¼ åˆ° Catbox å¤±è´¥: ${uploadError.message}\n\nå°†æ”¹ä¸ºæœ¬åœ°ä¿å­˜ã€‚`);
      songSrc = await file.arrayBuffer();
      isLocal = true;
    }
    
    const newSong = {
      name: title,
      artist: artist || 'æœªçŸ¥æ­Œæ‰‹',
      src: songSrc,
      fileType: file.type,
      isLocal: isLocal,
      lrcContent: "",
      cover: 'https://via.placeholder.com/300x300/cccccc/666666?text=Music'
    };
    
    char.myPhoneMusicPlaylist.unshift(newSong);
    await db.chats.put(char);
    renderMyPhoneMusicScreen();
    
    document.getElementById('myphone-add-music-modal')?.classList.remove('visible');
    document.getElementById('myphone-music-title-input').value = '';
    document.getElementById('myphone-music-artist-input').value = '';
    document.getElementById('myphone-music-file-input').value = '';
    showCustomAlert('æˆåŠŸ', 'æ­Œæ›²å·²æ·»åŠ ');
    
  } else {
    // ç½‘ç»œURL
    const url = document.getElementById('myphone-music-url-input')?.value?.trim();
    const title = document.getElementById('myphone-music-title-input')?.value?.trim();
    const artist = document.getElementById('myphone-music-artist-input')?.value?.trim();
    
    if (!title || !url) {
      showCustomAlert('é”™è¯¯', 'è¯·å¡«å†™æ­Œæ›²æ ‡é¢˜å’Œé“¾æ¥');
      return;
    }
    
    const newSong = {
      name: title,
      artist: artist || 'æœªçŸ¥æ­Œæ‰‹',
      src: url,
      isLocal: false,
      lrcContent: "",
      cover: 'https://via.placeholder.com/300x300/cccccc/666666?text=Music'
    };
    
    char.myPhoneMusicPlaylist.unshift(newSong);
    await db.chats.put(char);
    renderMyPhoneMusicScreen();
    
    document.getElementById('myphone-add-music-modal')?.classList.remove('visible');
    document.getElementById('myphone-music-title-input').value = '';
    document.getElementById('myphone-music-artist-input').value = '';
    document.getElementById('myphone-music-url-input').value = '';
    showCustomAlert('æˆåŠŸ', 'æ­Œæ›²å·²æ·»åŠ ');
  }
}

let lockScreenState = {
      passwordBuffer: '',
      isLocked: false
  };

  function initLockScreen() {
      const lockScreen = document.getElementById('lock-screen');
      
      // åˆå§‹åŒ–æ£€æŸ¥ï¼šå¦‚æœå¯ç”¨äº†é”å±ï¼Œåˆ™ç«‹å³æ˜¾ç¤º
      if (state.globalSettings.lockScreenEnabled) {
          // è®¾ç½®å£çº¸
          if (state.globalSettings.lockScreenWallpaper) {
              lockScreen.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
          } else {
              lockScreen.style.backgroundImage = 'linear-gradient(135deg, #1c1c1e, #3a3a3c)'; // é»˜è®¤æ·±è‰²èƒŒæ™¯
          }
          
          lockScreenState.isLocked = true;
          lockScreen.classList.add('active');
          updateLockScreenClock();
          
          // å¯åŠ¨é”å±æ—¶é’Ÿæ›´æ–°
          setInterval(updateLockScreenClock, 1000);
      }
      
      // ç»‘å®šè®¾ç½®ç•Œé¢çš„äº‹ä»¶
      const lockToggle = document.getElementById('lock-screen-toggle');
      const lockDetail = document.getElementById('lock-screen-settings-detail');
      const passwordInput = document.getElementById('lock-screen-password-input');
      const wallpaperPreview = document.getElementById('lock-wallpaper-preview');

      // å›æ˜¾è®¾ç½®
      if (lockToggle) {
          lockToggle.checked = state.globalSettings.lockScreenEnabled || false;
          lockDetail.style.display = lockToggle.checked ? 'block' : 'none';
          
          lockToggle.addEventListener('change', (e) => {
              lockDetail.style.display = e.target.checked ? 'block' : 'none';
          });
      }
      
      if (passwordInput) {
          passwordInput.value = state.globalSettings.lockScreenPassword || '';
      }

      if (state.globalSettings.lockScreenWallpaper) {
          wallpaperPreview.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
          wallpaperPreview.textContent = '';
      }
  }

  function updateLockScreenClock() {
      if (!lockScreenState.isLocked) return;
      
      const now = new Date();
      const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
      const dateString = now.toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'long' });
      
      document.getElementById('lock-time').textContent = timeString;
      document.getElementById('lock-date').textContent = dateString;
  }

  function showPasswordInput() {
      const lockScreen = document.getElementById('lock-screen');
      const passwordArea = document.getElementById('lock-password-area');
      
      lockScreen.classList.add('input-mode');
      passwordArea.style.display = 'flex';
      lockScreenState.passwordBuffer = '';
      updateDots();
  }

  function hidePasswordInput() {
      const lockScreen = document.getElementById('lock-screen');
      const passwordArea = document.getElementById('lock-password-area');
      
      lockScreen.classList.remove('input-mode');
      passwordArea.style.display = 'none';
      lockScreenState.passwordBuffer = '';
  }

  function updateDots() {
      const dots = document.querySelectorAll('.lock-dots .dot');
      const len = lockScreenState.passwordBuffer.length;
      dots.forEach((dot, index) => {
          if (index < len) dot.classList.add('filled');
          else dot.classList.remove('filled');
      });
  }

  function handleKeypadInput(num) {
      const lockScreen = document.getElementById('lock-screen');
      const isMyPhoneMode = lockScreen.classList.contains('myphone-lock-mode');
      
      if (isMyPhoneMode) {
          if (myPhoneLockScreenState.passwordBuffer.length < 4) {
              myPhoneLockScreenState.passwordBuffer += num;
              updateMyPhoneLockDots();
              
              if (myPhoneLockScreenState.passwordBuffer.length === 4) {
                  setTimeout(checkMyPhoneLockPassword, 200);
              }
          }
      } else {
          if (lockScreenState.passwordBuffer.length < 4) {
              lockScreenState.passwordBuffer += num;
              updateDots();
              
              if (lockScreenState.passwordBuffer.length === 4) {
                  setTimeout(checkLockPassword, 200);
              }
          }
      }
  }

  function deleteKeypadInput() {
      const lockScreen = document.getElementById('lock-screen');
      const isMyPhoneMode = lockScreen.classList.contains('myphone-lock-mode');
      
      if (isMyPhoneMode) {
          if (myPhoneLockScreenState.passwordBuffer.length > 0) {
              myPhoneLockScreenState.passwordBuffer = myPhoneLockScreenState.passwordBuffer.slice(0, -1);
              updateMyPhoneLockDots();
          }
      } else {
          if (lockScreenState.passwordBuffer.length > 0) {
              lockScreenState.passwordBuffer = lockScreenState.passwordBuffer.slice(0, -1);
              updateDots();
          }
      }
  }

  function checkLockPassword() {
      const correctPassword = state.globalSettings.lockScreenPassword;
      
      if (lockScreenState.passwordBuffer === correctPassword) {
          // è§£é”æˆåŠŸ
          const lockScreen = document.getElementById('lock-screen');
          lockScreen.classList.add('unlocking');
          lockScreenState.isLocked = false;
          
          setTimeout(() => {
              lockScreen.classList.remove('active');
              lockScreen.classList.remove('unlocking');
              hidePasswordInput(); // é‡ç½®çŠ¶æ€ä»¥å¤‡ä¸‹æ¬¡é”å®š
          }, 500);
      } else {
          // è§£é”å¤±è´¥
          const dots = document.querySelector('.lock-dots');
          dots.classList.add('shake-animation');
          if(navigator.vibrate) navigator.vibrate(200); // éœ‡åŠ¨åé¦ˆ
          
          setTimeout(() => {
              dots.classList.remove('shake-animation');
              lockScreenState.passwordBuffer = '';
              updateDots();
          }, 400);
      }
  }

  const lockSwipeArea = document.getElementById('lock-swipe-area');
  const lockScreen = document.getElementById('lock-screen');

  // å°è£…è§£é”è§¦å‘é€»è¾‘
  function handleUnlockTrigger() {
      // å¦‚æœå·²ç»åœ¨è¾“å…¥å¯†ç æ¨¡å¼ï¼Œå°±ä¸é‡å¤è§¦å‘
      if (lockScreen.classList.contains('input-mode')) return;

      const isMyPhoneMode = lockScreen.classList.contains('myphone-lock-mode');
      
      if (isMyPhoneMode) {
          // MyPhoneé”å±æ¨¡å¼
          const characterId = myPhoneLockScreenState.pendingCharacterId;
          if (!characterId) return;
          
          const char = state.chats[characterId];
          if (!char) return;
          
          if (char.settings.myPhoneLockScreenPassword) {
              showMyPhonePasswordInput();
          } else {
              // å¦‚æœæ²¡æœ‰è®¾ç½®å¯†ç ï¼Œç›´æ¥è§£é”
              lockScreen.classList.add('unlocking');
              myPhoneLockScreenState.isLocked = false;
              setTimeout(() => {
                  lockScreen.classList.remove('active');
                  lockScreen.classList.remove('unlocking');
                  lockScreen.classList.remove('myphone-lock-mode');
                  enterMyPhone(characterId);
                  myPhoneLockScreenState.pendingCharacterId = null;
              }, 500);
          }
      } else {
          // ä¸»å±å¹•é”å±æ¨¡å¼
          if (state.globalSettings.lockScreenPassword) {
              showPasswordInput();
          } else {
              // å¦‚æœæ²¡æœ‰è®¾ç½®å¯†ç ï¼Œç›´æ¥æ»‘åŠ¨è§£é”
              lockScreen.classList.add('unlocking');
              lockScreenState.isLocked = false;
              setTimeout(() => {
                  lockScreen.classList.remove('active');
                  lockScreen.classList.remove('unlocking');
              }, 500);
          }
      }
  }

  // 1. ä¿ç•™ç‚¹å‡»åº•éƒ¨æ¨ªæ¡è§£é” (å…¼å®¹é¼ æ ‡ç‚¹å‡»)
  if (lockSwipeArea) {
      lockSwipeArea.addEventListener('click', handleUnlockTrigger);
  }

  // 2. æ–°å¢ï¼šå…¨å±ä¸Šæ»‘è§£é”ç›‘å¬
  if (lockScreen) {
      let touchStartY = 0;
      let touchEndY = 0;
      
      // è§¦æ‘¸å¼€å§‹
      lockScreen.addEventListener('touchstart', (e) => {
          // è®°å½•èµ·å§‹Yåæ ‡
          touchStartY = e.changedTouches[0].screenY;
      }, { passive: true }); // passive: true ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½

      // è§¦æ‘¸ç»“æŸ
      lockScreen.addEventListener('touchend', (e) => {
          // è®°å½•ç»“æŸYåæ ‡
          touchEndY = e.changedTouches[0].screenY;
          
          // è®¡ç®—æ»‘åŠ¨è·ç¦»
          const swipeDistance = touchStartY - touchEndY;
          
          // é˜ˆå€¼ï¼šå‘ä¸Šæ»‘åŠ¨è¶…è¿‡ 50px åˆ™è§¦å‘è§£é”
          if (swipeDistance > 50) {
              handleUnlockTrigger();
          }
      });
  }

  document.querySelectorAll('.lock-keypad .key').forEach(key => {
      key.addEventListener('click', (e) => {
          e.stopPropagation();
          const action = key.dataset.action;
          if (action === 'delete') {
              deleteKeypadInput();
          } else if (key.dataset.num) {
              handleKeypadInput(key.dataset.num);
          }
      });
  });

  const lockCancelBtn = document.querySelector('.lock-cancel-btn');
  if (lockCancelBtn) {
      lockCancelBtn.addEventListener('click', hidePasswordInput);
  }

  // é”å±å£çº¸ä¸Šä¼ å¤„ç†
  const lockWallpaperInput = document.getElementById('lock-wallpaper-input');
  if (lockWallpaperInput) {
      lockWallpaperInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (file) {
              const base64Url = await new Promise(resolve => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.readAsDataURL(file);
              });
              
              const preview = document.getElementById('lock-wallpaper-preview');
              preview.style.backgroundImage = `url(${base64Url})`;
              preview.textContent = '';
              
              // ä¸´æ—¶å­˜å‚¨åˆ° input çš„ dataset ä¸­ï¼Œä»¥ä¾¿ä¿å­˜æ—¶ä½¿ç”¨
              preview.dataset.tempUrl = base64Url;
              
              // å¦‚æœå¼€å¯äº† ImgBBï¼Œè‡ªåŠ¨ä¸Šä¼  (å¯é€‰é€»è¾‘ï¼Œå¤ç”¨ä¹‹å‰çš„)
               if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
                  (async () => {
                      try {
                           await showCustomAlert("è¯·ç¨å€™...", "æ­£åœ¨ä¸Šä¼ é”å±å£çº¸åˆ° ImgBB...");
                           const imageUrl = await uploadImageToImgBB(base64Url);
                           preview.dataset.tempUrl = imageUrl;
                           await showCustomAlert("æˆåŠŸ", "é”å±å£çº¸å·²ä¸Šä¼ ï¼");
                      } catch (e) {
                          console.error(e);
                      }
                  })();
               }
          }
          event.target.value = null;
      });
  }
  
  document.getElementById('upload-lock-wallpaper-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡", "è¯·è¾“å…¥é”å±å£çº¸çš„URL", "", "url");
      if (url && url.trim()) {
          const preview = document.getElementById('lock-wallpaper-preview');
          preview.style.backgroundImage = `url(${url})`;
          preview.textContent = '';
          preview.dataset.tempUrl = url;
      }
  });

// --- GitHub å¤‡ä»½åŠŸèƒ½æ¨¡å— (å¹¶å‘ä¼˜åŒ–ç‰ˆ) ---

// è§£å†³ä¸­æ–‡ Base64 ç¼–ç é—®é¢˜çš„è¾…åŠ©å‡½æ•°
function utf8_to_b64(str) {
    return window.btoa(unescape(encodeURIComponent(str)));
}

function b64_to_utf8(str) {
    return decodeURIComponent(escape(window.atob(str)));
}

async function uploadToGitHub(isSilent = false) {
    let loadingToast = null;
    // --- 1. åŸºç¡€é…ç½®æ£€æŸ¥ ---
    if (!state.apiConfig.githubEnable) {
        if (!isSilent) await showCustomAlert("æœªå¼€å¯", "è¯·å…ˆåœ¨â€œAPIè®¾ç½®â€ -> â€œGitHub äº‘å¤‡ä»½â€ä¸­å¼€å¯æ­¤åŠŸèƒ½ã€‚");
        return;
    }

    const username = state.apiConfig.githubUsername;
    const repo = state.apiConfig.githubRepo;
    const token = state.apiConfig.githubToken;
    const baseFilename = (state.apiConfig.githubFilename || 'ephone_backup').replace(/\.json$/i, '');

    if (!username || !repo || !token) {
        if (!isSilent) await showCustomAlert("é…ç½®ç¼ºå¤±", "è¯·å…ˆåœ¨è®¾ç½®ä¸­ä¿å­˜ GitHub ç”¨æˆ·åã€ä»“åº“åå’Œ Tokenï¼");
        return;
    }

    // --- 2. ç¡®è®¤æç¤º ---
    if (!isSilent) {
        const confirmed = await showCustomConfirm(
            'ç¡®è®¤ä¸Šä¼ å¤‡ä»½',
            `å³å°†å¤‡ä»½æ•°æ®åˆ° GitHub ä»“åº“ï¼š<br><strong>${username}/${repo}</strong><br><br>é‡‡ç”¨<strong style="color:green">æµå¼ä¸Šä¼ </strong> æ¨¡å¼ã€‚<br>é€Ÿåº¦å°†æ˜¾è‘—æå‡ã€‚<br>ç¡®å®šè¦ç«‹å³ä¸Šä¼ å—ï¼Ÿ`,
            { confirmText: 'å¼€å§‹æé€Ÿä¸Šä¼ ' }
        );
        if (!confirmed) return;
        await showCustomAlert("å‡†å¤‡ä¸­...", "æ­£åœ¨åˆå§‹åŒ–å¹¶å‘ä¸Šä¼ ...");
    } else {
        console.log("â³ [è‡ªåŠ¨å¤‡ä»½] å¼€å§‹åå°é™é»˜å¤‡ä»½åˆ° GitHub...");
       
        loadingToast = showToast('æ­£åœ¨äº‘ç«¯å¤‡ä»½...', 'loading');
    }

    try {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
        const folderPath = `backups/${dateStr}/`; 

        // ã€æ ¸å¿ƒè®¾ç½®ã€‘
        const RAW_SIZE_LIMIT = 15 * 1024 * 1024; 
        
        // 2. å¢å¤§æ•°æ®åº“è¯»å–æ‰¹æ¬¡ï¼šåŠ å¿«è¯»å–é€Ÿåº¦
        const DB_BATCH_SIZE = 50; 
        
        // 3. å¢åŠ å¹¶å‘æ•°ï¼šåŒæ—¶ä¸Šä¼  6 ä¸ªåˆ†ç‰‡ (GitHub API é€šå¸¸å…è®¸è¾ƒé«˜å¹¶å‘)
        const MAX_CONCURRENT_UPLOADS = 4;

        let currentSliceIndex = 1;
        let currentSliceData = {}; 
        let currentSliceRawSize = 0; 
        
        // å¹¶å‘æ§åˆ¶é˜Ÿåˆ—
        const activeUploads = new Set();
        const errors = []; // æ”¶é›†é”™è¯¯

        // --- å†…éƒ¨å‡½æ•°ï¼šæ‰§è¡Œå•ä¸ªåˆ†ç‰‡ä¸Šä¼  (ç‹¬ç«‹ä½œç”¨åŸŸ) ---
        const triggerUploadTask = async (partIndex, dataSnapshot) => {
            const partFilename = `${baseFilename}_part${partIndex}.json`;
            const finalPath = `${folderPath}${partFilename}`;
            
            // æ„é€ åˆ†ç‰‡å¯¹è±¡
            const fileContentObj = {
                version: 4,
                timestamp: Date.now(),
                type: 'slice',
                part: partIndex,
                data: dataSnapshot
            };

            const contentString = JSON.stringify(fileContentObj);
            const contentBase64 = utf8_to_b64(contentString);
            const uploadSizeMB = (contentBase64.length / 1024 / 1024).toFixed(2);
            
            if (!isSilent) {
                // æ›´æ–° UI æ˜¾ç¤ºå½“å‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡æ•°é‡
                const modalBody = document.getElementById('custom-modal-body');
                if (modalBody) {
                    modalBody.innerHTML = `<div class="spinner" style="margin: 20px auto;"></div>
                    <p style="text-align:center;">
                        æ­£åœ¨å¹¶å‘ä¸Šä¼ ä¸­...<br>
                        å½“å‰é˜Ÿåˆ—: <b>${activeUploads.size + 1}</b> / ${MAX_CONCURRENT_UPLOADS}<br>
                        æ­£åœ¨å¤„ç†åˆ†ç‰‡: #${partIndex} (${uploadSizeMB} MB)
                    </p>`;
                }
            } else {
                console.log(`[GitHub] å¼€å§‹ä¸Šä¼ åˆ†ç‰‡ #${partIndex}...`);
            }

            // API URL
            let apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${finalPath}`;
            if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
                const relativePath = apiUrl.replace("https://api.github.com", "");
                apiUrl = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
            }

            // --- æ­¥éª¤ A: è·å– SHA ---
            let sha = null;
            try {
                const checkUrl = `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}t=${Date.now()}`;
                const getRes = await fetch(checkUrl, {
                    method: 'GET',
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (getRes.ok) {
                    const fileData = await getRes.json();
                    sha = fileData.sha;
                }
            } catch (e) { console.warn(`åˆ†ç‰‡ #${partIndex} è·å–SHAå¤±è´¥(å¯èƒ½æ˜¯æ–°æ–‡ä»¶)ï¼Œç»§ç»­ä¸Šä¼ `, e); }

            // --- æ­¥éª¤ B: ä¸Šä¼  (å¸¦é‡è¯•) ---
            let retryCount = 0;
            const maxRetries = 3;
            let success = false;
            let lastError = null;

            while (!success && retryCount < maxRetries) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 180000); // 3åˆ†é’Ÿè¶…æ—¶

                try {
                    const putRes = await fetch(apiUrl, {
                        method: 'PUT',
                        headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: `Auto Backup: ${dateStr} (Part ${partIndex})`,
                            content: contentBase64,
                            sha: sha || undefined
                        }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!putRes.ok) {
                        const err = await putRes.json();
                        throw new Error(err.message || putRes.statusText);
                    }
                    
                    success = true;
                    console.log(`âœ… [GitHub] åˆ†ç‰‡ #${partIndex} ä¸Šä¼ æˆåŠŸ`);

                } catch (err) {
                    clearTimeout(timeoutId);
                    lastError = err;
                    retryCount++;
                    console.warn(`âš ï¸ åˆ†ç‰‡ #${partIndex} ç¬¬ ${retryCount} æ¬¡é‡è¯•...`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            if (!success) {
                throw new Error(`åˆ†ç‰‡ #${partIndex} æœ€ç»ˆå¤±è´¥: ${lastError.message}`);
            }
        };

        // --- 3. æµå¼éå†æ•°æ®åº“ ---
        const tablesToBackup = db.tables.map(t => t.name);

        for (const tableName of tablesToBackup) {
            const totalCount = await db.table(tableName).count();
            if (totalCount === 0) continue;

            let offset = 0;
            
            while (offset < totalCount) {
                const batch = await db.table(tableName).offset(offset).limit(DB_BATCH_SIZE).toArray();
                
                for (const record of batch) {
                    const recordStr = JSON.stringify(record);
                    const recordSize = recordStr.length + tableName.length + 5; 

                    // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡ç‰‡
                    if (currentSliceRawSize + recordSize > RAW_SIZE_LIMIT) {
                        
                        // --- æ ¸å¿ƒå¹¶å‘é€»è¾‘ ---
                        // 1. åˆ›å»ºå½“å‰æ•°æ®çš„å¿«ç…§ (æ·±æ‹·è´æˆ–ç›´æ¥å¼•ç”¨ï¼Œè¿™é‡Œç›´æ¥ç”¨å¼•ç”¨å› ä¸ºä¸‹é¢ä¼šé‡ç½®å˜é‡)
                        const dataSnapshot = currentSliceData; 
                        const indexSnapshot = currentSliceIndex;

                        // 2. åˆ›å»º Promise ä»»åŠ¡
                        const taskPromise = triggerUploadTask(indexSnapshot, dataSnapshot).catch(err => {
                            console.error(err);
                            errors.push(err.message);
                        });

                        // 3. åŠ å…¥é˜Ÿåˆ—
                        activeUploads.add(taskPromise);
                        // ä»»åŠ¡å®Œæˆåä»é˜Ÿåˆ—ç§»é™¤
                        taskPromise.finally(() => activeUploads.delete(taskPromise));

                        // 4. å¦‚æœé˜Ÿåˆ—æ»¡äº†ï¼Œç­‰å¾…æœ€æ—©çš„ä¸€ä¸ªå®Œæˆ (Promise.race)
                        if (activeUploads.size >= MAX_CONCURRENT_UPLOADS) {
                            await Promise.race(activeUploads);
                        }

                        // 5. å¦‚æœæœ‰é”™è¯¯ï¼Œç«‹å³åœæ­¢
                        if (errors.length > 0) break;

                        // 6. é‡ç½®å®¹å™¨
                        currentSliceData = {};
                        currentSliceRawSize = 0;
                        currentSliceIndex++;
                    }

                    if (!currentSliceData[tableName]) {
                        currentSliceData[tableName] = [];
                    }
                    currentSliceData[tableName].push(record);
                    currentSliceRawSize += recordSize;
                }
                
                if (errors.length > 0) break;
                offset += DB_BATCH_SIZE;
            }
            if (errors.length > 0) break;
        }

        // --- 4. å¤„ç†æœ€åä¸€ä¸ªåˆ†ç‰‡ ---
        if (currentSliceRawSize > 0 && errors.length === 0) {
            const taskPromise = triggerUploadTask(currentSliceIndex, currentSliceData).catch(err => {
                errors.push(err.message);
            });
            activeUploads.add(taskPromise);
        }

        // --- 5. ç­‰å¾…æ‰€æœ‰å‰©ä½™ä»»åŠ¡å®Œæˆ ---
        if (!isSilent) {
             const modalBody = document.getElementById('custom-modal-body');
             if (modalBody) modalBody.innerHTML += `<p style="color:blue">æ­£åœ¨ç­‰å¾…æœ€å ${activeUploads.size} ä¸ªåˆ†ç‰‡å®Œæˆ...</p>`;
        }
        
        await Promise.all(activeUploads);

        // --- 6. ç»“æœå¤„ç† ---
        if (errors.length > 0) {
            throw new Error(`ä¸Šä¼ è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:\n${errors.join('\n')}`);
        }

        if (!isSilent) {
            await showCustomAlert(
                "âœ… å¤‡ä»½æˆåŠŸ", 
                `å…¨é‡æ•°æ®å¹¶å‘ä¸Šä¼ å®Œæˆï¼<br>å…±ä¸Šä¼  ${currentSliceIndex} ä¸ªåˆ†ç‰‡ã€‚<br><strong>è·¯å¾„ï¼š</strong> ${folderPath}`
            );
        } else {
            console.log(`âœ… [è‡ªåŠ¨å¤‡ä»½] æˆåŠŸï¼`);
            if (loadingToast) {
                loadingToast.classList.remove('visible');
                setTimeout(() => loadingToast.remove(), 400);
            }
            showToast('äº‘ç«¯å¤‡ä»½å·²å®Œæˆ', 'success');
        }

    } catch (error) {
        console.error("GitHub ä¸Šä¼ å¤±è´¥:", error);
        let errorMsg = error.message;
        if (error.name === 'AbortError') errorMsg = "ä¸Šä¼ è¶…æ—¶ (ç½‘ç»œè¾ƒæ…¢æˆ–ä»£ç†ä¸ç¨³å®š)ã€‚";
        
        if (!isSilent) {
            await showCustomAlert("âŒ å¤‡ä»½å¤±è´¥", `ä¸Šä¼ ä¸­æ–­ï¼š\n${errorMsg}`);
        } else {
            // ã€ä¿®æ”¹ç‚¹ 4ã€‘: å¤±è´¥æ—¶æ˜¾ç¤ºè­¦å‘Šå›¾æ ‡ï¼Œä½†ä¸æ‰“æ–­ç”¨æˆ·
            if (loadingToast) {
                loadingToast.classList.remove('visible');
                setTimeout(() => loadingToast.remove(), 400);
            }
            showToast('å¤‡ä»½å¤±è´¥: ç½‘ç»œé”™è¯¯', 'error');
        }
    }
}
async function restoreFromGitHub() {
    if (!state.apiConfig.githubEnable) {
        alert("è¯·å…ˆå¼€å¯ GitHub äº‘å¤‡ä»½åŠŸèƒ½ã€‚");
        return;
    }

    const username = state.apiConfig.githubUsername;
    const repo = state.apiConfig.githubRepo;
    const token = state.apiConfig.githubToken;

    if (!username || !repo || !token) {
        alert("è¯·å…ˆä¿å­˜ GitHub é…ç½®ï¼");
        return;
    }

    const modalBody = document.getElementById('custom-modal-body');
    const confirmBtn = document.getElementById('custom-modal-confirm');
    const cancelBtn = document.getElementById('custom-modal-cancel');

    const showProgress = (text) => {
        const modal = document.getElementById('custom-modal-overlay');
        document.getElementById('custom-modal-title').textContent = "GitHub æ¢å¤";
        modalBody.innerHTML = `<div class="spinner" style="margin: 20px auto;"></div><p style="text-align:center;">${text}</p>`;
        confirmBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        modal.classList.add('visible');
    };

    // é€šç”¨ Fetch
    const ghFetch = async (path) => {
        let url = `https://api.github.com/repos/${username}/${repo}/contents/${path}`;
        if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
             const relativePath = url.replace("https://api.github.com", "");
             url = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
        }
        const res = await fetch(url, {
            headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!res.ok) {
            if (res.status === 404) return [];
            throw new Error(`GitHub API Error: ${res.status}`);
        }
        return await res.json();
    };

    try {
        showProgress("æ­£åœ¨æœç´¢å¤‡ä»½...");

        // 1. æµè§ˆå¤‡ä»½ç›®å½•
        let rootPath = "";
        const backupsDir = await ghFetch("backups");
        
        if (backupsDir.length > 0) {
            const dateFolders = backupsDir.filter(item => item.type === 'dir');
            if (dateFolders.length > 0) {
                document.getElementById('custom-modal-overlay').classList.remove('visible');
                dateFolders.sort((a, b) => b.name.localeCompare(a.name));
                const dateChoices = dateFolders.map(f => ({ text: `ğŸ“… ${f.name}`, value: f.path }));
                const selectedPath = await showChoiceModal('è¯·é€‰æ‹©å¤‡ä»½æ—¥æœŸ', dateChoices);
                if (!selectedPath) return;
                rootPath = selectedPath;
                showProgress(`æ­£åœ¨è¯»å– ${rootPath} ...`);
            }
        }

        // 2. è·å–æ–‡ä»¶åˆ—è¡¨
        const files = await ghFetch(rootPath);
        
        // 3. æ™ºèƒ½åˆ†ç»„
        const backupSets = new Map(); 
        files.forEach(file => {
            if (!file.name.endsWith('.json')) return;
            // åŒ¹é… _partX.json æ ¼å¼
            const partMatch = file.name.match(/^(.*)_part(\d+)\.json$/);
            if (partMatch) {
                const baseName = partMatch[1]; // ç»„å
                const partNum = parseInt(partMatch[2]);
                if (!backupSets.has(baseName)) {
                    backupSets.set(baseName, { type: 'multipart', display: baseName, parts: [] });
                }
                backupSets.get(baseName).parts.push({ num: partNum, name: file.name, path: file.path });
            } else {
                // æ—§ç‰ˆå•æ–‡ä»¶
                backupSets.set(file.name, { type: 'single', display: file.name, name: file.name, path: file.path });
            }
        });

        if (backupSets.size === 0) throw new Error("æœªæ‰¾åˆ°å¤‡ä»½æ–‡ä»¶ã€‚");

        document.getElementById('custom-modal-overlay').classList.remove('visible');
        const choices = [];
        backupSets.forEach((info, key) => {
            let text = info.display;
            if (info.type === 'multipart') text += ` (${info.parts.length} ä¸ªåˆ†ç‰‡)`;
            choices.push({ text: text, value: key });
        });

        const selectedKey = await showChoiceModal('è¯·é€‰æ‹©è¦æ¢å¤çš„æ¡£æ¡ˆ', choices);
        if (!selectedKey) return;

        const targetSet = backupSets.get(selectedKey);
        const confirmRestore = await showCustomConfirm('æœ€åç¡®è®¤', `å³å°†æ¢å¤æ•°æ®ã€‚æœ¬åœ°æ•°æ®å°†è¢«è¦†ç›–ã€‚ç¡®å®šå—ï¼Ÿ`, { confirmButtonClass: 'btn-danger', confirmText: 'æ¢å¤' });
        if (!confirmRestore) return;

        showProgress("æ­£åœ¨ä¸‹è½½å¹¶æ¢å¤æ•°æ®...");

        // 4. æ¸…ç©ºæ•°æ®åº“ (ä¸€æ¬¡æ€§æ¸…ç©ºï¼Œé¿å…åˆ†ç‰‡æ¢å¤æ—¶æ•°æ®å†²çª)
        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }
        });

        // 5. å®šä¹‰ä¸‹è½½å’Œå¤„ç†å•ä¸ªæ–‡ä»¶çš„é€»è¾‘
        const processFile = async (filePath) => {
             let url = `https://api.github.com/repos/${username}/${repo}/contents/${filePath}`;
             if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
                 const relativePath = url.replace("https://api.github.com", "");
                 url = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
             }
             const res = await fetch(url, {
                headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3.raw' }
            });
            if (!res.ok) throw new Error(`ä¸‹è½½å¤±è´¥: ${res.status}`);
            
            const text = await res.text();
            let json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                // å°è¯• Base64 è§£ç  (å…¼å®¹æ—§é€»è¾‘)
                const decoded = decodeURIComponent(escape(window.atob(text.replace(/\s/g, ''))));
                json = JSON.parse(decoded);
            }

            // æ ¸å¿ƒï¼šæ ¹æ®æ ¼å¼å†³å®šå¦‚ä½•å¯¼å…¥
            const dataPart = json.data || json; // å…¼å®¹ {version:.., data:{...}} å’Œ ç›´æ¥ {...}
            
            // å†™å…¥æ•°æ®åº“
            for (const tableName of Object.keys(dataPart)) {
                const records = dataPart[tableName];
                if (Array.isArray(records) && records.length > 0) {
                    await db.table(tableName).bulkPut(records);
                }
            }
        };

        // 6. æ‰§è¡Œæ¢å¤
        if (targetSet.type === 'multipart') {
            targetSet.parts.sort((a, b) => a.num - b.num);
            for (let i = 0; i < targetSet.parts.length; i++) {
                const part = targetSet.parts[i];
                modalBody.innerHTML = `<div class="spinner"></div><p style="text-align:center;">æ­£åœ¨å¤„ç†åˆ†ç‰‡ ${i+1}/${targetSet.parts.length}...</p>`;
                await processFile(part.path);
                // å¼ºåˆ¶åƒåœ¾å›æ”¶å»ºè®®ï¼ˆé€šè¿‡æ–­å¼€å¼•ç”¨ï¼‰
                await new Promise(r => setTimeout(r, 50)); 
            }
        } else {
            await processFile(targetSet.path);
        }

        // 7. æ¢å¤ API é…ç½® (é˜²æ­¢è¦†ç›–åä¸¢å¤± Key)
        try {
            const restoredApiConfig = await db.apiConfig.get('main');
            if (restoredApiConfig) {
                 if (restoredApiConfig.imgbbApiKey) localStorage.setItem('imgbb-api-key', restoredApiConfig.imgbbApiKey);
                 if (restoredApiConfig.imgbbEnable !== undefined) localStorage.setItem('imgbb-enabled', restoredApiConfig.imgbbEnable);
                 if (restoredApiConfig.minimaxApiKey) localStorage.setItem('minimax-api-key', restoredApiConfig.minimaxApiKey);
                 if (restoredApiConfig.minimaxGroupId) localStorage.setItem('minimax-group-id', restoredApiConfig.minimaxGroupId);
                 // æ¢å¤ GitHub é…ç½®ï¼Œå¦åˆ™ä¸‹æ¬¡æ— æ³•å¤‡ä»½
                 if (restoredApiConfig.githubToken) state.apiConfig.githubToken = restoredApiConfig.githubToken;
            }
        } catch(e) {}

        confirmBtn.style.display = ''; 
        await showCustomAlert("æ¢å¤æˆåŠŸ", "æ‰€æœ‰åˆ†ç‰‡å·²å¤„ç†å®Œæ¯•ï¼Œæ•°æ®å·²æ¢å¤ï¼ç‚¹å‡»ç¡®å®šåˆ·æ–°é¡µé¢ã€‚");
        setTimeout(() => window.location.reload(), 500);

    } catch (error) {
        console.error(error);
        confirmBtn.style.display = ''; 
        await showCustomAlert("æ¢å¤å¤±è´¥", error.message);
    }
}
   let backupIntervalId = null;

    // ä¿®æ”¹å‡½æ•°å®šä¹‰ï¼Œæ¥æ”¶ intervalMinutes å‚æ•°
    function startAutoBackupTimer(intervalMinutes) {
        if (backupIntervalId) clearInterval(backupIntervalId);
        
        // å¦‚æœæ²¡ä¼ å‚æ•°ï¼Œå°è¯•ä» storage è¯»å–ï¼Œæˆ–è€…é»˜è®¤ 30
        if (!intervalMinutes) {
            const saved = localStorage.getItem('github-backup-interval');
            intervalMinutes = saved ? parseInt(saved) : 30;
        }

        console.log(`âœ… è‡ªåŠ¨å¤‡ä»½å®šæ—¶å™¨å·²å¯åŠ¨ (æ¯ ${intervalMinutes} åˆ†é’Ÿ)`);

        backupIntervalId = setInterval(async () => {
            const isEnabled = localStorage.getItem('github-enabled') === 'true';
            const isAuto = localStorage.getItem('github-auto-backup') === 'true';
            
            if (isEnabled && isAuto) {
                console.log("â° è§¦å‘å®šæ—¶è‡ªåŠ¨å¤‡ä»½...");
                await uploadToGitHub(true); 
            }
        }, intervalMinutes * 60 * 1000); // è½¬æ¢ä¸ºæ¯«ç§’
    }

    // åˆå§‹åŒ–è°ƒç”¨ä¹Ÿè¦æ”¹ä¸€ä¸‹
    const savedGhEnabled = localStorage.getItem('github-enabled') === 'true';
    const savedGhAuto = localStorage.getItem('github-auto-backup') === 'true';
    
    if (savedGhEnabled && savedGhAuto) {
        startAutoBackupTimer(); // è¿™é‡Œå®ƒä¼šè‡ªåŠ¨å»è¯» localStorage
    }
    

    function stopAutoBackupTimer() {
        if (backupIntervalId) {
            clearInterval(backupIntervalId);
            backupIntervalId = null;
            console.log("ğŸ›‘ è‡ªåŠ¨å¤‡ä»½å®šæ—¶å™¨å·²åœæ­¢");
        }
    }

    
    
    // å°†è¿™ä¸¤ä¸ªå‡½æ•°æš´éœ²ç»™å…¨å±€ï¼Œä»¥ä¾¿ save æŒ‰é’®è°ƒç”¨ (è™½ç„¶åœ¨é—­åŒ…é‡Œï¼Œä½†å¯ä»¥ç›´æ¥åœ¨ä¸Šé¢çš„ save æŒ‰é’®é€»è¾‘é‡Œç”¨)
    window.startAutoBackupTimer = startAutoBackupTimer;
    window.stopAutoBackupTimer = stopAutoBackupTimer;
// --- Open-Meteo å¤©æ°”åŠŸèƒ½æ¨¡å— ---

// 1. WMO å¤©æ°”ä»£ç è½¬æ–‡å­—
function getWeatherDescription(code) {
    const codes = {
        0: "æ™´æœ— (Clear sky)",
        1: "å¤§éƒ¨æ™´æœ— (Mainly clear)", 2: "å¤šäº‘ (Partly cloudy)", 3: "é˜´å¤© (Overcast)",
        45: "æœ‰é›¾ (Fog)", 48: "ç»“éœœé›¾ (Depositing rime fog)",
        51: "è½»å¾®æ¯›æ¯›é›¨ (Drizzle: Light)", 53: "ä¸­åº¦æ¯›æ¯›é›¨ (Drizzle: Moderate)", 55: "å¤§æ¯›æ¯›é›¨ (Drizzle: Dense)",
        61: "å°é›¨ (Rain: Slight)", 63: "ä¸­é›¨ (Rain: Moderate)", 65: "å¤§é›¨ (Rain: Heavy)",
        71: "å°é›ª (Snow fall: Slight)", 73: "ä¸­é›ª (Snow fall: Moderate)", 75: "å¤§é›ª (Snow fall: Heavy)",
        80: "é˜µé›¨ (Rain showers)", 81: "ä¸­åº¦é˜µé›¨", 82: "æš´é›¨",
        95: "é›·é›¨ (Thunderstorm)", 96: "é›·é›¨ä¼´æœ‰å†°é›¹", 99: "é‡åº¦é›·é›¨ä¼´æœ‰å†°é›¹"
    };
    return codes[code] || "æœªçŸ¥å¤©æ°”";
}

// 2. æœç´¢çœŸå®åŸå¸‚ (Geocoding API)
async function searchCityGeo(cityName) {
    try {
        const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cityName)}&count=1&language=zh&format=json`);
        const data = await response.json();
        if (data.results && data.results.length > 0) {
            return data.results[0]; // è¿”å› {name, latitude, longitude, country...}
        }
        return null;
    } catch (e) {
        console.error("åŸå¸‚æœç´¢å¤±è´¥:", e);
        return null;
    }
}

// 3. è·å–å¤©æ°”æ•°æ®
async function fetchWeather(lat, lon) {
    if (!lat || !lon) return null;
    try {
        // è·å–å½“å‰å¤©æ°”ï¼šæ¸©åº¦ã€å¤©æ°”ä»£ç ã€ç™½å¤©/é»‘å¤œã€é£é€Ÿ
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,is_day,wind_speed_10m&timezone=auto`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.current) {
            const c = data.current;
            const desc = getWeatherDescription(c.weather_code);
            const dayState = c.is_day ? "ç™½å¤©" : "å¤œæ™š";
            return `æ°”æ¸© ${c.temperature_2m}Â°C, æ¹¿åº¦ ${c.relative_humidity_2m}%, ${desc}, ${dayState}, é£é€Ÿ ${c.wind_speed_10m}km/h`;
        }
        return null;
    } catch (e) {
        console.error("è·å–å¤©æ°”å¤±è´¥:", e);
        return null;
    }
}

// 4. ç”Ÿæˆ Prompt æ³¨å…¥æ–‡æœ¬
async function getWeatherContextForPrompt(chat) {
    const wSettings = chat.settings.weather || {};
    if (!wSettings.enabled) return "";

    let context = "\n# ã€å®æ—¶ç¯å¢ƒä¸å¤©æ°”åŒæ­¥ã€‘\n";
    let hasData = false;

    // è·å–ç”¨æˆ·å¤©æ°”
    if (wSettings.userLat && wSettings.userLon) {
        const userWeather = await fetchWeather(wSettings.userLat, wSettings.userLon);
        if (userWeather) {
            const locationName = wSettings.userVirtualCity || "æ‰€åœ¨åœ°";
            context += `- ç”¨æˆ·(${chat.settings.myNickname || 'æˆ‘'})å½“å‰åœ¨ã€${locationName}ã€‘: ${userWeather}ã€‚\n`;
            hasData = true;
        }
    }

    // è·å–è§’è‰²å¤©æ°”
    if (wSettings.charLat && wSettings.charLon) {
        const charWeather = await fetchWeather(wSettings.charLat, wSettings.charLon);
        if (charWeather) {
            const locationName = wSettings.charVirtualCity || "æ‰€åœ¨åœ°";
            context += `- ä½ (${chat.name})å½“å‰åœ¨ã€${locationName}ã€‘: ${charWeather}ã€‚\n`;
            hasData = true;
        }
    }

    if (!hasData) return "";

    context += "è¯·æ ¹æ®ä¸Šè¿°å¤©æ°”å’Œæ—¶é—´çŠ¶æ€ï¼ˆå¦‚æ˜¯å¦ä¸‹é›¨ã€æ˜¯ç™½å¤©è¿˜æ˜¯å¤œæ™šï¼‰æ¥è°ƒæ•´ä½ çš„æå†™æ°›å›´ã€è§’è‰²çš„è¡ŒåŠ¨ï¼ˆå¦‚æ’‘ä¼ã€é¿æš‘ã€æ·»è¡£ï¼‰ä»¥åŠå¯¹è¯å†…å®¹ã€‚";
    return context;
}
let userBalance = 0;
const BLACK_GOLD_THRESHOLD = 10000; // é»‘é‡‘ä¼šå‘˜é˜ˆå€¼ï¼š1ä¸‡

async function initUserWallet() {
    try {
        let wallet = await db.userWallet.get('main');

        // å¦‚æœæ²¡æœ‰é’±åŒ…ï¼Œæˆ–è€…ä½™é¢å˜æˆäº† NaN/null/undefinedï¼Œå¼ºåˆ¶ä¿®å¤
        if (!wallet || typeof wallet.balance !== 'number' || isNaN(wallet.balance)) {
            console.warn("æ£€æµ‹åˆ°é’±åŒ…æ•°æ®å¼‚å¸¸ (NaN æˆ– ä¸å­˜åœ¨)ï¼Œæ­£åœ¨é‡ç½®...");
            
            // å°è¯•ä¿ç•™æ—§çš„äº²å±å¡æ•°æ®ï¼Œåªé‡ç½®ä½™é¢
            const oldKinship = (wallet && wallet.kinshipCards) ? wallet.kinshipCards : [];
            
            wallet = { 
                id: 'main', 
                balance: 0, // å¼ºåˆ¶é‡ç½®ä¸º 0
                kinshipCards: oldKinship, 
                lastResetMonth: '' 
            };
            
            await db.userWallet.put(wallet);
            userBalance = 0;
        } else {
            // æ•°æ®æ­£å¸¸ï¼Œè¯»å–ä½™é¢
            userBalance = wallet.balance;
            
            // è¡¥å…¨å¯èƒ½ç¼ºå¤±çš„å­—æ®µ
            if (!wallet.kinshipCards) {
                wallet.kinshipCards = [];
                await db.userWallet.put(wallet);
            }
        }

        // æ¯æœˆè‡ªåŠ¨é‡ç½®äº²å±å¡é¢åº¦é€»è¾‘ (ä¿æŒä¸å˜)
        const now = new Date();
        const currentMonthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
        if (wallet.lastResetMonth !== currentMonthKey) {
            if (wallet.kinshipCards && wallet.kinshipCards.length > 0) {
                wallet.kinshipCards.forEach(card => { card.spent = 0; });
                await db.userWallet.put(wallet);
            }
            wallet.lastResetMonth = currentMonthKey;
            await db.userWallet.put(wallet);
        }

        console.log("ç”¨æˆ·é’±åŒ…åˆå§‹åŒ–å®Œæˆï¼Œå½“å‰ä½™é¢:", userBalance);
        
        // ç«‹å³æ›´æ–°ç•Œé¢ä¸Šçš„æ˜¾ç¤ºï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºçš„è¯ï¼‰
        const displayEl = document.getElementById('alipay-balance-display');
        if(displayEl) displayEl.textContent = userBalance.toFixed(2);

    } catch (e) {
        console.error("åˆå§‹åŒ–é’±åŒ…å¤±è´¥:", e);
        userBalance = 0;
    }
}


// --- æ ¸å¿ƒä¿®å¤ï¼šå¼ºåˆ¶æ•°å­—è¿ç®—ï¼Œé˜²æ­¢å­—ç¬¦ä¸²æ‹¼æ¥æˆ–NaN ---
async function processTransaction(amount, type, description) {
    // 1. å¼ºåˆ¶è½¬ä¸ºæ•°å­—ï¼Œé˜²æ­¢ "100" + 50 å˜æˆ "10050"
    let safeAmount = parseFloat(amount);
    if (isNaN(safeAmount) || safeAmount <= 0) {
        console.error("è®°è´¦å¤±è´¥ï¼šé‡‘é¢æ— æ•ˆ", amount);
        return false; 
    }

    try {
        // 2. è·å–é’±åŒ…ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆå§‹åŒ–
        let wallet = await db.userWallet.get('main');
        if (!wallet) {
            wallet = { id: 'main', balance: 0, kinshipCards: [] };
        }
        
        // ç¡®ä¿ä½™é¢æ˜¯æ•°å­—
        if (typeof wallet.balance !== 'number') wallet.balance = 0;

        // 3. æ‰§è¡ŒåŠ å‡
        if (type === 'expense') {
            if (wallet.balance < safeAmount) {
                await showCustomAlert("æ”¯ä»˜å¤±è´¥", `ä½™é¢ä¸è¶³ï¼å½“å‰: ${wallet.balance.toFixed(2)}`);
                return false;
            }
            wallet.balance -= safeAmount;
        } else if (type === 'income') {
            wallet.balance += safeAmount;
        }

        // 4. ä¿å­˜é’±åŒ…
        await db.userWallet.put(wallet);
        
        // åŒæ­¥å…¨å±€å˜é‡
        window.userBalance = wallet.balance;

        // 5. å†™å…¥è´¦å•æµæ°´ (UserTransactions)
        const transaction = {
            timestamp: Date.now(),
            type: type,
            amount: safeAmount,
            description: description || 'æœªçŸ¥äº¤æ˜“'
        };
        await db.userTransactions.add(transaction);

        console.log(`âœ… [é’±åŒ…] äº¤æ˜“æˆåŠŸ: ${type} Â¥${safeAmount.toFixed(2)}. æ–°ä½™é¢: ${wallet.balance.toFixed(2)}`);
        return true;

    } catch (e) {
        console.error("å†™å…¥é’±åŒ…æ•°æ®åº“å¤±è´¥:", e);
        alert("ç³»ç»Ÿé”™è¯¯ï¼šè´¦å•å†™å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚");
        return false;
    }
}

async function openAlipayScreen() {
    // ã€å…³é”®ä¿®å¤ã€‘æ¯æ¬¡æ‰“å¼€æ—¶ï¼Œå¼ºåˆ¶ä»æ•°æ®åº“é‡æ–°è¯»å–æœ€æ–°ä½™é¢
    // è¿™æ ·èƒ½ä¿è¯æ˜¾ç¤ºçš„ä¸æ˜¯ NaN
    await initUserWallet(); 
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    const balanceEl = document.getElementById('alipay-balance-display');
    if(balanceEl) {
        // åŒé‡ä¿é™©ï¼Œå¦‚æœæ˜¯ NaN å°±æ˜¾ç¤º 0.00
        const safeBalance = isNaN(userBalance) ? 0 : userBalance;
        balanceEl.textContent = safeBalance.toFixed(2);
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨é»‘é‡‘ä¸»é¢˜
    const alipayScreen = document.getElementById('alipay-screen');
    const statusTag = document.getElementById('alipay-status-tag');
    
    if (userBalance >= BLACK_GOLD_THRESHOLD) {
        alipayScreen.classList.add('theme-blackgold');
        if(statusTag) statusTag.textContent = 'é»‘é‡‘ä¼šå‘˜';
    } else {
        alipayScreen.classList.remove('theme-blackgold');
        if(statusTag) statusTag.textContent = 'æ ‡å‡†ä¼šå‘˜';
    }
    
    // æ¸²æŸ“äº²å±å¡åŒºåŸŸ (é€»è¾‘ä¿æŒä¸å˜)
    const oldWrapper = document.getElementById('alipay-kinship-section-wrapper');
    if (oldWrapper) oldWrapper.remove();
    const container = document.querySelector('.alipay-card-container');
    const wallet = await db.userWallet.get('main');
    const kinshipCards = wallet?.kinshipCards || [];

    const kinshipWrapper = document.createElement('div');
    kinshipWrapper.id = 'alipay-kinship-section-wrapper'; 
    kinshipWrapper.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding: 0 5px;">
            <span class="kinship-section-title">äº²å±å¡ / äº²å¯†ä»˜</span>
            <span id="add-kinship-btn" style="font-size:22px; color:#1677ff; cursor:pointer; line-height:1;">+</span>
        </div>
    `;
    const scrollContainer = document.createElement('div');
    scrollContainer.id = 'alipay-kinship-section';

    if (kinshipCards.length === 0) {
        scrollContainer.innerHTML = `
            <div class="kinship-empty-state" style="background:white; width:100%; border-radius:12px; padding:20px; text-align:center; color:#999; box-shadow:0 2px 8px rgba(0,0,0,0.03);">
                <p style="margin:0; font-size:13px;">æš‚æ— äº²å±å¡ï¼Œå¿«å»é‚€è¯·TAå§</p>
            </div>`;
    } else {
        kinshipCards.forEach(card => {
            const chat = state.chats[card.chatId];
            const providerName = chat ? chat.name : 'æœªçŸ¥è§’è‰²';
            const providerAvatar = chat ? (chat.settings.aiAvatar || defaultAvatar) : defaultAvatar;
            const remaining = card.limit - (card.spent || 0);
            
            const cardEl = document.createElement('div');
            cardEl.className = 'kinship-card-entry';
            cardEl.innerHTML = `
                <button class="alipay-unbind-btn" data-chat-id="${card.chatId}">è§£ç»‘</button>
                <div class="kinship-top">
                    <div class="kinship-provider">
                        <img src="${providerAvatar}">
                        <span>${providerName} (èµ )</span>
                    </div>
                    <span style="font-size:11px; opacity:0.8;">æ¶ˆè´¹å¯¹æ–¹å¯è§</span>
                </div>
                <div class="kinship-label">æœ¬æœˆå‰©ä½™é¢åº¦</div>
                <div class="kinship-limit">Â¥ ${remaining.toFixed(2)}</div>
            `;
            scrollContainer.appendChild(cardEl);
        });
    }

    kinshipWrapper.appendChild(scrollContainer);
    container.appendChild(kinshipWrapper);

    const addBtn = kinshipWrapper.querySelector('#add-kinship-btn');
    if(addBtn) addBtn.onclick = openKinshipSelector;
    
    // æ¸²æŸ“è´¦å•åˆ—è¡¨
    if (typeof initBillListUI === 'function') {
        await initBillListUI(); 
    }
    
    showScreen('alipay-screen');
}
async function renderTransactionList() {
    // æ£€æŸ¥å½“å‰æ˜¯å¦åœ¨æ”¯ä»˜å®é¡µé¢ï¼Œå¦‚æœåœ¨ï¼Œåˆ™åˆ·æ–°åˆ—è¡¨
    const alipayScreen = document.getElementById('alipay-screen');
    if (alipayScreen && alipayScreen.classList.contains('active')) {
        await loadBills(true);
    }
}
// --- æ–°ç‰ˆæ”¯ä»˜å®è´¦å•é€»è¾‘ ---

// åˆå§‹åŒ–/é‡ç½®è´¦å•åˆ—è¡¨ UI
async function initBillListUI() {
    const container = document.getElementById('alipay-transaction-list'); // æ³¨æ„ï¼šè¿™æ˜¯åŸæ¥çš„å®¹å™¨ID
    
    // é‡ç½®å®¹å™¨æ ·å¼ä»¥é€‚åº”æ–°å¸ƒå±€
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.height = '100%';
    container.style.overflow = 'hidden';
    container.innerHTML = '';

    // 1. æ¸²æŸ“ç­›é€‰å¤´éƒ¨
    const header = document.createElement('div');
    header.className = 'bill-filter-header';
    
    // è·å–å½“å‰æœˆä»½ä½œä¸ºé»˜è®¤å€¼ (æˆ–è€…ç•™ç©ºæ˜¾ç¤ºå…¨éƒ¨)
    // billState.filterDate = new Date().toISOString().slice(0, 7); 

    header.innerHTML = `
        <div class="bill-date-picker-wrapper">
            <input type="month" id="bill-date-input" class="bill-date-input" value="${billState.filterDate}">
        </div>
        <div class="bill-type-tabs">
            <span class="bill-type-tab active" data-type="all">å…¨éƒ¨</span>
            <span class="bill-type-tab" data-type="expense">æ”¯å‡º</span>
            <span class="bill-type-tab" data-type="income">æ”¶å…¥</span>
        </div>
    `;
    container.appendChild(header);

    // 2. æ¸²æŸ“æ»šåŠ¨åˆ—è¡¨å®¹å™¨
    const scrollList = document.createElement('div');
    scrollList.id = 'bill-scroll-list';
    container.appendChild(scrollList);

    // 3. æ¸²æŸ“åº•éƒ¨åŠ è½½æç¤º
    const loader = document.createElement('div');
    loader.id = 'bill-loader';
    loader.className = 'bill-loading-more hidden';
    loader.textContent = 'æ­£åœ¨åŠ è½½æ›´å¤š...';
    scrollList.appendChild(loader);

    // 4. ç»‘å®šäº‹ä»¶
    bindBillEvents();

    // 5. åˆå§‹åŠ è½½æ•°æ®
    await loadBills(true);
}

// ç»‘å®šç­›é€‰å’Œæ»šåŠ¨äº‹ä»¶
function bindBillEvents() {
    // æ—¥æœŸç­›é€‰
    const dateInput = document.getElementById('bill-date-input');
    dateInput.addEventListener('change', (e) => {
        billState.filterDate = e.target.value;
        loadBills(true); // é‡ç½®å¹¶é‡æ–°åŠ è½½
    });

    // ç±»å‹ç­›é€‰
    const tabs = document.querySelectorAll('.bill-type-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', (e) => {
            // UI åˆ‡æ¢
            tabs.forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            
            // é€»è¾‘åˆ‡æ¢
            billState.filterType = e.target.dataset.type;
            loadBills(true);
        });
    });

    // æ»šåŠ¨åŠ è½½ (Infinite Scroll)
    const scrollList = document.getElementById('bill-scroll-list');
    scrollList.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = scrollList;
        // è·ç¦»åº•éƒ¨ 50px æ—¶è§¦å‘åŠ è½½
        if (scrollHeight - scrollTop <= clientHeight + 50) {
            if (billState.hasMore && !billState.isLoading) {
                loadBills(false);
            }
        }
    });
}

// æ ¸å¿ƒï¼šåŠ è½½è´¦å•æ•°æ®
async function loadBills(isReset = false) {
    if (billState.isLoading) return;
    
    const scrollList = document.getElementById('bill-scroll-list');
    const loader = document.getElementById('bill-loader');
    
    billState.isLoading = true;
    loader.classList.remove('hidden');

    if (isReset) {
        billState.page = 0;
        billState.hasMore = true;
        // æ¸…ç©ºåˆ—è¡¨ï¼ˆä¿ç•™loaderï¼‰
        const items = scrollList.querySelectorAll('.bill-item, .bill-month-separator, .bill-empty-msg');
        items.forEach(el => el.remove());
        scrollList.scrollTop = 0;
    }

    try {
        // --- æ„å»º Dexie æŸ¥è¯¢ ---
        let collection = db.userTransactions.orderBy('timestamp').reverse();

        // 1. å†…å­˜è¿‡æ»¤ (å› ä¸º IndexedDB å¤æ‚æŸ¥è¯¢æ¯”è¾ƒéº»çƒ¦ï¼Œå–å‡ºæ¥å†ç­›æ€§èƒ½é€šå¸¸è¶³å¤Ÿ)
        // å¦‚æœæ•°æ®é‡æå¤§ï¼Œå»ºè®®å…ˆç”¨ compound indexï¼Œä½†è¿™é‡Œæˆ‘ä»¬å‡è®¾æ•°æ®é‡åœ¨ä¸‡çº§ä»¥å†…
        let allMatches = await collection.toArray();

        // 2. åº”ç”¨ç±»å‹è¿‡æ»¤
        if (billState.filterType !== 'all') {
            allMatches = allMatches.filter(t => t.type === billState.filterType);
        }

        // 3. åº”ç”¨æ—¥æœŸè¿‡æ»¤
        if (billState.filterDate) {
            const [year, month] = billState.filterDate.split('-');
            allMatches = allMatches.filter(t => {
                const d = new Date(t.timestamp);
                return d.getFullYear() === parseInt(year) && (d.getMonth() + 1) === parseInt(month);
            });
        }

        // 4. æ‰‹åŠ¨åˆ†é¡µ
        const start = billState.page * billState.pageSize;
        const end = start + billState.pageSize;
        const pageData = allMatches.slice(start, end);

        // æ›´æ–°çŠ¶æ€
        if (pageData.length < billState.pageSize) {
            billState.hasMore = false;
            loader.textContent = 'â€” æ²¡æœ‰æ›´å¤šè®°å½•äº† â€”';
            loader.classList.remove('hidden'); // ä¿æŒæ˜¾ç¤ºåº•çº¿
        } else {
            loader.textContent = 'åŠ è½½ä¸­...';
        }

        if (pageData.length === 0 && isReset) {
            scrollList.insertAdjacentHTML('afterbegin', 
                '<div class="bill-empty-msg" style="text-align:center; padding:40px; color:#999;">æš‚æ— ç›¸å…³è´¦å•</div>'
            );
        } else {
            renderBillItems(pageData, scrollList, loader);
        }

        billState.page++;

    } catch (error) {
        console.error("åŠ è½½è´¦å•å¤±è´¥:", error);
        loader.textContent = 'åŠ è½½å¤±è´¥';
    } finally {
        billState.isLoading = false;
        if (billState.hasMore) loader.classList.add('hidden'); // å¦‚æœè¿˜æœ‰æ›´å¤šï¼Œå…ˆéšè—loadingï¼Œç­‰æ»šåŠ¨å†æ˜¾ç¤º
    }
}

// æ¸²æŸ“åˆ—è¡¨é¡¹ (å¸¦æœˆä»½åˆ†ç»„) - ä¿®å¤ç‰ˆï¼šé˜²æ­¢ amount ä¸ºç©ºå¯¼è‡´å´©æºƒ
function renderBillItems(transactions, container, loaderEl) {
    let lastMonthStr = '';
    
    // å¦‚æœä¸æ˜¯ç¬¬ä¸€é¡µï¼Œå°è¯•è·å–åˆ—è¡¨ä¸­æœ€åä¸€ä¸ªæœˆä»½æ ‡é¢˜
    const existingSeparators = container.querySelectorAll('.bill-month-separator');
    if (existingSeparators.length > 0) {
        lastMonthStr = existingSeparators[existingSeparators.length - 1].textContent;
    }

    const fragment = document.createDocumentFragment();

    transactions.forEach(t => {
        // --- ã€æ ¸å¿ƒä¿®å¤å¼€å§‹ã€‘ ---
        // å¼ºåˆ¶å°†é‡‘é¢è½¬æ¢ä¸ºæ•°å­—ï¼Œå¦‚æœæ˜¯ undefined/null/NaNï¼Œåˆ™é»˜è®¤ä¸º 0
        let safeAmount = Number(t.amount);
        if (isNaN(safeAmount)) {
            console.warn("æ£€æµ‹åˆ°å¼‚å¸¸è´¦å•æ•°æ® (é‡‘é¢æ— æ•ˆ):", t);
            safeAmount = 0;
        }
        // --- ã€æ ¸å¿ƒä¿®å¤ç»“æŸã€‘ ---

        const date = new Date(t.timestamp);
        const monthStr = `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ`;
        
        // å¦‚æœæœˆä»½å˜åŒ–ï¼Œæ’å…¥åˆ†å‰²çº¿
        if (monthStr !== lastMonthStr) {
            const separator = document.createElement('div');
            separator.className = 'bill-month-separator';
            separator.textContent = monthStr;
            fragment.appendChild(separator);
            lastMonthStr = monthStr;
        }

        // æ¸²æŸ“å•æ¡è®°å½•
        const timeStr = `${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}`;
        const isIncome = t.type === 'income';
        const sign = isIncome ? '+' : '-';
        const colorClass = isIncome ? 'income' : 'expense';

        const item = document.createElement('div');
        item.className = 'bill-item';
        item.innerHTML = `
            <div class="bill-info">
                <div class="bill-title">${t.description || 'æœªçŸ¥äº¤æ˜“'}</div>
                <div class="bill-time">${timeStr}</div>
            </div>
            <div class="bill-amount ${colorClass}">${sign}${safeAmount.toFixed(2)}</div>
        `;
        fragment.appendChild(item);
    });

    // æ’å…¥åˆ° loader ä¹‹å‰
    container.insertBefore(fragment, loaderEl);
}

// 5. ç”¨æˆ·å……å€¼
async function handleUserTopUp() {
    const amountStr = await showCustomPrompt("å……å€¼", "è¯·è¾“å…¥å……å€¼é‡‘é¢ (CNY):", "", "number");
    if (!amountStr) return;
    
    const amount = parseFloat(amountStr);
    if (isNaN(amount) || amount <= 0) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢");
        return;
    }

    await processTransaction(amount, 'income', 'ä½™é¢å……å€¼');
    // åˆ·æ–°ç•Œé¢
    openAlipayScreen(); 
    await showCustomAlert("å……å€¼æˆåŠŸ", `æˆåŠŸå……å€¼ Â¥${amount.toFixed(2)}`);
}

// æš´éœ²ç»™ HTML è°ƒç”¨
window.openAlipayScreen = openAlipayScreen;
window.handleUserTopUp = handleUserTopUp;
// å˜é‡å­˜å‚¨å½“å‰é€‰ä¸­çš„è§’è‰²ID
let selectedKinshipCharId = null;

async function openKinshipSelector() {
    const characters = Object.values(state.chats).filter(c => !c.isGroup);
    if (characters.length === 0) return alert("æ²¡æœ‰å¯ç»‘å®šçš„è§’è‰²");

    const modal = document.getElementById('kinship-creation-modal');
    const listEl = document.getElementById('kinship-char-list');
    const limitInput = document.getElementById('kinship-limit-input');
    
    // --- æ–°å¢ï¼šè·å–æˆ–åˆ›å»ºç±»å‹é€‰æ‹©å®¹å™¨ ---
    let typeContainer = document.getElementById('kinship-type-container');
    if (!typeContainer) {
        // å¦‚æœHTMLé‡Œæ²¡æœ‰ï¼ŒåŠ¨æ€åˆ›å»ºä¸€ä¸ªæ’å…¥åˆ°é‡‘é¢è¾“å…¥æ¡†å‰é¢
        typeContainer = document.createElement('div');
        typeContainer.id = 'kinship-type-container';
        typeContainer.style.cssText = "margin-bottom: 15px; display: flex; gap: 10px; justify-content: center;";
        
        const inputGroup = limitInput.parentElement; // è·å–é‡‘é¢è¾“å…¥æ¡†çš„çˆ¶å®¹å™¨
        inputGroup.parentElement.insertBefore(typeContainer, inputGroup); // æ’åœ¨è¾“å…¥æ¡†å‰é¢
    }
    
    // æ¸²æŸ“ä¸¤ä¸ªé€‰é¡¹æŒ‰é’®
    typeContainer.innerHTML = `
        <label class="radio-btn-wrapper" style="flex:1;">
            <input type="radio" name="kinship-type" value="grant" checked>
            <div class="radio-btn-content" style="text-align:center; padding:10px; border:1px solid #ddd; border-radius:8px; cursor:pointer;">
                <div style="font-weight:bold; color:#ff5252;">æˆ‘é€TA</div>
                <div style="font-size:12px; color:#666;">(èŠ±æˆ‘çš„é’±)</div>
            </div>
        </label>
        <label class="radio-btn-wrapper" style="flex:1;">
            <input type="radio" name="kinship-type" value="request">
            <div class="radio-btn-content" style="text-align:center; padding:10px; border:1px solid #ddd; border-radius:8px; cursor:pointer;">
                <div style="font-weight:bold; color:#1677ff;">é—®TAè¦</div>
                <div style="font-size:12px; color:#666;">(èŠ±TAçš„é’±)</div>
            </div>
        </label>
    `;
    
    // æ·»åŠ ç®€å•çš„ç‚¹å‡»æ ·å¼åˆ‡æ¢é€»è¾‘
    const radios = typeContainer.querySelectorAll('input[name="kinship-type"]');
    const updateStyles = () => {
        radios.forEach(radio => {
            const content = radio.nextElementSibling;
            if (radio.checked) {
                content.style.borderColor = radio.value === 'grant' ? '#ff5252' : '#1677ff';
                content.style.backgroundColor = radio.value === 'grant' ? '#fff0f0' : '#f0f7ff';
            } else {
                content.style.borderColor = '#ddd';
                content.style.backgroundColor = '#fff';
            }
        });
    };
    radios.forEach(r => r.addEventListener('change', updateStyles));
    updateStyles(); // åˆå§‹åŒ–æ ·å¼

    // --- é‡ç½®çŠ¶æ€ ---
    listEl.innerHTML = '';
    selectedKinshipCharId = null;
    limitInput.value = ''; 

    // æ¸²æŸ“è§’è‰²åˆ—è¡¨
    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item'; 
        item.dataset.id = char.id;
        
        item.onclick = () => {
            listEl.querySelectorAll('.clear-posts-item').forEach(el => {
                el.classList.remove('selected');
                const cb = el.querySelector('.checkbox');
                if(cb) cb.classList.remove('selected');
            });
            
            item.classList.add('selected');
            const cb = item.querySelector('.checkbox');
            cb.classList.add('selected');
            
            selectedKinshipCharId = char.id;
        };

        const avatar = char.settings.aiAvatar || defaultAvatar;
        
        item.innerHTML = `
            <div class="checkbox" style="pointer-events: none;"></div>
            <img src="${avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; object-fit: cover;">
            <span class="name" style="font-weight: 500; font-size: 16px;">${char.name}</span>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}



// 2. å‘é€ç”³è¯·æ¶ˆæ¯ (æ”¯æŒåŒå‘)
// type: 'grant' (æˆ‘é€TA) | 'request' (é—®TAè¦)
async function sendKinshipRequest(chatId, limit, type = 'grant') {
    const chat = state.chats[chatId];
    const myNickname = chat.settings.myNickname || 'æˆ‘';

    // 1. æ„é€ ç”¨æˆ·æ¶ˆæ¯ (æ˜¾ç¤ºåœ¨èŠå¤©ç•Œé¢)
    let userContentText = "";
    if (type === 'grant') {
        userContentText = `[æˆ‘ä¸ºä½ å¼€é€šäº†â€œäº²å±å¡â€ï¼Œæ¯æœˆé¢åº¦ Â¥${limit}]`;
    } else {
        userContentText = `[æˆ‘å‘ä½ å‘èµ·äº†â€œäº²å±å¡â€ä»£ä»˜ç”³è¯·ï¼Œæ¯æœˆé¢åº¦ Â¥${limit}]`;
    }

    const userMsg = {
        role: 'user',
        type: 'kinship_request',
        content: userContentText,
        limit: limit,
        status: 'pending',
        requestType: type, // è®°å½•ç±»å‹ï¼Œæ–¹ä¾¿åç»­å¤„ç†
        timestamp: Date.now()
    };
    chat.history.push(userMsg);

    // 2. æ„é€ ç³»ç»Ÿæç¤º (ç»™ AI çœ‹çš„é€»è¾‘)
    let systemContentText = "";
    
    if (type === 'grant') {
        // --- æƒ…å†µ A: æˆ‘é€ AI (AI è¢«åŒ…å…») ---
        systemContentText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·(${myNickname})ä¸ºä½ å¼€é€šäº†æ”¯ä»˜å®â€œäº²å±å¡â€ï¼ˆäº²å¯†ä»˜ï¼‰ï¼Œæ¯æœˆé¢åº¦ Â¥${limit}ã€‚è¿™æ„å‘³ç€ä½ çš„æ¶ˆè´¹å°†ç”±ç”¨æˆ·ä¹°å•ã€‚è¯·æ ¹æ®ä½ ä»¬çš„å…³ç³»ï¼ˆæ˜¯å¦æ„¿æ„æ¥å—å¯¹æ–¹çš„é¦ˆèµ ï¼‰å†³å®šæ¥å—è¿˜æ˜¯æ‹’ç»ã€‚è¯·ä½¿ç”¨ 'kinship_response' æŒ‡ä»¤è¿›è¡Œå›åº”ã€‚]`;
    } else {
        // --- æƒ…å†µ B: æˆ‘é—® AI è¦ (æ±‚åŒ…å…») ---
        systemContentText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·(${myNickname})å‘ä½ ç”³è¯·å¼€é€šæ”¯ä»˜å®â€œäº²å±å¡â€ï¼ˆäº²å¯†ä»˜ï¼‰ï¼Œæ¯æœˆé¢åº¦ Â¥${limit}ã€‚è¿™æ„å‘³ç€ç”¨æˆ·çš„æ¶ˆè´¹å°†ç”±ä½ ä¹°å•ã€‚è¯·æ ¹æ®ä½ çš„ç»æµçŠ¶å†µå’Œå¯¹ç”¨æˆ·çš„å® çˆ±ç¨‹åº¦ï¼Œå†³å®šæ¥å—è¿˜æ˜¯æ‹’ç»ã€‚è¯·ä½¿ç”¨ 'kinship_response' æŒ‡ä»¤è¿›è¡Œå›åº”ã€‚]`;
    }

    const systemMsg = {
        role: 'system',
        content: systemContentText,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(systemMsg);

    await db.chats.put(chat);
    
    if(state.activeChatId === chatId) {
        appendMessage(userMsg, chat);
        // è§¦å‘ AI æ€è€ƒ
        triggerAiResponse();
    } else {
        openChat(chatId);
    }      
}



// ==========================================
// â–¼â–¼â–¼ åŸºé‡‘ç†è´¢æ¨¡å—å®Œæ•´é€»è¾‘ (ä¿®å¤æ•´åˆç‰ˆ) â–¼â–¼â–¼
// ==========================================

// 1. åˆå§‹åŒ–åŸºé‡‘æ•°æ®
async function initFunds() {
    const count = await db.funds.count();
    if (count === 0) {
        const initialFunds = [
            { id: 'f01', code: '001001', name: 'æ‹›è´¢è¿›å®æ··åˆ', riskLevel: 'medium', currentNav: 1.520, lastDayNav: 1.510, history: [] },
            { id: 'f02', code: '002088', name: 'ç§‘æŠ€å…ˆé”‹æˆé•¿', riskLevel: 'high', currentNav: 2.305, lastDayNav: 2.280, history: [] },
            { id: 'f03', code: '003099', name: 'ç¨³å¥å€ºåŸºA', riskLevel: 'low', currentNav: 1.050, lastDayNav: 1.049, history: [] },
            { id: 'f04', code: '005666', name: 'æ–°èƒ½æºç²¾é€‰', riskLevel: 'high', currentNav: 3.100, lastDayNav: 3.200, history: [] },
            { id: 'f05', code: '008888', name: 'æ¶ˆè´¹çº¢åˆ©æŒ‡æ•°', riskLevel: 'medium', currentNav: 1.880, lastDayNav: 1.885, history: [] },
            { id: 'f06', code: '110022', name: 'å…¨çƒåŒ»ç–—åŒ»è¯', riskLevel: 'high', currentNav: 0.950, lastDayNav: 0.940, history: [] }
        ];
        await db.funds.bulkAdd(initialFunds);
    }
    // è¡¥å…¨é’±åŒ…å­—æ®µ
    const wallet = await db.userWallet.get('main');
    if (wallet && !wallet.fundHoldings) {
        wallet.fundHoldings = [];
        await db.userWallet.put(wallet);
    }
}

// 2. å…¨å±€ä¸»é¢˜æ£€æŸ¥ (æ ¸å¿ƒï¼šä½™é¢å˜åŠ¨è‡ªåŠ¨åˆ‡æ¢é»‘é‡‘/è“è‰²)
function checkThemeStatus() {
    const threshold = 10000; // é»‘é‡‘é˜ˆå€¼
    const isGold = userBalance >= threshold;
    
    // åŒæ­¥ Alipay å’Œ Fund ä¸¤ä¸ªå±å¹•
    const screens = ['alipay-screen', 'fund-screen'];
    
    screens.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            if (isGold) {
                el.classList.add('theme-blackgold');
            } else {
                el.classList.remove('theme-blackgold');
            }
        }
    });

    // æ›´æ–°é¦–é¡µæ ‡ç­¾
    const statusTag = document.getElementById('alipay-status-tag');
    if (statusTag) {
        if (isGold) {
            statusTag.textContent = 'é»‘é‡‘ä¼šå‘˜';
            statusTag.style.color = '#d4af37';
            statusTag.style.borderColor = '#d4af37';
        } else {
            statusTag.textContent = 'æ ‡å‡†ä¼šå‘˜';
            statusTag.style.color = 'white';
            statusTag.style.borderColor = 'white';
        }
    }
    // æ›´æ–°é¦–é¡µä½™é¢
    const balanceDisplay = document.getElementById('alipay-balance-display');
    if (balanceDisplay) balanceDisplay.textContent = userBalance.toFixed(2);
}

// 3. æ¨¡æ‹Ÿå¸‚åœºæ³¢åŠ¨
// 3. æ¨¡æ‹Ÿå¸‚åœºæ³¢åŠ¨ (å‡çº§ç‰ˆï¼šè®°å½•å†å²èµ°åŠ¿)
async function simulateFundMarket() {
    const funds = await db.funds.toArray();
    const updates = [];
    
    // å¸‚åœºæ•´ä½“æƒ…ç»ª (-0.02 ~ +0.02)
    const marketSentiment = (Math.random() - 0.45) * 0.05; 

    for (const fund of funds) {
        // 1. è¡¥å…¨å†å²æ•°æ® (å¦‚æœæ˜¯æ–°åŸºé‡‘ï¼Œå…ˆä¼ªé€  15 ä¸ªå†å²ç‚¹ï¼Œè®©å›¾è¡¨æœ‰ä¸œè¥¿ç”»)
        if (!fund.history || fund.history.length === 0) {
            fund.history = [];
            let mockNav = fund.currentNav;
            for(let i=0; i<15; i++) {
                // å€’æ¨å†å²æ•°æ®
                mockNav = mockNav * (1 - (Math.random() - 0.5) * 0.02);
                fund.history.unshift(parseFloat(mockNav.toFixed(4)));
            }
        }

        // 2. è®¡ç®—ä»Šæ—¥æ³¢åŠ¨
        let volatility = 0.01; // ä½é£é™©æ³¢åŠ¨å°
        if (fund.riskLevel === 'medium') volatility = 0.03;
        if (fund.riskLevel === 'high') volatility = 0.06; // é«˜é£é™©æ³¢åŠ¨å¤§

        const individualChange = (Math.random() - 0.5) * volatility;
        const changePercent = marketSentiment + individualChange;
        
        // 3. è®°å½•æ—§å‡€å€¼åˆ°å†å² (ç”¨äºç”»å›¾)
        // ä¿æŒ history æœ€å¤šå­˜ 20 ä¸ªç‚¹ï¼Œé˜²æ­¢æ•°æ®åº“æ— é™è†¨èƒ€
        if (fund.history.length >= 20) fund.history.shift();
        fund.history.push(fund.currentNav);

        // 4. æ›´æ–°å½“å‰å‡€å€¼
        const oldNav = fund.currentNav;
        let newNav = oldNav * (1 + changePercent);
        if (newNav < 0.1) newNav = 0.1; // é˜²æ­¢è·Œæˆè´Ÿæ•°

        fund.lastDayNav = oldNav; // æ˜¨æ—¥å‡€å€¼
        fund.currentNav = parseFloat(newNav.toFixed(4)); // ä»Šæ—¥å‡€å€¼
        
        updates.push(fund);
    }
    await db.funds.bulkPut(updates);
}

// 4. æ‰“å¼€åŸºé‡‘é¡µé¢
async function openFundScreen() {
    // ç§»é™¤ Math.random åˆ¤æ–­ï¼Œæ¯æ¬¡æ‰“å¼€éƒ½æ¨¡æ‹Ÿä¸€æ¬¡æ³¢åŠ¨ï¼Œè¥é€ â€œå®æ—¶è¡Œæƒ…â€çš„æ„Ÿè§‰
    // æˆ–è€…ä¿ç•™ await simulateFundMarket(); 
    await simulateFundMarket(); 
    
    checkThemeStatus(); 
    await renderFundScreen();
    showScreen('fund-screen');
}

// 5. æ¸²æŸ“åŸºé‡‘ä¸»ç•Œé¢
let activeFundTab = 'market'; // é»˜è®¤é€‰ä¸­å¸‚åœº

async function renderFundScreen() {
    const funds = await db.funds.toArray();
    const wallet = await db.userWallet.get('main');
    const holdings = wallet.fundHoldings || [];
    
    let totalAssets = 0;
    let totalProfit = 0;
    let yesterdayProfit = 0;

    holdings.forEach(h => {
        const fund = funds.find(f => f.id === h.fundId);
        if (fund) {
            const marketValue = h.units * fund.currentNav;
            const costValue = h.units * h.cost;
            const yesterdayValue = h.units * fund.lastDayNav;
            
            totalAssets += marketValue;
            totalProfit += (marketValue - costValue);
            yesterdayProfit += (marketValue - yesterdayValue);
        }
    });

    document.getElementById('fund-total-assets').textContent = totalAssets.toFixed(2);
    
    const totalProfitEl = document.getElementById('fund-total-profit');
    totalProfitEl.textContent = (totalProfit >= 0 ? "+" : "") + totalProfit.toFixed(2);
    totalProfitEl.style.color = totalProfit >= 0 ? '#ff9c9c' : '#a0f0a0';

    const yesterdayProfitEl = document.getElementById('fund-yesterday-profit');
    yesterdayProfitEl.textContent = (yesterdayProfit >= 0 ? "+" : "") + yesterdayProfit.toFixed(2);
    
    // æ ¹æ®å½“å‰ Tab æ¸²æŸ“åˆ—è¡¨
    if (activeFundTab === 'market') {
        renderFundMarketList(funds);
    } else {
        renderFundMyList(funds, holdings);
    }
}
// --- è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆè¿·ä½ èµ°åŠ¿å›¾ SVG ---
function generateMiniChartSvg(dataPoints, isUp) {
    if (!dataPoints || dataPoints.length < 2) return '';

    const width = 60;  // å›¾è¡¨å®½
    const height = 20; // å›¾è¡¨é«˜
    const color = isUp ? '#ff3b30' : '#4cd964'; // çº¢æ¶¨ç»¿è·Œ
    
    // æ‰¾å‡ºæœ€å¤§æœ€å°å€¼ï¼Œç”¨äºå½’ä¸€åŒ–
    const min = Math.min(...dataPoints);
    const max = Math.max(...dataPoints);
    const range = max - min || 1; // é˜²æ­¢é™¤ä»¥0

    // ç”Ÿæˆè·¯å¾„ç‚¹
    // åæ ‡ç³»ï¼šXè½´å‡åŒ€åˆ†å¸ƒï¼ŒYè½´æ ¹æ®ä»·æ ¼è®¡ç®— (ä»·æ ¼è¶Šé«˜ï¼ŒYè¶Šå°/è¶Šé ä¸Š)
    const points = dataPoints.map((val, index) => {
        const x = (index / (dataPoints.length - 1)) * width;
        const y = height - ((val - min) / range) * height; 
        return `${x},${y}`;
    }).join(' ');

    // è¿”å› SVG å­—ç¬¦ä¸²
    return `
        <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="overflow:visible;">
            <polyline fill="none" stroke="${color}" stroke-width="2" points="${points}" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
}
// æ¸²æŸ“å¸‚åœºåˆ—è¡¨ (å¸¦èµ°åŠ¿å›¾ç‰ˆ)
function renderFundMarketList(funds) {
    const listEl = document.getElementById('fund-market-list');
    listEl.style.display = 'block';
    document.getElementById('fund-my-list').style.display = 'none';
    listEl.innerHTML = '';

    funds.forEach(fund => {
        const changeRate = ((fund.currentNav - fund.lastDayNav) / fund.lastDayNav) * 100;
        const isUp = changeRate >= 0;
        const colorClass = isUp ? 'fund-up' : 'fund-down';
        const sign = isUp ? '+' : '';
        
        // é£é™©æ ‡ç­¾
        let riskColorBg, riskColorText, riskText;
        if (fund.riskLevel === 'high') {
             riskColorBg = '#fff1f0'; riskColorText = '#ff4d4f'; riskText = 'é«˜é£é™©';
        } else if (fund.riskLevel === 'medium') {
             riskColorBg = '#fff7e6'; riskColorText = '#fa8c16'; riskText = 'ä¸­é£é™©';
        } else {
             riskColorBg = '#f6ffed'; riskColorText = '#52c41a'; riskText = 'ç¨³å¥';
        }
        
        const riskTag = `<span class="fund-tag" style="background:${riskColorBg}; color:${riskColorText};">${riskText}</span>`;

        // â–¼â–¼â–¼ ç”Ÿæˆèµ°åŠ¿å›¾ â–¼â–¼â–¼
        // æŠŠå†å²æ•°æ®å’Œå½“å‰æ•°æ®åˆå¹¶èµ·æ¥ç”»å›¾
        const chartData = [...(fund.history || []), fund.currentNav];
        const chartSvg = generateMiniChartSvg(chartData, isUp);

        const item = document.createElement('div');
        item.className = 'fund-item';
        item.onclick = () => openFundTradeModal('buy', fund); 

        // é‡æ–°å¸ƒå±€ï¼šå·¦è¾¹ä¿¡æ¯ï¼Œä¸­é—´å›¾è¡¨ï¼Œå³è¾¹æ•°æ®
        item.innerHTML = `
            <div class="fund-info" style="flex: 1.2;">
                <h4 style="margin-bottom:6px; font-size:15px;">${fund.name}</h4>
                <div class="fund-tags">
                    <span class="fund-tag" style="background:#f5f5f5; color:#999;">${fund.code}</span>
                    ${riskTag}
                </div>
            </div>
            
            <div class="fund-chart" style="flex: 1; display:flex; justify-content:center; align-items:center; opacity:0.8;">
                ${chartSvg}
            </div>

            <div class="fund-data" style="flex: 1; text-align:right;">
                <div class="fund-change ${colorClass}" style="font-size:18px; font-weight:bold;">${sign}${changeRate.toFixed(2)}%</div>
                <div class="fund-nav" style="font-size:11px; color:#999; margin-top:4px;">å‡€å€¼ ${fund.currentNav.toFixed(4)}</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

// æ¸²æŸ“æŒä»“åˆ—è¡¨
function renderFundMyList(funds, holdings) {
    const listEl = document.getElementById('fund-my-list');
    listEl.style.display = 'block';
    document.getElementById('fund-market-list').style.display = 'none';
    listEl.innerHTML = '';

    if (holdings.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— æŒä»“</div>';
        return;
    }

    holdings.forEach(h => {
        const fund = funds.find(f => f.id === h.fundId);
        if (!fund) return;
        
        const marketValue = h.units * fund.currentNav;
        const costValue = h.units * h.cost;
        const profit = marketValue - costValue;
        const profitRate = (profit / costValue) * 100;
        
        const isUp = profit >= 0;
        const colorClass = isUp ? 'fund-up' : 'fund-down';
        const sign = isUp ? '+' : '';

        const item = document.createElement('div');
        item.className = 'fund-item';
        item.onclick = () => openFundTradeModal('sell', fund, h); // ç‚¹å‡»å–å‡º
        item.innerHTML = `
            <div class="fund-info">
                <h4>${fund.name}</h4>
                <div style="font-size:12px; color:#666;">æŒæœ‰ ${h.units.toFixed(2)} ä»½</div>
            </div>
            <div class="fund-data">
                <div class="fund-change ${colorClass}">${sign}${profit.toFixed(2)}</div>
                <div class="fund-nav" style="font-size:11px;">${sign}${profitRate.toFixed(2)}%</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

// åˆ‡æ¢ Tab
function switchFundTab(tab) {
    activeFundTab = tab;
    // æ›´æ–° CSS ç±»
    document.querySelectorAll('.frame-tab').forEach(el => el.classList.remove('active'));
    document.getElementById(`tab-fund-${tab}`).classList.add('active');
    renderFundScreen();
}

// 6. äº¤æ˜“ç›¸å…³
let currentTradeContext = null;

async function openFundTradeModal(type, fund, holding = null) {
    currentTradeContext = { type, fund, holding };
    const modal = document.getElementById('fund-trade-modal');
    
    // è·å–ä½™é¢
    const wallet = await db.userWallet.get('main');
    const balance = wallet.balance || 0;

    document.getElementById('fund-trade-name').textContent = fund.name;
    document.getElementById('fund-trade-code').textContent = fund.code;
    document.getElementById('fund-trade-nav').textContent = fund.currentNav.toFixed(4);
    
    const changeRate = ((fund.currentNav - fund.lastDayNav) / fund.lastDayNav) * 100;
    const changeEl = document.getElementById('fund-trade-change');
    changeEl.textContent = (changeRate >= 0 ? "+" : "") + changeRate.toFixed(2) + "%";
    changeEl.className = changeRate >= 0 ? 'fund-up' : 'fund-down';

    const inputEl = document.getElementById('fund-trade-amount');
    inputEl.value = '';
    const confirmBtn = document.getElementById('fund-confirm-btn');
    const titleEl = document.getElementById('fund-trade-title');
    const labelEl = document.getElementById('fund-trade-label');
    const infoEl = document.getElementById('fund-trade-info');

    if (type === 'buy') {
        titleEl.textContent = 'ä¹°å…¥åŸºé‡‘';
        labelEl.innerHTML = `ä¹°å…¥é‡‘é¢ (ä½™é¢: Â¥<span id="fund-wallet-balance">${balance.toFixed(2)}</span>)`;
        infoEl.textContent = "è´¹ç‡ 0.00%";
        confirmBtn.textContent = "ç¡®è®¤ä¹°å…¥";
        confirmBtn.style.backgroundColor = "#1677ff";
        currentTradeContext.maxAmount = balance;
    } else {
        titleEl.textContent = 'å–å‡ºåŸºé‡‘';
        const holdingVal = holding.units * fund.currentNav;
        labelEl.innerHTML = `å–å‡ºé‡‘é¢ (æŒæœ‰: Â¥<span id="fund-wallet-balance">${holdingVal.toFixed(2)}</span>)`;
        infoEl.textContent = `æŒæœ‰ä»½é¢: ${holding.units.toFixed(2)} ä»½`;
        confirmBtn.textContent = "ç¡®è®¤å–å‡º";
        confirmBtn.style.backgroundColor = "#ff9800";
        currentTradeContext.maxAmount = holdingVal;
    }

    modal.classList.add('visible');
}

// ç¡®è®¤äº¤æ˜“ (ç»‘å®šåœ¨HTML onclick)
window.handleFundTradeConfirm = async function() {
    if (!currentTradeContext) return;
    const amount = parseFloat(document.getElementById('fund-trade-amount').value);
    
    if (isNaN(amount) || amount <= 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert("æç¤º", "è¯·è¾“å…¥æœ‰æ•ˆé‡‘é¢");
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }
    if (amount > currentTradeContext.maxAmount) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert("å¤±è´¥", "ä½™é¢æˆ–ä»½é¢ä¸è¶³");
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    const { type, fund } = currentTradeContext;
    const wallet = await db.userWallet.get('main');
    let holdings = wallet.fundHoldings || [];

    if (type === 'buy') {
        const success = await processTransaction(amount, 'expense', `åŸºé‡‘ä¹°å…¥-${fund.name}`);
        if (!success) return;

        const existing = holdings.find(h => h.fundId === fund.id);
        const newUnits = amount / fund.currentNav;
        
        if (existing) {
            const totalCost = (existing.units * existing.cost) + amount;
            existing.units += newUnits;
            existing.cost = totalCost / existing.units;
        } else {
            holdings.push({ fundId: fund.id, units: newUnits, cost: fund.currentNav });
        }
        await showCustomAlert("æˆåŠŸ", "ä¹°å…¥æˆåŠŸï¼");
    } else {
        const idx = holdings.findIndex(h => h.fundId === fund.id);
        if (idx === -1) return;
        
        const unitsToSell = amount / fund.currentNav;
        holdings[idx].units -= unitsToSell;
        if (holdings[idx].units < 0.01) holdings.splice(idx, 1);

        await processTransaction(amount, 'income', `åŸºé‡‘å–å‡º-${fund.name}`);
        await showCustomAlert("æˆåŠŸ", "å–å‡ºæˆåŠŸï¼");
    }

    wallet.fundHoldings = holdings;
    await db.userWallet.put(wallet);

    // äº¤æ˜“åç«‹å³æ£€æŸ¥ä¸»é¢˜
    checkThemeStatus();

    document.getElementById('fund-trade-modal').classList.remove('visible');
    renderFundScreen();
};

// æš´éœ²ç»™å…¨å±€
window.openFundScreen = openFundScreen;
window.switchFundTab = switchFundTab; // è¿™æ¬¡è¡¥ä¸Šäº†ï¼
window.refreshFundMarket = async () => {
    await showCustomAlert("åˆ·æ–°ä¸­", "æ­£åœ¨æ›´æ–°è¡Œæƒ…...");
    await simulateFundMarket();
    await renderFundScreen();
};
let auctionState = {
    isActive: false,
    item: null,
    currentPrice: 0,
    timer: 30,
    timerId: null,
    npcIntervalId: null,
    lastBidder: null, // { name: string, type: 'user'|'npc'|'char', id: string }
    bidHistory: []
};

// 1. æ‰“å¼€æ‹å–è¡Œ
async function openAuctionScreen() {
    showScreen('auction-screen');
    // å¦‚æœå½“å‰æ²¡æœ‰æ´»åŠ¨æ‹å–ï¼Œæˆ–è€…æ‹å–å·²ç»“æŸï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„é¢„è§ˆ
    if (!auctionState.isActive) {
        document.getElementById('auction-item-img').style.display = 'none';
        document.getElementById('auction-loading').style.display = 'block';
        document.getElementById('auction-item-name').textContent = "æ­£åœ¨æœå¯»é»‘å¸‚...";
        document.getElementById('auction-item-desc').textContent = "";
        
        // è‡ªåŠ¨å¼€å§‹ç”Ÿæˆ
        generateNewAuctionItem();
    }
}


async function generateNewAuctionItem() {
    const btn = document.querySelector('#auction-screen .action-btn');
    btn.style.pointerEvents = 'none';
    btn.textContent = 'è¿›è´§ä¸­...';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey) {
        alert("è¯·å…ˆé…ç½®APIï¼");
        btn.style.pointerEvents = 'auto';
        btn.textContent = 'æ–°æ‹å“';
        return;
    }

    // --- 1. æ™ºèƒ½è®¾å®šåˆ¤å®šé€»è¾‘ ---
    let auctionContext = "";
    
    // å°è¯•å¯»æ‰¾åŒ…å« "é»‘å¸‚" æˆ– "æ‹å–" çš„ä¸–ç•Œä¹¦
    const auctionBook = state.worldBooks.find(wb => wb.name.includes('é»‘å¸‚') || wb.name.includes('æ‹å–'));

    if (auctionBook) {
        console.log("âœ… æ‰¾åˆ°ä¸“å±æ‹å–è®¾å®šä¹¦:", auctionBook.name);
        const contentPreview = auctionBook.content
            .filter(e => e.enabled !== false)
            .map(e => e.content).join('; ');
        // å¦‚æœæœ‰ä¸–ç•Œä¹¦ï¼Œå¼ºåˆ¶ AI éµå®ˆä¸–ç•Œä¹¦
        auctionContext = `
    ã€å½“å‰æ‹å–è¡Œç‰¹æ®Šä¸–ç•Œè§‚ (æœ€é«˜ä¼˜å…ˆçº§)ã€‘: 
    ${contentPreview}
    
    (è¯·æ ¹æ®ä¸Šè¿°ç‰¹æ®Šä¸–ç•Œè§‚ç”Ÿæˆç¬¦åˆè®¾å®šçš„æ‹å“å’ŒNPCï¼Œå¿½ç•¥ç°å®ä¸–ç•Œçš„é™åˆ¶)
    `;
    } else {
        console.log("â„¹ï¸ æœªæ‰¾åˆ°ä¸“å±è®¾å®šï¼Œä½¿ç”¨é»˜è®¤è±ªå¥¢è®¾å®š");
        auctionContext = `
    ã€é»˜è®¤æ‹å“ç±»åˆ«æ¸…å•ã€‘:
    1. é¡¶çº§ç å®ï¼šç¨€æœ‰é’»çŸ³é¡¹é“¾ã€çº¢è“å®çŸ³æˆ’æŒ‡ã€çš‡å† ã€æ‰‹é•¯ï¼ˆé€‚åˆé€ç»™æ‹äººï¼‰ã€‚
    2. ä¼ ä¸–å¤è‘£ï¼šæ˜æ¸…ç“·å™¨ã€æ¬§æ´²ä¸­ä¸–çºªå¤ç‰©ã€ç»ç‰ˆåè¡¨ã€ç‰çºã€‚
    3. è‰ºæœ¯çå“ï¼šä¸–ç•Œåç”»ï¼ˆè™šæ„çš„çœŸè¿¹ï¼‰ã€è‘—åé›•å¡‘ã€‚
    4. å¥¢åèµ„äº§ï¼šæµ·å²›å¥‘çº¦ã€ç§äººé£æœºã€é¡¶çº§è±ªè½¦ã€åº„å›­é’¥åŒ™ã€‚
    5. æ¸¸æˆæŠ½å¡ï¼šçç¨€æ¸¸æˆé“å…·ã€ç»ç‰ˆçš®è‚¤è´¦å·ã€‚
    
    (è¯·ä»…ä»ä¸Šè¿° 5 ä¸ªç±»åˆ«ä¸­é€‰æ‹©ä¸€ç§ç”Ÿæˆ)
    `;
    }

    // 2. è·å–è§’è‰²åˆ—è¡¨ (ç”¨äº AI é¢„åˆ¤è°ä¼šä¹°)
    const charList = Object.values(state.chats).filter(c => !c.isGroup).map(c => {
        return `${c.name}(${c.settings.aiPersona.substring(0, 50)}...)`;
    }).join('\n');

    const systemPrompt = `
    ä½ æ˜¯ä¸€ä½é¡¶çº§æ‹å–è¡Œçš„é¦–å¸­æ‹å–å®˜ã€‚
    
    # æ ¸å¿ƒä»»åŠ¡
    è¯·æ ¹æ®ä¸‹é¢çš„ã€è®¾å®šæ¥æºã€‘ï¼Œå®Œæˆä¸¤ä¸ªä»»åŠ¡ï¼š
    1. ç”Ÿæˆä¸€ä»¶æå…·ä»·å€¼çš„æ‹å“ã€‚
    2. ç”Ÿæˆä¸€æ‰¹ç¬¦åˆè¯¥ä¸–ç•Œè§‚èƒŒæ™¯çš„â€œè·¯äººNPCç«æ‹è€…â€ã€‚
    
    ${auctionContext}
    
    # ä»»åŠ¡ Bï¼šä¹°å®¶æ„å‘åˆ†æ
    ä¸‹é¢æ˜¯ä»Šå¤©çš„å—é‚€å®¾å®¢åå•ï¼ˆç”¨æˆ·çš„é‡è¦è§’è‰²ï¼‰ï¼š
    ${charList}
    è¯·åˆ†æè¿™ä»¶æ‹å“å¯¹å“ªäº›å®¾å®¢æœ‰å¸å¼•åŠ›ï¼Ÿ
    
    # å›å¤æ ¼å¼é“å¾‹
    å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼š
    {
        "item": {
            "name": "ç‰©å“åç§° (ä¸­æ–‡ï¼Œåå­—è¦éœ¸æ°”æˆ–ä¼˜é›…)",
            "description": "ä¸€æ®µç²¾å½©çš„æè¿°ï¼Œå¼ºè°ƒå…¶ç¨€æœ‰åº¦ã€å†å²ä»·å€¼æˆ–ç‰¹æ®ŠåŠŸèƒ½ï¼ˆ50å­—ä»¥å†…ï¼Œä¸­æ–‡ï¼‰",
            "basePrice": åˆå§‹ä»·æ ¼(æ•°å­—, å»ºè®® 10000 ä»¥ä¸Š),
            "image_prompt": "ç‰©å“çš„è‹±æ–‡è§†è§‰æè¿°, high quality, cinematic lighting, detailed, clean background"
        },
        "interested_bidders": ["å®¾å®¢Açš„åå­—", "å®¾å®¢Bçš„åå­—"],
        "world_npcs": ["NPCåå­—1", "NPCåå­—2", "NPCåå­—3", "NPCåå­—4", "NPCåå­—5"]
    }
    
    æ³¨æ„ï¼š
    1. image_prompt å¿…é¡»å…¨æ˜¯è‹±æ–‡å•è¯ã€‚
    2. interested_bidders æ•°ç»„é‡Œåªèƒ½å¡«ä¸Šé¢â€œå—é‚€å®¾å®¢åå•â€é‡Œå‡ºç°è¿‡çš„åå­—ã€‚
    3. world_npcs æ˜¯ä½ æ ¹æ®ä¸–ç•Œè§‚ç”Ÿæˆçš„è·¯äººã€‚ä¾‹å¦‚ï¼šå¦‚æœæ˜¯ä¿®ä»™ä¸–ç•Œï¼Œç”Ÿæˆ"é’äº‘é—¨é•¿è€"ã€"æ•£ä¿®å¤§èƒ½"ï¼›å¦‚æœæ˜¯èµ›åšä¸–ç•Œï¼Œç”Ÿæˆ"è’å‚å…¬å¸é«˜ç®¡"ã€"å¤œä¹‹åŸä¸­é—´äºº"ã€‚å¦‚æœæ˜¯é»˜è®¤è®¾å®šï¼Œç”Ÿæˆ"çŸ³æ²¹ç‹å­"ã€"ç¥ç§˜æ”¶è—å®¶"ç­‰ã€‚
    `;

    try {
        let isGemini = proxyUrl.includes('generativelanguage');
        let config = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:'ç”Ÿæˆä¸€ä»¶æ‹å“'}]);
        
        const response = isGemini ? 
            await fetch(config.url, config.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:'ç”Ÿæˆä¸€ä»¶æ‹å“'}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("APIè¯·æ±‚å¤±è´¥");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const json = JSON.parse(text.replace(/^```json\s*/, '').replace(/```$/, ''));

        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(json.item.image_prompt)}`;
        const limitMultiplier = 1.5 + Math.random() * 2.0; 
        
        auctionState.item = json.item;
        auctionState.basePrice = json.item.basePrice;
        auctionState.limitPrice = json.item.basePrice * limitMultiplier;
        auctionState.currentPrice = json.item.basePrice;
        auctionState.isActive = true;
        auctionState.timer = 20; 
        auctionState.lastBidder = null; 
        auctionState.bidHistory = [];
        
        auctionState.interestedChars = json.interested_bidders || [];
        // ã€æ ¸å¿ƒæ–°å¢ã€‘ä¿å­˜ç”Ÿæˆçš„ NPC åˆ—è¡¨
        auctionState.worldNPCs = json.world_npcs || [];

        console.log("å¯¹æœ¬æ‹å“æ„Ÿå…´è¶£çš„è§’è‰²:", auctionState.interestedChars);
        console.log("æœ¬åœºè·¯äººNPC:", auctionState.worldNPCs);

        // æ›´æ–°UI
        document.getElementById('auction-item-name').textContent = json.item.name;
        document.getElementById('auction-item-desc').textContent = json.item.description;
        document.getElementById('auction-current-price').textContent = `Â¥ ${json.item.basePrice.toLocaleString()}`;
        
        const imgEl = document.getElementById('auction-item-img');
        imgEl.src = imageUrl;
        imgEl.style.display = 'block';
        document.getElementById('auction-loading').style.display = 'none';
        
        document.getElementById('auction-log').innerHTML = '<div style="color:#666; padding:5px;">æ‹å–å¼€å§‹ï¼åº•ä»· Â¥' + json.item.basePrice + '</div>';

        startAuctionLoop();

    } catch (e) {
        console.error(e);
        alert("è¿›è´§å¤±è´¥ï¼Œè¯·é‡è¯•");
    } finally {
        btn.style.pointerEvents = 'auto';
        btn.textContent = 'æ–°æ‹å“';
    }
}

// æ–°å¢ï¼šæ‹å–å¸ˆå–Šè¯çŠ¶æ€
let auctioneerState = 0; 

function startAuctionLoop() {
    if (auctionState.timerId) clearInterval(auctionState.timerId);
    if (auctionState.npcIntervalId) clearInterval(auctionState.npcIntervalId);

    const timerEl = document.getElementById('auction-timer');
    const logEl = document.getElementById('auction-log'); // è·å–æ—¥å¿—åŒºåŸŸ
    auctioneerState = 0; // é‡ç½®å–Šè¯

    // å€’è®¡æ—¶é€»è¾‘
    auctionState.timerId = setInterval(() => {
        auctionState.timer--;
        
        // æ ¼å¼åŒ–å€’è®¡æ—¶æ˜¾ç¤º
        timerEl.textContent = `${auctionState.timer.toFixed(1)}s`;
        
        // è§†è§‰è­¦å‘Š
        if (auctionState.timer <= 5) {
            timerEl.style.color = '#ff0055'; // çº¢è‰²ç´§è¿«
            timerEl.style.textShadow = '0 0 10px #ff0055';
        } else {
            timerEl.style.color = '#f0ad4e';
            timerEl.style.textShadow = 'none';
        }

        // --- ç©æ³•å¢å¼ºï¼šæ‹å–å¸ˆå–Šè¯ ---
        if (auctionState.timer <= 10 && auctioneerState === 0) {
            addAuctionLog("System", `ğŸ”¨ ${auctionState.currentPrice} ç¬¬ä¸€æ¬¡ï¼`);
            auctioneerState = 1;
        }
        if (auctionState.timer <= 5 && auctioneerState === 1) {
            addAuctionLog("System", `ğŸ”¨ ${auctionState.currentPrice} ç¬¬äºŒæ¬¡ï¼è¿˜æœ‰äººåŠ ä»·å—ï¼Ÿ`);
            auctioneerState = 2;
        }
        if (auctionState.timer <= 2 && auctioneerState === 2) {
            addAuctionLog("System", `ğŸ”¨ ${auctionState.currentPrice} ç¬¬ä¸‰æ¬¡ï¼å³å°†æˆäº¤...`);
            auctioneerState = 3;
        }

        if (auctionState.timer <= 0) {
            endAuction();
        }
    }, 1000); // è¿™é‡Œå…¶å®å¯ä»¥æ”¹æˆ 100ms å¢åŠ å¹³æ»‘åº¦ï¼Œä½† 1000ms å¤Ÿç”¨äº†

    // NPC å‡ºä»·é€»è¾‘ (ç¨å¾®åŠ å¿«é¢‘ç‡)
    auctionState.npcIntervalId = setInterval(() => {
        if (!auctionState.isActive) return;
        
        // å¢åŠ éšæœºæ€§ï¼šä¸æ˜¯æ¯æ¬¡tickéƒ½æ£€æŸ¥ï¼Œè€Œæ˜¯æ›´éšæœº
        if (Math.random() < 0.7) { 
            npcBid();
        }
    }, 800); 
}

// 4. NPC/ç†Ÿäºº å‡ºä»·é€»è¾‘ (ä¿®å¤ç‰ˆï¼šæ›´æ™ºèƒ½ã€æœ‰æœºä¼šèµ¢)
// 4. NPC/ç†Ÿäºº å‡ºä»·é€»è¾‘ (AIäº’æç‰ˆ)
function npcBid() {
    // ã€æ ¸å¿ƒä¿®æ”¹1ã€‘åˆ é™¤äº† "if (lastBidder !== 'user') return" è¿™è¡Œä»£ç 
    // ç°åœ¨å…è®¸ AI ä¹‹é—´äº’ç›¸ç«ä»·ï¼Œä¸éœ€è¦ç­‰ç©å®¶
    
    // 1. ä»·æ ¼å°é¡¶æ£€æŸ¥ (é˜²æ­¢æ— é™äº’åˆ·)
    if (auctionState.currentPrice >= auctionState.limitPrice) {
        // è¶…è¿‡ä¼°å€¼ä¸Šé™åï¼Œ90%æ¦‚ç‡åœæ­¢ï¼Œ10%æ¦‚ç‡â€œä¸Šå¤´â€ç»§ç»­è·Ÿ
        if (Math.random() > 0.1) return; 
    }

    // 2. è®¡ç®—å‡ºä»·æ¦‚ç‡ (ä»·æ ¼è¶Šé«˜ï¼Œè·Ÿæ‹è¶ŠçŠ¹è±«)
    const premiumRatio = auctionState.currentPrice / auctionState.basePrice;
    const bidChance = 0.8 / (premiumRatio * premiumRatio); // ç¨å¾®è°ƒé«˜äº†ç³»æ•°ï¼Œè®©åæœŸä¹Ÿæ•¢è·Ÿ
    if (Math.random() > bidChance) return;

    // 3. ç¡®å®šæœ¬æ¬¡è°æƒ³å‡ºä»· (30% è§’è‰² vs 70% NPC)
    let candidate = null;
    
    // è·å–æ„Ÿå…´è¶£çš„è§’è‰²åˆ—è¡¨
    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
    const interestedCandidates = allCharacters.filter(c => 
        auctionState.interestedChars && auctionState.interestedChars.includes(c.name)
    );

    // éª°å­åˆ¤å®šï¼šæœ¬æ¬¡æ˜¯ç†Ÿäººå‡ºæ‰‹(30%) è¿˜æ˜¯ åœŸè±ªè·¯äººå‡ºæ‰‹(70%)
    if (interestedCandidates.length > 0 && Math.random() < 0.3) {
        const char = interestedCandidates[Math.floor(Math.random() * interestedCandidates.length)];
        candidate = { name: char.name, type: 'char', id: char.id };
    } else {
        // --- NPC æ±  ---
        let npcName = "ç¥ç§˜ä¹°å®¶";
        
        // ä¼˜å…ˆä»ç”Ÿæˆçš„åˆ—è¡¨é‡Œæ‰¾ï¼Œå¹¶ä¸”å°½é‡æ‰¾ä¸€ä¸ªâ€œä¸æ˜¯å½“å‰æœ€é«˜å‡ºä»·è€…â€çš„äºº
        if (auctionState.worldNPCs && auctionState.worldNPCs.length > 0) {
            // è¿‡æ»¤æ‰å½“å‰æ­£åœ¨é¢†å…ˆçš„äººï¼Œåˆ¶é€ â€œç«äº‰â€æ„Ÿ
            const rivals = auctionState.worldNPCs.filter(n => 
                !auctionState.lastBidder || n !== auctionState.lastBidder.name
            );
            
            if (rivals.length > 0) {
                npcName = rivals[Math.floor(Math.random() * rivals.length)];
            } else {
                npcName = auctionState.worldNPCs[0];
            }
        } else {
            // å…œåº•åå•
            const richNames = ["ç¥ç§˜ä¹°å®¶", "è‹å¯Œæ¯”VIP", "è¿ªæ‹œç‹å®¤æˆå‘˜", "åå°”è¡—æŠ•èµ„äºº", 
            "åœ°äº§å¤§äº¨", "ä½è°ƒçš„æ”¶è—å®¶", "æŸä¸Šå¸‚å…¬å¸CEO", "æ¸¯å²›ååª›", "çŸ³æ²¹ç‹å­"];
            npcName = richNames[Math.floor(Math.random() * richNames.length)];
        }
        
        candidate = { name: npcName, type: 'npc' };
    }

    // ã€æ ¸å¿ƒä¿®æ”¹2ã€‘é˜²è‡ªå·±é¡¶è‡ªå·±
    // å¦‚æœæƒ³å‡ºä»·çš„äººï¼Œå·²ç»æ˜¯å½“å‰æœ€é«˜å‡ºä»·è€…äº†ï¼Œé‚£å°±ä¸å‡ºäº†ï¼Œç­‰åˆ«äººé¡¶
    if (auctionState.lastBidder && auctionState.lastBidder.name === candidate.name) {
        return;
    }

    // 4. å†³å®šåŠ ä»·å¹…åº¦
    let increasePercent = 0.05; // é»˜è®¤åŠ  5%

    // ã€æ ¸å¿ƒä¿®æ”¹3ã€‘NPC æ›´æœ‰é’±é€»è¾‘
    // å¦‚æœæ˜¯ NPCï¼Œæœ‰ 30% çš„æ¦‚ç‡â€œè´¢å¤§æ°”ç²—â€ï¼Œç›´æ¥åŠ ä»· 10%~15%ï¼Œå‹åˆ¶å…¨åœº
    if (candidate.type === 'npc' && Math.random() < 0.3) {
        increasePercent = 0.15; 
    }

    const newPrice = Math.floor(auctionState.currentPrice * (1 + increasePercent));
    updateAuctionState(newPrice, candidate);
}

// 5. ç”¨æˆ·å‡ºä»·é€»è¾‘
async function placeBid(multiplier) {
    if (!auctionState.isActive) return;

    let bidAmount = 0;
    if (multiplier === 'custom') {
        const input = await showCustomPrompt("æ‰‹åŠ¨å‡ºä»·", "è¾“å…¥é‡‘é¢ (ä¸èƒ½ä½äºå½“å‰ä»·)", auctionState.currentPrice + 100, 'number');
        if (!input) return;
        bidAmount = parseFloat(input);
    } else {
        bidAmount = Math.floor(auctionState.currentPrice * multiplier);
    }

    if (bidAmount <= auctionState.currentPrice) {
        alert("å‡ºä»·å¿…é¡»é«˜äºå½“å‰ä»·æ ¼ï¼");
        return;
    }

    // æ£€æŸ¥ä½™é¢ (é¢„æ£€æŸ¥ï¼Œè™½ç„¶ä¸æ‰£æ¬¾ï¼Œä½†è¦é˜²æ­¢ä¹±ç‚¹)
    const wallet = await db.userWallet.get('main');
    const totalAssets = wallet.balance + (wallet.kinshipCards || []).reduce((sum, c) => sum + (c.limit - (c.spent||0)), 0);
    
    if (totalAssets < bidAmount) {
        // éœ‡åŠ¨åé¦ˆ
        if(navigator.vibrate) navigator.vibrate(200);
        showCustomAlert("èµ„é‡‘ä¸è¶³", "ä½ çš„èµ„äº§æ€»é¢ä¸è¶³ä»¥æ”¯ä»˜æ­¤ä»·æ ¼ï¼");
        return;
    }

    const user = { name: state.qzoneSettings.nickname || 'æˆ‘', type: 'user', id: 'user' };
    updateAuctionState(bidAmount, user);
}

// è¾…åŠ©å‡½æ•°ï¼šç»Ÿä¸€æ·»åŠ æ—¥å¿—
function addAuctionLog(type, text) {
    const logEl = document.getElementById('auction-log');
    const div = document.createElement('div');
    
    if (type === 'System') {
        div.innerHTML = `<span style="color:#00f3ff; font-weight:bold;">[æ‹å–å®˜]</span> ${text}`;
    } else {
        div.innerHTML = text; // æ™®é€šå‡ºä»·æ—¥å¿—
    }
    
    if (type === 'bid-me') div.className = 'bid-me';
    if (type === 'bid-friend') div.className = 'bid-friend';
    
    logEl.appendChild(div); // æ”¹ä¸º appendChildï¼ŒåŠ åœ¨æœ€ä¸‹é¢
    logEl.scrollTop = logEl.scrollHeight;
}

// ä¿®æ”¹åŸæœ‰çš„ updateAuctionState
function updateAuctionState(newPrice, bidder) {
    auctionState.currentPrice = newPrice;
    auctionState.lastBidder = bidder;
    auctionState.bidHistory.push(bidder); // è®°å½•

    // --- ç©æ³•å¢å¼ºï¼šåŠ æ—¶æœºåˆ¶ ---
    // å¦‚æœå‰©ä½™æ—¶é—´å°‘äº 10 ç§’ï¼Œæœ‰äººå‡ºä»·åˆ™å›è¡€åˆ° 10~15 ç§’
    if (auctionState.timer < 10) {
        const bonusTime = Math.floor(Math.random() * 5) + 10; // éšæœºå›è¡€
        auctionState.timer = bonusTime;
        // è§†è§‰åé¦ˆï¼šé‡ç½®å–Šè¯çŠ¶æ€
        auctioneerState = 0; 
        
        // è§†è§‰åé¦ˆï¼šé—ªçƒä¸€ä¸‹å€’è®¡æ—¶
        const timerEl = document.getElementById('auction-timer');
        timerEl.style.color = '#00ff00'; // ç»¿è‰²è¡¨ç¤ºæ—¶é—´å¢åŠ 
        setTimeout(() => timerEl.style.color = '#f0ad4e', 300);
        
        addAuctionLog("System", "â±ï¸ æœ‰äººå‡ºä»·ï¼Œæ—¶é—´å»¶é•¿ï¼");
    }

    // æ›´æ–°ä»·æ ¼ UI
    const priceEl = document.getElementById('auction-current-price');
    priceEl.textContent = `Â¥ ${newPrice.toLocaleString()}`;
    priceEl.classList.remove('shake-animation');
    void priceEl.offsetWidth; 
    priceEl.classList.add('shake-animation');

    // æ„é€ å‡ºä»·æ—¥å¿—å†…å®¹
    let content = "";
    let logType = "bid-npc";
    
    if (bidder.type === 'user') {
        content = `ğŸš© <b>ä½ </b> å‡ºä»· Â¥${newPrice.toLocaleString()}`;
        logType = "bid-me";
        // éœ‡åŠ¨åé¦ˆ (å¦‚æœè®¾å¤‡æ”¯æŒ)
        if(navigator.vibrate) navigator.vibrate(50);
    } else if (bidder.type === 'char') {
        content = `ğŸ”¥ <b>${bidder.name}</b> ä¸¾ç‰Œ Â¥${newPrice.toLocaleString()}!`;
        logType = "bid-friend";
    } else {
        content = `${bidder.name} å‡ºä»· Â¥${newPrice.toLocaleString()}`;
    }
    
    // å†™å…¥æ—¥å¿—
    const logEl = document.getElementById('auction-log');
    const div = document.createElement('div');
    div.innerHTML = content;
    div.className = logType;
    logEl.appendChild(div); 
    logEl.scrollTop = logEl.scrollHeight;
}

// 7. æ‹å–ç»“æŸç»“ç®— - ä¿®å¤ç‰ˆ
async function endAuction() {
    clearInterval(auctionState.timerId);
    clearInterval(auctionState.npcIntervalId);
    auctionState.isActive = false;
    
    const winner = auctionState.lastBidder;
    const finalPrice = auctionState.currentPrice;
    const item = auctionState.item;

    document.getElementById('auction-timer').textContent = "ç»“æŸ";
    document.getElementById('auction-item-image-container').classList.remove('auction-win-anim');

    // æƒ…å†µ1ï¼šæ ¹æœ¬æ²¡äººå‡ºä»·ï¼ˆæµæ‹ï¼‰
    if (!winner) {
        await showCustomAlert("æ‹å–ç»“æŸ", "æ— äººå‡ºä»·ï¼Œè¯¥æ‹å“å·²æµæ‹ã€‚");
        return;
    }

    // æƒ…å†µ2ï¼šç”¨æˆ·è·èƒœ
    if (winner.type === 'user') {
        document.getElementById('auction-item-image-container').classList.add('auction-win-anim');
        
        // è·å–é’±åŒ…
        const wallet = await db.userWallet.get('main');
        const balance = wallet.balance || 0;
        const kinshipCards = wallet.kinshipCards || [];

        const paymentOptions = [];
        if (balance >= finalPrice) {
            paymentOptions.push({ 
                text: `<span style="color:#1677ff;font-weight:bold;">ä½™é¢æ”¯ä»˜</span> (å‰©ä½™ Â¥${balance.toFixed(2)})`, 
                value: 'balance' 
            });
        }
        kinshipCards.forEach(card => {
            const remaining = card.limit - (card.spent || 0);
            if (remaining >= finalPrice) {
                const chat = state.chats[card.chatId];
                paymentOptions.push({
                    text: `<span style="color:#ff5252;font-weight:bold;">äº²å±å¡ - ${chat.name}</span> (å‰©ä½™ Â¥${remaining.toFixed(2)})`,
                    value: `kinship_${card.chatId}`
                });
            }
        });

        if (paymentOptions.length === 0) {
             await showCustomAlert("ç«æ‹æˆåŠŸä½†æ”¯ä»˜å¤±è´¥", "ä½ èµ¢äº†ç«æ‹ï¼Œä½†èµ„é‡‘ä¸è¶³ä»¥æ”¯ä»˜ï¼");
             return;
        }

        // æå‡å¼¹çª—å±‚çº§
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        const method = await showChoiceModal(`ç«æ‹æˆåŠŸï¼æ”¯ä»˜ Â¥${finalPrice}`, paymentOptions);
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        
        if (!method) {
             await showCustomAlert("äº¤æ˜“å–æ¶ˆ", "ä½ æ”¾å¼ƒäº†æ”¯ä»˜ã€‚");
             return;
        }

        // æ‰£æ¬¾
        let providerChatId = null;
        if (method === 'balance') {
            await processTransaction(finalPrice, 'expense', `é»‘å¸‚è´­ä¹°-${item.name}`);
        } else {
            // ã€ä¿®å¤ã€‘ä½¿ç”¨ replace æå–å®Œæ•´çš„ chatId (ä¾‹å¦‚ chat_123456)
            const chatId = method.replace('kinship_', ''); 
            
            providerChatId = chatId;
            const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === chatId);
            
            if (cardIndex > -1) {
                // 1. æ›´æ–°é¢åº¦
                wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + finalPrice;
                await db.userWallet.put(wallet);
                
                // 2. å†™å…¥è´¦å•
                await db.userTransactions.add({
                    timestamp: Date.now(),
                    type: 'expense',
                    amount: finalPrice,
                    description: `äº²å±å¡é»‘å¸‚-${item.name}`
                });
                
                console.log(`[é»‘å¸‚] äº²å±å¡æ‰£æ¬¾æˆåŠŸ: -${finalPrice}`);
            } else {
                console.error(`[é»‘å¸‚] æ‰£æ¬¾å¤±è´¥ï¼šæ‰¾ä¸åˆ°IDä¸º ${chatId} çš„äº²å±å¡`);
                alert("æ”¯ä»˜å¼‚å¸¸ï¼šæœªæ‰¾åˆ°å¯¹åº”çš„äº²å±å¡è®°å½•ã€‚");
                return;
            }
        }

        // å…¥åº“
        await db.inventory.add({
            name: item.name,
            type: 'treasure',
            description: item.description,
            image: item.image_prompt,
            acquiredPrice: finalPrice,
            acquiredTime: Date.now()
        });

        const giftConfirmed = await showCustomConfirm(
            "ç«æ‹æˆåŠŸï¼", 
            `ä½ å·²æˆåŠŸæ‹ä¸‹ã€${item.name}ã€‘ï¼\n\nè¦ç°åœ¨å°±æŠŠå®ƒä½œä¸ºç¤¼ç‰©ï¼Œé€ç»™æŸä½è§’è‰²å—ï¼Ÿ`,
            { confirmText: 'ğŸ ç«‹å³èµ é€', cancelText: 'æ”¾å…¥ä»“åº“' }
        );

        if (giftConfirmed) {
            await openAuctionGiftSelector(item, finalPrice);
        } else {
            await showCustomAlert("å·²å…¥åº“", "ç‰©å“å·²å®‰å…¨å­˜å…¥ä½ çš„åº“å­˜ã€‚");
        }

        // è§¦å‘è®°å¿†å’Œé€šçŸ¥
        if (providerChatId) {
            const providerChat = state.chats[providerChatId];
            if (providerChat) {
                const msg = {
                    role: 'system',
                    content: `[æ¶ˆè´¹é€šçŸ¥ï¼šç”¨æˆ·ä½¿ç”¨ä½ çš„äº²å±å¡åœ¨é»‘å¸‚æ‹å–è¡Œæ¶ˆè´¹äº† Â¥${finalPrice}ï¼Œè´­ä¹°äº†â€œ${item.name}â€ã€‚]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                providerChat.history.push(msg);
                await db.chats.put(providerChat);
            }
        }
        
        // é€šçŸ¥åœ¨åœºçš„ç†Ÿäºº
        const uniqueBidders = [...new Set(auctionState.bidHistory.filter(b => b.type === 'char').map(b => b.id))];
        for (const charId of uniqueBidders) {
            if (charId === providerChatId) continue;
            const char = state.chats[charId];
            if (char) {
                const msg = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šåœ¨åˆšæ‰çš„é»‘å¸‚æ‹å–ä¸­ï¼Œç”¨æˆ·ä»¥ Â¥${finalPrice} çš„ä»·æ ¼å‡»è´¥äº†åœ¨åœºçš„ç«æ‹è€…ï¼ˆåŒ…æ‹¬ä½ ï¼‰ï¼Œèµ¢å¾—äº†â€œ${item.name}â€ã€‚]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                char.history.push(msg);
                await db.chats.put(char);
            }
        }

    } else {
        // --- Char æˆ– NPC è·èƒœ ---
        
        if (winner.type === 'char') {
            // å¦‚æœæ˜¯æˆ‘ä»¬çš„è§’è‰²èµ¢äº†
            const chat = state.chats[winner.id];
            if (chat) {
                await showCustomAlert("ç«æ‹ç»“æŸ", `æ­å–œï¼æ‚¨çš„å¥½å‹ã€${winner.name}ã€‘ä»¥ Â¥${finalPrice.toLocaleString()} æˆåŠŸæ‹å¾—å®ç‰©ï¼`);
                
                // è§¦å‘ AI å†³ç­–ï¼šæ˜¯å¦é€ç»™ç”¨æˆ·
                // æˆ‘ä»¬ä¸ç›´æ¥å¼¹çª—é—®ç”¨æˆ·ï¼Œè€Œæ˜¯å‘é€ä¸€æ¡éšè—çš„ç³»ç»Ÿæ¶ˆæ¯ç»™ AIï¼Œè®© AI è‡ªå·±å†³å®š
                const systemPrompt = `
                [ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšåœ¨æ‹å–ä¼šä¸Šæ–¥èµ„ Â¥${finalPrice.toLocaleString()} æ‹ä¸‹äº†â€œ${item.name}â€(${item.description})ã€‚
                è¯·æ ¹æ®ä½ çš„äººè®¾å’Œä¸ç”¨æˆ·çš„å…³ç³»ï¼Œå†³å®šæ€ä¹ˆå¤„ç†è¿™ä¸ªç‰©å“ã€‚
                ä½ å¯ä»¥ï¼š
                1. é€ç»™ç”¨æˆ·ä½œä¸ºæƒŠå–œ (ä½¿ç”¨ 'gift' æŒ‡ä»¤)ã€‚
                2. è‡ªå·±æ”¶è—ï¼Œå¹¶å‘ç”¨æˆ·ç‚«è€€ (ä½¿ç”¨ 'text' æˆ– 'ai_image' æŒ‡ä»¤)ã€‚
                3. æŠ±æ€¨å¤ªè´µäº† (ä½¿ç”¨ 'text' æŒ‡ä»¤)ã€‚
                è¯·å¼€å§‹ä½ çš„è¡¨æ¼”ã€‚]
                `;
                
                chat.history.push({
                    role: 'system',
                    content: systemPrompt,
                    timestamp: Date.now(),
                    isHidden: true
                });
                await db.chats.put(chat);
                
                // å¦‚æœå½“å‰æ²¡åœ¨èŠå¤©ç•Œé¢ï¼Œå°±ä¸å¼ºåˆ¶è·³è½¬ï¼Œåªåœ¨åå°è§¦å‘
                // å¦‚æœæƒ³æ›´æ˜æ˜¾ï¼Œå¯ä»¥å¼ºåˆ¶è·³è½¬ï¼š
                const confirmJump = await showCustomConfirm("å»çœ‹çœ‹ï¼Ÿ", `${winner.name} ä¼¼ä¹æœ‰è¯å¯¹ä½ è¯´ã€‚`, {confirmText:"å‰å¾€èŠå¤©"});
                if (confirmJump) {
                    openChat(winner.id);
                    triggerAiResponse(); // è§¦å‘ AI å›å¤
                } else {
                    // åªæ˜¯åå°è§¦å‘ï¼Œä¸‹æ¬¡è¿›èŠå¤©èƒ½çœ‹åˆ°
                    // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ‰‹åŠ¨è°ƒç”¨ä¸€æ¬¡ APIï¼Œä½†å› ä¸ºä¸åœ¨èŠå¤©ç•Œé¢ï¼Œå¯èƒ½éœ€è¦è°¨æ…å¤„ç†
                    // ç®€å•èµ·è§ï¼Œå»ºè®®å°±ç”¨ä¸Šé¢çš„è·³è½¬é€»è¾‘
                }
            }
        } else {
            // çº¯è·¯äºº NPC èµ¢äº†
            await showCustomAlert("æ‹å–ç»“æŸ", `å¾ˆé—æ†¾ï¼Œè¢«ã€${winner.name}ã€‘ä»¥ Â¥${finalPrice.toLocaleString()} æ‹èµ°äº†ã€‚`);
        }
    }
}
// æ–°å¢ï¼šæ‰“å¼€é€ç¤¼å¯¹è±¡é€‰æ‹©å™¨ (æ»šåŠ¨åˆ—è¡¨ä¿®å¤ç‰ˆ)
async function openAuctionGiftSelector(item, price) {
    const characters = Object.values(state.chats).filter(c => !c.isGroup);
    if (characters.length === 0) return alert("æ²¡æœ‰å¯èµ é€çš„è§’è‰²");

    // è·å–æ¨¡æ€æ¡†å…ƒç´ 
    const modal = document.getElementById('custom-modal-overlay');
    const titleEl = document.getElementById('custom-modal-title');
    const bodyEl = document.getElementById('custom-modal-body');
    const footerEl = document.querySelector('#custom-modal .custom-modal-footer');

    // 1. è®¾ç½®æ ‡é¢˜
    titleEl.textContent = `å°†â€œ${item.name}â€é€ç»™...`;

    // 2. é‡ç½® Footer æ ·å¼ (æ¸…é™¤ä¹‹å‰ showChoiceModal å¯èƒ½ç•™ä¸‹çš„åˆ†é¡µæŒ‰é’®å’Œæ ·å¼)
    footerEl.innerHTML = '';
    footerEl.style.flexDirection = 'row'; // æ¢å¤æ¨ªå‘å¸ƒå±€
    footerEl.style.justifyContent = 'center';
    footerEl.style.maxHeight = ''; // æ¸…é™¤é«˜åº¦é™åˆ¶
    footerEl.style.overflowY = ''; // æ¸…é™¤æ»šåŠ¨

    // æ·»åŠ ä¸€ä¸ªç®€å•çš„å–æ¶ˆæŒ‰é’®
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'å–æ¶ˆ';
    cancelBtn.style.color = '#666';
    cancelBtn.onclick = () => modal.classList.remove('visible');
    footerEl.appendChild(cancelBtn);

    // 3. æ„å»ºæ»šåŠ¨åˆ—è¡¨ (æ¸²æŸ“åœ¨ Body ä¸­)
    bodyEl.innerHTML = '';
    
    const listContainer = document.createElement('div');
    // æ ·å¼ï¼šæœ€å¤§é«˜åº¦é™åˆ¶ + å‚ç›´æ»šåŠ¨
    listContainer.style.cssText = `
        max-height: 60vh; 
        overflow-y: auto; 
        display: flex; 
        flex-direction: column; 
        text-align: left;
        margin: 0 -16px; /* æŠµæ¶ˆ modal-body çš„å†…è¾¹è·ï¼Œè®©åˆ—è¡¨è´´è¾¹ */
        border-top: 1px solid #eee;
    `;

    // æŒ‰åç§°æ’åºï¼Œæ–¹ä¾¿æŸ¥æ‰¾
    characters.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    characters.forEach(char => {
        const row = document.createElement('div');
        // å•ä¸ªé€‰é¡¹æ ·å¼
        row.style.cssText = `
            display: flex;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid #f5f5f5;
            cursor: pointer;
            transition: background-color 0.2s;
        `;
        
        const avatar = char.settings.aiAvatar || defaultAvatar;
        
        row.innerHTML = `
            <img src="${avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px; object-fit: cover; border: 1px solid #eee;">
            <div style="flex-grow: 1;">
                <div style="font-weight: 500; font-size: 16px; color: var(--text-primary);">${char.name}</div>
            </div>
            <div style="color: #ccc;">â€º</div>
        `;

        // ç‚¹å‡»äº‹ä»¶
        row.onclick = async () => {
            // è§†è§‰åé¦ˆ
            row.style.backgroundColor = '#f0f0f0';
            setTimeout(async () => {
                modal.classList.remove('visible');
                await sendAuctionGiftToChat(char.id, item, price);
            }, 100);
        };

        listContainer.appendChild(row);
    });

    bodyEl.appendChild(listContainer);
    
    // 4. æ˜¾ç¤ºæ¨¡æ€æ¡†
    modal.classList.add('visible');
}

// æ–°å¢ï¼šå‘é€ç¤¼ç‰©æ¶ˆæ¯åˆ°èŠå¤©
async function sendAuctionGiftToChat(chatId, item, price) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. æ„é€ ç¤¼ç‰©å›¾ç‰‡URL
    // å¦‚æœæ˜¯ AI ç”Ÿçš„å›¾ï¼Œå°è¯•æå– prompt é‡æ–°æ„é€ é“¾æ¥ï¼Œæˆ–è€…ç›´æ¥ç”¨é»˜è®¤å›¾
    let imageUrl = 'https://i.postimg.cc/Hs7BLh76/alipay.png'; 
    if (item.image_prompt) {
        imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
    }

    // 2. æ„é€ ç¤¼ç‰©æ¶ˆæ¯
    const giftMessage = {
        role: 'user',
        type: 'gift',
        timestamp: Date.now(),
        items: [{
            name: `[ç¨€ä¸–çå®] ${item.name}`,
            price: price,
            imageUrl: imageUrl,
            quantity: 1
        }],
        total: price,
        recipients: null // å•èŠä¸éœ€è¦ recipients
    };

    chat.history.push(giftMessage);

    // 3. æ·»åŠ ç³»ç»Ÿæç¤ºï¼Œè®©AIçŸ¥é“è¿™æ˜¯åˆšæ‹ä¸‹æ¥çš„
    const hiddenMessage = {
        role: 'system',
        content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšåœ¨é»‘å¸‚æ‹å–ä¼šä¸Šï¼Œæ–¥å·¨èµ„ï¼ˆÂ¥${price.toLocaleString()}ï¼‰æ‹ä¸‹äº†ç¨€ä¸–çå®â€œ${item.name}â€å¹¶ç›´æ¥é€ç»™äº†ä½ ã€‚ç‰©å“æè¿°ï¼š${item.description}ã€‚è¿™æ˜¯æå…¶è´µé‡çš„ç¤¼ç‰©ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾åšå‡ºå¼ºçƒˆçš„ååº”ï¼ˆæƒŠè®¶ã€æ„ŸåŠ¨ã€æˆ–æ˜¯è´£æ€ªä¹±èŠ±é’±ï¼‰ã€‚]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);

    // 4. è·³è½¬å¹¶è§¦å‘ AI å›å¤
    await showCustomAlert("èµ é€æˆåŠŸ", `ç¤¼ç‰©å·²é€è¾¾ç»™ ${chat.name}ï¼æ­£åœ¨å‰å¾€èŠå¤©ç•Œé¢...`);
    
    // åˆ‡æ¢å±å¹•
    showScreen('chat-list-screen'); // å…ˆåˆ‡åˆ°åˆ—è¡¨åˆ·æ–°çŠ¶æ€
    setTimeout(() => {
        openChat(chatId); // æ‰“å¼€èŠå¤©
        triggerAiResponse(); // è§¦å‘ AI å›å¤
    }, 300);
}
// è¾…åŠ©ï¼šè®°å½•å‡ºä»·å†å²
const originalUpdateAuctionState = updateAuctionState;
updateAuctionState = function(newPrice, bidder) {
    auctionState.bidHistory.push(bidder); // è®°å½•æ‰€æœ‰å‡ºä»·è€…
    originalUpdateAuctionState(newPrice, bidder); // è°ƒç”¨åŸé€»è¾‘
}
window.openAuctionScreen = openAuctionScreen;
window.generateNewAuctionItem = generateNewAuctionItem;
window.placeBid = placeBid;
// --- é»‘å¸‚ä»“åº“åŠŸèƒ½ ---

// 1. æ‰“å¼€ä»“åº“
async function openInventoryModal() {
    const modal = document.getElementById('inventory-modal');
    const listEl = document.getElementById('inventory-list');
    
    modal.classList.add('visible');
    listEl.innerHTML = '<div class="spinner"></div>'; // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»

    try {
        // ä»æ•°æ®åº“è¯»å–è—å“ï¼ŒæŒ‰æ—¶é—´å€’åº
        const items = await db.inventory.orderBy('acquiredTime').reverse().toArray();
        
        listEl.innerHTML = '';
        if (items.length === 0) {
            listEl.innerHTML = '<div style="text-align:center; color:#666; margin-top:50px;">ä»“åº“ç©ºç©ºå¦‚ä¹Ÿ<br>å¿«å»ç«æ‹ç‚¹å¥½ä¸œè¥¿å§</div>';
            return;
        }

        items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'inventory-item';
            
            // å›¾ç‰‡å¤„ç†ï¼šå…¼å®¹ Pollinations å’Œæ™®é€š URL
            let imageUrl = 'https://i.postimg.cc/Hs7BLh76/alipay.png'; 
            if (item.image) {
                if (item.image.startsWith('http') || item.image.startsWith('data:')) {
                     imageUrl = item.image;
                } else {
                     // å¦‚æœæ˜¯ promptï¼Œè½¬æ¢æˆé“¾æ¥
                     imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image)}`;
                }
            }

            div.innerHTML = `
                <img src="${imageUrl}" class="inventory-img" loading="lazy">
                <div class="inventory-info">
                    <div class="inventory-name">${item.name}</div>
                    <div class="inventory-desc">${item.description || 'ç¨€ä¸–çå®'}</div>
                    <div class="inventory-price">å…¥æ‰‹ä»·: Â¥${(item.acquiredPrice || 0).toLocaleString()}</div>
                </div>
                <button class="inventory-use-btn">èµ é€</button>
            `;

            // ç»‘å®šèµ é€æŒ‰é’®
            const btn = div.querySelector('.inventory-use-btn');
            btn.onclick = () => handleGiftFromInventory(item);

            listEl.appendChild(div);
        });

    } catch (e) {
        console.error(e);
        listEl.innerHTML = '<div style="text-align:center; color:#ff3b30;">åŠ è½½å¤±è´¥</div>';
    }
}

// 2. å…³é—­ä»“åº“
function closeInventoryModal() {
    document.getElementById('inventory-modal').classList.remove('visible');
}

// 3. ä»ä»“åº“èµ é€
async function handleGiftFromInventory(item) {
    // å…³é—­ä»“åº“å¼¹çª—
    closeInventoryModal();

    // æ„é€ èµ é€å¯¹è±¡
    const giftItem = {
        name: item.name,
        description: item.description,
        image_prompt: item.image 
    };

    // è°ƒç”¨ç°æœ‰çš„èµ é€é€‰æ‹©å™¨ (å¤ç”¨ openAuctionGiftSelector)
    // ä¼ å…¥å…¥æ‰‹ä»·ä½œä¸ºç¤¼ç‰©çš„ä»·å€¼
    await openAuctionGiftSelector(giftItem, item.acquiredPrice || 9999);
}

// æš´éœ²ç»™å…¨å±€ä½¿ç”¨
window.openInventoryModal = openInventoryModal;
window.closeInventoryModal = closeInventoryModal;
// === å®Œæ•´ç‰ˆ playSynthScore å‡½æ•° (æ”¯æŒèŠ‚å¥ + å…¨ä¹å™¨) ===
let globalPolySynth = null;

async function playSynthScore(btnElement, notesJson, instrumentType = 'piano') {
    let notes = [];
    try {
        // 1. è§£æä¹è°±æ•°æ®
        // å…¼å®¹æ—§ç‰ˆçº¯å­—ç¬¦ä¸²æ•°ç»„ ["C4", "E4"] å’Œæ–°ç‰ˆå¯¹è±¡æ•°ç»„ [{"n":"C4","d":"4n"}]
        const rawNotes = (typeof notesJson === 'string') ? JSON.parse(notesJson) : notesJson;
        
        // ç»Ÿä¸€æ ¼å¼åŒ–ä¸ºæ–°ç‰ˆå¯¹è±¡ {n: éŸ³é«˜, d: æ—¶é•¿}
        notes = rawNotes.map(item => {
            if (typeof item === 'string') {
                return { n: item, d: '8n' }; // æ—§ç‰ˆæ•°æ®é»˜è®¤8åˆ†éŸ³ç¬¦
            }
            return { n: item.n, d: item.d || '4n' }; // æ–°ç‰ˆæ•°æ®ï¼Œé»˜è®¤4åˆ†éŸ³ç¬¦
        });

    } catch(e) { console.error("ä¹è°±è§£æå¤±è´¥", e); return; }

    if (!notes || notes.length === 0) return;

    // 2. å¯åŠ¨éŸ³é¢‘å¼•æ“
    await Tone.start();

    // åˆå§‹åŒ–åˆæˆå™¨ (å•ä¾‹æ¨¡å¼)
    if (!globalPolySynth) {
        globalPolySynth = new Tone.PolySynth(Tone.Synth).toDestination();
    }
    
    // é‡ç½®åŸºç¡€éŸ³é‡
    globalPolySynth.volume.value = -8;

    // 3. é…ç½®ä¹å™¨éŸ³è‰² (Switch Case)
    switch (instrumentType) {
        case 'chiptune': // 8-bit æ¸¸æˆé£
            globalPolySynth.set({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            });
            break;
            
        case 'synth': // ç”µå­åˆæˆå™¨
            globalPolySynth.set({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 2 }
            });
            break;

        case 'guitar': // å‰ä»– (æ¸…è„†æ‹¨å¼¦)
            globalPolySynth.set({
                oscillator: { type: "triangle" }, 
                envelope: { 
                    attack: 0.01, decay: 0.3, sustain: 0.1, release: 1.0 
                }
            });
            globalPolySynth.volume.value = -5; // è¡¥å¿éŸ³é‡
            break;

        case 'violin': // å°æç´ (ç¼“æ…¢èµ·éŸ³ï¼Œç»µé•¿å»¶éŸ³)
            globalPolySynth.set({
                oscillator: { type: "sawtooth" },
                envelope: { 
                    attack: 0.2, decay: 0.1, sustain: 0.8, release: 1.5 
                }
            });
            globalPolySynth.volume.value = -10; // å¼¦ä¹è¾ƒå“ï¼Œé™ä½éŸ³é‡
            break;

        case 'flute': // ç¬›å­ (çº¯å‡€æ­£å¼¦æ³¢)
            globalPolySynth.set({
                oscillator: { type: "sine" },
                envelope: { 
                    attack: 0.1, decay: 0.1, sustain: 0.9, release: 0.5 
                }
            });
            break;

        case 'guzheng': // å¤ç­ (å°–é”æ‹¨å¼¦ï¼Œå¿«é€Ÿè¡°å‡)
            globalPolySynth.set({
                oscillator: { type: "triangle" },
                envelope: { 
                    attack: 0.005, decay: 0.4, sustain: 0, release: 1.5 
                }
            });
            globalPolySynth.volume.value = -5;
            break;

        case 'kalimba': // æ‹‡æŒ‡ç´ (å¯çˆ±ï¼Œç©ºçµ)
            globalPolySynth.set({
                oscillator: { type: "sine" },
                envelope: { 
                    attack: 0.001, decay: 0.1, sustain: 0, release: 1.2 
                }
            });
            break;

        case 'piano': // é»˜è®¤é’¢ç´
        default:
            globalPolySynth.set({
                oscillator: { type: "triangle" },
                envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }
            });
            break;
    }

    // 4. æ›´æ–° UI çŠ¶æ€
    btnElement.textContent = "âšâš";
    btnElement.classList.add('playing');
    btnElement.disabled = true;

    // 5. ã€æ ¸å¿ƒã€‘æŒ‰èŠ‚å¥æ’­æ”¾é€»è¾‘
    const now = Tone.now();
    let accumulatedTime = 0; // ç´¯è®¡æ—¶é—´è½´ï¼Œç”¨äºè®¡ç®—ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„æ’­æ”¾æ—¶é—´ç‚¹

    notes.forEach((noteObj) => {
        // ç®€å•çš„æ­£åˆ™æ£€æŸ¥éŸ³ç¬¦æ ¼å¼ (å¦‚ C4, D#5)
        if (noteObj.n && /^[A-G][#b]?[0-9]$/.test(noteObj.n)) {
            // è®¡ç®—å½“å‰éŸ³ç¬¦çš„æ—¶é•¿ (ç§’)
            const durationInSeconds = Tone.Time(noteObj.d).toSeconds();
            
            // åœ¨å½“å‰ç´¯è®¡çš„æ—¶é—´ç‚¹è§¦å‘å£°éŸ³
            // triggerAttackRelease(éŸ³é«˜, æŒç»­æ—¶é—´, è§¦å‘æ—¶é—´ç‚¹)
            globalPolySynth.triggerAttackRelease(noteObj.n, noteObj.d, now + accumulatedTime);
            
            // ç´¯åŠ æ—¶é—´ï¼Œè®©ä¸‹ä¸€ä¸ªéŸ³ç¬¦æ’åœ¨åé¢
            accumulatedTime += durationInSeconds;
        }
    });

    // 6. æ’­æ”¾ç»“æŸé‡ç½®
    // ç­‰å¾…æ€»æ—¶é•¿ + 0.5ç§’ä½™éŸ³åï¼Œæ¢å¤æŒ‰é’®
    setTimeout(() => {
        btnElement.textContent = "â–¶";
        btnElement.classList.remove('playing');
        btnElement.disabled = false;
    }, accumulatedTime * 1000 + 500);
}
// æš´éœ²ç»™å…¨å±€
window.playSynthScore = playSynthScore;
// --- To-Do List é€»è¾‘å¼€å§‹ ---

function getTodoDateString(date) {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
}


async function openTodoList() {
    if (!state.activeChatId) return;
    
    // é‡ç½®åˆ°ä»Šå¤©
    currentTodoDate = new Date();
    updateTodoDateDisplay();
    await renderTodoList();
    
    showScreen('todo-list-screen');
}

function updateTodoDateDisplay() {
    const displayEl = document.getElementById('todo-current-date-display');
    const now = new Date();
    const dateStr = getTodoDateString(currentTodoDate);
    const todayStr = getTodoDateString(now);
    
    if (dateStr === todayStr) {
        displayEl.textContent = "ä»Šå¤©";
    } else {
        displayEl.textContent = dateStr;
    }
}

function changeTodoDate(days) {
    currentTodoDate.setDate(currentTodoDate.getDate() + days);
    updateTodoDateDisplay();
    renderTodoList();
}

// 1. ä¿®æ”¹ renderTodoList
async function renderTodoList() {
    const container = document.getElementById('todo-list-container');
    container.innerHTML = '';
    
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    const targetDateStr = getTodoDateString(currentTodoDate);
    const todos = chat.todoList || [];
    
    // ç­›é€‰å½“å¤©çš„ä»»åŠ¡
    const dayTodos = todos.filter(t => t.date === targetDateStr);
    
    // æ’åº
    dayTodos.sort((a, b) => {
        if (a.status === b.status) {
            return (a.time || '00:00').localeCompare(b.time || '00:00');
        }
        return a.status === 'completed' ? 1 : -1;
    });

    if (dayTodos.length === 0) {
        container.innerHTML = `<div class="todo-empty-state">ğŸ“… ${targetDateStr}<br>æš‚æ— å¾…åŠäº‹é¡¹</div>`;
        return;
    }

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šå­˜å…¥ç¼“å­˜ï¼Œé‡ç½®è®¡æ•°ï¼Œè°ƒç”¨åˆ†æ‰¹åŠ è½½ ---
    todoCache = dayTodos;
    todoRenderCount = 0;
    loadMoreTodos();
}

// 2. æ–°å¢ loadMoreTodos
function loadMoreTodos() {
    if (isLoadingMoreTodos) return;

    const container = document.getElementById('todo-list-container');
    if (!container) return;

    if (todoRenderCount >= todoCache.length) return;

    isLoadingMoreTodos = true;
    const BATCH_SIZE = 30; // æ¯æ¬¡åŠ è½½30æ¡
    const nextSliceEnd = todoRenderCount + BATCH_SIZE;
    const itemsToRender = todoCache.slice(todoRenderCount, nextSliceEnd);

    const fragment = document.createDocumentFragment();

    itemsToRender.forEach(todo => {
        const item = document.createElement('div');
        const isUser = (todo.creator === 'user' || !todo.creator);
        const creatorClass = isUser ? 'is-user' : 'is-char';
        
        item.className = `todo-item ${todo.status} ${creatorClass}`;
        item.dataset.id = todo.id;
        
        const colorMap = {
            'æ—¥å¸¸': '#8e8e93', 'å·¥ä½œ': '#007aff', 'é‡è¦': '#ff3b30', 
            'ç”Ÿæ´»': '#34c759', 'çº¦ä¼š': '#af52de', 'å­¦ä¹ ': '#ff9500','è®°è´¦': '#ffc107'
        };
        const tagColor = colorMap[todo.type] || '#8e8e93';

        item.innerHTML = `
            <div class="todo-checkbox"></div>
            <div class="todo-info">
                <div class="todo-content">${escapeHTML(todo.content)}</div>
                <div class="todo-meta">
                    <span class="todo-tag" style="--tag-color: ${tagColor};">${todo.type || 'æ—¥å¸¸'}</span>
                    ${todo.time ? `<span class="todo-time">â° ${todo.time}</span>` : ''}
                </div>
            </div>
            <button class="todo-delete-btn">Ã—</button>
        `;
        
        item.querySelector('.todo-checkbox').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleTodoStatus(todo.id);
        });

        item.querySelector('.todo-delete-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            deleteTodo(todo.id);
        });
        
        item.addEventListener('click', () => openTodoEditor(todo));

        fragment.appendChild(item);
    });

    container.appendChild(fragment);
    todoRenderCount += itemsToRender.length;
    isLoadingMoreTodos = false;
}

async function toggleTodoStatus(id) {
    const chat = state.chats[state.activeChatId];
    const todo = chat.todoList.find(t => t.id === id);
    
    if (todo) {
        // 1. åˆ‡æ¢çŠ¶æ€
        const isCompleting = todo.status !== 'completed';
        todo.status = isCompleting ? 'completed' : 'pending';
        
        // 2. ã€æ ¸å¿ƒã€‘åªä¿ç•™è®°å½•ç³»ç»Ÿæç¤ºï¼Œåˆ é™¤äº† triggerAiResponse
        if (isCompleting) { 
            const myNickname = chat.settings.myNickname || 'æˆ‘';
            
            // æ„é€ ç³»ç»Ÿæç¤ºè¯ï¼Œåªä½œä¸ºè®°å¿†æ¤å…¥
            const systemHint = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·(${myNickname}) åˆšåˆšåœ¨å¾…åŠæ¸…å•ä¸­å‹¾é€‰å®Œæˆäº†ï¼šâ€œ${todo.content}â€ã€‚]`;

            // æ’å…¥éšè—æ¶ˆæ¯
            const hiddenMsg = {
                role: 'system',
                content: systemHint,
                timestamp: Date.now(),
                isHidden: true // ç”¨æˆ·çœ‹ä¸è§ï¼ŒAIä¸‹æ¬¡ç”Ÿæˆæ—¶èƒ½çœ‹è§
            };
            
            chat.history.push(hiddenMsg);
        }

        // 3. ä¿å­˜å¹¶åˆ·æ–°ç•Œé¢
        await db.chats.put(chat);
        renderTodoList(); 
    }
}

async function deleteTodo(id) {
    const confirmed = await showCustomConfirm("åˆ é™¤äº‹é¡¹", "ç¡®å®šè¦åˆ é™¤è¿™æ¡å¾…åŠäº‹é¡¹å—ï¼Ÿ");
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.todoList = chat.todoList.filter(t => t.id !== id);
        await db.chats.put(chat);
        renderTodoList();
    }
}

function openTodoEditor(todo = null) {
    const modal = document.getElementById('todo-editor-modal');
    const titleEl = document.getElementById('todo-editor-title');
    
    editingTodoId = todo ? todo.id : null;
    titleEl.textContent = todo ? 'ç¼–è¾‘äº‹é¡¹' : 'æ·»åŠ äº‹é¡¹';
    
    document.getElementById('todo-content-input').value = todo ? todo.content : '';
    document.getElementById('todo-date-input').value = todo ? todo.date : getTodoDateString(currentTodoDate);
    document.getElementById('todo-time-input').value = todo ? todo.time : '';
    
    // é‡ç½®å¹¶è®¾ç½®ç±»å‹é€‰ä¸­
    const typeOptions = document.querySelectorAll('.todo-type-option');
    typeOptions.forEach(opt => opt.classList.remove('active'));
    const targetType = todo ? todo.type : 'æ—¥å¸¸';
    const activeOption = Array.from(typeOptions).find(opt => opt.dataset.value === targetType);
    if (activeOption) activeOption.classList.add('active');
    
    modal.classList.add('visible');
}

async function saveTodo() {
    const content = document.getElementById('todo-content-input').value.trim();
    const date = document.getElementById('todo-date-input').value;
    const time = document.getElementById('todo-time-input').value;
    const typeEl = document.querySelector('.todo-type-option.active');
    const type = typeEl ? typeEl.dataset.value : 'æ—¥å¸¸';

    if (!content || !date) {
        alert("å†…å®¹å’Œæ—¥æœŸä¸èƒ½ä¸ºç©ºï¼");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.todoList) chat.todoList = [];

    if (editingTodoId) {
        const todo = chat.todoList.find(t => t.id === editingTodoId);
        if (todo) {
            todo.content = content;
            todo.date = date;
            todo.time = time;
            todo.type = type;
        }
    } else {
        chat.todoList.push({
            id: Date.now(),
            content,
            date,
            time,
            type,
            status: 'pending',
            creator: 'user',
            timestamp: Date.now()
        });
    }

    await db.chats.put(chat);
    
    // å¦‚æœæ—¥è®°æ—¥æœŸå˜äº†ï¼Œè·³è½¬åˆ°è¯¥æ—¥æœŸ
    const newDate = new Date(date);
    if (!isNaN(newDate.getTime())) {
         currentTodoDate = newDate;
         updateTodoDateDisplay();
    }

    document.getElementById('todo-editor-modal').classList.remove('visible');
    renderTodoList();
}
// --- To-Do List é€»è¾‘ç»“æŸ ---
// ==========================================
// â–¼â–¼â–¼ ç»¿æ±Ÿ (Green River) åŒäººåˆ›ä½œæ¨¡å— â–¼â–¼â–¼
// ==========================================

let grState = {
    activeStoryId: null,
    isGenerating: false
};

// é»˜è®¤ä½œè€…é¢„è®¾
const DEFAULT_AUTHORS = [
    { name: "ç»†è…»æƒ…æ„Ÿ", style: "ä¾§é‡å¿ƒç†æå†™ï¼Œæ–‡ç¬”ç»†è…»ï¼Œæ“…é•¿æ•æ‰äººç‰©é—´å¾®å¦™çš„æƒ…æ„ŸæµåŠ¨ï¼Œæ°›å›´æ„Ÿå¼ºã€‚", maxOutput: 600 },
    { name: "æ­£å‰§å‰§æƒ…", style: "æ³¨é‡å‰§æƒ…é€»è¾‘ï¼ŒèŠ‚å¥ç´§å‡‘ï¼Œå¯¹ç™½å¹²ç»ƒï¼Œæ“…é•¿æ¨åŠ¨æ•…äº‹æƒ…èŠ‚å‘å±•ã€‚", maxOutput: 800 },
    { name: "è½»æ¾æ—¥å¸¸", style: "å¹½é»˜é£è¶£ï¼Œè½»æ¾æ„‰å¿«ï¼Œå¤šç”¨ç”ŸåŠ¨çš„å¯¹è¯å’Œæœ‰è¶£çš„ç»†èŠ‚æå†™ï¼Œæ²»æ„ˆç³»ã€‚", maxOutput: 500 },
    { name: "æ„è¯†æµ", style: "å¤§é‡ä½¿ç”¨éšå–»å’Œè±¡å¾ï¼Œå¥å¼ä¼˜ç¾å¤æ‚ï¼Œç€é‡äºæ„è±¡å’Œå“²å­¦æ€è€ƒï¼Œå¼±åŒ–å…·ä½“æƒ…èŠ‚ã€‚", maxOutput: 400 },
    
    // è‘—åä½œå®¶æ–‡é£
    { name: "é²è¿…", style: "çŠ€åˆ©æ·±åˆ»ï¼Œå–„ç”¨è®½åˆºå’Œæ‰¹åˆ¤ï¼Œæ–‡ç¬”ç®€ç»ƒæœ‰åŠ›ï¼Œæ­éœ²ç¤¾ä¼šé»‘æš—é¢ï¼Œè¯­è¨€è¾›è¾£è€Œå¯Œæœ‰æˆ˜æ–—æ€§ã€‚å¤šç”¨çŸ­å¥ï¼ŒèŠ‚å¥æ˜å¿«ï¼Œå¸¸æœ‰æ·±åˆ»çš„ç¤¾ä¼šæ´å¯Ÿã€‚", maxOutput: 600 },
    { name: "å¼ çˆ±ç²", style: "ç»†è…»æ•æ„Ÿï¼Œæ“…é•¿æå†™éƒ½å¸‚ç”·å¥³çš„æƒ…æ„Ÿçº è‘›ï¼Œæ–‡å­—åä¸½è€Œè‹å‡‰ï¼Œå–„ç”¨æ¯”å–»å’Œæ„è±¡ï¼Œç¬”è§¦å†·é™å…‹åˆ¶ï¼Œå……æ»¡äººç”Ÿå†µå‘³ã€‚å…³æ³¨ç»†èŠ‚ï¼Œæ°›å›´æ„Ÿæå¼ºã€‚", maxOutput: 700 },
    { name: "è€èˆ", style: "äº¬å‘³åè¶³ï¼Œè¯­è¨€ç”ŸåŠ¨å¹½é»˜ï¼Œå–„äºåˆ»ç”»å°äººç‰©çš„æ‚²æ¬¢ç¦»åˆï¼Œæ–‡å­—æœ´å®è€Œå¯Œæœ‰ç”Ÿæ´»æ°”æ¯ï¼Œå¯¹è¯ç”ŸåŠ¨ä¼ ç¥ï¼Œå……æ»¡å¸‚äº•çƒŸç«å‘³ã€‚", maxOutput: 650 },
    { name: "æ²ˆä»æ–‡", style: "æŠ’æƒ…è¯—æ„ï¼Œæ–‡å­—æ¸…æ–°éš½æ°¸ï¼Œå–„äºæç»˜æ¹˜è¥¿é£æƒ…å’Œäººæ€§ç¾å¥½ï¼Œç¬”è§¦ç»†è…»æ¸©å©‰ï¼Œå……æ»¡è¯—æ„å’Œç”»é¢æ„Ÿï¼Œè¯­è¨€ä¼˜ç¾æµç•…ã€‚", maxOutput: 600 },
    { name: "é’±é’Ÿä¹¦", style: "åšå­¦æœºæ™ºï¼Œè¯­è¨€å¹½é»˜è®½åˆºï¼Œå–„ç”¨å…¸æ•…å’Œæ¯”å–»ï¼Œæ–‡å­—é›…è‡´è€ŒçŠ€åˆ©ï¼Œå……æ»¡çŸ¥è¯†åˆ†å­çš„ç¿æ™ºå’Œè°ƒä¾ƒï¼Œå™è¿°é£æ ¼ç‹¬ç‰¹ã€‚", maxOutput: 700 },
    { name: "å·´é‡‘", style: "æ¿€æƒ…æ¾æ¹ƒï¼Œæ–‡å­—çœŸæŒšçƒ­çƒˆï¼Œå…³æ³¨ç¤¾ä¼šç°å®å’Œäººæ€§æŒ£æ‰ï¼Œç¬”è§¦é¥±å«æ„Ÿæƒ…ï¼Œè¯­è¨€æµç•…è‡ªç„¶ï¼Œå……æ»¡ç†æƒ³ä¸»ä¹‰è‰²å½©ã€‚", maxOutput: 650 },
    { name: "æ—è¯­å ‚", style: "å¹½é»˜é›…è‡´ï¼Œä¸­è¥¿åˆç’§ï¼Œæ–‡å­—é—²é€‚è‡ªåœ¨ï¼Œå–„äºè®®è®ºå’ŒæŠ’æƒ…ï¼Œè¯­è¨€è½»æ¾è¯™è°ï¼Œå……æ»¡ç”Ÿæ´»å“²ç†å’Œäººç”Ÿæ™ºæ…§ã€‚", maxOutput: 600 },
    { name: "å†°å¿ƒ", style: "æ¸…æ–°çº¯å‡€ï¼Œæ–‡å­—æ¸©å©‰æŸ”ç¾ï¼Œå–„äºæŠ’å‘æ¯çˆ±ã€ç«¥çœŸå’Œè‡ªç„¶ä¹‹ç¾ï¼Œç¬”è§¦ç»†è…»çœŸæŒšï¼Œè¯­è¨€ä¼˜ç¾å¦‚è¯—ï¼Œå……æ»¡æ¸©æƒ…ã€‚", maxOutput: 500 },
    { name: "ä½™å", style: "å†·å³»å…‹åˆ¶ï¼Œå–„äºæå†™å‘½è¿çš„è’è¯å’Œäººæ€§çš„åšéŸ§ï¼Œæ–‡å­—ç®€æ´æœ‰åŠ›ï¼Œå™äº‹å†·é™å®¢è§‚ï¼Œå´èƒ½ç›´å‡»äººå¿ƒï¼Œå……æ»¡æ‚²æ‚¯æƒ…æ€€ã€‚", maxOutput: 650 },
    { name: "è«è¨€", style: "é­”å¹»ç°å®ï¼Œæƒ³è±¡åŠ›ä¸°å¯Œï¼Œæ–‡å­—æ£è‚†æ±ªæ´‹ï¼Œå–„äºç”¨æ°‘é—´ä¼ è¯´å’Œä¹¡åœŸå…ƒç´ ï¼Œè¯­è¨€æµ“çƒˆå¥”æ”¾ï¼Œå……æ»¡ç”Ÿå‘½åŠ›å’Œå¼ åŠ›ã€‚", maxOutput: 800 }
];

// 1. åˆå§‹åŒ–æ•°æ® (åœ¨ openGreenRiverScreen æ—¶è°ƒç”¨)
async function initGreenRiverData() {
    const count = await db.grAuthors.count();
    if (count === 0) {
        await db.grAuthors.bulkAdd(DEFAULT_AUTHORS);
    }
}

// 2. æ‰“å¼€ä¸»ç•Œé¢
async function openGreenRiverScreen() {
    await initGreenRiverData();
    showScreen('green-river-screen');
    renderBookList();
}

// 3. æ¸²æŸ“ä¹¦æ¶
// æ‰¾åˆ° renderBookList å‡½æ•°ï¼Œæ›¿æ¢æ•´ä¸ªå‡½æ•°
async function renderBookList() {
    const listEl = document.getElementById('gr-book-list');
    listEl.innerHTML = '';
    
    const stories = await db.grStories.orderBy('lastUpdated').reverse().toArray();
    const authors = await db.grAuthors.toArray();
    const authorMap = new Map(authors.map(a => [a.id, a.name]));
    
    // è·å–å·²å…³è”çš„ä¹¦ç±IDé›†åˆ
    const existingBooks = await db.readingLibrary.toArray();
    const linkedIds = new Set(existingBooks.map(b => b.linkedStoryId).filter(id => id));

    if (stories.length === 0) {
        listEl.innerHTML = '<p style="grid-column:1/-1; text-align:center; color:var(--gr-text-sub); margin-top:50px;">ä¹¦æ¶æ˜¯ç©ºçš„ï¼Œç‚¹å‡»å³ä¸Šè§’æ–°å»ºä¸€éƒ¨ä½œå“å§ã€‚</p>';
        return;
    }

    stories.forEach(story => {
        const authorName = authorMap.get(story.authorId) || 'æœªçŸ¥ä½œè€…';
        const div = document.createElement('div');
        div.className = 'gr-book-card';
        
        const wordCount = story.chapters.reduce((acc, ch) => acc + ch.content.length, 0);
        
        // ã€æ ¸å¿ƒé€»è¾‘ä¿®æ”¹ã€‘
        const isAdded = linkedIds.has(story.id);
        // å¦‚æœå·²åŠ å…¥ï¼Œæ˜¾ç¤ºâ€œå·²åœ¨ä¹¦æ¶â€ï¼Œç‚¹å‡»è§¦å‘ç§»é™¤ï¼›å¦åˆ™æ˜¾ç¤ºâ€œåŠ å…¥â€ï¼Œç‚¹å‡»è§¦å‘åŠ å…¥
        const btnText = isAdded ? 'å·²åœ¨ä¹¦æ¶' : 'åŠ å…¥å…±è¯»';
        const btnClass = isAdded ? 'gr-add-shelf-btn added' : 'gr-add-shelf-btn';
        const actionFn = isAdded ? 'removeGreenRiverFromShelf' : 'addGreenRiverToShelf';
        
        div.innerHTML = `
            <div>
                <div class="gr-book-title">${story.title}</div>
                <div class="gr-book-meta">
                    <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                    ${authorName}
                </div>
            </div>
            <div class="gr-book-meta" style="justify-content: space-between; margin-top:15px; align-items: flex-end;">
                <div style="display:flex; flex-direction:column; gap:2px;">
                    <span>${story.chapters.length} ç« </span>
                    <span>${(wordCount/1000).toFixed(1)}k å­—</span>
                </div>
                <button class="${btnClass}" onclick="event.stopPropagation(); ${actionFn}(${story.id}, this);">
                    ${isAdded ? 'âœ“ ' : '+ '}${btnText}
                </button>
            </div>
        `;
        
        div.onclick = (e) => {
            if(e.target.tagName !== 'BUTTON') openReader(story.id);
        };
        
        addLongPressListener(div, async () => {
             if(confirm(`ç¡®å®šè¦åˆ é™¤ä½œå“ã€Š${story.title}ã€‹å—ï¼Ÿ`)) {
                 await db.grStories.delete(story.id);
                 renderBookList();
             }
        });
        
        listEl.appendChild(div);
    });
}

// 4. ä½œè€…ç®¡ç†
// --- ç»¿æ±Ÿä½œè€…ç®¡ç†é‡æ„ (ä¿®å¤å¸ƒå±€å’Œç¼–è¾‘åŠŸèƒ½) ---

let editingAuthorId = null; // ç”¨äºè®°å½•å½“å‰æ­£åœ¨ç¼–è¾‘çš„ä½œè€…ID

// 1. æ‰“å¼€ä½œè€…ç®¡ç†åˆ—è¡¨ (æ¸²æŸ“ç•Œé¢)
async function openAuthorManager() {
    showScreen('gr-author-screen');
    const listEl = document.getElementById('gr-author-list');
    listEl.innerHTML = '';
    
    const authors = await db.grAuthors.toArray();
    
    if (authors.length === 0) {
         listEl.innerHTML = '<p style="text-align:center; color:#999; margin-top:50px;">è¿˜æ²¡æœ‰è®¾å®šä½œè€…ï¼Œç‚¹å‡»å³ä¸Šè§’â€œ+â€æ·»åŠ ã€‚</p>';
         return;
    }

    authors.forEach(author => {
        const div = document.createElement('div');
        div.className = 'gr-author-item';
        div.innerHTML = `
            <div class="gr-author-info" style="flex-grow: 1; padding-right: 10px; min-width: 0;">
                <h3 style="margin: 0 0 5px 0; font-size: 16px; font-weight: 600; color: #1C1C1E;">${author.name}</h3>
                <p style="margin: 0; font-size: 13px; color: #8E8E93; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.5;">${author.style}</p>
            </div>
            <div class="gr-author-actions">
                <button class="gr-icon-btn" onclick="openAuthorEditor(${author.id})" title="ç¼–è¾‘">
                   <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button class="gr-icon-btn" style="color:#ff3b30;" onclick="deleteAuthor(${author.id})" title="åˆ é™¤">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        `;
        listEl.appendChild(div);
    });
}

// 2. æ‰“å¼€ç¼–è¾‘/æ·»åŠ å¼¹çª—
// å¦‚æœä¼ å…¥ idï¼Œåˆ™æ˜¯ç¼–è¾‘æ¨¡å¼ï¼›å¦åˆ™æ˜¯æ·»åŠ æ¨¡å¼
async function openAuthorEditor(id = null) {
    editingAuthorId = id;
    const modal = document.getElementById('gr-author-editor-modal');
    const titleEl = document.getElementById('gr-author-editor-title');
    const nameInput = document.getElementById('gr-author-name-input');
    const styleInput = document.getElementById('gr-author-style-input');

    if (id) {
        // ç¼–è¾‘æ¨¡å¼ï¼šå›æ˜¾æ•°æ®
        const author = await db.grAuthors.get(id);
        if (author) {
            titleEl.textContent = "ç¼–è¾‘ä½œè€…";
            nameInput.value = author.name;
            styleInput.value = author.style;
        }
    } else {
        // æ·»åŠ æ¨¡å¼ï¼šæ¸…ç©ºæ•°æ®
        titleEl.textContent = "æ·»åŠ ä½œè€…";
        nameInput.value = "";
        styleInput.value = "";
    }

    modal.classList.add('visible');
}

// 3. ä¿å­˜ä½œè€… (ç”±å¼¹çª—å†…çš„ä¿å­˜æŒ‰é’®è°ƒç”¨)
async function saveAuthor() {
    const name = document.getElementById('gr-author-name-input').value.trim();
    const style = document.getElementById('gr-author-style-input').value.trim();

    if (!name || !style) {
        alert("åç§°å’Œé£æ ¼æè¿°éƒ½ä¸èƒ½ä¸ºç©ºï¼");
        return;
    }

    if (editingAuthorId) {
        // æ›´æ–°
        await db.grAuthors.update(editingAuthorId, { name, style });
    } else {
        // æ–°å¢
        await db.grAuthors.add({ name, style, maxOutput: 600 });
    }

    // å…³é—­å¼¹çª—å¹¶åˆ·æ–°åˆ—è¡¨
    document.getElementById('gr-author-editor-modal').classList.remove('visible');
    openAuthorManager();
}

// 4. åˆ é™¤ä½œè€…
async function deleteAuthor(id) {
    const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šåˆ é™¤è¿™ä½ä½œè€…è®¾å®šå—ï¼Ÿ\n(è¿™ä¸ä¼šå½±å“å·²ç”Ÿæˆçš„ç« èŠ‚å†…å®¹)", { confirmButtonClass: 'btn-danger' });
    if(confirmed) {
        await db.grAuthors.delete(id);
        openAuthorManager();
    }
}

// 5. ç»‘å®šå¤´éƒ¨â€œ+â€æŒ‰é’®åˆ°æ–°çš„ç¼–è¾‘å™¨é€»è¾‘
// (è¿™ä¸ªå‡½æ•°åä¸HTMLä¸­çš„onclick="addAuthor()"å¯¹åº”ï¼Œæˆ‘ä»¬å°†å…¶é‡å®šå‘åˆ°openAuthorEditor)
function addAuthor() {
    openAuthorEditor(null);
}

// 6. ç»‘å®šä¿å­˜æŒ‰é’®äº‹ä»¶ (åœ¨åˆå§‹åŒ–æ—¶æ‰§è¡Œä¸€æ¬¡å³å¯ï¼Œé˜²æ­¢é‡å¤ç»‘å®š)
const saveBtn = document.getElementById('gr-save-author-btn');
if (saveBtn) {
    // ä½¿ç”¨ cloneNode ç§»é™¤æ—§çš„ç›‘å¬å™¨ (å¦‚æœæœ‰çš„è¯)
    const newBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newBtn, saveBtn);
    newBtn.onclick = saveAuthor;
}

// æš´éœ²ç»™å…¨å±€
window.openAuthorManager = openAuthorManager;
window.openAuthorEditor = openAuthorEditor;
window.addAuthor = addAuthor;
window.deleteAuthor = deleteAuthor;

// 5. æ–°å»ºä½œå“ (è®¾ç½®é¡µ)
async function createNewStory() {
    grState.activeStoryId = null; // æ ‡è®°ä¸ºæ–°å»º
    document.getElementById('gr-story-title').value = '';
    await loadStorySettingsUI();
    document.getElementById('gr-settings-modal').classList.add('visible');
}

async function openStorySettings() {
    if(!grState.activeStoryId) return;
    const story = await db.grStories.get(grState.activeStoryId);
    if(!story) return;

    document.getElementById('gr-story-title').value = story.title;
    await loadStorySettingsUI(story.settings, story.authorId);
    
    document.getElementById('gr-settings-modal').classList.add('visible');
}

// åŠ è½½è®¾ç½®å¼¹çª—ä¸­çš„é€‰é¡¹
// åŠ è½½è®¾ç½®å¼¹çª—ä¸­çš„é€‰é¡¹ (ä¿®å¤ç‰ˆï¼šå¢åŠ å­—æ•°å’Œæ¡æ•°çš„å›æ˜¾)
async function loadStorySettingsUI(settings = {}, selectedAuthorId = null) {
    // 1. åŠ è½½ä½œè€…åˆ—è¡¨
    const authorSelect = document.getElementById('gr-author-select');
    authorSelect.innerHTML = '';
    const authors = await db.grAuthors.toArray();
    authors.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.id;
        opt.textContent = a.name;
        if(selectedAuthorId === a.id) opt.selected = true;
        authorSelect.appendChild(opt);
    });

    // 2. åŠ è½½è§’è‰²åˆ—è¡¨ (Chats + NPCs)
    const charList = document.getElementById('gr-char-list');
    charList.innerHTML = '';
    const chars = Object.values(state.chats); 
    const npcs = await db.npcs.toArray();
    
    const allEntities = [
        ...chars.map(c => ({ id: c.id, name: c.name, type: c.isGroup ? 'ç¾¤èŠ' : 'è§’è‰²' })),
        ...npcs.map(n => ({ id: `npc_${n.id}`, name: n.name, type: 'NPC' }))
    ];

    allEntities.forEach(item => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        // å›æ˜¾ï¼šæ£€æŸ¥æ˜¯å¦åœ¨å·²ä¿å­˜çš„åˆ—è¡¨ä¸­
        const isChecked = settings.charIds && settings.charIds.includes(item.id);
        div.innerHTML = `<input type="checkbox" value="${item.id}" ${isChecked?'checked':''}> <span>${item.name} <small style="color:#999">(${item.type})</small></span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        charList.appendChild(div);
    });

    // 3. åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨
    const wbList = document.getElementById('gr-worldbook-list');
    wbList.innerHTML = '';
    const books = await db.worldBooks.toArray();
    books.forEach(book => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        // å›æ˜¾ï¼šæ£€æŸ¥æ˜¯å¦åœ¨å·²ä¿å­˜çš„åˆ—è¡¨ä¸­
        const isChecked = settings.bookIds && settings.bookIds.includes(book.id);
        div.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked?'checked':''}> <span>${book.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        wbList.appendChild(div);
    });
    
    // 4. åŠ è½½Useré¢„è®¾
    const userSelect = document.getElementById('gr-user-persona-select');
    userSelect.innerHTML = '<option value="">å½“å‰é»˜è®¤</option>';
    const presets = await db.personaPresets.toArray();
    presets.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.persona.substring(0, 20) + '...';
        // å›æ˜¾ï¼šé€‰ä¸­å·²ä¿å­˜çš„ User Persona
        if(settings.userPersonaId === p.id) opt.selected = true;
        userSelect.appendChild(opt);
    });

    // 5. ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šå›æ˜¾å­—æ•°å’Œä¸Šä¸‹æ–‡æ¡æ•°
    // å¦‚æœ settings é‡Œæœ‰å€¼ï¼Œå°±ç”¨ settings é‡Œçš„ï¼›å¦‚æœæ²¡æœ‰ï¼ˆæ–°å»ºæ—¶ï¼‰ï¼Œå°±ç”¨é»˜è®¤å€¼ 500 å’Œ 20
    document.getElementById('gr-output-length').value = settings.outputLength || 500;
    document.getElementById('gr-context-limit').value = settings.contextLimit || 20;
    document.getElementById('gr-macro-world-view').value = settings.macroWorldView || '';
    
    // 6. åŠ è½½ä½œè€…è¿½æ›´ç›¸å…³è®¾ç½®
    const autoUpdateEnabled = document.getElementById('gr-auto-update-enabled');
    const autoUpdateSettings = document.getElementById('gr-auto-update-settings');
    const updateType = document.getElementById('gr-auto-update-type');
    const updateAuthorSelect = document.getElementById('gr-update-author-select');
    const updateCharacterSelect = document.getElementById('gr-update-character-select');
    const updateFrequency = document.getElementById('gr-update-frequency');
    const customFrequencyGroup = document.getElementById('gr-custom-frequency-group');
    const customFrequencyHours = document.getElementById('gr-custom-frequency-hours');
    
    // å›æ˜¾è¿½æ›´å¼€å…³
    autoUpdateEnabled.checked = settings.autoUpdate?.enabled || false;
    autoUpdateSettings.style.display = autoUpdateEnabled.checked ? 'block' : 'none';
    
    // å¡«å……ä½œè€…é€‰æ‹©åˆ—è¡¨ï¼ˆè¿½æ›´ç”¨ï¼‰
    updateAuthorSelect.innerHTML = '';
    authors.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.id;
        opt.textContent = a.name;
        if(settings.autoUpdate?.authorId === a.id) opt.selected = true;
        updateAuthorSelect.appendChild(opt);
    });
    
    // å¡«å……è§’è‰²é€‰æ‹©åˆ—è¡¨ï¼ˆè¿½æ›´ç”¨ï¼‰
    updateCharacterSelect.innerHTML = '';
    allEntities.forEach(item => {
        const opt = document.createElement('option');
        opt.value = item.id;
        opt.textContent = `${item.name} (${item.type})`;
        if(settings.autoUpdate?.characterId === item.id) opt.selected = true;
        updateCharacterSelect.appendChild(opt);
    });
    
    // å›æ˜¾è¿½æ›´æ–¹å¼
    updateType.value = settings.autoUpdate?.type || 'author';
    document.getElementById('gr-update-author-select-group').style.display = 
        updateType.value === 'author' ? 'block' : 'none';
    document.getElementById('gr-update-character-select-group').style.display = 
        updateType.value === 'character' ? 'block' : 'none';
    
    // å›æ˜¾æ›´æ–°é¢‘ç‡
    updateFrequency.value = settings.autoUpdate?.frequency || 'manual';
    customFrequencyGroup.style.display = 
        updateFrequency.value === 'custom' ? 'block' : 'none';
    customFrequencyHours.value = settings.autoUpdate?.customHours || 24;
    
    // ç»‘å®šè¿½æ›´è®¾ç½®çš„äº‹ä»¶ç›‘å¬
    autoUpdateEnabled.onchange = () => {
        autoUpdateSettings.style.display = autoUpdateEnabled.checked ? 'block' : 'none';
    };
    
    updateType.onchange = () => {
        document.getElementById('gr-update-author-select-group').style.display = 
            updateType.value === 'author' ? 'block' : 'none';
        document.getElementById('gr-update-character-select-group').style.display = 
            updateType.value === 'character' ? 'block' : 'none';
    };
    
    updateFrequency.onchange = () => {
        customFrequencyGroup.style.display = 
            updateFrequency.value === 'custom' ? 'block' : 'none';
    };
    
    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    const saveBtn = document.getElementById('gr-save-story-btn');
    const cancelBtn = document.getElementById('gr-cancel-settings-btn');
    
    // ä½¿ç”¨ cloneNode æ¸…é™¤æ—§çš„ç›‘å¬å™¨ï¼Œé˜²æ­¢å¤šæ¬¡ç‚¹å‡»
    const newSaveBtn = saveBtn.cloneNode(true);
    const newCancelBtn = cancelBtn.cloneNode(true);
    
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

    newSaveBtn.onclick = () => saveStorySettings();
    newCancelBtn.onclick = () => document.getElementById('gr-settings-modal').classList.remove('visible');
}

// 5. ä¿®å¤ç‰ˆï¼šä¿å­˜ä½œå“è®¾ç½®
async function saveStorySettings() {
    // è·å– DOM å…ƒç´ 
    const titleInput = document.getElementById('gr-story-title');
    const authorSelect = document.getElementById('gr-author-select');
    const userPersonaSelect = document.getElementById('gr-user-persona-select');
    const outputLengthInput = document.getElementById('gr-output-length'); // æ£€æŸ¥HTML IDæ˜¯å¦ä¸€è‡´
    const contextLimitInput = document.getElementById('gr-context-limit'); // æ£€æŸ¥HTML IDæ˜¯å¦ä¸€è‡´
    const macroWorldViewInput = document.getElementById('gr-macro-world-view');
    const title = titleInput.value.trim();
    const authorId = parseInt(authorSelect.value);
    
    const charIds = Array.from(document.querySelectorAll('#gr-char-list input:checked')).map(cb => cb.value);
    const bookIds = Array.from(document.querySelectorAll('#gr-worldbook-list input:checked')).map(cb => cb.value);
    const userPersonaId = userPersonaSelect.value;
    
    // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šç¡®ä¿è¿™é‡Œå–åˆ°çš„æ˜¯æ•°å­—ï¼Œå¹¶ä¸”æœ‰é»˜è®¤å€¼
    const outputLength = parseInt(outputLengthInput.value) || 500;
    const contextLimit = parseInt(contextLimitInput.value) || 20;
    const macroWorldView = macroWorldViewInput.value.trim();
    if (!title) return alert("è¯·è¾“å…¥ä¹¦å");
    if (charIds.length === 0) return alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²æˆ–ç¾¤èŠ");

    // è·å–ä½œè€…è¿½æ›´è®¾ç½®
    const autoUpdateEnabled = document.getElementById('gr-auto-update-enabled').checked;
    const autoUpdate = autoUpdateEnabled ? {
        enabled: true,
        type: document.getElementById('gr-auto-update-type').value,
        authorId: parseInt(document.getElementById('gr-update-author-select').value),
        characterId: document.getElementById('gr-update-character-select').value,
        frequency: document.getElementById('gr-update-frequency').value,
        customHours: parseInt(document.getElementById('gr-custom-frequency-hours').value) || 24,
        lastUpdate: null // é¦–æ¬¡åˆ›å»ºæ—¶ä¸ºnullï¼Œä¹‹åä¼šè®°å½•æœ€åæ›´æ–°æ—¶é—´
    } : {
        enabled: false
    };
    
    const settings = { 
        charIds, 
        bookIds, 
        userPersonaId, 
        outputLength, // è¿™é‡Œçš„åå­—è¦å’Œ prompt é‡Œçš„å¯¹åº”
        contextLimit,
        macroWorldView,
        autoUpdate // æ·»åŠ ä½œè€…è¿½æ›´è®¾ç½®
    };

    if (grState.activeStoryId) {
        // æ›´æ–°ç°æœ‰ä½œå“
        await db.grStories.update(grState.activeStoryId, { title, authorId, settings });
    } else {
        // æ–°å»ºä½œå“
        const newStory = {
            title,
            authorId,
            settings,
            chapters: [],
            lastUpdated: Date.now()
        };
        grState.activeStoryId = await db.grStories.add(newStory);
    }
    
    document.getElementById('gr-settings-modal').classList.remove('visible');
    
    // æ‰“å¼€é˜…è¯»å™¨ï¼Œå¹¶å®šä½åˆ°æœ€æ–°ä¸€ç« 
    const story = await db.grStories.get(grState.activeStoryId);
    const lastIndex = Math.max(0, story.chapters.length - 1);
    openReader(grState.activeStoryId, lastIndex);
}

// 6. é˜…è¯»å™¨é€»è¾‘ - åˆ†é¡µç‰ˆ (Jinjiang Style)
async function openReader(storyId, chapterIndex = 0) {
    grState.activeStoryId = storyId;
    const story = await db.grStories.get(storyId);
    if (!story) return;

    // ç¡®ä¿ç´¢å¼•åˆæ³•
    const totalChapters = story.chapters.length;
    if (totalChapters > 0 && chapterIndex >= totalChapters) chapterIndex = totalChapters - 1;
    if (chapterIndex < 0) chapterIndex = 0;
    
    grState.currentChapterIndex = chapterIndex;

    // æ›´æ–°é¡¶éƒ¨æ ‡é¢˜
    document.getElementById('gr-book-name-display').textContent = story.title;
    
    const contentArea = document.getElementById('gr-reader-content');
    contentArea.innerHTML = '';

    // --- åœºæ™¯ A: å°šæœªå¼€å§‹ (æ²¡æœ‰ç« èŠ‚) ---
    if (totalChapters === 0) {
        document.getElementById('gr-chapter-title-display').textContent = "åºç« ";
        contentArea.innerHTML = `
            <div style="text-align:center; padding-top:100px; color:#888;">
                <p>æ•…äº‹å°šæœªå¼€å§‹ã€‚</p>
                <p>è¯·åœ¨ä¸‹æ–¹è¾“å…¥ç¬¬ä¸€ç« çš„å‰§æƒ…èµ°å‘ï¼Œç‚¹å‡»â€œç»­å†™â€å¼€å§‹åˆ›ä½œã€‚</p>
            </div>
        `;
        // æ˜¾ç¤ºå†™ä½œæ§åˆ¶æ ï¼Œéšè—ç¿»é¡µæ 
        document.getElementById('gr-pagination-controls').style.display = 'none';
        document.getElementById('gr-writing-controls').style.display = 'flex';
        
        // ç»‘å®šç”ŸæˆæŒ‰é’®
        updateGenButtonBinding();
        showScreen('gr-reader-screen');
        return;
    }

    // --- åœºæ™¯ B: æ˜¾ç¤ºç‰¹å®šç« èŠ‚ ---
    const chapter = story.chapters[chapterIndex];
    const chapterTitle = chapter.title || `ç¬¬ ${chapterIndex + 1} ç« `; // å¦‚æœæ²¡æœ‰æ ‡é¢˜ï¼Œä½¿ç”¨é»˜è®¤
    
    document.getElementById('gr-chapter-title-display').textContent = chapterTitle;

    // 1. é¡¶éƒ¨ï¼šå‰æƒ…æè¦ (Context)
    if (chapter.prevSummary) {
        contentArea.innerHTML += `
            <details class="gr-summary-box top-summary">
                <summary>ğŸ“– ä¸Šæ–‡æè¦ (Context)</summary>
                <div class="gr-summary-content" style="font-size:12px; color:#888;">${chapter.prevSummary}</div>
            </details>
        `;
    }

    // 2. ç« èŠ‚å¤§æ ‡é¢˜
    contentArea.innerHTML += `<div class="gr-chapter-title-large">${chapterTitle}</div>`;

    // 3. æ­£æ–‡
    contentArea.innerHTML += `<div class="gr-chapter-text">${chapter.content.replace(/\n/g, '<br>')}</div>`;

    // 4. åº•éƒ¨ï¼šæœ¬ç« æ‘˜è¦ (å¯ç¼–è¾‘)
    const summaryHtml = `
            <div class="gr-summary-card editable">
                <div class="gr-summary-header">
                    <span class="gr-summary-title">Chapter Checkpoint Â· å‰§æƒ…å­˜æ¡£</span>
                    <button class="gr-mini-btn save-summary-btn" data-index="${chapterIndex}">ä¿å­˜ä¿®æ”¹</button>
                </div>
                <textarea class="gr-summary-input" data-index="${chapterIndex}" placeholder="åœ¨æ­¤å¤„æ¦‚æ‹¬æœ¬ç« å…³é”®å‰§æƒ…ç‚¹ï¼Œä¾›AIè®°å¿†...">${chapter.summary || ''}</textarea>
                 <div class="gr-summary-footer">
                    * AIç»­å†™æ—¶å°†è¯»å–æ­¤æ¡†å†…å®¹ä½œä¸ºå”¯ä¸€è®°å¿†ä¾æ®ã€‚
                </div>
            </div>
        `;
        contentArea.innerHTML += summaryHtml;
        contentArea.innerHTML += `<div style="height: 100px;"></div>`;

    // ç»‘å®šä¿å­˜æ‘˜è¦æŒ‰é’®
    contentArea.querySelectorAll('.save-summary-btn').forEach(btn => {
        btn.onclick = (e) => {
            const idx = parseInt(e.target.dataset.index);
            const textarea = contentArea.querySelector(`.gr-summary-input[data-index="${idx}"]`);
            saveChapterSummary(storyId, idx, textarea.value);
            e.target.textContent = "å·²ä¿å­˜";
            setTimeout(() => e.target.style.display = 'none', 1000);
        };
    });

    // 5. æ›´æ–°åº•éƒ¨å¯¼èˆªæ çŠ¶æ€
    const prevBtn = document.getElementById('gr-prev-chapter-btn');
    const nextBtn = document.getElementById('gr-next-chapter-btn');
    const paginationDiv = document.getElementById('gr-pagination-controls');
    const writingDiv = document.getElementById('gr-writing-controls');
    const rerollBtn = document.getElementById('gr-reroll-btn');

    // æ€»æ˜¯æ˜¾ç¤ºåˆ†é¡µæ ï¼Œå†™ä½œæ åªåœ¨æœ€åä¸€é¡µæ˜¾ç¤º
    paginationDiv.style.display = 'flex';
    
    prevBtn.disabled = (chapterIndex === 0);
    prevBtn.onclick = () => openReader(storyId, chapterIndex - 1);

    if (chapterIndex < totalChapters - 1) {
        // å¦‚æœä¸æ˜¯æœ€åä¸€ç« 
        nextBtn.textContent = "ä¸‹ä¸€ç« ";
        nextBtn.onclick = () => openReader(storyId, chapterIndex + 1);
        writingDiv.style.display = 'none'; // éšè—å†™ä½œæ 
    } else {
        // å¦‚æœæ˜¯æœ€åä¸€ç« 
        nextBtn.textContent = "ç»­å†™ä¸‹ä¸€ç« ";
        nextBtn.onclick = () => {
             // ç‚¹å‡»ä¸‹ä¸€ç« æŒ‰é’®æ—¶ï¼Œæ˜¾ç¤ºå†™ä½œæ ï¼Œå¹¶è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
             writingDiv.style.display = 'flex';
             contentArea.scrollTop = contentArea.scrollHeight;
             document.getElementById('gr-direction-input').focus();
        };
        // é»˜è®¤ä¹Ÿæ˜¾ç¤ºå†™ä½œæ 
        writingDiv.style.display = 'flex';
        
        // ç»‘å®šé‡å†™æŒ‰é’®
        rerollBtn.onclick = async () => {
             const confirmed = await showCustomConfirm("é‡å†™æœ¬ç« ", "ç¡®å®šè¦åˆ é™¤å½“å‰ç« èŠ‚å¹¶é‡æ–°ç”Ÿæˆå—ï¼Ÿ", {confirmText:"é‡å†™", confirmButtonClass:"btn-danger"});
             if (confirmed) handleGenerateStoryContent(true);
        };
    }
    
    // ç»‘å®šç”ŸæˆæŒ‰é’®
    updateGenButtonBinding();
    
    showScreen('gr-reader-screen');
    contentArea.scrollTop = 0;
}

// è¾…åŠ©ï¼šç»‘å®šç”ŸæˆæŒ‰é’®
function updateGenButtonBinding() {
    const genBtn = document.getElementById('gr-generate-btn');
    // ä½¿ç”¨å…‹éš†èŠ‚ç‚¹æ¥ç§»é™¤æ—§çš„ç›‘å¬å™¨
    const newBtn = genBtn.cloneNode(true);
    genBtn.parentNode.replaceChild(newBtn, genBtn);
    newBtn.onclick = () => handleGenerateStoryContent(false);
}

// è¾…åŠ©ï¼šæ›´æ–°åº•éƒ¨æ§åˆ¶æ 
function updateControlPanel(story) {
    const controlPanel = document.querySelector('.gr-control-panel');
    // æ¸…ç©ºæ—§å†…å®¹ï¼Œé‡æ–°æ„å»º
    controlPanel.innerHTML = `
        <div style="display:flex; gap:10px; align-items:center; width:100%;">
            <div class="gr-input-group" style="flex-grow:1;">
                <input type="text" id="gr-direction-input" class="gr-input" placeholder="è¾“å…¥å‰§æƒ…èµ°å‘ (ç•™ç©ºåˆ™è‡ªç”±ç»­å†™)...">
            </div>
            
            ${story.chapters.length > 0 ? `
            <button id="gr-reroll-btn" class="gr-main-btn" style="background-color:#F4F4F5; color:#666; border:1px solid #ddd;" title="ä¸æ»¡å½“å‰ç« ï¼Ÿé‡å†™ï¼">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
            </button>
            ` : ''}

            <button id="gr-generate-btn" class="gr-main-btn">
                <span id="gr-gen-text">ç»­å†™</span>
                <svg id="gr-gen-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
            </button>
        </div>
    `;

    // ç»‘å®šäº‹ä»¶
    document.getElementById('gr-generate-btn').onclick = () => handleGenerateStoryContent(false); // false = ä¸æ˜¯é‡å†™
    
    const rerollBtn = document.getElementById('gr-reroll-btn');
    if (rerollBtn) {
        rerollBtn.onclick = async () => {
            const confirmed = await showCustomConfirm("é‡å†™æœ¬ç« ", "ç¡®å®šè¦åˆ é™¤å½“å‰æœ€æ–°ç« èŠ‚å¹¶é‡æ–°ç”Ÿæˆå—ï¼Ÿ\n(å¦‚æœä½ åˆšæ‰ä¿®æ”¹äº†æ‘˜è¦ï¼Œé‡å†™åéœ€è¦é‡æ–°ä¿®æ”¹)", {confirmText:"é‡å†™", confirmButtonClass:"btn-danger"});
            if (confirmed) {
                handleGenerateStoryContent(true); // true = æ˜¯é‡å†™
            }
        };
    }
}

// è¾…åŠ©ï¼šä¿å­˜ä¿®æ”¹åçš„æ‘˜è¦
async function saveChapterSummary(storyId, chapterIndex, newSummary) {
    const story = await db.grStories.get(storyId);
    if (story && story.chapters[chapterIndex]) {
        story.chapters[chapterIndex].summary = newSummary;
        await db.grStories.put(story);
        console.log("æ‘˜è¦å·²æ‰‹åŠ¨æ›´æ–°");
    }
}
// 7. æ ¸å¿ƒç”Ÿæˆé€»è¾‘ (The Writer) - å­—æ•°å¼ºåŠ›ä¿®æ­£ç‰ˆ
async function handleGenerateStoryContent(isReroll = false) {
    if (grState.isGenerating) return;
    
    let story = await db.grStories.get(grState.activeStoryId);
    
    // --- é‡å†™é€»è¾‘ ---
    if (isReroll && story.chapters.length > 0) {
        story.chapters.pop();
        await db.grStories.put(story);
        openReader(story.id, Math.max(0, story.chapters.length - 1));
    }

    const author = await db.grAuthors.get(story.authorId);
    const directionInput = document.getElementById('gr-direction-input');
    const userDirection = directionInput.value.trim();
    
    const genBtn = document.getElementById('gr-generate-btn');
    const btnText = document.getElementById('gr-gen-text'); // è·å–æ–‡å­—æ ‡ç­¾
    grState.isGenerating = true;
    
    if(genBtn) {
        genBtn.disabled = true;
        // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šåŠ äº†åˆ¤æ–­ï¼Œåªæœ‰å½“æ–‡å­—æ ‡ç­¾å­˜åœ¨æ—¶æ‰ä¿®æ”¹æ–‡å­—ï¼Œå¦åˆ™åªç¦ç”¨æŒ‰é’®
        if (btnText) btnText.textContent = "æ’°å†™ä¸­..."; 
    }

    try {
        // è·å–ç›®æ ‡å­—æ•°ï¼Œå¹¶åšä¸€ä¸ªâ€œæº¢ä»·â€å¤„ç†
        // å¦‚æœç”¨æˆ·è®¾ç½® 500ï¼Œæˆ‘ä»¬å‘Šè¯‰ AI å†™ 800ï¼Œè¿™æ ·å®ƒå·æ‡’æ‰“æŠ˜ååˆšå¥½æ˜¯ 500
        const settingValue = parseInt(story.settings.outputLength) || 500;
        const targetWordCount = Math.floor(settingValue * 1.5); 
        
        const historyLimit = story.settings.contextLimit || 20;

        // --- æ„å»ºä¸Šä¸‹æ–‡ ---
        let charsContext = "";
        for (const id of story.settings.charIds) {
            if (id.startsWith('npc_')) {
                const npcId = parseInt(id.replace('npc_', ''));
                const npc = await db.npcs.get(npcId);
                if (npc) charsContext += `- NPC ${npc.name}: ${npc.persona}\n`;
            } else {
                const chat = state.chats[id];
                if (chat) {
                    const memories = (chat.longTermMemory || [])
                        .map(m => `  * ${m.content}`)
                        .join('\n');

                    const history = chat.history.slice(-historyLimit).map(m => {
                        if(m.role === 'system' || m.type === 'red_packet' || m.type === 'waimai_request' || m.type === 'transfer') return null;
                        let content = String(m.content);
                        if(content.includes("çº¢åŒ…") || content.includes("æ‰‹æœº") || content.includes("è½¬è´¦")) return null; 
                        return `  > ${m.senderName}: ${content.substring(0, 50)}`;
                    }).filter(Boolean).join('\n');
                    
                    charsContext += `### è§’è‰²: ${chat.name}\n- **æ ¸å¿ƒäººè®¾**: ${chat.settings.aiPersona}\n`;
                    if (memories) charsContext += `- **ã€é‡è¦ï¼šé•¿æœŸè®°å¿†ã€‘**:\n${memories}\n`;
                    if (history) charsContext += `- **ã€è¯­æ°”å‚è€ƒ (æœ€è¿‘èŠå¤©)ã€‘**:\n${history}\n`;
                    charsContext += `\n`;
                }
            }
        }

        let userPersonaText = "æ™®é€šç”¨æˆ·";
        if (story.settings.userPersonaId) {
            const preset = await db.personaPresets.get(story.settings.userPersonaId);
            if (preset) userPersonaText = preset.persona;
        } else if (state.chats[Object.keys(state.chats)[0]]) {
             userPersonaText = state.chats[Object.keys(state.chats)[0]].settings.myPersona;
        }

        let worldBookText = "";
        for (const bid of story.settings.bookIds) {
            const wb = await db.worldBooks.get(bid);
            if (wb) worldBookText += `- ã€Š${wb.name}ã€‹è®¾å®š: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join(';')}\n`;
        }

        let prevSummary = "è¿™æ˜¯æ•…äº‹çš„å¼€å§‹ã€‚";
        if (story.chapters && story.chapters.length > 0) {
            const lastChapter = story.chapters[story.chapters.length - 1];
            if (lastChapter && lastChapter.summary) {
                prevSummary = lastChapter.summary;
            }
        }
let macroContext = "";
    if (story.settings.macroWorldView) {
        macroContext = `
# ã€ğŸ”¥ æ ¸å¿ƒä¸–ç•Œè§‚ / IFçº¿è®¾å®š (æœ€é«˜ä¼˜å…ˆçº§)ã€‘
æ³¨æ„ï¼šè¿™æ˜¯ä¸€æ¡IFçº¿æˆ–ç‰¹æ®ŠèƒŒæ™¯æ•…äº‹ã€‚**ä½ å¿…é¡»ä¼˜å…ˆéµå¾ªä»¥ä¸‹è®¾å®š**ï¼Œå¦‚æœä»¥ä¸‹è®¾å®šä¸è§’è‰²çš„åŸå§‹äººè®¾æˆ–è®°å¿†å†²çªï¼Œ**è¯·ä»¥ä»¥ä¸‹è®¾å®šä¸ºå‡†å¹¶è¿›è¡Œé€‚é…**ï¼
---
${story.settings.macroWorldView}
---
`;
    }
        // E. Prompt å¼ºåŠ›ä¼˜åŒ– (å­—æ•°æ‰©å…… + æ ‡é¢˜ç”Ÿæˆ)
        const systemPrompt = `
# èº«ä»½
ä½ ç°åœ¨æ˜¯ã€${author.name}ã€‘ã€‚æ–‡é£ç‰¹ç‚¹: ${author.style}

# æ ¸å¿ƒä»»åŠ¡
ç»­å†™è¿™ç¯‡å°è¯´çš„æ–°ä¸€ç« ã€‚
${macroContext}
# ã€æœ€é«˜ä¼˜å…ˆçº§ï¼šå­—æ•°æ‰©å……æŒ‡ä»¤ã€‘
ä½ å¿…é¡»è¾“å‡º **${targetWordCount} å­—** ä»¥ä¸Šçš„å†…å®¹ã€‚
ä¸ºäº†è¾¾åˆ°è¿™ä¸ªå­—æ•°ï¼Œä½ **å¿…é¡»**æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
1.  **æ‹’ç»æµæ°´è´¦**ï¼šä¸è¦åªå†™â€œä»–åšäº†ä»€ä¹ˆâ€ï¼Œè¦å†™â€œä»–å¦‚ä½•åšã€ä»€ä¹ˆè¡¨æƒ…ã€å¿ƒé‡Œæƒ³äº†ä»€ä¹ˆã€å‘¨å›´ç¯å¢ƒå¦‚ä½•â€ã€‚
2.  **ç»†èŠ‚æå†™**ï¼šå¢åŠ ç¯å¢ƒæå†™ï¼ˆå…‰å½±ã€æ°”å‘³ã€å£°éŸ³ï¼‰ã€å¾®è¡¨æƒ…æå†™ã€è‚¢ä½“åŠ¨ä½œæå†™ã€‚
3.  **å¿ƒç†æ´»åŠ¨**ï¼šå¤§å¹…å¢åŠ è§’è‰²çš„å†…å¿ƒç‹¬ç™½å’Œçº ç»“ã€‚
4.  **æ…¢é•œå¤´**ï¼šå°†å…³é”®åŠ¨ä½œæ‹†è§£ï¼Œæ”¾æ…¢å™äº‹èŠ‚å¥ã€‚

# æ•°æ®ä½¿ç”¨æŒ‡å—
1. **ä¸–ç•Œè§‚**: ${worldBookText ? "å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹è®¾å®šï¼š" + worldBookText : "è¯·æ ¹æ®è§’è‰²è®¾å®šè‡ªè¡Œåˆ¤æ–­ã€‚"}
2. **æ—¶ä»£å‡€åŒ–**: ä¸¥ç¦å‡ºç°ä¸ç¬¦åˆä¸–ç•Œè§‚çš„ç°ä»£ç‰©å“ã€‚
3. **é•¿æœŸè®°å¿†**: å¿…é¡»éµå®ˆè§’è‰²æ¡£æ¡ˆä¸­çš„è®°å¿†äº‹å®ã€‚

# è®¾å®šèµ„æ–™
- **"æˆ‘" (User) çš„è®¾å®š**: ${userPersonaText}
- **ç™»åœºè§’è‰²æ¡£æ¡ˆ**:
${charsContext}

# å½“å‰è¿›åº¦
- **å‰æƒ…æè¦**: ${prevSummary}
- **ç”¨æˆ·æŒ‡ç¤º**: ${userDirection || "ï¼ˆæ— æŒ‡ç¤ºï¼Œè¯·é¡ºå…¶è‡ªç„¶åœ°å‘å±•å‰§æƒ…ï¼Œé‡ç‚¹æ˜¯å†™å¤Ÿå­—æ•°ï¼ï¼‰"}

# è¾“å‡ºæ ¼å¼ (JSON)
å›å¤å¿…é¡»ä¸”åªèƒ½æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼š
\`\`\`json
{
  "title": "å››å­—æˆ–å¤šå­—æ ‡é¢˜ (å¦‚ï¼šæœˆä¸‹å¯¹é…Œã€å±æœºå››ä¼)",
  "content": "æ­£æ–‡å†…å®¹ (å¿…é¡»ä½¿ç”¨${author.style}é£æ ¼ï¼Œ**å¼ºåˆ¶å†™æ»¡ ${targetWordCount} å­—**ï¼Œå¤šç”¨æ¢è¡Œç¬¦\\nå¢åŠ é˜…è¯»æ„Ÿ)",
  "summary": "ç”¨é™ˆè¿°å¥æ¦‚æ‹¬æœ¬ç« å…³é”®äº‹å®ï¼ˆè°ã€åœ¨å“ªé‡Œã€åšäº†ä»€ä¹ˆï¼‰ï¼Œä¾›ä¸‹ä¸€ç« è®°å¿†ä½¿ç”¨ã€‚"
}
\`\`\`
`;
        
        // API è°ƒç”¨
        const { proxyUrl, apiKey, model } = state.apiConfig;
        const messages = [{role: 'user', content: `è¯·å¼€å§‹å†™ä½œï¼Œè¯·åŠ¡å¿…å†™å¤Ÿ ${targetWordCount} å­—ï¼`}];
        
        let response;
        if (proxyUrl.includes('generativelanguage')) {
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messages);
            response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
            response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        ...messages
                    ],
                    temperature: 0.9 // æé«˜æ¸©åº¦ï¼Œè®©å®ƒæ›´å•°å—¦ä¸€ç‚¹
                })
            });
        }
        
        if (!response.ok) {
             const errText = await response.text();
             throw new Error(`API è¯·æ±‚å¤±è´¥ (${response.status}): ${errText}`);
        }
        
        const data = await response.json();
        const aiText = getGeminiResponseText(data);
        
        // 1. æå– JSON éƒ¨åˆ†
        let jsonStr = aiText;
        const jsonMatch = aiText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            jsonStr = jsonMatch[0];
        } else {
            throw new Error("AIæœªè¿”å›æœ‰æ•ˆJSONæ ¼å¼");
        }

        let result;
        try {
            // 2. å°è¯•ç›´æ¥è§£æ
            result = JSON.parse(jsonStr);
        } catch (e) {
            console.warn("JSONè§£æåˆæ¬¡å¤±è´¥ï¼Œå°è¯•ä¿®å¤è½¬ä¹‰å­—ç¬¦...", e);
            
            // 3. ã€æ ¸å¿ƒä¿®å¤ã€‘: è‡ªåŠ¨ä¿®å¤é”™è¯¯çš„è½¬ä¹‰å­—ç¬¦
            // æ­£åˆ™å«ä¹‰ï¼šæŸ¥æ‰¾æ‰€æœ‰åæ–œæ ï¼Œå¦‚æœå®ƒåé¢è·Ÿçš„ä¸æ˜¯ json å…è®¸çš„è½¬ä¹‰ç¬¦( " \ / b f n r t u )ï¼Œå°±æŠŠå®ƒæ›¿æ¢ä¸ºåŒåæ–œæ 
            const fixedStr = jsonStr.replace(/\\([^"\\\/bfnrtu])/g, '\\\\$1');
            
            try {
                result = JSON.parse(fixedStr);
                console.log("JSONè‡ªåŠ¨ä¿®å¤æˆåŠŸï¼");
            } catch (e2) {
                // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
                throw new Error("JSONè§£æå¤±è´¥: " + e.message);
            }
        }
        
        const newChapter = {
            title: result.title || `ç¬¬ ${story.chapters.length + 1} ç« `,
            content: result.content,
            summary: result.summary, 
            prevSummary: prevSummary, 
            timestamp: Date.now()
        };
        
        // å¹¶å‘å®‰å…¨è·å–
        story = await db.grStories.get(grState.activeStoryId);
        story.chapters.push(newChapter);
        story.lastUpdated = Date.now();
        await db.grStories.put(story);
        
        openReader(story.id, story.chapters.length - 1);
        document.getElementById('gr-direction-input').value = ''; 

    } catch (e) {
        console.error("ç»¿æ±Ÿç”Ÿæˆå¤±è´¥:", e);
        alert("ç”Ÿæˆå¤±è´¥: " + e.message);
    } finally {
        grState.isGenerating = false;
        if(genBtn) {
            genBtn.disabled = false;
            // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šåŒæ ·åªåœ¨æ–‡å­—æ ‡ç­¾å­˜åœ¨æ—¶æ‰æ¢å¤æ–‡å­—
            if (btnText) btnText.textContent = "ç»­å†™";
        }
    }
}
// 8. ä¾§è¾¹æ ç›®å½•åŠŸèƒ½
function openChapterList() {
    const sidebar = document.getElementById('gr-chapter-sidebar');
    const overlay = document.getElementById('gr-sidebar-overlay');
    const listContainer = document.getElementById('gr-chapter-list-content');
    const countEl = document.getElementById('gr-total-chapters');
    
    if (!grState.activeStoryId) return;
    
    db.grStories.get(grState.activeStoryId).then(story => {
        listContainer.innerHTML = '';
        countEl.textContent = `å…± ${story.chapters.length} ç« `;
        
        story.chapters.forEach((ch, index) => {
            const div = document.createElement('div');
            div.className = 'gr-sidebar-item';
            if(index === grState.currentChapterIndex) div.classList.add('active');
            
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between;">
                    <span>${index + 1}. ${ch.title || 'æ— é¢˜'}</span>
                    <span style="font-size:12px; color:#999;">${new Date(ch.timestamp).toLocaleTimeString()}</span>
                </div>
                <div style="font-size:12px; color:#999; margin-left:10px; margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${(ch.summary || '').substring(0, 20)}...</div>
            `;
            
            div.onclick = () => {
                openReader(story.id, index);
                closeChapterList();
            };
            listContainer.appendChild(div);
        });
        
        sidebar.classList.add('visible');
        overlay.classList.add('visible');
    });
}

function closeChapterList() {
    document.getElementById('gr-chapter-sidebar').classList.remove('visible');
    document.getElementById('gr-sidebar-overlay').classList.remove('visible');
}
// æš´éœ²ç»™ HTML onclick
window.openChapterList = openChapterList;
window.closeChapterList = closeChapterList;
// ==========================================
// â–¼â–¼â–¼ ä½œè€…è¿½æ›´åŠŸèƒ½ â–¼â–¼â–¼
// ==========================================

// æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ›´æ–°
async function checkAutoUpdate(story) {
    if (!story.settings.autoUpdate || !story.settings.autoUpdate.enabled) {
        return false;
    }
    
    const autoUpdate = story.settings.autoUpdate;
    
    // å¦‚æœé¢‘ç‡è®¾ç½®ä¸ºæ‰‹åŠ¨ï¼Œä¸è‡ªåŠ¨æ›´æ–°
    if (autoUpdate.frequency === 'manual') {
        return false;
    }
    
    // å¦‚æœä»æœªæ›´æ–°è¿‡ï¼Œç«‹å³è§¦å‘ç¬¬ä¸€æ¬¡æ›´æ–°
    if (!autoUpdate.lastUpdate) {
        return true;
    }
    
    // è®¡ç®—æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    let intervalMs;
    switch (autoUpdate.frequency) {
        case 'daily':
            intervalMs = 24 * 60 * 60 * 1000; // 24å°æ—¶
            break;
        case 'weekly':
            intervalMs = 7 * 24 * 60 * 60 * 1000; // 7å¤©
            break;
        case 'custom':
            intervalMs = (autoUpdate.customHours || 24) * 60 * 60 * 1000;
            break;
        default:
            return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ›´æ–°æ—¶é—´
    const now = Date.now();
    const timeSinceLastUpdate = now - autoUpdate.lastUpdate;
    return timeSinceLastUpdate >= intervalMs;
}

// è‡ªåŠ¨ç”Ÿæˆæ–°ç« èŠ‚
async function autoGenerateChapter(storyId) {
    try {
        console.log(`[ä½œè€…è¿½æ›´] å¼€å§‹ä¸ºä½œå“ ${storyId} ç”Ÿæˆæ–°ç« èŠ‚`);
        
        const story = await db.grStories.get(storyId);
        if (!story) {
            console.error(`[ä½œè€…è¿½æ›´] ä½œå“ ${storyId} ä¸å­˜åœ¨`);
            return false;
        }
        
        const autoUpdate = story.settings.autoUpdate;
        if (!autoUpdate || !autoUpdate.enabled) {
            return false;
        }
        
        // è·å–ä½œè€…ä¿¡æ¯
        const author = await db.grAuthors.get(story.authorId);
        if (!author) {
            console.error(`[ä½œè€…è¿½æ›´] ä½œè€… ${story.authorId} ä¸å­˜åœ¨`);
            return false;
        }
        
        // æ„å»ºç”Ÿæˆæç¤ºè¯
        const settingValue = parseInt(story.settings.outputLength) || 500;
        const targetWordCount = Math.floor(settingValue * 1.5);
        const historyLimit = story.settings.contextLimit || 20;
        
        // è·å–è§’è‰²ä¿¡æ¯
        let charsContext = "";
        for (const charId of story.settings.charIds) {
            if (charId.startsWith('npc_')) {
                const npcId = parseInt(charId.replace('npc_', ''));
                const npc = await db.npcs.get(npcId);
                if (npc) {
                    charsContext += `[NPC] ${npc.name}: ${npc.description || ''}\n`;
                }
            } else {
                const char = state.chats[charId];
                if (char) {
                    charsContext += `${char.name}: ${char.firstMessage || char.description || ''}\n`;
                }
            }
        }
        
        // è·å–ä¸–ç•Œä¹¦ä¿¡æ¯
        let worldBookContext = "";
        for (const bookId of story.settings.bookIds) {
            const book = await db.worldBooks.get(bookId);
            if (book) {
                worldBookContext += `\n[${book.name}]\n`;
                if (Array.isArray(book.content)) {
                    book.content.forEach(entry => {
                        if (typeof entry === 'object' && entry.content) {
                            worldBookContext += `${entry.content}\n`;
                        } else if (typeof entry === 'string') {
                            worldBookContext += `${entry}\n`;
                        }
                    });
                } else if (typeof book.content === 'string') {
                    worldBookContext += book.content;
                }
            }
        }
        
        // è·å–å†å²ç« èŠ‚
        const recentChapters = story.chapters.slice(-historyLimit);
        let chaptersText = "";
        recentChapters.forEach((ch, idx) => {
            const chTitle = ch.title || `ç¬¬ ${idx + 1} ç« `;
            chaptersText += `\n\n[${chTitle}]\næ‘˜è¦: ${ch.summary || 'æ— '}\næ­£æ–‡:\n${ch.content}`;
        });
        
        // æ ¹æ®è¿½æ›´æ–¹å¼æ„å»ºç‰¹æ®Šæç¤ºè¯
        let updatePrompt = "";
        if (autoUpdate.type === 'character') {
            // ä½¿ç”¨è§’è‰²è§†è§’
            const charId = autoUpdate.characterId;
            let charName = "æœªçŸ¥è§’è‰²";
            if (charId.startsWith('npc_')) {
                const npcId = parseInt(charId.replace('npc_', ''));
                const npc = await db.npcs.get(npcId);
                if (npc) charName = npc.name;
            } else {
                const char = state.chats[charId];
                if (char) charName = char.name;
            }
            updatePrompt = `\n\nã€ç‰¹åˆ«è¯´æ˜ã€‘æœ¬æ¬¡æ›´æ–°è¯·ä»¥ ${charName} çš„ç¬¬ä¸€äººç§°è§†è§’è¿›è¡Œå™è¿°ï¼Œå±•ç°${charName}çš„å†…å¿ƒæ´»åŠ¨å’Œæ‰€è§æ‰€é—»ã€‚`;
        } else if (autoUpdate.type === 'author') {
            // ä½¿ç”¨æŒ‡å®šä½œè€…æ–‡é£
            const updateAuthor = await db.grAuthors.get(autoUpdate.authorId);
            if (updateAuthor) {
                updatePrompt = `\n\nã€ç‰¹åˆ«è¯´æ˜ã€‘æœ¬æ¬¡æ›´æ–°è¯·ä¸¥æ ¼æ¨¡ä»¿ã€${updateAuthor.name}ã€‘çš„æ–‡é£ï¼š${updateAuthor.style}`;
            }
        }
        
        // æ„å»ºå®Œæ•´æç¤ºè¯
        const fullPrompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å°è¯´ç»­å†™AIã€‚è¯·æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ï¼Œç»­å†™ä¸‹ä¸€ç« èŠ‚å†…å®¹ã€‚

ã€åŸºç¡€è®¾å®šã€‘
${story.settings.macroWorldView || 'æ— ç‰¹æ®Šè®¾å®š'}

ã€è§’è‰²ä¿¡æ¯ã€‘
${charsContext}

${worldBookContext}

ã€å·²æœ‰ç« èŠ‚ã€‘ï¼ˆä½œä¸ºä¸Šä¸‹æ–‡å‚è€ƒï¼‰${chaptersText}

ã€ä½œè€…æ–‡é£ã€‘
${author.style}

${updatePrompt}

ã€ç»­å†™è¦æ±‚ã€‘
1. è¿™æ˜¯è‡ªåŠ¨è¿½æ›´åŠŸèƒ½ç”Ÿæˆçš„æ–°ç« èŠ‚ï¼Œè¯·è‡ªç„¶åœ°æ¨è¿›å‰§æƒ…å‘å±•
2. å­—æ•°è¦æ±‚ï¼šçº¦ ${targetWordCount} å­—
3. ä¿æŒä¸å‰æ–‡çš„è¿è´¯æ€§
4. ç¬¦åˆè§’è‰²æ€§æ ¼å’Œä¸–ç•Œè§‚è®¾å®š
5. è¯·è¾“å‡º: æ ‡é¢˜ï¼ˆä¸€è¡Œï¼‰ã€æ‘˜è¦ï¼ˆä¸€å°æ®µï¼‰ã€æ­£æ–‡ï¼ˆå®Œæ•´ç« èŠ‚å†…å®¹ï¼‰

æ ¼å¼ç¤ºä¾‹ï¼š
æ ‡é¢˜: ç¬¬Xç«  XXX
æ‘˜è¦: XXXï¼ˆç®€è¦æ¦‚æ‹¬æœ¬ç« å†…å®¹ï¼Œ50å­—ä»¥å†…ï¼‰
æ­£æ–‡:
ï¼ˆè¿™é‡Œæ˜¯ç« èŠ‚æ­£æ–‡å†…å®¹ï¼‰

ç°åœ¨å¼€å§‹ç»­å†™ï¼š`;
        
        // è°ƒç”¨AIç”Ÿæˆ
        const apiConfig = await db.apiConfig.get('main');
        if (!apiConfig || !apiConfig.proxyUrl || !apiConfig.apiKey) {
            console.error('[ä½œè€…è¿½æ›´] APIé…ç½®ä¸å®Œæ•´');
            return false;
        }
        
        const isGemini = apiConfig.proxyUrl.includes('generativelanguage');
        let response;
        
        if (isGemini) {
            const payload = {
                contents: [{
                    parts: [{
                        text: fullPrompt
                    }]
                }]
            };
            
            response = await fetch(`${apiConfig.proxyUrl}/${apiConfig.model}:generateContent?key=${apiConfig.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
        } else {
            const payload = {
                model: apiConfig.model,
                messages: [{
                    role: 'user',
                    content: fullPrompt
                }],
                temperature: 0.8,
                max_tokens: targetWordCount * 2
            };
            
            response = await fetch(`${apiConfig.proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiConfig.apiKey}`
                },
                body: JSON.stringify(payload)
            });
        }
        
        if (!response.ok) {
            console.error('[ä½œè€…è¿½æ›´] APIè¯·æ±‚å¤±è´¥:', response.status);
            return false;
        }
        
        const data = await response.json();
        let aiOutput = '';
        
        if (isGemini) {
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                aiOutput = data.candidates[0].content.parts.map(p => p.text).join('');
            }
        } else {
            if (data.choices && data.choices[0] && data.choices[0].message) {
                aiOutput = data.choices[0].message.content;
            }
        }
        
        if (!aiOutput) {
            console.error('[ä½œè€…è¿½æ›´] AIè¿”å›å†…å®¹ä¸ºç©º');
            return false;
        }
        
        // è§£æAIè¾“å‡º
        const lines = aiOutput.split('\n');
        let newTitle = `ç¬¬ ${story.chapters.length + 1} ç« `;
        let newSummary = '';
        let newContent = '';
        
        let currentSection = '';
        for (let line of lines) {
            if (line.startsWith('æ ‡é¢˜:') || line.startsWith('æ ‡é¢˜ï¼š')) {
                newTitle = line.replace(/^æ ‡é¢˜[:ï¼š]\s*/, '').trim();
                currentSection = 'title';
            } else if (line.startsWith('æ‘˜è¦:') || line.startsWith('æ‘˜è¦ï¼š')) {
                newSummary = line.replace(/^æ‘˜è¦[:ï¼š]\s*/, '').trim();
                currentSection = 'summary';
            } else if (line.startsWith('æ­£æ–‡:') || line.startsWith('æ­£æ–‡ï¼š')) {
                currentSection = 'content';
            } else if (currentSection === 'content') {
                newContent += line + '\n';
            } else if (currentSection === 'summary' && !line.startsWith('æ­£æ–‡')) {
                newSummary += line + ' ';
            }
        }
        
        newContent = newContent.trim();
        newSummary = newSummary.trim();
        
        if (!newContent) {
            console.error('[ä½œè€…è¿½æ›´] è§£æå†…å®¹å¤±è´¥');
            return false;
        }
        
        // æ·»åŠ æ–°ç« èŠ‚
        story.chapters.push({
            title: newTitle,
            content: newContent,
            summary: newSummary,
            createdAt: Date.now(),
            autoGenerated: true // æ ‡è®°ä¸ºè‡ªåŠ¨ç”Ÿæˆ
        });
        
        // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
        story.settings.autoUpdate.lastUpdate = Date.now();
        story.lastUpdated = Date.now();
        
        await db.grStories.put(story);
        
        console.log(`[ä½œè€…è¿½æ›´] æˆåŠŸä¸ºä½œå“ã€Š${story.title}ã€‹ç”Ÿæˆæ–°ç« èŠ‚: ${newTitle}`);
        return true;
        
    } catch (error) {
        console.error('[ä½œè€…è¿½æ›´] ç”Ÿæˆå¤±è´¥:', error);
        return false;
    }
}

// æ£€æŸ¥æ‰€æœ‰ä½œå“çš„è¿½æ›´çŠ¶æ€
async function checkAllStoriesForAutoUpdate() {
    try {
        const stories = await db.grStories.toArray();
        
        for (const story of stories) {
            if (await checkAutoUpdate(story)) {
                console.log(`[ä½œè€…è¿½æ›´] ä½œå“ã€Š${story.title}ã€‹éœ€è¦æ›´æ–°`);
                await autoGenerateChapter(story.id);
                // æ·»åŠ å»¶è¿Ÿï¼Œé¿å…åŒæ—¶å‘é€å¤ªå¤šè¯·æ±‚
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    } catch (error) {
        console.error('[ä½œè€…è¿½æ›´] æ£€æŸ¥æ›´æ–°å¤±è´¥:', error);
    }
}

// å¯åŠ¨è¿½æ›´å®šæ—¶å™¨ï¼ˆæ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼‰
let autoUpdateTimer = null;

function startAutoUpdateTimer() {
    if (autoUpdateTimer) {
        clearInterval(autoUpdateTimer);
    }
    
    // æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
    autoUpdateTimer = setInterval(() => {
        console.log('[ä½œè€…è¿½æ›´] å®šæ—¶æ£€æŸ¥å¼€å§‹...');
        checkAllStoriesForAutoUpdate();
    }, 60 * 60 * 1000); // 1å°æ—¶
    
    console.log('[ä½œè€…è¿½æ›´] å®šæ—¶å™¨å·²å¯åŠ¨');
}

// åœæ­¢è¿½æ›´å®šæ—¶å™¨
function stopAutoUpdateTimer() {
    if (autoUpdateTimer) {
        clearInterval(autoUpdateTimer);
        autoUpdateTimer = null;
        console.log('[ä½œè€…è¿½æ›´] å®šæ—¶å™¨å·²åœæ­¢');
    }
}

// é¡µé¢åŠ è½½æ—¶å¯åŠ¨å®šæ—¶å™¨
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        startAutoUpdateTimer();
        // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
        setTimeout(checkAllStoriesForAutoUpdate, 5000); // å»¶è¿Ÿ5ç§’åé¦–æ¬¡æ£€æŸ¥
    });
}

// æš´éœ²ç»™å…¨å±€
window.openGreenRiverScreen = openGreenRiverScreen;
window.openAuthorManager = openAuthorManager;
window.createNewStory = createNewStory;
window.openStorySettings = openStorySettings;
window.addAuthor = addAuthor;
window.deleteAuthor = deleteAuthor;
window.checkAllStoriesForAutoUpdate = checkAllStoriesForAutoUpdate; // æ‰‹åŠ¨è§¦å‘æ£€æŸ¥
window.autoGenerateChapter = autoGenerateChapter; // æ‰‹åŠ¨è§¦å‘å•ä¸ªä½œå“æ›´æ–°
// ==========================================
// â–¼â–¼â–¼ é‚®ç®± (Mail) åŠŸèƒ½æ¨¡å— â–¼â–¼â–¼
// ==========================================

let mailState = {
    currentEmailId: null,
    isEditMode: false,
    selectedEmails: new Set()
};

// 1. æ‰“å¼€é‚®ç®±åº”ç”¨
async function openEmailApp() {
    showScreen('email-screen');
    await renderEmailList();
}

// 2. æ¸²æŸ“é‚®ä»¶åˆ—è¡¨
async function renderEmailList() {
    const listEl = document.getElementById('email-list');
    listEl.innerHTML = '';
    
    const emails = await db.emails.orderBy('timestamp').reverse().toArray();

    if (emails.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:50px; color:#8E8E93;">No Mail</div>';
        return;
    }

    const searchTerm = document.getElementById('mail-search-input').value.toLowerCase();

    emails.forEach(email => {
        if (searchTerm && !email.subject.toLowerCase().includes(searchTerm) && !email.content.toLowerCase().includes(searchTerm)) {
            return;
        }

        const div = document.createElement('div');
        // å¦‚æœå½“å‰åœ¨ç¼–è¾‘æ¨¡å¼ï¼Œä¿æŒ editing ç±»
        const itemClass = `mail-item ${email.isRead ? '' : 'unread'} ${mailState.isEditMode ? 'editing' : ''}`;
        div.className = itemClass;
        div.dataset.id = email.id; // ç»‘å®šIDæ–¹ä¾¿æŸ¥æ‰¾
        
        // æ£€æŸ¥æ˜¯å¦å·²è¢«é€‰ä¸­
        if (mailState.selectedEmails.has(email.id)) {
            div.classList.add('selected');
        }
        
        const date = new Date(email.timestamp);
        const timeStr = date.toLocaleDateString() === new Date().toLocaleDateString() 
            ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) 
            : date.toLocaleDateString();

        // ã€å…³é”®ã€‘æ·»åŠ  mail-select-checkbox ç»“æ„
        div.innerHTML = `
            <div class="mail-select-checkbox"></div>
            <div class="mail-item-header">
                <span class="mail-sender">${escapeHTML(email.sender)}</span>
                <span class="mail-date">${timeStr}</span>
            </div>
            <div class="mail-subject">${escapeHTML(email.subject)}</div>
            <div class="mail-preview">${escapeHTML(email.content).replace(/\n/g, ' ').substring(0, 80)}</div>
        `;
        
        div.onclick = () => {
            if (mailState.isEditMode) {
                // ç¼–è¾‘æ¨¡å¼ï¼šåˆ‡æ¢é€‰ä¸­çŠ¶æ€
                handleEmailSelection(div, email.id);
            } else {
                // æ™®é€šæ¨¡å¼ï¼šæ‰“å¼€è¯¦æƒ…
                openEmailDetail(email.id);
            }
        };
        listEl.appendChild(div);
    });
}

function handleEmailSelection(element, id) {
    if (mailState.selectedEmails.has(id)) {
        mailState.selectedEmails.delete(id);
        element.classList.remove('selected');
    } else {
        mailState.selectedEmails.add(id);
        element.classList.add('selected');
    }
    updateMailDeleteButton();
}

function updateMailDeleteButton() {
    const btn = document.getElementById('mail-delete-selected-btn');
    const count = mailState.selectedEmails.size;
    btn.textContent = count > 0 ? `åˆ é™¤ (${count})` : 'åˆ é™¤';
    btn.disabled = count === 0;
}
async function executeBatchDeleteEmails() {
    const count = mailState.selectedEmails.size;
    if (count === 0) return;

    const confirmed = await showCustomConfirm(
        'åˆ é™¤é‚®ä»¶', 
        `ç¡®å®šè¦åˆ é™¤è¿™ ${count} å°é‚®ä»¶å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`,
        { confirmButtonClass: 'btn-danger', confirmText: 'åˆ é™¤' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(mailState.selectedEmails);
        await db.emails.bulkDelete(idsToDelete);
        
        // æ¸…ç©ºé€‰ä¸­çŠ¶æ€
        mailState.selectedEmails.clear();
        updateMailDeleteButton();
        
        // é‡æ–°æ¸²æŸ“åˆ—è¡¨ï¼ˆæ­¤æ—¶è¿˜æ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œæ‰€ä»¥åˆ—è¡¨ä¼šä¿æŒå³ç§»çŠ¶æ€ï¼‰
        await renderEmailList();
        
        // å¯é€‰ï¼šå¦‚æœåˆ å®Œæƒ³è‡ªåŠ¨é€€å‡ºç¼–è¾‘æ¨¡å¼ï¼Œè°ƒç”¨ toggleEmailEditMode();
    }
}
function handleSelectAllEmails() {
    const listEl = document.getElementById('email-list');
    const allItems = listEl.querySelectorAll('.mail-item');
    
    // å¦‚æœå½“å‰å·²é€‰æ•°é‡ç­‰äºæ€»æ•°ï¼Œåˆ™è§†ä¸ºâ€œå–æ¶ˆå…¨é€‰â€ï¼Œå¦åˆ™â€œå…¨é€‰â€
    const isSelectingAll = mailState.selectedEmails.size < allItems.length;

    allItems.forEach(item => {
        const id = parseInt(item.dataset.id);
        if (isSelectingAll) {
            mailState.selectedEmails.add(id);
            item.classList.add('selected');
        } else {
            mailState.selectedEmails.delete(id);
            item.classList.remove('selected');
        }
    });
    updateMailDeleteButton();
}
// 3. æ‰“å¼€é‚®ä»¶è¯¦æƒ… (æ›´æ–°ç‰ˆï¼šç»‘å®šå¤´éƒ¨æŒ‰é’®)
async function openEmailDetail(id) {
    const email = await db.emails.get(id);
    if (!email) return;
    
    mailState.currentEmailId = id;

    // æ ‡è®°ä¸ºå·²è¯»
    if (!email.isRead) {
        await db.emails.update(id, { isRead: true });
    }

    document.getElementById('mail-detail-subject').textContent = email.subject;
    document.getElementById('mail-detail-from').textContent = email.sender;
    document.getElementById('mail-detail-to').textContent = email.recipient || 'Me';
    document.getElementById('mail-detail-time').textContent = new Date(email.timestamp).toLocaleString();
    
    // å¤´åƒé¦–å­—æ¯
    const avatarEl = document.getElementById('mail-detail-avatar');
    avatarEl.textContent = email.sender.charAt(0).toUpperCase();
    
    // æ­£æ–‡ (å¤„ç†æ¢è¡Œ)
    document.getElementById('mail-detail-body').innerHTML = email.content.replace(/\n/g, '<br>');
    
    // ç»‘å®šå¤´éƒ¨å³ä¸Šè§’çš„æŒ‰é’®äº‹ä»¶
    
    // 1. è½¬å‘æŒ‰é’®
    const forwardBtn = document.getElementById('forward-email-btn');
    // ç§»é™¤æ—§ç›‘å¬å™¨ (ä½¿ç”¨ cloneNode)
    const newForwardBtn = forwardBtn.cloneNode(true);
    forwardBtn.parentNode.replaceChild(newForwardBtn, forwardBtn);
    newForwardBtn.onclick = () => forwardEmailToChat(email);

    // 2. åˆ é™¤æŒ‰é’® (æ–°å¢åœ¨å³ä¸Šè§’)
    const deleteBtn = document.getElementById('delete-email-btn');
    if (deleteBtn) {
        const newDeleteBtn = deleteBtn.cloneNode(true);
        deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
        newDeleteBtn.onclick = () => deleteCurrentEmail();
    }

    showScreen('email-detail-screen');
}

function closeEmailDetail() {
    showScreen('email-screen');
    renderEmailList(); // åˆ·æ–°çŠ¶æ€
}

// 4. åˆ‡æ¢ç¼–è¾‘æ¨¡å¼
function toggleEmailEditMode() {
    mailState.isEditMode = !mailState.isEditMode;
    const btn = document.getElementById('mail-edit-btn');
    const actionBar = document.getElementById('mail-action-bar');
    const listEl = document.getElementById('email-list');
    
    if (mailState.isEditMode) {
        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        btn.textContent = 'å®Œæˆ'; // æŒ‰é’®å˜æ–‡å­—
        btn.style.color = 'var(--mail-accent)';
        btn.style.fontWeight = '600';
        btn.innerHTML = 'å®Œæˆ'; // è¦†ç›–æ‰ä¹‹å‰çš„â€œç¼–è¾‘â€æ–‡å­—æˆ–å›¾æ ‡
        
        actionBar.style.display = 'flex';
        mailState.selectedEmails.clear();
        updateMailDeleteButton();
        
        // ç»™åˆ—è¡¨é¡¹æ·»åŠ æ ·å¼ç±»
        listEl.querySelectorAll('.mail-item').forEach(item => item.classList.add('editing'));
        
    } else {
        // é€€å‡ºç¼–è¾‘æ¨¡å¼
        btn.innerHTML = 'ç¼–è¾‘'; // æ¢å¤æ–‡å­—
        btn.style.color = 'currentColor';
        btn.style.fontWeight = 'normal';
        
        actionBar.style.display = 'none';
        mailState.selectedEmails.clear();
        
        // ç§»é™¤æ ·å¼ç±»
        listEl.querySelectorAll('.mail-item').forEach(item => {
            item.classList.remove('editing', 'selected');
        });
    }
}

async function deleteEmail(id) {
    if(confirm("ç¡®å®šè¦åˆ é™¤è¿™å°é‚®ä»¶å—ï¼Ÿ")) {
        await db.emails.delete(id);
        renderEmailList();
    }
}

async function deleteCurrentEmail() {
    if(mailState.currentEmailId) {
        await deleteEmail(mailState.currentEmailId);
        closeEmailDetail();
    }
}

// 5. æ‰“å¼€ç”Ÿæˆå™¨é…ç½®
function saveMailConfig() {
    const config = {
        userMask: document.getElementById('mail-user-mask').value.trim(),
        worldContext: document.getElementById('mail-world-context').value.trim(),
        personaId: document.getElementById('mail-user-persona-select').value,
        allowRandom: document.getElementById('mail-allow-random-npc').checked,
        genCount: document.getElementById('mail-gen-count').value,
        // ä¿å­˜é€‰ä¸­çš„å‘ä»¶äººåå­—æ•°ç»„
        selectedSenders: Array.from(document.querySelectorAll('#mail-sender-list input:checked')).map(cb => cb.value),
        // ä¿å­˜é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
        selectedBookIds: Array.from(document.querySelectorAll('#mail-context-list input:checked')).map(cb => cb.value)
    };
    localStorage.setItem('ephone_mail_config', JSON.stringify(config));
    console.log("é‚®ç®±é…ç½®å·²ä¿å­˜:", config);
    return config;
}

// 2. [æ–°åŠŸèƒ½] åŠ è½½é‚®ç®±é…ç½®
function loadMailConfig() {
    const saved = localStorage.getItem('ephone_mail_config');
    return saved ? JSON.parse(saved) : null;
}

// 3. [ä¿®æ”¹] æ‰“å¼€è®¾ç½®å¼¹çª— (åŸ openEmailGenerator)
// æ”¹åä¸º openEmailSettings æ›´è´´åˆ‡ï¼ŒåŒæ—¶åœ¨æ‰“å¼€æ—¶å›å¡«æ•°æ®
async function openEmailSettings() {
    // å…ˆæ¸²æŸ“åˆ—è¡¨ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
    const personaSelect = document.getElementById('mail-user-persona-select');
    if (personaSelect) {
        personaSelect.innerHTML = '<option value="">-- ä»…ä½¿ç”¨ä¸‹æ–¹å…³é”®è¯ (æ— è¯¦ç»†äººè®¾) --</option>';
        if (state.activeChatId) {
            const currentChat = state.chats[state.activeChatId];
            if (currentChat && currentChat.settings.myPersona) {
                 const opt = document.createElement('option');
                 opt.value = 'current_chat';
                 opt.textContent = `å½“å‰èŠå¤©è®¾å®š: ${currentChat.settings.myPersona.substring(0, 15).replace(/\n/g, ' ')}...`;
                 personaSelect.appendChild(opt);
            }
        }
        if (state.personaPresets && state.personaPresets.length > 0) {
            state.personaPresets.forEach((p, index) => {
                const opt = document.createElement('option');
                opt.value = p.id;
                const summary = p.persona ? p.persona.substring(0, 20).replace(/\n/g, ' ') : `é¢„è®¾ ${index + 1}`;
                opt.textContent = `äººè®¾åº“: ${summary}...`;
                personaSelect.appendChild(opt);
            });
        }
    }
    
    // æ¸²æŸ“å‘ä»¶äººåˆ—è¡¨
    const listEl = document.getElementById('mail-sender-list');
    listEl.innerHTML = '';
    const chars = Object.values(state.chats).filter(c => !c.isGroup);
    const npcs = await db.npcs.toArray();
    [...chars, ...npcs].forEach(c => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        div.innerHTML = `<input type="checkbox" value="${c.name}" data-type="${c.id ? 'char' : 'npc'}"> <span>${c.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        listEl.appendChild(div);
    });

    // æ¸²æŸ“ä¸–ç•Œä¹¦åˆ—è¡¨
    const wbList = document.getElementById('mail-context-list');
    wbList.innerHTML = '';
    const books = await db.worldBooks.toArray();
    books.forEach(book => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        div.innerHTML = `<input type="checkbox" value="${book.id}"> <span>${book.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        wbList.appendChild(div);
    });

    // --- æ ¸å¿ƒï¼šå›å¡«å·²ä¿å­˜çš„æ•°æ® ---
    const config = loadMailConfig();
    if (config) {
        if(config.userMask) document.getElementById('mail-user-mask').value = config.userMask;
        if(config.worldContext) document.getElementById('mail-world-context').value = config.worldContext;
        if(config.personaId) personaSelect.value = config.personaId;
        if(config.genCount) document.getElementById('mail-gen-count').value = config.genCount;
        document.getElementById('mail-allow-random-npc').checked = config.allowRandom !== false; // é»˜è®¤ true

        // å›å¡«å¤é€‰æ¡†
        if (config.selectedSenders) {
            config.selectedSenders.forEach(val => {
                const cb = document.querySelector(`#mail-sender-list input[value="${val}"]`);
                if(cb) cb.checked = true;
            });
        }
        if (config.selectedBookIds) {
            config.selectedBookIds.forEach(val => {
                const cb = document.querySelector(`#mail-context-list input[value="${val}"]`);
                if(cb) cb.checked = true;
            });
        }
    }

    document.getElementById('email-generator-modal').classList.add('visible');
}

// 4. [æ–°å¢] ä¸€é”®æ¥æ”¶åŠŸèƒ½
async function handleQuickReceiveMail() {
    const config = loadMailConfig();
    
    // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œå¼ºåˆ¶æ‰“å¼€è®¾ç½®çª—å£
    if (!config || !config.userMask) {
        await showCustomAlert("æç¤º", "è¯·å…ˆç‚¹å‡»æ—è¾¹çš„é½¿è½®å›¾æ ‡âš™ï¸ï¼Œé…ç½®æ‚¨çš„æ”¶ä»¶äººèº«ä»½å’ŒèƒŒæ™¯ã€‚");
        openEmailSettings();
        return;
    }

    await showCustomAlert("æ­£åœ¨æ¥æ”¶...", `æ­£åœ¨æ ¹æ®ä¿å­˜çš„é…ç½® (${config.userMask}) ç”Ÿæˆé‚®ä»¶...`);
    
    // è°ƒç”¨æ ¸å¿ƒç”Ÿæˆå‡½æ•°
    await executeEmailGeneration(config);
}
// 5. [æ ¸å¿ƒæå–] å°†ç”Ÿæˆé€»è¾‘å°è£…ä¸ºç‹¬ç«‹å‡½æ•°
async function executeEmailGeneration(config) {
    // è§£æ„é…ç½®
    const { userMask, worldContext, allowRandom, personaId, selectedSenders, selectedBookIds } = config;
    let genCount = parseInt(config.genCount) || 3;
    if (genCount > 10) genCount = 10;

    // è·å–è¯¦ç»†äººè®¾æ–‡æœ¬
    let detailedPersona = "";
    if (personaId === 'current_chat' && state.activeChatId) {
         const chat = state.chats[state.activeChatId];
         detailedPersona = chat.settings.myPersona || "";
    } else if (personaId) {
         const preset = state.personaPresets.find(p => p.id === personaId);
         if (preset) detailedPersona = preset.persona;
    }

    // æ„å»ºä¸Šä¸‹æ–‡ (ä¸–ç•Œä¹¦ + è§’è‰²è®°å¿†)
    let worldBookText = "";
    for (const bid of (selectedBookIds || [])) {
        const wb = await db.worldBooks.get(bid);
        if (wb) worldBookText += `- ã€Š${wb.name}ã€‹: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join('; ')}\n`;
    }

    let characterContext = "";
    if (selectedSenders && selectedSenders.length > 0) {
        const activeChars = Object.values(state.chats).filter(c => !c.isGroup && selectedSenders.includes(c.name));
        if (activeChars.length > 0) {
            characterContext = "\n# ã€é‡è¦ã€‘æŒ‡å®šå‘ä»¶äººçš„è¯¦ç»†æ¡£æ¡ˆ\n";
            activeChars.forEach(chat => {
                const memory = (chat.longTermMemory && chat.longTermMemory.length > 0) ? chat.longTermMemory.map(m => m.content).join('; ') : 'æš‚æ— ';
                const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5).map(m => `${m.role === 'user' ? 'æˆ‘' : chat.name}: ${String(m.content).substring(0, 50)}`).join('\n');
                characterContext += `## å‘ä»¶äºº: ${chat.name}\n- **äººè®¾**: ${chat.settings.aiPersona.substring(0, 200)}...\n- **é•¿æœŸè®°å¿†**: ${memory}\n- **æœ€è¿‘å¯¹è¯**: \n${recentHistory}\n\n`;
            });
        }
    }

    // Prompt
    const systemPrompt = `
# è§’è‰²ï¼šé‚®ä»¶ç³»ç»Ÿç”Ÿæˆå™¨
è¯·æ ¹æ®ä»¥ä¸‹è®¾å®šç”Ÿæˆ **${genCount}** å°é‚®ä»¶ã€‚

# æ”¶ä»¶äººæ¡£æ¡ˆ
- **èº«ä»½**: ${userMask}
${detailedPersona ? `- **è¯¦ç»†èƒŒæ™¯**: ${detailedPersona.replace(/\n/g, ' ')}` : ""}
- **ä¸–ç•Œè§‚**: ${worldContext || "ç°ä»£èŒåœº/ç”Ÿæ´»"}
${worldBookText ? "- **ä¸–ç•Œä¹¦è§„åˆ™**: \n" + worldBookText : ""}

${characterContext}

# å‘ä»¶äººå€™é€‰
${selectedSenders && selectedSenders.length > 0 ? "- æŒ‡å®šå‘ä»¶äºº: " + selectedSenders.join(', ') : ""}
${allowRandom ? "- å…è®¸ç”Ÿæˆéšæœºè·¯äºº/å¹¿å‘Š/é€šçŸ¥" : ""}

# è¾“å‡ºæ ¼å¼ (JSON Only)
\`\`\`json
[
  {
    "sender": "å‘ä»¶äººå§“å",
    "subject": "é‚®ä»¶æ ‡é¢˜",
    "content": "é‚®ä»¶æ­£æ–‡ (æ”¯æŒæ¢è¡Œç¬¦\\n)",
    "timestamp_offset": 0 (è·ç¦»ç°åœ¨çš„åˆ†é’Ÿæ•°ï¼Œè´Ÿæ•°è¡¨ç¤ºè¿‡å»)
  }
]
\`\`\`
`;

    // API è°ƒç”¨
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let apiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:`Generate ${genCount} emails`}]);
        
        const response = isGemini ? 
            await fetch(apiConfig.url, apiConfig.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:`Generate ${genCount} emails`}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("APIè¯·æ±‚å¤±è´¥");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const jsonStr = text.replace(/^```json\s*/, '').replace(/```$/, '');
        const emails = JSON.parse(jsonStr);

        const now = Date.now();
        const newEmails = emails.map(e => ({
            sender: e.sender,
            senderType: 'gen',
            recipient: userMask,
            subject: e.subject,
            content: e.content,
            timestamp: now - (e.timestamp_offset || 0) * 60000,
            isRead: false
        }));

        await db.emails.bulkAdd(newEmails);
        
        // åˆ·æ–°åˆ—è¡¨
        await renderEmailList();
        // æç¤ºæˆåŠŸ
        await showCustomAlert("æ¥æ”¶æˆåŠŸ", `æ”¶åˆ° ${newEmails.length} å°æ–°é‚®ä»¶ã€‚`);

    } catch (e) {
        console.error(e);
        alert("ç”Ÿæˆå¤±è´¥: " + e.message);
    }
}



// 7. æŠŠæ–°å‡½æ•°æš´éœ²ç»™å…¨å±€

// 6. æ ¸å¿ƒç”Ÿæˆé€»è¾‘ (å¢å¼ºç‰ˆï¼šæ”¯æŒè®°å¿†è¯»å– + è‡ªå®šä¹‰æ¡æ•°)
document.getElementById('start-generate-email-btn').addEventListener('click', async () => {
    // --- 1. è·å–åŸºç¡€è¾“å…¥ ---
    const userMask = document.getElementById('mail-user-mask').value.trim();
    const worldContext = document.getElementById('mail-world-context').value.trim();
    const allowRandom = document.getElementById('mail-allow-random-npc').checked;
    
    // è·å–è‡ªå®šä¹‰æ•°é‡ï¼Œé»˜è®¤ä¸º 3
    let genCount = parseInt(document.getElementById('mail-gen-count').value);
    if (isNaN(genCount) || genCount < 1) genCount = 3;
    if (genCount > 10) genCount = 10; // é™åˆ¶æœ€å¤§10æ¡é˜²æ­¢è¶…æ—¶

    // è·å–è¯¦ç»†äººè®¾ (ä¸Šä¸€æ­¥ä¿®æ”¹çš„åŠŸèƒ½)
    const personaSelect = document.getElementById('mail-user-persona-select');
    let detailedPersona = "";
    if (personaSelect && personaSelect.value) {
        if (personaSelect.value === 'current_chat' && state.activeChatId) {
             const chat = state.chats[state.activeChatId];
             detailedPersona = chat.settings.myPersona || "";
        } else {
             const preset = state.personaPresets.find(p => p.id === personaSelect.value);
             if (preset) detailedPersona = preset.persona;
        }
    }

    // è·å–é€‰ä¸­çš„å‘ä»¶äººåå­—
    const selectedSenders = Array.from(document.querySelectorAll('#mail-sender-list input:checked')).map(cb => cb.value);
    const selectedBookIds = Array.from(document.querySelectorAll('#mail-context-list input:checked')).map(cb => cb.value);

    if (!userMask) return alert("è¯·è®¾ç½®æ”¶ä»¶äººèº«ä»½");
    
    const btn = document.getElementById('start-generate-email-btn');
    const originalBtnText = btn.textContent; 
    btn.textContent = "è¯»å–è®°å¿†ä¸­...";
    btn.disabled = true;

    // --- 2. æ„å»ºä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ ---
    let worldBookText = "";
    for (const bid of selectedBookIds) {
        const wb = await db.worldBooks.get(bid);
        if (wb) worldBookText += `- ã€Š${wb.name}ã€‹: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join('; ')}\n`;
    }

    // --- 3. ã€æ ¸å¿ƒæ–°å¢ã€‘æ„å»ºè§’è‰²è¯¦ç»†ä¸Šä¸‹æ–‡ (è®°å¿†+å¯¹è¯) ---
    let characterContext = "";
    if (selectedSenders.length > 0) {
        // åœ¨æ‰€æœ‰èŠå¤©ä¸­æŸ¥æ‰¾é€‰ä¸­çš„å‘ä»¶äºº
        const activeChars = Object.values(state.chats).filter(c => !c.isGroup && selectedSenders.includes(c.name));
        
        if (activeChars.length > 0) {
            characterContext = "\n# ã€é‡è¦ã€‘æŒ‡å®šå‘ä»¶äººçš„è¯¦ç»†æ¡£æ¡ˆ (è¯·æ ¹æ®è¿™äº›ä¿¡æ¯ç”Ÿæˆä¸ªæ€§åŒ–é‚®ä»¶)\n";
            
            activeChars.forEach(chat => {
                // æå–é•¿æœŸè®°å¿†
                const memory = (chat.longTermMemory && chat.longTermMemory.length > 0) 
                    ? chat.longTermMemory.map(m => m.content).join('; ') 
                    : 'æš‚æ— ';
                
                // æå–æœ€è¿‘ 5 æ¡å¯¹è¯ (ç”¨äºæ•æ‰å½“å‰å…³ç³»çŠ¶æ€ï¼Œå¦‚åµæ¶ã€çƒ­æ‹ã€é™Œç”Ÿ)
                const recentHistory = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-5)
                    .map(m => `${m.role === 'user' ? 'æˆ‘' : chat.name}: ${String(m.content).substring(0, 50)}`)
                    .join('\n');

                characterContext += `## å‘ä»¶äºº: ${chat.name}\n`;
                characterContext += `- **æ ¸å¿ƒäººè®¾**: ${chat.settings.aiPersona.substring(0, 200)}...\n`; // æˆªå–ä¸€éƒ¨åˆ†é˜²æ­¢Tokenæº¢å‡º
                characterContext += `- **é•¿æœŸè®°å¿†**: ${memory}\n`;
                characterContext += `- **æœ€è¿‘å¯¹è¯çŠ¶æ€**: \n${recentHistory || '(æ— æœ€è¿‘å¯¹è¯)'}\n`;
                characterContext += `> æŒ‡å¯¼: è¯·æ ¹æ®è¯¥è§’è‰²çš„æ€§æ ¼å’Œä½ ä»¬æœ€è¿‘çš„å¯¹è¯çŠ¶æ€ï¼ˆä¾‹å¦‚æ˜¯å¦åˆšåµè¿‡æ¶ã€æ˜¯å¦æœ‰æœªå®Œæˆçš„çº¦å®šï¼‰æ¥æ’°å†™é‚®ä»¶ã€‚\n\n`;
            });
        }
    }

    // --- 4. æ„å»º Prompt ---
    const systemPrompt = `
# è§’è‰²ï¼šé‚®ä»¶ç³»ç»Ÿç”Ÿæˆå™¨
è¯·æ ¹æ®ä»¥ä¸‹è®¾å®šç”Ÿæˆ **${genCount}** å°é‚®ä»¶ã€‚

# æ”¶ä»¶äººæ¡£æ¡ˆ
- **å½“å‰èº«ä»½(User Mask)**: ${userMask}
${detailedPersona ? `- **è¯¦ç»†äººè®¾èƒŒæ™¯**: ${detailedPersona.replace(/\n/g, ' ')}` : ""}
- **æ‰€åœ¨ä¸–ç•Œè§‚**: ${worldContext || "ç°ä»£èŒåœº/ç”Ÿæ´»"}
${worldBookText ? "- **ä¸–ç•Œä¹¦è§„åˆ™**: \n" + worldBookText : ""}

${characterContext}

# å‘ä»¶äººå€™é€‰æ± 
${selectedSenders.length > 0 ? "- æŒ‡å®šå‘ä»¶äººåˆ—è¡¨: " + selectedSenders.join(', ') : ""}
${allowRandom ? "- å…è®¸ç”Ÿæˆéšæœºè·¯äºº/ç³»ç»Ÿé€šçŸ¥/åƒåœ¾é‚®ä»¶ (å¦‚: é“¶è¡Œè´¦å•, å¹¿å‘Š, ç¥ç§˜é‚€è¯·, å·¥ä½œé€šå‘Š)" : ""}

# æ ¸å¿ƒè¦æ±‚
1. **è¿è´¯æ€§**: å¦‚æœå‘ä»¶äººæ˜¯ä¸Šè¿°â€œæŒ‡å®šå‘ä»¶äººâ€ä¸­çš„è§’è‰²ï¼Œé‚®ä»¶å†…å®¹**å¿…é¡»**ä¸ä½ ä»¬çš„â€œæœ€è¿‘å¯¹è¯çŠ¶æ€â€å’Œâ€œé•¿æœŸè®°å¿†â€ç›¸ç¬¦ã€‚
   - *ä¾‹å­*: å¦‚æœæœ€è¿‘å¯¹è¯åœ¨åµæ¶ï¼Œé‚®ä»¶å¯èƒ½æ˜¯é“æ­‰ä¿¡æˆ–å†·æ·¡çš„é€šçŸ¥ï¼›å¦‚æœæœ€è¿‘åœ¨çƒ­æ‹ï¼Œé‚®ä»¶å¯èƒ½æ˜¯æƒ…ä¹¦ã€‚
2. **æ²‰æµ¸æ„Ÿ**: é‚®ä»¶å†…å®¹å¿…é¡»ç¬¦åˆæ”¶ä»¶äººèº«ä»½å’Œä¸–ç•Œè§‚ã€‚
3. **å¤šæ ·æ€§**: åŒ…å«ä¸åŒç±»å‹çš„é‚®ä»¶ï¼ˆæ­£å¼ã€éæ­£å¼ã€åƒåœ¾é‚®ä»¶ã€ç´§æ€¥é€šçŸ¥ï¼‰ã€‚
4. **æ ¼å¼**: è¿”å›ä¸€ä¸ªJSONæ•°ç»„ã€‚

# è¾“å‡ºæ ¼å¼ (JSON Only)
\`\`\`json
[
  {
    "sender": "å‘ä»¶äººå§“å",
    "subject": "é‚®ä»¶æ ‡é¢˜",
    "content": "é‚®ä»¶æ­£æ–‡ (æ”¯æŒæ¢è¡Œç¬¦\\n)",
    "timestamp_offset": 0 (è·ç¦»ç°åœ¨çš„åˆ†é’Ÿæ•°ï¼Œè´Ÿæ•°è¡¨ç¤ºè¿‡å»ï¼Œä¾‹å¦‚ 60 è¡¨ç¤ºä¸€å°æ—¶å‰æ”¶åˆ°)
  }
]
\`\`\`
`;

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        btn.textContent = "ç”Ÿæˆä¸­...";
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let config = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:`Generate ${genCount} emails`}]);
        
        const response = isGemini ? 
            await fetch(config.url, config.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:`Generate ${genCount} emails`}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("APIè¯·æ±‚å¤±è´¥");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const jsonStr = text.replace(/^```json\s*/, '').replace(/```$/, '');
        const emails = JSON.parse(jsonStr);

        // ä¿å­˜åˆ°æ•°æ®åº“
        const now = Date.now();
        const newEmails = emails.map(e => ({
            sender: e.sender,
            senderType: 'gen',
            recipient: userMask,
            subject: e.subject,
            content: e.content,
            timestamp: now - (e.timestamp_offset || 0) * 60000,
            isRead: false
        }));

        await db.emails.bulkAdd(newEmails);
        
        document.getElementById('email-generator-modal').classList.remove('visible');
        await renderEmailList();
        await showCustomAlert("æ¥æ”¶æˆåŠŸ", `æ”¶åˆ° ${newEmails.length} å°æ–°é‚®ä»¶ã€‚`);

    } catch (e) {
        console.error(e);
        alert("æ¥æ”¶å¤±è´¥: " + e.message);
    } finally {
        btn.textContent = originalBtnText;
        btn.disabled = false;
    }
});

// 7. è½¬å‘åˆ°èŠå¤© (å¡ç‰‡ç‰ˆ)
async function forwardEmailToChat(email) {
    // å¼¹å‡ºé€‰æ‹©èŠå¤©å¯¹è±¡çš„å¼¹çª— (å¤ç”¨ç°æœ‰çš„)
    await openShareTargetPicker();
    
    const confirmBtn = document.getElementById('confirm-share-target-btn');
    
    // ä½¿ç”¨ cloneNode ç§»é™¤æ—§ç›‘å¬å™¨
    const newBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
    
    newBtn.onclick = async () => {
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
            .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) return alert("è¯·é€‰æ‹©è¦è½¬å‘åˆ°çš„èŠå¤©ã€‚");

        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šä¸å†æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œè€Œæ˜¯åˆ›å»ºä¸€ä¸ªç»“æ„åŒ–æ¶ˆæ¯å¯¹è±¡
        const emailCardMsg = {
            role: 'user',
            type: 'forwarded_email', // æ–°å¢çš„ç±»å‹
            timestamp: Date.now(),
            content: `[é‚®ä»¶] ${email.subject}`, // ç®€ç•¥æ–‡æœ¬ï¼Œç”¨äºé¢„è§ˆ
            emailData: {
                subject: email.subject,
                sender: email.sender,
                date: new Date(email.timestamp).toLocaleString(),
                preview: email.content.replace(/\n/g, ' ').substring(0, 100), // æå–å‰100å­—åšé¢„è§ˆ
                fullContent: email.content // ä¿å­˜å®Œæ•´å†…å®¹ä¾›ç‚¹å‡»æŸ¥çœ‹
            }
        };

        // ç»™ AI çš„ç³»ç»Ÿæç¤º (ä¿æŒä¸å˜ï¼Œè®© AI ç†è§£é‚®ä»¶å†…å®¹)
        const forwardContentForAI = `
ğŸ“§ **è½¬å‘é‚®ä»¶**
**å‘ä»¶äºº:** ${email.sender}
**æ”¶ä»¶äºº:** ${email.recipient || 'æˆ‘'}
**ä¸»é¢˜:** ${email.subject}
----------------
${email.content}
`;

        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                // 1. æ¨é€å¡ç‰‡æ¶ˆæ¯
                targetChat.history.push(emailCardMsg);
                
            
                const isSelfEmail = (email.sender === targetChat.name) || (email.sender === targetChat.originalName);
                
                let systemHintText = "";
                
                if (isSelfEmail) {
                    // å¦‚æœæ˜¯AIè‡ªå·±å‘çš„ï¼Œå¼ºè°ƒè¿™æ˜¯â€œå›é¡¾â€
                    systemHintText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æŠŠä½ ã€ä¹‹å‰å‘ç»™TAçš„è¿™å°é‚®ä»¶ã€‘è½¬å‘å›ç»™ä½ äº†ã€‚è¯·æ³¨æ„ï¼šè¿™å°é‚®ä»¶æ˜¯**ä½ è‡ªå·±å†™**çš„ï¼Œä¸æ˜¯ç”¨æˆ·å†™çš„ã€‚ç”¨æˆ·å¯èƒ½æ˜¯æƒ³å’Œä½ è®¨è®ºé‚®ä»¶é‡Œçš„å†…å®¹ï¼Œæˆ–è€…å¯¹ä½ çš„é‚®ä»¶è¡¨ç¤ºå›åº”ã€‚è¯·ä»¥â€œé‚®ä»¶ä½œè€…â€çš„èº«ä»½è¿›è¡Œå›å¤ã€‚]`;
                } else {
                    // å¦‚æœæ˜¯åˆ«äººå‘çš„ï¼Œä¿æŒåŸæ ·
                    systemHintText = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·è½¬å‘äº†ä¸€å°é‚®ä»¶ç»™ä½ ã€‚è¿™å°é‚®ä»¶æ˜¯ã€${email.sender}ã€‘å†™çš„ã€‚è¯·æ ¹æ®å†…å®¹å’Œä½ ä»¬çš„å…³ç³»åšå‡ºååº”ã€‚]`;
                }

                // 2. æ¨é€ç³»ç»Ÿæç¤º (éšè—)
                targetChat.history.push({
                    role: 'system',
                    content: `${systemHintText}\n\n--- é‚®ä»¶è¯¦æƒ… ---\n${forwardContentForAI}`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                });
              
                
                await db.chats.put(targetChat);
            }
        }

        document.getElementById('share-target-modal').classList.remove('visible');
        await showCustomAlert("è½¬å‘æˆåŠŸ", "é‚®ä»¶å·²ä»¥å¡ç‰‡å½¢å¼å‘é€ã€‚");
        
        // å¦‚æœå½“å‰å°±åœ¨è¯¥èŠå¤©ï¼Œåˆ·æ–°æ˜¾ç¤º
        if (state.activeChatId && selectedTargetIds.includes(state.activeChatId)) {
             renderChatInterface(state.activeChatId);
        }
    };
}

// æœç´¢æ¡†äº‹ä»¶ç»‘å®š
document.getElementById('mail-search-input').addEventListener('input', renderEmailList);

// æš´éœ²ç»™å…¨å±€
window.openEmailApp = openEmailApp;
window.openEmailSettings = openEmailSettings;      
window.handleQuickReceiveMail = handleQuickReceiveMail;
window.toggleEmailEditMode = toggleEmailEditMode;
window.closeEmailDetail = closeEmailDetail;
window.deleteCurrentEmail = deleteCurrentEmail;
// --- æ–°å¢ï¼šç´§æ€¥é‡ç½®å¤–è§‚åŠŸèƒ½ (ä¸åˆ é™¤é¢„è®¾) ---
async function handleEmergencyAppearanceReset() {
    const confirmed = await showCustomConfirm(
        "ç¡®è®¤é‡ç½®å¤–è§‚ï¼Ÿ",
        "æ­¤æ“ä½œå°†æŠŠå½“å‰çš„å£çº¸ã€ä¸»é¢˜ã€CSSã€å›¾æ ‡å’Œå­—ä½“æ¢å¤ä¸ºé»˜è®¤çŠ¶æ€ã€‚\n\nâœ… ä½ çš„ã€é¢„è®¾åº“ã€‘ä¸ä¼šè¢«åˆ é™¤ã€‚\nâœ… æ­¤åŠŸèƒ½ç”¨äºä¿®å¤å›  CSS é”™è¯¯å¯¼è‡´æ— æ³•æ‰“å¼€å¤–è§‚è®¾ç½®çš„é—®é¢˜ã€‚\n\nç¡®å®šè¦æ‰§è¡Œå—ï¼Ÿ", 
        { confirmButtonClass: 'btn-danger', confirmText: 'ç«‹å³é‡ç½®' }
    );

    if (!confirmed) return;

    await showCustomAlert("å¤„ç†ä¸­...", "æ­£åœ¨é‡ç½®å¤–è§‚é…ç½®...");

    try {
        // 1. é‡ç½®å†…å­˜ä¸­çš„ state.globalSettings åˆ°é»˜è®¤å€¼ (ä»…å¤–è§‚ç›¸å…³)
        // æ³¨æ„ï¼šä¿ç•™ API Key ç­‰å…¶ä»–è®¾ç½®
        
        // æ¢å¤é»˜è®¤å›¾æ ‡å¯¹è±¡
        const defaultAppIcons = { ...DEFAULT_APP_ICONS };
        const defaultCPhoneIcons = { ...DEFAULT_CPHONE_ICONS };
        const defaultMyPhoneIcons = { ...DEFAULT_MYPHONE_ICONS };

        state.globalSettings.wallpaper = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
        state.globalSettings.cphoneWallpaper = 'linear-gradient(135deg, #f6d365, #fda085)';
        state.globalSettings.globalChatBackground = ''; // æ¸…é™¤å…¨å±€èŠå¤©èƒŒæ™¯
        state.globalSettings.globalCss = ''; // ã€æ ¸å¿ƒã€‘æ¸…ç©º CSS
        state.globalSettings.fontUrl = '';   // æ¸…ç©ºå­—ä½“
        state.globalSettings.theme = 'light'; // æ¢å¤äº®è‰²æ¨¡å¼
        state.globalSettings.appIcons = defaultAppIcons;
        state.globalSettings.cphoneAppIcons = defaultCPhoneIcons;
        state.globalSettings.myphoneAppIcons = defaultMyPhoneIcons;
        
        // æ¢å¤äº¤äº’å¼€å…³
        state.globalSettings.showStatusBar = false;
        state.globalSettings.showPhoneFrame = false;
        state.globalSettings.detachStatusBar = false;
        state.globalSettings.enableMinimalChatUI = false;
        state.globalSettings.alwaysShowMusicIsland = false;
        
        // æ¸…ç©ºè‡ªå®šä¹‰æŒ‰é’®æ’åº
        state.globalSettings.chatActionButtonsOrder = null;

        // 2. ä¿å­˜åˆ°æ•°æ®åº“
        await db.globalSettings.put(state.globalSettings);
        
        // 3. ç«‹å³åº”ç”¨æ›´æ”¹ (åˆ·æ–° UI)
        localStorage.setItem('ephone-theme', 'light');
        applyTheme('light');
        
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        
        applyGlobalCss(''); // ç«‹å³ç§»é™¤ CSS æ ·å¼
        applyCustomFont(''); // ç§»é™¤å­—ä½“
        
        applyAppIcons();
        applyCPhoneAppIcons();
        applyMyPhoneAppIconsGlobal();
        
        applyStatusBarVisibility();
        applyPhoneFrame(false);
        applyDetachStatusBarMode(false);
        applyMinimalChatUI(false);
        
        // é‡ç½®æŒ‰é’®æ’åº
        if (typeof resetButtonOrder === 'function') {
            await resetButtonOrder(); // è¿™æ˜¯ä¸€ä¸ªç°æœ‰çš„å‡½æ•°ï¼Œå¤ç”¨å®ƒ
        }

        await showCustomAlert("é‡ç½®æˆåŠŸ", "å¤–è§‚å·²æ¢å¤é»˜è®¤çŠ¶æ€ï¼\nç°åœ¨ä½ åº”è¯¥å¯ä»¥æ­£å¸¸æ‰“å¼€å¤–è§‚è®¾ç½®é¡µé¢äº†ã€‚");

    } catch (error) {
        console.error("é‡ç½®å¤–è§‚å¤±è´¥:", error);
        await showCustomAlert("é”™è¯¯", `é‡ç½®å¤±è´¥: ${error.message}`);
    }
}
// --- æ–°å¢ï¼šæ¢å¤å‡ºå‚è®¾ç½® (åˆå§‹åŒ–æ‰€æœ‰å†…å®¹) ---
async function handleFactoryReset() {
    // --- é˜²è¯¯è§¦æœºåˆ¶ ç¬¬1å±‚ï¼šå¼¹çª—è­¦å‘Š ---
    const confirmed = await showCustomConfirm(
        "â˜ ï¸ ä¸¥é‡è­¦å‘Šï¼šåˆå§‹åŒ–åº”ç”¨",
        "æ­¤æ“ä½œå°†ã€æ°¸ä¹…åˆ é™¤ã€‘æœ¬åœ°å­˜å‚¨çš„æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬ï¼š\n\nâŒ æ‰€æœ‰èŠå¤©è®°å½•å’Œè®¾å®š\nâŒ æ‰€æœ‰å›¾ç‰‡ã€è¡¨æƒ…åŒ…ã€é¢„è®¾\nâŒ æ‰€æœ‰APIé…ç½®å’Œå¤–è§‚è®¾ç½®\n\nåº”ç”¨å°†å˜å›åˆšå®‰è£…æ—¶çš„æ ·å­ã€‚æ•°æ®ä¸€æ—¦åˆ é™¤æ— æ³•æ¢å¤ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ", 
        { 
            confirmButtonClass: 'btn-danger', 
            confirmText: 'æˆ‘æ˜ç™½ï¼Œç»§ç»­' 
        }
    );

    if (!confirmed) return;

    // --- é˜²è¯¯è§¦æœºåˆ¶ ç¬¬2å±‚ï¼šå¼ºåˆ¶è¾“å…¥éªŒè¯ ---
    // è¦æ±‚ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥ç‰¹å®šæ–‡å­—ï¼Œé˜²æ­¢æ‰‹æ»‘è¿ç‚¹
    const verificationText = "ç«‹å³é‡ç½®";
    const userInput = await showCustomPrompt(
        "æœ€ç»ˆç¡®è®¤",
        `ä¸ºäº†ç¡®è®¤è¿™ä¸æ˜¯è¯¯æ“ä½œï¼Œè¯·åœ¨ä¸‹æ–¹æ¡†ä¸­å‡†ç¡®è¾“å…¥â€œ${verificationText}â€å››ä¸ªå­—ï¼š`,
        "",
        "text"
    );

    if (userInput !== verificationText) {
        await showCustomAlert("æ“ä½œå–æ¶ˆ", "éªŒè¯æ–‡å­—è¾“å…¥é”™è¯¯ï¼Œåˆå§‹åŒ–å·²å–æ¶ˆã€‚");
        return;
    }

    // --- æ‰§è¡Œæ¸…ç† ---
    await showCustomAlert("æ­£åœ¨é‡ç½®...", "æ­£åœ¨é”€æ¯æ‰€æœ‰æ•°æ®ï¼Œåº”ç”¨å³å°†é‡å¯...");

    try {
        // 1. æ¸…ç©º IndexedDB æ‰€æœ‰è¡¨
        // æˆ‘ä»¬ä¸ä½¿ç”¨ db.delete() æ˜¯ä¸ºäº†é¿å…é‡è¿æ•°æ®åº“çš„å¤æ‚æ€§ï¼Œç›´æ¥æ¸…ç©ºè¡¨å†…å®¹æ•ˆæœä¸€æ ·ä¸”æ›´ç¨³
        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                console.log(`æ­£åœ¨æ¸…ç©ºè¡¨: ${table.name}`);
                await table.clear();
            }
        });

        // 2. æ¸…ç©º LocalStorage (åŒ…æ‹¬ä¸»é¢˜ã€è¯­è¨€ã€æœªè¯»è®¡æ•°ã€ä¸´æ—¶ç¼“å­˜ç­‰)
        localStorage.clear();

        // 3. å¼ºåˆ¶åˆ·æ–°é¡µé¢
        // å»¶è¿Ÿä¸€ä¸‹è®©ç”¨æˆ·çœ‹åˆ°æç¤ºï¼Œç„¶ååˆ·æ–°é‡è½½æ•´ä¸ªåº”ç”¨
        setTimeout(() => {
            window.location.reload(true);
        }, 1000);

    } catch (error) {
        console.error("åˆå§‹åŒ–å¤±è´¥:", error);
        await showCustomAlert("é”™è¯¯", `é‡ç½®è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}\nè¯·å°è¯•æ‰‹åŠ¨æ¸…é™¤æµè§ˆå™¨ç¼“å­˜ã€‚`);
    }
}
// --- æ–°å¢ï¼šç®€æ˜“å›¾ç‰‡æ”¾å¤§æŸ¥çœ‹å™¨ (ç‹¬ç«‹äºç›¸å†Œ) ---
function openSimpleImageZoom(src) {
    // 1. æ£€æŸ¥é¡µé¢ä¸Šæ˜¯å¦å·²ç»æœ‰è¿™ä¸ªé®ç½©å±‚ï¼Œæ²¡æœ‰å°±åˆ›å»º
    let overlay = document.getElementById('simple-image-zoom-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'simple-image-zoom-overlay';
        overlay.innerHTML = '<img src="" alt="Zoomed Image">';
        
        // ç‚¹å‡»é®ç½©å±‚ä»»æ„ä½ç½®å…³é—­
        overlay.addEventListener('click', () => {
            overlay.classList.remove('visible');
            setTimeout(() => { overlay.style.display = 'none'; }, 250);
        });
        
        document.body.appendChild(overlay);
    }

    // 2. è®¾ç½®å›¾ç‰‡å¹¶æ˜¾ç¤º
    const img = overlay.querySelector('img');
    img.src = src;
    
    overlay.style.display = 'flex';
    // å¼ºåˆ¶é‡ç»˜ä»¥è§¦å‘ transition
    void overlay.offsetWidth; 
    overlay.classList.add('visible');
}
// --- Reddit åŠŸèƒ½æ¨¡å— ---

async function handleRedditSearch(query = '') {
    const listEl = document.getElementById('char-reddit-list');
    listEl.innerHTML = '<div class="spinner"></div>'; // åŠ è½½ä¸­

    let targetUrl;
    if (query === 'popular' || !query) {
        targetUrl = `https://www.reddit.com/r/popular.json?limit=30&raw_json=1`;
    } else {
        targetUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=30&raw_json=1&sort=relevance`;
    }

    // ä½¿ç”¨ CORS ä»£ç†ç»•è¿‡è·¨åŸŸé™åˆ¶
    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error("ç½‘ç»œè¯·æ±‚å¤±è´¥");
        
        const json = await response.json();
        const posts = json.data.children;
        
        renderRedditList(posts);
    } catch (error) {
        console.error("Reddit API Error:", error);
        listEl.innerHTML = '<p style="text-align:center; padding:20px; color:#999;">æ— æ³•è¿æ¥åˆ° Redditï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ä»£ç†ã€‚</p>';
    }
}
// [Modify] openRedditDetail to handle cross-screen navigation
async function openRedditDetail(post) {
    // 1. Detect if we are opening from the Chat Interface
    const isFromChat = document.getElementById('chat-interface-screen').classList.contains('active');

    const titleEl = document.getElementById('char-article-title');
    const contentEl = document.getElementById('char-article-content');
    const backBtn = document.querySelector('#char-browser-article-screen .back-btn');
    
    // Header actions setup
    let headerActions = document.querySelector('#char-browser-article-screen .header .header-actions');
    if (!headerActions) {
        const header = document.querySelector('#char-browser-article-screen .header');
        headerActions = document.createElement('div');
        headerActions.className = 'header-actions';
        header.appendChild(headerActions);
    }

    // UI Loading State
    titleEl.textContent = "åŠ è½½ä¸­...";
    contentEl.innerHTML = '<div class="spinner" style="margin-top:50px;"></div>';
    
    // 2. Critical Fix: Switch Main Screen if coming from Chat
    if (isFromChat) {
        showScreen('character-phone-screen');
    }
    
    // Switch Sub-screen
    switchToCharScreen('char-browser-article-screen');

    // 3. Configure Back Button based on source
    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        if (isFromChat) {
            // If from chat, go back to chat
            showScreen('chat-interface-screen');
        } else {
            // If from app list, go back to app list
            switchToCharScreen('char-reddit-screen');
        }
    };
    
    // 4. Setup Forward Button
    headerActions.innerHTML = '';
    const forwardBtn = document.createElement('span');
    forwardBtn.className = 'action-btn';
    forwardBtn.innerHTML = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>`;
    forwardBtn.title = "è½¬å‘ç»™TA";
    headerActions.appendChild(forwardBtn);

    // 5. Handle Inner Links
    contentEl.onclick = async (e) => {
        const link = e.target.closest('a.reddit-inner-link');
        if (link) {
            e.preventDefault();
            const href = link.href;
            const redditMatch = href.match(/reddit\.com\/r\/[^\/]+\/comments\/([a-zA-Z0-9]+)/);
            if (redditMatch) {
                const urlObj = new URL(href);
                const permalink = urlObj.pathname; 
                // Recursively open, preserving context logic is tricky, so we treat inner links as internal nav
                await openRedditDetail({ permalink: permalink });
            } else {
                window.open(href, '_blank');
            }
        }
    };

    try {
        // 6. Fetch Data
        const permalink = post.permalink;
        if (!permalink) throw new Error("æ— æ•ˆçš„å¸–å­é“¾æ¥");

        const targetUrl = `https://www.reddit.com${permalink}.json?raw_json=1`;
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
        
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error("æ— æ³•åŠ è½½å¸–å­è¯¦æƒ…");

        const json = await response.json();
        const fullPostData = json[0].data.children[0].data;
        const commentsData = json[1].data.children;
        
        // Forward Logic Data Object
        const postObjForForward = {
            id: fullPostData.id,
            title: fullPostData.title,
            subreddit_name_prefixed: fullPostData.subreddit_name_prefixed,
            author: fullPostData.author,
            score: fullPostData.score,
            num_comments: fullPostData.num_comments,
            permalink: fullPostData.permalink,
            selftext: fullPostData.selftext || '',
            thumbnail: (fullPostData.preview && fullPostData.preview.images[0]) ? fullPostData.preview.images[0].source.url.replace(/&amp;/g, '&') : (fullPostData.thumbnail && fullPostData.thumbnail.startsWith('http') ? fullPostData.thumbnail : null),
            url: fullPostData.url
        };
        
        forwardBtn.onclick = () => {
            forwardRedditPost(null, postObjForForward); 
        };

        // Render Title
        titleEl.textContent = fullPostData.subreddit_name_prefixed;

        let htmlContent = '';

        // A. Header
        htmlContent += `
            <div style="margin-bottom: 15px;">
                <h2 style="font-size: 20px; font-weight: bold; margin: 0 0 8px 0;">${escapeHTML(fullPostData.title)}</h2>
                <div style="color: #888; font-size: 12px;">
                    u/${fullPostData.author} â€¢ ${new Date(fullPostData.created_utc * 1000).toLocaleString()}
                </div>
            </div>
        `;

        // B. Media
        const ytMatch = fullPostData.url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/\s]{11})/);
        
        if (ytMatch) {
            const videoId = ytMatch[1];
            htmlContent += `
                <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; margin-bottom: 10px; background: #000;">
                    <iframe src="https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1&playsinline=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" frameborder="0" allowfullscreen></iframe>
                </div>`;
        } else if (fullPostData.is_video && fullPostData.media && fullPostData.media.reddit_video) {
            htmlContent += `
    <video controls playsinline poster="${fullPostData.thumbnail}" style="width: 100%; border-radius: 8px; margin-bottom: 5px; background: #000;">
        <source src="${fullPostData.media.reddit_video.fallback_url}" type="video/mp4">
    </video>
    <div style="font-size:12px; color:#999; margin-bottom:15px;">
        âš ï¸ æ³¨ï¼šRedditåŸç”Ÿè§†é¢‘å¯èƒ½æ— å£°ï¼Œ<a href="${fullPostData.url}" target="_blank" style="color:#007aff;">ç‚¹å‡»æ­¤å¤„è·³è½¬åŸç½‘é¡µè§‚çœ‹</a>
    </div>`;
        } else if (fullPostData.url && fullPostData.url.match(/\.(jpg|jpeg|png|gif)$/i)) {
            htmlContent += `<img src="${fullPostData.url}" style="width:100%; border-radius:8px; margin-bottom:15px;">`;
        } else if (fullPostData.preview && fullPostData.preview.images && fullPostData.preview.images.length > 0) {
            const imgUrl = fullPostData.preview.images[0].source.url.replace(/&amp;/g, '&');
            htmlContent += `<img src="${imgUrl}" style="width:100%; border-radius:8px; margin-bottom:15px;">`;
        }

        // C. Text
        if (fullPostData.selftext) {
            let processedText = escapeHTML(fullPostData.selftext);
            processedText = processedText.replace(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g, '<a href="$2" class="reddit-inner-link" style="color:#007aff; text-decoration:none;">$1</a>');
            processedText = processedText.replace(/(^|\s)(https?:\/\/[^\s<]+)/g, '$1<a href="$2" class="reddit-inner-link" style="color:#007aff; text-decoration:none;">ğŸ”— Link</a>');
            processedText = processedText.replace(/\n/g, '<br>');
            htmlContent += `<div style="line-height:1.6; font-size:15px; color:#333; margin-bottom:20px; word-break: break-word;">${processedText}</div>`;
        } 

        // D. Data Bar
        const score = fullPostData.score > 1000 ? (fullPostData.score/1000).toFixed(1) + 'k' : fullPostData.score;
        htmlContent += `
            <div style="display:flex; gap:20px; padding:10px 0; border-top:1px solid #eee; border-bottom:1px solid #eee; margin-bottom:15px; font-size:13px; color:#555; align-items:center;">
                <span style="display:flex; align-items:center; gap:4px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:#ff4500;">
                        <path d="M12 19V5M5 12l7-7 7 7"/>
                    </svg> 
                    ${score} èµ
                </span>
                <span style="display:flex; align-items:center; gap:4px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                    </svg>
                    ${fullPostData.num_comments} è¯„è®º
                </span>
            </div>
        `;

        // E. Comments
        htmlContent += `<div style="font-weight:bold; margin-bottom:10px;">è¯„è®º</div>`;
        if (commentsData.length === 0) {
            htmlContent += `<div style="text-align:center; color:#999; padding:20px;">æš‚æ— è¯„è®º</div>`;
        } else {
            commentsData.forEach(child => {
                const c = child.data;
                if (!c.body) return;
                htmlContent += `
                    <div class="reddit-comment-item" style="margin-bottom:15px; padding-bottom:15px; border-bottom:1px solid #f9f9f9;">
                        <div style="font-size:12px; color:#888; margin-bottom:4px; display:flex; justify-content:space-between;">
                            <span style="color: #1c1c1e; font-weight: 500;">${c.author}</span>
                            <span>${c.score} pts</span>
                        </div>
                        <div style="font-size:14px; line-height:1.5; color:#333;">${escapeHTML(c.body).replace(/\n/g, '<br>')}</div>
                    </div>
                `;
            });
        }

        contentEl.innerHTML = htmlContent;
        contentEl.scrollTop = 0;

    } catch (error) {
        console.error("Reddit Detail Error:", error);
        contentEl.innerHTML = `
            <div style="padding:20px; text-align:center;">
                <h3>åŠ è½½å¤±è´¥</h3>
                <p style="color:#888; font-size:14px;">${error.message}</p>
            </div>
        `;
    }
}
function renderRedditList(posts) {
    const listEl = document.getElementById('char-reddit-list');
    listEl.innerHTML = '';

    if (!posts || posts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; padding:20px; color:#999;">æœªæ‰¾åˆ°å†…å®¹</p>';
        return;
    }

    posts.forEach(child => {
        const post = child.data;
        
        // å›¾ç‰‡æå–é€»è¾‘
        let previewImage = '';
        if (post.preview && post.preview.images && post.preview.images.length > 0) {
            previewImage = post.preview.images[0].source.url.replace(/&amp;/g, '&');
        } else if (post.thumbnail && post.thumbnail.startsWith('http')) {
            previewImage = post.thumbnail;
        }

        const item = document.createElement('div');
        item.className = 'reddit-post-item';
        
        // åˆ†æ•°æ˜¾ç¤ºä¼˜åŒ–
        const score = post.score > 1000 ? (post.score/1000).toFixed(1) + 'k' : post.score;

        item.innerHTML = `
            <div class="reddit-vote-box">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: #ff4500;">
                    <path d="M12 19V5M5 12l7-7 7 7"/>
                </svg>
                <span style="font-weight:bold; margin-top:2px;">${score}</span>
            </div>
            <div class="reddit-content-box">
                <div class="reddit-meta">
                    <div class="reddit-sub-icon"></div>
                    <strong>${post.subreddit_name_prefixed}</strong>
                    <span>â€¢ u/${post.author}</span>
                </div>
                <div class="reddit-title">${post.title}</div>
                ${previewImage ? `<img src="${previewImage}" class="reddit-preview-img" loading="lazy">` : ''}
                
                <button class="reddit-forward-btn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    è½¬å‘ç»™TA
                </button>
            </div>
        `;
        
        // ç¼“å­˜æ•°æ®ä»¥ä¾¿è½¬å‘ä½¿ç”¨
        if (!window.redditPostCache) window.redditPostCache = new Map();
        window.redditPostCache.set(post.id, post);

        // --- ã€å…³é”®ä¿®æ”¹ 1ã€‘ç‚¹å‡»å¡ç‰‡æ•´ä½“ -> æ‰“å¼€è¯¦æƒ…é¡µ ---
        item.addEventListener('click', () => {
            openRedditDetail(post);
        });

        // --- ã€å…³é”®ä¿®æ”¹ 2ã€‘ç‚¹å‡»è½¬å‘æŒ‰é’® -> è§¦å‘è½¬å‘ (å¹¶é˜»æ­¢å†’æ³¡) ---
        const forwardBtn = item.querySelector('.reddit-forward-btn');
        forwardBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // é˜»æ­¢è§¦å‘è¯¦æƒ…é¡µè·³è½¬
            forwardRedditPost(post.id); // ç›´æ¥è°ƒç”¨å‡½æ•°
        });

        listEl.appendChild(item);
    });
}

// [ä¿®æ”¹] è½¬å‘ Reddit å¸–å­ (æ”¯æŒé€‰äºº + ä¸ç«‹å³å›å¤)
// å‚æ•°: postId (ä»åˆ—è¡¨ç‚¹å‡»æ—¶ä¼ å…¥), directData (ä»è¯¦æƒ…é¡µç‚¹å‡»æ—¶ç›´æ¥ä¼ å…¥æ•°æ®å¯¹è±¡)
async function forwardRedditPost(postId, directData = null) {
    // 1. è·å–å¸–å­æ•°æ®
    let post;
    if (directData) {
        post = directData;
    } else {
        // åˆ—è¡¨æ¨¡å¼ï¼šä»ç¼“å­˜è·å–
        if (!window.redditPostCache) window.redditPostCache = new Map();
        post = window.redditPostCache.get(postId);
    }

    if (!post) {
        alert("æ— æ³•è·å–å¸–å­æ•°æ®");
        return;
    }

    // 2. å¼¹å‡ºé€‰æ‹©å™¨ (å¤ç”¨ç°æœ‰çš„ Share Picker)
    await openShareTargetPicker();
    
    const confirmBtn = document.getElementById('confirm-share-target-btn');
    
    // ä½¿ç”¨ cloneNode ç§»é™¤æ—§ç›‘å¬å™¨ï¼Œé˜²æ­¢é‡å¤ç»‘å®š
    const newBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
    
    newBtn.onclick = async () => {
        // 3. è·å–é€‰ä¸­çš„èŠå¤©å¯¹è±¡
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
            .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) return alert("è¯·é€‰æ‹©è¦è½¬å‘åˆ°çš„èŠå¤©ã€‚");

        // 4. æ„é€ ç”¨æˆ·å¡ç‰‡æ¶ˆæ¯ (User View)
        const redditMsg = {
            role: 'user',
            type: 'reddit_share',
            timestamp: Date.now(),
            redditData: {
                title: post.title,
                subreddit: post.subreddit_name_prefixed,
                author: post.author,
                score: post.score,
                num_comments: post.num_comments,
                permalink: post.permalink,
                // å¤„ç†å›¾ç‰‡é“¾æ¥
                image: post.thumbnail || (post.preview && post.preview.images[0] ? post.preview.images[0].source.url.replace(/&amp;/g, '&') : null),
                selftext: post.selftext ? post.selftext.substring(0, 150) + '...' : ''
            }
        };
        
        document.getElementById('share-target-modal').classList.remove('visible');
        
        // 5. åå°æŠ“å–å®Œæ•´å†…å®¹ (ç»™ AI çœ‹) - è¿™éƒ¨åˆ†éœ€è¦ä¸€ç‚¹æ—¶é—´
        // ä¸ºäº†ä½“éªŒï¼Œå…ˆæ˜¾ç¤º"æ­£åœ¨å‘é€"ï¼Œå®é™…ä¸Šæ˜¯åå°å¼‚æ­¥å¤„ç†
        await showCustomAlert("è½¬å‘ä¸­...", "æ­£åœ¨ç”Ÿæˆé¢„è§ˆå¹¶å‘é€ï¼Œè¯·ç¨å€™...");
        
        // æ„å»º AI ä¸Šä¸‹æ–‡
        let fullContextForAI = `æ ‡é¢˜: "${post.title}"\næ¥è‡ª: ${post.subreddit_name_prefixed}\n`;
        if (post.selftext) {
             fullContextForAI += `\n[å†…å®¹æ‘˜è¦]: ${post.selftext.substring(0, 500)}...\n`;
        }
        
        // å°è¯•å¼‚æ­¥è·å–æ›´å¤šè¯¦æƒ… (å¯é€‰)
        try {
            const targetUrl = `https://www.reddit.com${post.permalink}.json?raw_json=1`;
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
            const res = await fetch(proxyUrl);
            if (res.ok) {
                const json = await res.json();
                const comments = json[1].data.children;
                // è¡¥å……å‰3æ¡çƒ­è¯„
                if (comments.length > 0) {
                    fullContextForAI += `\n[çƒ­é—¨è¯„è®º (Top 3)]:\n`;
                    comments.slice(0, 3).forEach((c, i) => {
                        if (c.data.body) {
                            fullContextForAI += `${i+1}. ${c.data.author}: ${c.data.body.substring(0, 150)}\n`;
                        }
                    });
                }
            }
        } catch (e) {
            console.warn("æŠ“å–è¯¦æƒ…å¤±è´¥ï¼Œä»…ä½¿ç”¨åŸºæœ¬ä¿¡æ¯", e);
        }

        // 6. å¾ªç¯å‘é€ç»™é€‰ä¸­çš„èŠå¤©
        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                // A. æ¨é€å¡ç‰‡æ¶ˆæ¯
                targetChat.history.push(redditMsg);
                
                // B. æ¨é€ç³»ç»Ÿæç¤º (éšè—æ¶ˆæ¯ï¼Œç»™AIçœ‹)
                const hiddenSystemMsg = {
                    role: 'system',
                    content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·è½¬å‘äº†ä¸€ä¸ª Reddit å¸–å­ç»™ä½ ã€‚
è¯·ä½ é˜…è¯»ä»¥ä¸‹å¸–å­è¯¦æƒ…å’Œç½‘å‹è¯„è®ºã€‚
æ³¨æ„ï¼š**ç”¨æˆ·è¿˜æ²¡æœ‰å¯¹æ­¤å‘è¡¨çœ‹æ³•**ï¼ŒTAå¯èƒ½æ­£åœ¨æ‰“å­—ã€‚è¯·ä½ **å…ˆä¸è¦å›å¤**ï¼Œè€å¿ƒç­‰å¾…ç”¨æˆ·æ¥ä¸‹æ¥çš„æ¶ˆæ¯ã€‚
---
${fullContextForAI}
---]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                targetChat.history.push(hiddenSystemMsg);
                await db.chats.put(targetChat);
            }
        }

        // 7. è·³è½¬é€»è¾‘
        // éšè—æç¤ºæ¡†
        document.querySelector('#custom-modal-overlay').classList.remove('visible');
        
        // å¦‚æœåªé€‰äº†ä¸€ä¸ªäººï¼Œç›´æ¥è·³è½¬åˆ°é‚£ä¸ªäººçš„èŠå¤©çª—å£
        if (selectedTargetIds.length === 1) {
            const targetId = selectedTargetIds[0];
            showScreen('chat-interface-screen'); // åˆ‡åˆ°èŠå¤©ç•Œé¢å®¹å™¨
            openChat(targetId); // åŠ è½½å…·ä½“èŠå¤©
            
            // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šè¿™é‡Œä¸å†è°ƒç”¨ triggerAiResponse()
            // å¹¶ä¸”è®©è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹ï¼Œæ–¹ä¾¿ç”¨æˆ·ç»§ç»­è¯´è¯
            setTimeout(() => {
                const input = document.getElementById('chat-input');
                if (input) input.focus();
            }, 500);
            
        } else {
            // å¦‚æœé€‰äº†å¤šä¸ªäººï¼Œæç¤ºå‘é€æˆåŠŸå¹¶åœç•™åœ¨å½“å‰é¡µæˆ–å›åˆ—è¡¨
            alert(`å·²è½¬å‘ç»™ ${selectedTargetIds.length} ä½å¥½å‹ã€‚`);
        }
    };
}
window.forwardRedditPost = forwardRedditPost;
// --- [æ›´æ–°ç‰ˆ] æ ¹æ®äººè®¾ç”Ÿæˆ Reddit æ¨èæµ (æ”¯æŒ15-20ä¸ªå…³é”®è¯ + ç¨³å®šæœç´¢) ---
async function handleGenerateSimulatedReddit() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ·±åº¦åˆ†æâ€œ${chat.name}â€çš„å…´è¶£ç½‘ç»œ...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®å¥½APIä¿¡æ¯ã€‚');
        return;
    }

    // 1. å‡†å¤‡ä¸Šä¸‹æ–‡æ•°æ®
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? 'ç”¨æˆ·' : state.qzoneSettings.nickname;
    
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    // ç¡®ä¿ filterHistoryWithDoNotSendRules å¯ç”¨ï¼Œå¦‚æœæŠ¥é”™è¯·æ£€æŸ¥è¯¥å‡½æ•°æ˜¯å¦å®šä¹‰
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : 'æ— ';

    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    // 2. æ„å»º Prompt (ä¿®æ”¹äº†æ•°é‡è¦æ±‚)
    const systemPrompt = `
# ä½ çš„ä»»åŠ¡
ä½ æ˜¯ä¸€ä¸ªè™šæ‹Ÿç”¨æˆ·ç”»åƒåˆ†æå¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”è§’è‰²â€œ${chat.name}â€ï¼Œæ ¹æ®TAçš„äººè®¾ã€æ‰€å¤„çš„ä¸–ç•Œè§‚ã€é•¿æœŸè®°å¿†ã€ä»¥åŠä¸ç”¨æˆ·ï¼ˆ${userDisplayNameForAI}ï¼‰çš„æœ€è¿‘äº’åŠ¨ï¼Œ**æ¨æµ‹TAç°åœ¨æœ€å¯èƒ½åœ¨ Reddit ä¸Šæµè§ˆæˆ–æœç´¢çš„å…³é”®è¯**ã€‚

# æ ¸å¿ƒè§„åˆ™
1.  **è¯­è¨€ç­–ç•¥**: 
    - è¯·æ ¹æ®è§’è‰²çš„äººè®¾å’Œæƒ³çœ‹çš„å†…å®¹å†³å®šè¯­è¨€ã€‚
    - å¦‚æœè§’è‰²æƒ³çœ‹å›½é™…æ–°é—»ã€æŠ€æœ¯æ–‡æ¡£ã€è¿·å›  (Memes) æˆ–ç‰¹å®šå¤–è¯­å†…å®¹ï¼Œè¯·ç”Ÿæˆã€è‹±æ–‡ã€‘å…³é”®è¯ã€‚
    - å¦‚æœè§’è‰²æƒ³çœ‹ä¸­æ–‡åœˆçš„è®¨è®ºã€åè¯­æ–°é—»æˆ–ç‰¹å®šä¸­æ–‡è¯é¢˜ï¼Œè¯·ç”Ÿæˆã€ä¸­æ–‡ã€‘å…³é”®è¯ã€‚
2.  **æ·±åº¦äººè®¾ç»‘å®š**: å…³é”®è¯å¿…é¡»ç´§æ‰£è§’è‰²çš„æ€§æ ¼ã€èŒä¸šã€çˆ±å¥½ä»¥åŠ**ä¸–ç•Œè§‚è®¾å®š**ã€‚
3.  **å¤šæ ·æ€§ä¸æ•°é‡ (å…³é”®)**: è¯·ç”Ÿæˆ **15åˆ°20ä¸ª** ä¸åŒçš„å…³é”®è¯ï¼Œæ¶µç›–è§’è‰²å…´è¶£çš„å„ä¸ªæ–¹é¢ï¼ˆä»æ ¸å¿ƒçˆ±å¥½åˆ°æ½œæ„è¯†çš„å¥½å¥‡ï¼‰ã€‚
4.  **æ ¼å¼é“å¾‹**: 
    - ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
    - æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª**å­—ç¬¦ä¸²**ã€‚
    - ç¤ºä¾‹: \`["keyword1", "r/China_irl", "coding help", "çŒ«å’ª", ...]\`

# ä¾›ä½ å‚è€ƒçš„è¯¦ç»†ä¸Šä¸‹æ–‡
- **è§’è‰²äººè®¾**: ${chat.settings.aiPersona}
- **ç”¨æˆ·(${userDisplayNameForAI})çš„äººè®¾**: ${chat.settings.myPersona || 'æ— '}
- **é•¿æœŸè®°å¿†**: 
${longTermMemoryContext}
${worldBookContext} 
- **æœ€è¿‘å¯¹è¯**:
${recentHistoryWithUser}

ç°åœ¨ï¼Œè¯·ç”Ÿæˆè¿™ç»„è¯¦ç»†çš„ Reddit æœç´¢å…³é”®è¯ã€‚`;

    try {
        // 3. è°ƒç”¨ LLM
        const messagesForApi = [{ role: 'user', content: "è¯·ç”ŸæˆRedditå…³é”®è¯åˆ—è¡¨ã€‚" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    // ä½¿ç”¨å…¨å±€è®¾ç½®çš„æ¸©åº¦ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ 1.0
                    temperature: state.globalSettings.apiTemperature || 1.0, 
                })
            });

        if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        
        let keywords;
        try {
            keywords = JSON.parse(cleanedJson);
        } catch (e) {
            throw new Error("AIè¿”å›æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æJSON");
        }

        if (!Array.isArray(keywords) || keywords.length === 0) throw new Error("AIæ²¡æœ‰è¿”å›æœ‰æ•ˆçš„å…³é”®è¯æ•°ç»„ã€‚");

        // 4. [æ ¸å¿ƒä¿®æ”¹] é€ä¸ªæœç´¢å…³é”®è¯ (ä¸²è¡Œ+å»¶è¿Ÿï¼Œé˜²æ­¢å°å·)
        await showCustomAlert("æœç´¢ä¸­...", `AI ç”Ÿæˆäº† ${keywords.length} ä¸ªå…´è¶£å…³é”®è¯ï¼Œæ­£åœ¨èšåˆå…¨ç½‘å†…å®¹... (è¿™ä¸€æ­¥å¯èƒ½éœ€è¦åå‡ ç§’ï¼Œè¯·è€å¿ƒç­‰å¾…)`);
        
        const listEl = document.getElementById('char-reddit-list');
        listEl.innerHTML = '<div class="spinner" style="margin-top:50px;"></div>';

        // ä¸å†æˆªå– slice(0, 4)ï¼Œä½¿ç”¨å…¨éƒ¨å…³é”®è¯ (keywords)
        const queries = keywords; 
        let aggregatedPosts = [];

        // å®šä¹‰å»¶æ—¶å‡½æ•°
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // å®šä¹‰å•ä¸ªæœç´¢å‡½æ•°
        const fetchRedditData = async (query) => {
            try {
                let targetUrl;
                // é’ˆå¯¹ r/xxx ä¼˜åŒ–
                if (query.startsWith('r/')) {
                    // limit=5, ç¨å¾®å‡å°‘å•æ¬¡è¯·æ±‚é‡ï¼Œå› ä¸ºæˆ‘ä»¬æ€»è¯·æ±‚æ¬¡æ•°å˜å¤šäº†
                    targetUrl = `https://www.reddit.com/${query}/hot.json?limit=5&raw_json=1`;
                } else {
                    targetUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=5&raw_json=1&sort=relevance`;
                }
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                
                const res = await fetch(proxyUrl);
                if(!res.ok) return [];
                const json = await res.json();
                return json.data.children; 
            } catch (e) {
                console.warn(`æœç´¢å…³é”®è¯ ${query} å¤±è´¥:`, e);
                return [];
            }
        };

        // [ä¿®æ”¹] ä½¿ç”¨ for...of å¾ªç¯ä¸²è¡Œè¯·æ±‚ï¼Œè€Œä¸æ˜¯ Promise.all å¹¶è¡Œ
        // è¿™æ ·è™½ç„¶æ…¢ä¸€ç‚¹ï¼Œä½†èƒ½ä¿è¯ 20 ä¸ªè¯éƒ½èƒ½æœå®Œè€Œä¸ç‚¸æ¥å£
        for (const [index, query] of queries.entries()) {
            // åœ¨æ§åˆ¶å°æ‰“å°è¿›åº¦ï¼Œæ–¹ä¾¿è°ƒè¯•
            console.log(`[Redditç”Ÿæˆæµ] æ­£åœ¨æœç´¢ (${index + 1}/${queries.length}): ${query}`);
            
            const posts = await fetchRedditData(query);
            if (posts && posts.length > 0) {
                aggregatedPosts.push(...posts);
            }
            
            // æ¯æ¬¡è¯·æ±‚é—´éš” 600ms
            await delay(600);
        }

        if (aggregatedPosts.length === 0) {
            throw new Error("æ‰€æœ‰å…³é”®è¯éƒ½æœªèƒ½æœç´¢åˆ°å†…å®¹ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜æˆ–å…³é”®è¯å¤ªåé—¨ã€‚");
        }

        // 5. å»é‡ä¸æ‰“ä¹± (æ´—ç‰Œç®—æ³•)
        const uniquePosts = [];
        const seenIds = new Set();
        
        // æ´—ç‰Œ
        for (let i = aggregatedPosts.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [aggregatedPosts[i], aggregatedPosts[j]] = [aggregatedPosts[j], aggregatedPosts[i]];
        }

        // å»é‡
        aggregatedPosts.forEach(item => {
            const post = item.data;
            if (!seenIds.has(post.id)) {
                seenIds.add(post.id);
                uniquePosts.push(item);
            }
        });

        // æˆªå–å‰ 30 æ¡æ˜¾ç¤º (å‘¼åº”ä½ ä¹‹å‰çš„éœ€æ±‚)
        const finalFeed = uniquePosts.slice(0, 30);

        // 6. ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“ (æŒä¹…åŒ–)
        chat.simulatedRedditFeed = finalFeed; 
        await db.chats.put(chat);             
        console.log(`Reddit æ¨èæµå·²ä¿å­˜ï¼Œå…± ${finalFeed.length} æ¡`);

        // 7. æ¸²æŸ“
        renderRedditList(finalFeed);
        
        // æ›´æ–°å¼¹çª—æç¤ºå®Œæˆ
        // (showCustomAlert é»˜è®¤æœ‰ç¡®è®¤æŒ‰é’®ï¼Œä¸ºäº†ä½“éªŒå¯ä»¥ä¸å¼¹æ–°çš„ï¼Œæˆ–è€…è‡ªåŠ¨å…³é—­æ—§çš„)
        // è¿™é‡Œæˆ‘ä»¬ç›´æ¥è®©ç•Œé¢æ˜¾ç¤ºå‡ºæ¥å³å¯

    } catch (error) {
        console.error("ç”Ÿæˆ Reddit æ¨èå¤±è´¥:", error);
        await showCustomAlert("ç”Ÿæˆå¤±è´¥", `æ— æ³•ç”Ÿæˆæ¨èå†…å®¹ã€‚\né”™è¯¯: ${error.message}`);
        // å¤±è´¥æ—¶å›é€€åˆ°çƒ­é—¨
        handleRedditSearch('popular');
    }
}
  async function init() {

    initLanguage();
 
    async function handleWorldBookImport(files) {
      if (!files || files.length === 0) return;

      try {
        // åˆ†ç¦»JSONæ–‡ä»¶å’ŒTXTæ–‡ä»¶
        const jsonFiles = [];
        const txtFiles = [];
        
        for (const file of files) {
          if (file.name.toLowerCase().endsWith('.json')) {
            jsonFiles.push(file);
          } else if (file.name.toLowerCase().endsWith('.txt')) {
            txtFiles.push(file);
          }
        }

        // å¤„ç†JSONæ–‡ä»¶ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼Œä»…å¤„ç†ç¬¬ä¸€ä¸ªJSONæ–‡ä»¶ï¼‰
        if (jsonFiles.length > 0) {
          const file = jsonFiles[0];
          const text = await file.text();
          const data = JSON.parse(text);

          if (data.type === 'EPhoneWorldBookBackup') {
            console.log("æ£€æµ‹åˆ° EPhone å¤‡ä»½æ–‡ä»¶ï¼Œæ‰§è¡Œæ ‡å‡†å¯¼å…¥...");
            await importWorldBooks(data);
          } else if (data.entries && typeof data.entries === 'object') {
            console.log("æ£€æµ‹åˆ° ä¸–ç•Œä¹¦æ–‡ä»¶ï¼Œéœ€è¦æ¿€æ´»ç ...");
            try {
              await requirePinActivation();
              await importTavernWorldBook(data, file.name);
            } catch (error) {
              console.warn("ä¸–ç•Œä¹¦å¯¼å…¥è¢«å–æ¶ˆ:", error.message);
            }
          } else {
            throw new Error("æ–‡ä»¶æ ¼å¼æ— æ³•è¯†åˆ«ã€‚è¯·ç¡®ä¿æ‚¨é€‰æ‹©çš„æ˜¯æœ‰æ•ˆçš„ EPhone ä¸–ç•Œä¹¦å¤‡ä»½æˆ– Tavern AI ä¸–ç•Œä¹¦æ–‡ä»¶ã€‚");
          }
        }

        // å¤„ç†TXTæ–‡ä»¶
        if (txtFiles.length > 0) {
          await handleTxtWorldBookImport(txtFiles);
        }

      } catch (error) {
        console.error("å¯¼å…¥ä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£ææˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
      }
    }

    // æ–°å¢ï¼šå¤„ç†TXTæ–‡ä»¶å¯¼å…¥
    async function handleTxtWorldBookImport(txtFiles) {
      try {
        // è¯»å–æ‰€æœ‰TXTæ–‡ä»¶çš„å†…å®¹
        const fileContents = await Promise.all(
          txtFiles.map(async (file) => ({
            name: file.name,
            content: await file.text()
          }))
        );

        // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†è®©ç”¨æˆ·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶
        const selectedFiles = await showTxtImportConfirmModal(fileContents);
        
        if (!selectedFiles || selectedFiles.length === 0) {
          return;
        }

        // ä¸ºæ¯ä¸ªé€‰ä¸­çš„TXTæ–‡ä»¶åˆ›å»ºä¸€æœ¬ä¸–ç•Œä¹¦
        let importedCount = 0;
        for (const fileData of selectedFiles) {
          const bookName = fileData.name.replace(/\.txt$/i, '');
          
          const newWorldBook = {
            id: 'wb_txt_' + Date.now() + '_' + importedCount,
            name: bookName,
            content: [{
              keys: [],
              comment: 'ç”±TXTæ–‡ä»¶å¯¼å…¥',
              content: fileData.content.trim(),
              enabled: true
            }],
            categoryId: null
          };

          await db.worldBooks.add(newWorldBook);
          state.worldBooks.push(newWorldBook);
          importedCount++;
          
          // æ·»åŠ å°å»¶è¿Ÿç¡®ä¿IDå”¯ä¸€
          await new Promise(resolve => setTimeout(resolve, 10));
        }

        await renderWorldBookScreen();
        await showCustomAlert('å¯¼å…¥æˆåŠŸ', `æˆåŠŸå¯¼å…¥ ${importedCount} ä¸ªTXTæ–‡ä»¶åˆ°ä¸–ç•Œä¹¦ï¼`);

      } catch (error) {
        console.error("TXTæ–‡ä»¶å¯¼å…¥å¤±è´¥:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `TXTæ–‡ä»¶å¯¼å…¥å¤±è´¥: ${error.message}`);
      }
    }

    // æ˜¾ç¤ºTXTæ–‡ä»¶å¯¼å…¥ç¡®è®¤å¯¹è¯æ¡†
    function showTxtImportConfirmModal(fileContents) {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'flex';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <h2 style="margin-top: 0;">ç¡®è®¤å¯¼å…¥TXTæ–‡ä»¶</h2>
            <p style="color: #666; margin-bottom: 15px;">
              æ‰¾åˆ° ${fileContents.length} ä¸ªTXTæ–‡ä»¶ï¼Œè¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶ï¼š
            </p>
            <div style="flex: 1; overflow-y: auto; margin-bottom: 20px;">
              ${fileContents.map((file, index) => `
                <div style="margin-bottom: 15px; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                  <label style="display: flex; align-items: start; cursor: pointer;">
                    <input type="checkbox" class="txt-import-checkbox" data-index="${index}" 
                           style="margin-right: 10px; margin-top: 3px;" checked>
                    <div style="flex: 1;">
                      <div style="font-weight: bold; margin-bottom: 8px;">${escapeHTML(file.name)}</div>
                      <div style="font-size: 12px; color: #666; max-height: 100px; overflow: auto; 
                                  white-space: pre-wrap; word-break: break-word; 
                                  background: white; padding: 8px; border-radius: 4px;">
                        ${escapeHTML(file.content.substring(0, 200))}${file.content.length > 200 ? '...' : ''}
                      </div>
                      <div style="font-size: 11px; color: #999; margin-top: 5px;">
                        æ–‡ä»¶å¤§å°: ${(file.content.length / 1024).toFixed(2)} KB
                      </div>
                    </div>
                  </label>
                </div>
              `).join('')}
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
              <button id="txt-import-select-all" style="padding: 10px 20px; background: #666; color: white; 
                      border: none; border-radius: 5px; cursor: pointer;">å…¨é€‰</button>
              <button id="txt-import-cancel" style="padding: 10px 20px; background: #ccc; color: #333; 
                      border: none; border-radius: 5px; cursor: pointer;">å–æ¶ˆ</button>
              <button id="txt-import-confirm" style="padding: 10px 20px; background: #007aff; color: white; 
                      border: none; border-radius: 5px; cursor: pointer;">ç¡®è®¤å¯¼å…¥</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        const checkboxes = modal.querySelectorAll('.txt-import-checkbox');
        
        // å…¨é€‰/å–æ¶ˆå…¨é€‰æŒ‰é’®
        const selectAllBtn = modal.querySelector('#txt-import-select-all');
        let allSelected = true;
        selectAllBtn.addEventListener('click', () => {
          allSelected = !allSelected;
          checkboxes.forEach(cb => cb.checked = allSelected);
          selectAllBtn.textContent = allSelected ? 'å–æ¶ˆå…¨é€‰' : 'å…¨é€‰';
        });

        // å–æ¶ˆæŒ‰é’®
        modal.querySelector('#txt-import-cancel').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve(null);
        });

        // ç¡®è®¤æŒ‰é’®
        modal.querySelector('#txt-import-confirm').addEventListener('click', () => {
          const selected = [];
          checkboxes.forEach(cb => {
            if (cb.checked) {
              const index = parseInt(cb.dataset.index);
              selected.push(fileContents[index]);
            }
          });
          
          document.body.removeChild(modal);
          
          if (selected.length === 0) {
            showCustomAlert('æç¤º', 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œå¯¼å…¥');
            resolve(null);
          } else {
            resolve(selected);
          }
        });

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            document.body.removeChild(modal);
            resolve(null);
          }
        });
      });
    }

 
    async function importTavernWorldBook(tavernData, fileName) {
      const bookNameSuggestion = fileName.replace(/\.json$/i, '');

      const newBookName = await showCustomPrompt(
        "å¯¼å…¥ Tavern AI ä¸–ç•Œä¹¦",
        "è¯·ä¸ºè¿™æœ¬è®¾å®šé›†å‘½åï¼š",
        bookNameSuggestion
      );

      if (!newBookName || !newBookName.trim()) {
        alert("å¯¼å…¥å·²å–æ¶ˆï¼Œå› ä¸ºæœªæä¾›ä¹¦åã€‚");
        return;
      }

      const newEntries = Object.values(tavernData.entries).map(entry => {

        return {
          keys: entry.key || [],
          comment: entry.comment || 'æ— å¤‡æ³¨',
          content: entry.content || '',
          enabled: !entry.disable
        };
      }).filter(entry => entry.content);

      if (newEntries.length === 0) {
        alert("è¿™ä¸ª Tavern AI ä¸–ç•Œä¹¦ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆçš„æ¡ç›®ã€‚");
        return;
      }

      const newWorldBook = {
        id: 'wb_' + Date.now(),
        name: newBookName.trim(),
        content: newEntries,
        categoryId: null
      };

      await db.worldBooks.add(newWorldBook);
      state.worldBooks.push(newWorldBook);
      await renderWorldBookScreen();

      await showCustomAlert('å¯¼å…¥æˆåŠŸï¼', `å·²æˆåŠŸä» Tavern AI æ–‡ä»¶å¯¼å…¥è®¾å®šé›†ã€Š${newBookName}ã€‹ã€‚`);
    }


    async function exportWorldBooks() {
      try {
        const books = await db.worldBooks.toArray();
        const categories = await db.worldBookCategories.toArray();

        if (books.length === 0 && categories.length === 0) {
          alert("æ²¡æœ‰å¯å¯¼å‡ºçš„ä¸–ç•Œä¹¦æ•°æ®ã€‚");
          return;
        }

        const backupData = {
          type: 'EPhoneWorldBookBackup',
          version: 1,
          timestamp: Date.now(),
          books: books,
          categories: categories
        };

        const blob = new Blob(
          [JSON.stringify(backupData, null, 2)], {
            type: 'application/json'
          }
        );
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `EPhone-WorldBooks-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);

        await showCustomAlert('å¯¼å‡ºæˆåŠŸ', 'æ‰€æœ‰ä¸–ç•Œä¹¦æ•°æ®å·²æˆåŠŸå¯¼å‡ºï¼');

      } catch (error) {
        console.error("å¯¼å‡ºä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å‡ºå¤±è´¥', `å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯: ${error.message}`);
      }
    }


    async function importWorldBooks(data) {

      try {
        if (data.type !== 'EPhoneWorldBookBackup' || !data.books) {
          throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¸–ç•Œä¹¦å¤‡ä»½æ–‡ä»¶ã€‚");
        }

        const confirmed = await showCustomConfirm(
          'å¯¼å…¥ä¸–ç•Œä¹¦',
          'è¿™å°†ç”¨æ–‡ä»¶ä¸­çš„æ•°æ®ã€å®Œå…¨è¦†ç›–ã€‘æ‚¨å½“å‰æ‰€æœ‰çš„ä¸–ç•Œä¹¦å’Œåˆ†ç±»ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼', {
            confirmButtonClass: 'btn-danger',
            confirmText: 'ç¡®è®¤è¦†ç›–'
          }
        );

        if (!confirmed) return;

        await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
          await db.worldBooks.clear();
          await db.worldBookCategories.clear();

          if (Array.isArray(data.books)) {
            await db.worldBooks.bulkPut(data.books);
          }
          if (Array.isArray(data.categories)) {
            await db.worldBookCategories.bulkPut(data.categories);
          }
        });


        state.worldBooks = await db.worldBooks.toArray();
        await renderWorldBookScreen();

        await showCustomAlert('å¯¼å…¥æˆåŠŸ', 'ä¸–ç•Œä¹¦æ•°æ®å·²æˆåŠŸæ¢å¤ï¼');

      } catch (error) {
        console.error("å¯¼å…¥ä¸–ç•Œä¹¦æ—¶å‡ºé”™:", error);
        await showCustomAlert('å¯¼å…¥å¤±è´¥', `æ–‡ä»¶è§£ææˆ–åº”ç”¨å¤±è´¥: ${error.message}`);
      }
    }



    const lastActiveTimestamp = localStorage.getItem('ephoneLastActiveTimestamp');
    if (lastActiveTimestamp) {
      const minutesOffline = (Date.now() - parseInt(lastActiveTimestamp)) / (1000 * 60);

      if (minutesOffline > 5) {


        simulateBackgroundActivity(minutesOffline);
      }
    }

    setupCharPlayerControls();

    window.showScreen = showScreen;
    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.handleListenTogetherClick = handleListenTogetherClick;

    window.openCharacterSelector = openCharacterSelector;
    window.openCharApp = openCharApp;
    window.switchToMyPhone = switchToMyPhone;
    window.openCharWallet = openCharWallet;
    window.switchToCharHomeScreen = switchToCharHomeScreen;
    window.openNpcEditor = openNpcEditor;
    
    // MY Phone å‡½æ•°æš´éœ²
    window.openMyphoneScreen = openMyphoneScreen;
    window.openMyPhoneApp = openMyPhoneApp;
    window.switchToMyPhoneHomeScreen = switchToMyPhoneHomeScreen;
    window.switchToCPhone = switchToCPhone;
    window.openMyPhoneSettings = openMyPhoneSettings;
    window.openMyPhoneViewRecords = openMyPhoneViewRecords;
    window.showMyPhoneAddContactDialog = showMyPhoneAddContactDialog;
    window.manualCreateMyPhoneContact = manualCreateMyPhoneContact;
    window.showImportMainScreenCharacters = showImportMainScreenCharacters;
    window.updateImportSelectAllState = updateImportSelectAllState;
    window.importSelectedCharacters = importSelectedCharacters;
    window.openMyPhoneContactSettings = openMyPhoneContactSettings;
    window.saveMyPhoneContactSettings = saveMyPhoneContactSettings;
    window.changeMyPhoneContactAvatar = changeMyPhoneContactAvatar;
    window.addMyPhoneMessage = addMyPhoneMessage;
    window.showMyPhoneTransferActionModal = showMyPhoneTransferActionModal;
    window.handleMyPhoneTransferResponse = handleMyPhoneTransferResponse;



    const stickerActionBar = document.createElement('div');
    stickerActionBar.id = 'sticker-action-bar';
    stickerActionBar.innerHTML = `
       <input type="checkbox" id="select-all-stickers-checkbox" style="margin-right: 10px;">
      <button id="delete-selected-stickers-btn" class="form-button-secondary">åˆ é™¤ (0)</button>
   `;
    document.getElementById('sticker-panel').appendChild(stickerActionBar);
   const exportStickersBtn = document.createElement('button');
   exportStickersBtn.id = 'export-selected-stickers-btn';
   exportStickersBtn.textContent = 'å¯¼å‡º (0)';
   exportStickersBtn.className = 'form-button'; // ä½¿ç”¨ä¸»æŒ‰é’®æ ·å¼
   exportStickersBtn.style.marginLeft = '10px';
   
   stickerActionBar.appendChild(exportStickersBtn);
   
   exportStickersBtn.addEventListener('click', executeBatchExportStickers);
    const globalCssStyleTag = document.createElement('style');
    globalCssStyleTag.id = 'global-custom-style';
    document.head.appendChild(globalCssStyleTag);


    qzoneStickerPanelState.panelEl = document.getElementById('qzone-sticker-panel');
    qzoneStickerPanelState.gridEl = document.getElementById('qzone-sticker-grid');

    const savedTheme = localStorage.getItem('ephone-theme') || 'light';
    applyTheme(savedTheme);



    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);



    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);




    applyScopedCss('', '#chat-messages', 'custom-bubble-style');
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');

    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.showScreen = showScreen;
    window.renderChatListProxy = renderChatList;
    window.renderApiSettingsProxy = renderApiSettings;
    window.renderWallpaperScreenProxy = renderWallpaperScreen;
    window.renderWorldBookScreenProxy = renderWorldBookScreen;

    await loadAllDataFromDB();
    await initFunds();
    applyStatusBarVisibility();
    applyPhoneFrame(state.globalSettings.showPhoneFrame);
    applyDetachStatusBarMode(state.globalSettings.detachStatusBar);
    applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
    await migrateOldRedPacketData();


    applyGlobalCss(state.globalSettings.globalCss);



    const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
    updateUnreadIndicator(storedCount);



    if (state.globalSettings && state.globalSettings.fontUrl) {
      applyCustomFont(state.globalSettings.fontUrl);
    }

    updateClock();
    setInterval(updateClock, 1000 * 30);
    applyGlobalWallpaper();
    initBatteryManager();

    applyAppIcons();
    applyWidgetData();





    document.getElementById('rules-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('rules-tab')) {
        switchRuleCategory(e.target.dataset.categoryId);
      }
    });



    document.getElementById('add-new-rule-btn').addEventListener('click', () => openRuleEditor(null));
    document.getElementById('cancel-rule-editor-btn').addEventListener('click', () => {
      document.getElementById('rule-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-rule-btn').addEventListener('click', saveRenderingRule);



    document.getElementById('pat-btn').addEventListener('click', async () => {

      if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
        const chat = state.chats[state.activeChatId];

        // å¼¹å‡ºé€‰æ‹©æ¡†ï¼šæ‹è‡ªå·±è¿˜æ˜¯æ‹å¯¹æ–¹
        const choice = await showChoiceModal('æ‹ä¸€æ‹', [
          { text: 'æ‹å¯¹æ–¹', value: 'pat_other' },
          { text: 'æ‹è‡ªå·±', value: 'pat_self' }
        ]);

        if (choice === 'pat_other') {
          handleUserPat(chat.id, chat.originalName);
        } else if (choice === 'pat_self') {
          handleUserPatSelf(chat.id);
        }
      }
    });


    let activeAnnouncementId = null;

 
    function showAnnouncementActions(annoId) {
      activeAnnouncementId = annoId;
      const chat = state.chats[state.activeChatId];
      const announcement = chat.announcements.find(a => a.id === annoId);
      if (!announcement) return;

      const pinButton = document.getElementById('announcement-action-pin');

      pinButton.textContent = announcement.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶å…¬å‘Š';

      document.getElementById('announcement-actions-modal').classList.add('visible');
    }

 
    async function handlePinAnnouncement() {
      if (!activeAnnouncementId) return;
      const chat = state.chats[state.activeChatId];
      const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
      if (announcement) {
        announcement.isPinned = !announcement.isPinned;
        await db.chats.put(chat);
        showAnnouncementBoard();
      }
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    }

  
    async function handleDeleteAnnouncement() {
      if (!activeAnnouncementId) return;

      const confirmed = await showCustomConfirm("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™æ¡å…¬å‘Šå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚", {
        confirmButtonClass: 'btn-danger'
      });

      if (confirmed) {
        const chat = state.chats[state.activeChatId];

        chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
        await db.chats.put(chat);
        showAnnouncementBoard();
      }
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    }

    document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
    document.getElementById('custom-modal-overlay').addEventListener('click', (e) => {
      if (e.target === modalOverlay) hideCustomModal();
    });
    document.getElementById('export-data-btn').addEventListener('click', async () => {

      const choice = await showChoiceModal('é€‰æ‹©å¯¼å‡ºæ–¹å¼', [{
          text: 'åˆ†ç‰‡å¯¼å‡º (æ¨èï¼Œæ‰“åŒ…ä¸ºZIPï¼Œè§£å‹æ¯ä¸ªåˆ‡ç‰‡é€‰æ‹©å¢é‡å¯¼å…¥)',
          value: 'slice'
        },
        {
          text: 'æ™ºèƒ½å¯¼å‡º (å•ä¸ªå¤§æ–‡ä»¶ï¼Œå¤ªå¤§å¯èƒ½ä¼šå¯¼è‡´å¯¼å…¥ä¸äº†)',
          value: 'stream'
        },
        {
          text: 'ä¼ ç»Ÿå¯¼å‡º (å…¼å®¹æ—§ç‰ˆæˆ–å†…å­˜å°çš„æµè§ˆå™¨)',
          value: 'blob'
        }
      ]);


      if (choice === 'slice') {
        exportDataAsSlicedZip();
      } else if (choice === 'stream') {
        exportDataAsStream();
      } else if (choice === 'blob') {
        exportDataAsBlob();
      }

    });



    document.getElementById('cleanup-data-btn').addEventListener('click', cleanupRedundantData);

    document.getElementById('offline-mode-toggle').addEventListener('change', (e) => {

      document.getElementById('offline-mode-options').style.display = e.target.checked ? 'block' : 'none';
    });
    document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
    document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
      document.getElementById('time-zone-group').style.display = e.target.checked ? 'block' : 'none';
    });

    document.getElementById('import-data-input').addEventListener('change', e => handleSmartImport(e.target.files[0]));
    document.getElementById('import-card-input').addEventListener('change', handleCardImport);
    
    // æ‰¹é‡å¯¼å…¥æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬
    document.getElementById('select-all-import-cards')?.addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('.batch-import-card-checkbox');
      checkboxes.forEach(cb => {
        cb.checked = e.target.checked;
        const cardId = cb.dataset.cardId;
        const card = pendingImportCards.find(c => c.id === cardId);
        if (card) card.selected = e.target.checked;
      });
    });
    
    document.getElementById('confirm-batch-import-btn')?.addEventListener('click', confirmBatchImport);
    document.getElementById('cancel-batch-import-btn')?.addEventListener('click', cancelBatchImport);
    
    // ============================================================
    // â–¼â–¼â–¼ å…¨å±€å®‰å…¨è¿”å›ä¸å˜é‡æ¸…ç†ç³»ç»Ÿ (é˜²ç‚¸ç¾¤/é˜²ä¸²å°) â–¼â–¼â–¼
    // ============================================================

    // 1. å®šä¹‰é€šç”¨æ¸…ç†å‡½æ•° (æ‰€æœ‰â€œé€€å‡º/è¿”å›â€æ“ä½œéƒ½åº”è¯¥è°ƒç”¨å®ƒ)
    function forceGlobalCleanup() {
        console.log("æ‰§è¡Œå…¨å±€å˜é‡æ¸…ç†...");
        
        // A. æ¸…ç†å›å¤/å¼•ç”¨çŠ¶æ€
        if (typeof cancelReplyMode === 'function') cancelReplyMode();
        currentReplyContext = null;

        // B. æ¸…ç†å¤šé€‰/ç¼–è¾‘æ¨¡å¼
        if (typeof exitSelectionMode === 'function') exitSelectionMode();
        
        // C. æ¸…ç†å®šæ—¶å™¨ (é˜²æ­¢å¤–å–/æ¸¸æˆå€’è®¡æ—¶åœ¨åå°æŠ¥é”™)
        if (typeof cleanupWaimaiTimers === 'function') cleanupWaimaiTimers();
        if (typeof stopAutoBackupTimer === 'function') stopAutoBackupTimer(); // å¦‚æœæœ‰è‡ªåŠ¨å¤‡ä»½

        // D. å¼ºåˆ¶å…³é—­æ‚¬æµ®å±‚/é¢æ¿
        const gomokuOverlay = document.getElementById('gomoku-overlay');
        if (gomokuOverlay) {
             gomokuOverlay.classList.remove('visible');
             // é‡ç½®äº”å­æ£‹çŠ¶æ€ï¼Œé˜²æ­¢ä¸‹æ¬¡æ‰“å¼€å¡æ­»
             if(state.activeChatId && gomokuState[state.activeChatId]) {
                 gomokuState[state.activeChatId].isActive = false; 
             }
        }
        
        const stickerPanel = document.getElementById('sticker-panel');
        if (stickerPanel) stickerPanel.classList.remove('visible');

        const musicPanel = document.getElementById('music-playlist-panel');
        if (musicPanel) musicPanel.classList.remove('visible');

        // E. æ¸…ç†å…¨å±€ä¸´æ—¶å˜é‡ (æœ€é‡è¦çš„ä¸€æ­¥ï¼)
        ruleCache = {}; 
        activeMessageTimestamp = null; 
        activeTransferTimestamp = null; 
        //lastRawAiResponse = ''; 
        //lastResponseTimestamps = [];
        
        // F. é‡ç½® UI æ ·å¼
        applyScopedCss('', '#chat-messages', 'custom-bubble-style');
        applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');
        
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) typingIndicator.style.display = 'none';
        
        // G. æ ¸å¿ƒï¼šè§£é™¤å½“å‰èŠå¤©ç»‘å®š
        state.activeChatId = null;
    }

    // 2. ç»‘å®šï¼šèŠå¤©ç•Œé¢ -> è¿”å›åˆ—è¡¨
    document.getElementById('back-to-list-btn').addEventListener('click', () => {
        forceGlobalCleanup(); // æ‰§è¡Œæ¸…ç†
        showScreen('chat-list-screen'); // åˆ‡æ¢ç”»é¢
    });

    // 3. ç»‘å®šï¼šç‹¼äººæ€ -> é€€å‡ºæ¸¸æˆ
    document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('é€€å‡ºæ¸¸æˆ', 'ç¡®å®šè¦é€€å‡ºå½“å‰è¿™å±€ç‹¼äººæ€å—ï¼Ÿæ¸¸æˆè¿›åº¦å°†ä¸ä¼šè¢«ä¿å­˜ã€‚', {
            confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
            werewolfGameState.isActive = false;
            
            // å¦‚æœæ˜¯ç¾¤èŠæ¨¡å¼ï¼Œè¿”å›èŠå¤©ç•Œé¢ï¼ˆä¸æ¸…ç†activeChatIdï¼Œå› ä¸ºè¿˜åœ¨ç¾¤é‡Œï¼‰
            if (werewolfGameState.chatId) {
                showScreen('chat-interface-screen');
            } else {
                // å¦‚æœæ˜¯å…¨å±€æ¨¡å¼ï¼Œè¿”å›ä¸»é¡µï¼ˆæ‰§è¡Œæ¸…ç†ï¼ï¼‰
                forceGlobalCleanup();
                showScreen('home-screen');
            }
        }
    });

    // 4. ç»‘å®šï¼šç»¿æ±Ÿ/æ”¯ä»˜å®/è®¾ç½® -> è¿”å›ä¸»é¡µ (è‡ªåŠ¨æŸ¥æ‰¾å¹¶ç»‘å®š)
    // å› ä¸ºè¿™äº›æŒ‰é’®åœ¨HTMLé‡Œæ²¡æœ‰IDï¼Œæˆ‘ä»¬ç”¨é€‰æ‹©å™¨æ‰¹é‡ç»‘å®šâ€œå®‰å…¨é”â€
    const safeBackSelectors = [
        '#green-river-screen .gr-icon-btn', // ç»¿æ±Ÿè¿”å›
        '#alipay-screen .back-btn',         // æ”¯ä»˜å®è¿”å›
        '#api-settings-screen .back-btn',   // APIè®¾ç½®è¿”å›
        '#wallpaper-screen .back-btn',      // å¤–è§‚è®¾ç½®è¿”å›
        '#font-settings-screen .back-btn',  // å­—ä½“è®¾ç½®è¿”å›
        '#tutorial-screen .back-btn'        // æ•™ç¨‹è¿”å›
    ];

    safeBackSelectors.forEach(selector => {
        const btn = document.querySelector(selector);
        if (btn) {
            // ç§»é™¤æ—§çš„ inline onclick (å¦‚æœæœ‰å†²çªçš„è¯)ï¼Œæˆ–è€…ç›´æ¥è¿½åŠ 
            // è¿™é‡Œæˆ‘ä»¬è¿½åŠ ä¸€ä¸ªæ¸…ç†æ“ä½œï¼Œå®ƒä¼šåœ¨ onclick è·³è½¬ä¹‹å‰æˆ–åŒæ—¶æ‰§è¡Œ
            btn.addEventListener('click', () => {
                forceGlobalCleanup();
                // æ³¨æ„ï¼šåŸæœ¬çš„ showScreen('home-screen') å†™åœ¨ HTML onclick é‡Œï¼Œä¾ç„¶ä¼šæ‰§è¡Œ
                // è¿™é‡Œåªæ˜¯é¢å¤–åŠ äº†ä¸€é“ä¿é™©
            });
        }
    });

    // ============================================================


    document.getElementById('add-chat-btn').addEventListener('click', async () => {

      const choice = await showChoiceModal('åˆ›å»ºæ–°èŠå¤©', [{
          text: 'æ‰‹åŠ¨åˆ›å»ºè§’è‰²',
          value: 'manual'
        },
        {
          text: 'ä»è§’è‰²å¡å¯¼å…¥ (.json/.png)',
          value: 'import_card'
        },
        {
          text: 'å¯¼å…¥æ–‡ä»¶ï¼ˆä»…TXTã€DOCXã€ZIPï¼ŒZIPä¹Ÿåªè§£æTXTå’ŒDOCXï¼‰',
          value: 'import_file'
        }
      ]);

      if (choice === 'manual') {

        const remarkName = await showCustomPrompt('åˆ›å»ºæ–°èŠå¤© (ç¬¬1/2æ­¥)', 'è¯·è¾“å…¥ä½ æƒ³ä¸ºTaè®¾ç½®çš„ã€å¤‡æ³¨åã€‘');
        if (!remarkName || !remarkName.trim()) return;

        const originalName = await showCustomPrompt('åˆ›å»ºæ–°èŠå¤© (ç¬¬2/2æ­¥)', 'è¯·è¾“å…¥Taçš„ã€æœ¬åã€‘');
        if (!originalName || !originalName.trim()) return;


        const newChatId = 'chat_' + Date.now();
        const newChat = {
          id: newChatId,
          name: remarkName.trim(),
          originalName: originalName.trim(),
          isGroup: false,
          isPinned: false,
          unreadCount: 0,
          relationship: {
            status: 'friend',
            blockedTimestamp: null,
            applicationReason: ''
          },
          status: {
            text: 'åœ¨çº¿',
            lastUpdate: Date.now(),
            isBusy: false
          },
          settings: {
            aiPersona: 'è¿™æ˜¯ä¸€ä¸ªé€šè¿‡æ‰‹åŠ¨åˆ›å»ºçš„è§’è‰²ã€‚',
            myPersona: 'æˆ‘æ˜¯è°å‘€ã€‚',
            myNickname: 'æˆ‘',
            maxMemory: 10,
            aiAvatar: defaultAvatar,
            myAvatar: defaultAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarLibrary: [],
            myAvatarLibrary: [],
            enableBackgroundActivity: true,
            actionCooldownMinutes: 15,
            enableTimePerception: true,
            isOfflineMode: false,
            offlineMinLength: 100,
            offlineMaxLength: 300,
            offlinePresetId: null,
            timeZone: 'Asia/Shanghai',
            myPhoneLockScreenEnabled: false,
            myPhoneLockScreenPassword: '',
            userStatus: {
              text: 'åœ¨çº¿',
              lastUpdate: Date.now(),
              isBusy: false
            }
          },
          history: [],
          musicData: {
            totalTime: 0
          },
          longTermMemory: [],
          thoughtsHistory: []
        };
        state.chats[newChatId] = newChat;
        await db.chats.put(newChat);
        renderChatList();

      } else if (choice === 'import_card') {
     
        try {
          
          await requirePinActivation();

        
          document.getElementById('import-card-input').click();

        } catch (error) {
        
          console.warn("è§’è‰²å¡å¯¼å…¥è¢«å–æ¶ˆ:", error.message);
        }
       
      } else if (choice === 'import_file') {
        // å¯¼å…¥æ–‡ä»¶ï¼ˆéé…’é¦†ï¼‰
        await handleCharacterFileImport();
      }
    });



    document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);

    document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
    document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

    document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
    document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
    document.getElementById('music-return-btn').addEventListener('click', returnToChat);
    document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
    document.getElementById('music-next-btn').addEventListener('click', playNext);
    document.getElementById('music-prev-btn').addEventListener('click', playPrev);
    document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
    document.getElementById('music-playlist-btn').addEventListener('click', () => {
      updatePlaylistUI();
      document.getElementById('music-playlist-panel').classList.add('visible');
    });
    document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
    document.getElementById('manage-playlist-btn').addEventListener('click', togglePlaylistManagementMode);
    document.getElementById('select-all-playlist-checkbox').addEventListener('change', handleSelectAllPlaylistItems);
    document.getElementById('delete-selected-songs-btn').addEventListener('click', executeDeleteSelectedSongs);
    document.getElementById('upload-selected-to-catbox-btn').addEventListener('click', executeBatchUploadToCatbox);
    document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
    document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
    document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);

    document.getElementById('playlist-body').addEventListener('click', (e) => {
      const target = e.target;
      const trackIndex = parseInt(target.dataset.index);

      if (isNaN(trackIndex)) return;

      if (target.classList.contains('album-art-btn')) {
        handleChangeAlbumArt(trackIndex);
      } else if (target.classList.contains('lyrics-btn')) {
        handleManualLrcImport(trackIndex);
      } else if (target.classList.contains('bg-btn')) {
        handleChangeBackground(trackIndex);
      } else if (target.classList.contains('delete-track-btn')) {
        deleteTrack(trackIndex);
      }
    });

    audioPlayer.addEventListener('ended', async () => { // 1. åœ¨è¿™é‡Œæ·»åŠ  async
  document.getElementById('vinyl-view').classList.remove('spinning');
  
  // 2. ä¿æŒ playNext(true) ä¸å˜ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šå‘é€â€œç”¨æˆ·åˆ‡æ­Œâ€çš„é”™è¯¯æç¤º
  playNext(true); 

  // 3. ç­‰å¾… playNext æ‰§è¡Œå®Œæ¯•ï¼Œç¡®ä¿ musicState.currentIndex å·²ç»æ›´æ–°
  //    (æ³¨æ„ï¼šplayNext ä¸æ˜¯å¼‚æ­¥çš„ï¼Œä½† playSong æ˜¯ã€‚ä¸è¿‡ playNext ä¼šåŒæ­¥æ›´æ–° currentIndex)
  //    ä¸ºäº†ä¿é™©èµ·è§ï¼Œæˆ‘ä»¬ç¨å¾®ç­‰å¾…ä¸€ä¸‹ç¡®ä¿çŠ¶æ€å·²æ›´æ–°ã€‚
  await new Promise(resolve => setTimeout(resolve, 50)); 

  // 4. æ‰‹åŠ¨æ·»åŠ ä¸€æ¡â€œè‡ªåŠ¨æ¢æ­Œâ€çš„ç³»ç»Ÿæç¤º
  const track = musicState.playlist[musicState.currentIndex]; 
  if (track && musicState.isActive && musicState.activeChatId) {
    const chat = state.chats[musicState.activeChatId];
    if (chat) {
      const systemMessage = {
        role: 'system',
        content: `[ç³»ç»Ÿæç¤ºï¼šä¸Šä¸€é¦–æ­Œæ›²æ’­æ”¾å®Œæ¯•ï¼Œå·²è‡ªåŠ¨ä¸ºä½ åˆ‡æ¢åˆ°ã€Š${track.name}ã€‹ - ${track.artist}]`,
        timestamp: Date.now(),
        isHidden: true // è¿™æ¡æ¶ˆæ¯ç”¨æˆ·çœ‹ä¸è§ï¼Œä½†AIåœ¨ä¸‹æ¬¡å›å¤æ—¶ä¼šè¯»åˆ°
      };
      chat.history.push(systemMessage);
      await db.chats.put(chat); // å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“
    }
  }
});





    const chatInput = document.getElementById('chat-input');


    document.getElementById('send-btn').addEventListener('click', () => {
      playSilentAudio();
      const content = chatInput.value.trim();
      if (!content || !state.activeChatId) return;

      const chat = state.chats[state.activeChatId];
      if (content.startsWith('/n ') || content.startsWith('/æ—ç™½ ')) {
        const narrationText = content.replace(/^\/n\s+|^\/æ—ç™½\s+/, '');
        
        const msg = {
            role: 'system', // è®¾ä¸º system å±…ä¸­æ˜¾ç¤º
            type: 'narration',
            content: narrationText,
            timestamp: Date.now()
        };
        
        // ä¿å­˜å¹¶æ¸²æŸ“
        chat.history.push(msg);
        db.chats.put(chat);
        appendMessage(msg, chat);
        
        chatInput.value = '';
        chatInput.style.height = 'auto';
        chatInput.focus();
        return; // é˜»æ­¢å‘é€æ™®é€šæ¶ˆæ¯
    }
      const msg = {
        role: 'user',
        content,
        timestamp: Date.now()
      };

      if (currentReplyContext) {
        msg.quote = currentReplyContext;
      }


      appendMessage(msg, chat);


      (async () => {
        chat.history.push(msg);
        await db.chats.put(chat);
        renderChatList();

      })();


      chatInput.value = '';
      chatInput.style.height = 'auto';
      chatInput.focus();
      cancelReplyMode();
      document.body.classList.remove('chat-actions-expanded');
    });
    document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-btn').click();
      }
    });


    document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    
    const base64Url = await new Promise((res, rej) => {
      const reader = new FileReader();
      reader.onload = () => res(reader.result);
      reader.onerror = () => rej(reader.error);
      reader.readAsDataURL(file);
    });

   
    newWallpaperBase64 = base64Url;

  
    renderWallpaperScreen(); 

  
    if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
        
        (async () => {
            try {
                console.log("[ImgBB] åå°å¼€å§‹ä¸Šä¼ å£çº¸...");
                
                const imageUrl = await uploadImageToImgBB(base64Url);

               
                if (newWallpaperBase64 === base64Url) {
                    newWallpaperBase64 = imageUrl; // æ‚„æ‚„åœ°å°†å˜é‡æ›´æ–°ä¸º URL
                    console.log("[ImgBB] åå°å£çº¸ä¸Šä¼ æˆåŠŸï¼Œä¸´æ—¶å˜é‡å·²æ›´æ–°ä¸º URLã€‚");
                } else {
                    console.log("[ImgBB] åå°å£çº¸ä¸Šä¼ å®Œæˆï¼Œä½†ç”¨æˆ·å·²æ›´æ”¹é€‰æ‹©ï¼Œæ”¾å¼ƒæ›´æ–°ã€‚");
                }
            } catch (uploadError) {
             
                console.error("åå°å£çº¸ä¸Šä¼ å¤±è´¥:", uploadError.message);
                
            }
        })(); 
    }

  
    event.target.value = null; 
  }
});

    document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {

      if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
      }




      state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
      state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;

      state.globalSettings.showPhoneFrame = document.getElementById('phone-frame-toggle-switch').checked;
      state.globalSettings.enableMinimalChatUI = document.getElementById('minimal-chat-ui-switch').checked;
      state.globalSettings.alwaysShowMusicIsland = document.getElementById('dynamic-island-music-toggle-switch').checked;
      state.globalSettings.detachStatusBar = document.getElementById('detach-status-bar-switch').checked;
      state.globalSettings.lockScreenEnabled = document.getElementById('lock-screen-toggle').checked;
      state.globalSettings.lockScreenPassword = document.getElementById('lock-screen-password-input').value.trim();
      
      const lockPreview = document.getElementById('lock-wallpaper-preview');
      if (lockPreview.dataset.tempUrl) {
          state.globalSettings.lockScreenWallpaper = lockPreview.dataset.tempUrl;
      }
      await db.globalSettings.put(state.globalSettings);


      applyGlobalWallpaper();
      applyCPhoneWallpaper();
      newWallpaperBase64 = null;

      applyAppIcons();
      applyCPhoneAppIcons();
      applyMyPhoneAppIconsGlobal();

      applyGlobalCss(state.globalSettings.globalCss);
      applyStatusBarVisibility();
      applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
      initLockScreen();
      alert('å¤–è§‚è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
      showScreen('home-screen');
    });


    const messagesView = document.getElementById('messages-view');
    messagesView.addEventListener('scroll', () => {

      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = messagesView;



      if (scrollHeight - scrollTop - clientHeight < clientHeight) {

        if (!isLoadingMoreChats) {

          loadMoreChats();
        }
      }
    });


    document.getElementById('save-api-settings-btn').addEventListener('click', async () => {

      state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
      state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
      // ä¼˜å…ˆä½¿ç”¨æ‰‹å†™è¾“å…¥æ¡†çš„å€¼ï¼Œå¦‚æœä¸ºç©ºåˆ™ä½¿ç”¨ä¸‹æ‹‰æ¡†çš„å€¼
      const modelInput = document.getElementById('model-input').value.trim();
      state.apiConfig.model = modelInput || document.getElementById('model-select').value;
      state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
      state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
      state.apiConfig.minimaxModel = document.getElementById('minimax-model-select').value;
      const domainSelect = document.getElementById('minimax-domain-select');
      if (domainSelect) {
          state.apiConfig.minimaxDomain = domainSelect.value;
          localStorage.setItem('minimax-domain', domainSelect.value);
      }
      localStorage.setItem('minimax-group-id', state.apiConfig.minimaxGroupId);
      localStorage.setItem('minimax-api-key', state.apiConfig.minimaxApiKey);
      localStorage.setItem('minimax-model', state.apiConfig.minimaxModel);
      state.apiConfig.secondaryProxyUrl = document.getElementById('secondary-proxy-url').value.trim();
      state.apiConfig.secondaryApiKey = document.getElementById('secondary-api-key').value.trim();
      // ä¼˜å…ˆä½¿ç”¨æ‰‹å†™è¾“å…¥æ¡†çš„å€¼ï¼Œå¦‚æœä¸ºç©ºåˆ™ä½¿ç”¨ä¸‹æ‹‰æ¡†çš„å€¼
      const secondaryModelInput = document.getElementById('secondary-model-input').value.trim();
      state.apiConfig.secondaryModel = secondaryModelInput || document.getElementById('secondary-model-select').value;
      const imgbbEnable = document.getElementById('imgbb-enable-switch').checked;
      const imgbbApiKey = document.getElementById('imgbb-api-key').value.trim();
      const catboxEnable = document.getElementById('catbox-enable-switch').checked;
      const catboxUserHash = document.getElementById('catbox-userhash').value.trim();

      
      state.apiConfig.imgbbEnable = imgbbEnable;
      state.apiConfig.imgbbApiKey = imgbbApiKey;
      state.apiConfig.catboxEnable = catboxEnable;
      state.apiConfig.catboxUserHash = catboxUserHash;

      
      localStorage.setItem('imgbb-enabled', imgbbEnable);
      localStorage.setItem('imgbb-api-key', imgbbApiKey);
      localStorage.setItem('catbox-enabled', catboxEnable);
      localStorage.setItem('catbox-userhash', catboxUserHash);
      const githubEnable = document.getElementById('github-enable-switch').checked;
      const githubAutoBackup = document.getElementById('github-auto-backup-switch').checked;
      let backupInterval = parseInt(document.getElementById('github-backup-interval').value);
      if (isNaN(backupInterval) || backupInterval < 1) backupInterval = 30;
        state.apiConfig.githubEnable = githubEnable;
       state.apiConfig.githubAutoBackup = githubAutoBackup;
       const githubProxyEnable = document.getElementById('github-proxy-switch').checked;
        const githubProxyUrl = document.getElementById('github-proxy-url').value.trim();
        
        state.apiConfig.githubProxyEnable = githubProxyEnable;
        state.apiConfig.githubProxyUrl = githubProxyUrl;
        
        localStorage.setItem('github-proxy-enabled', githubProxyEnable);
        localStorage.setItem('github-proxy-url', githubProxyUrl);
        state.apiConfig.githubUsername = document.getElementById('github-username').value.trim();
        state.apiConfig.githubRepo = document.getElementById('github-repo').value.trim();
        state.apiConfig.githubToken = document.getElementById('github-token').value.trim();
        state.apiConfig.githubFilename = document.getElementById('github-filename').value.trim() || 'ephone_backup.json';
        localStorage.setItem('github-username', state.apiConfig.githubUsername);
        localStorage.setItem('github-repo', state.apiConfig.githubRepo);
        localStorage.setItem('github-token', state.apiConfig.githubToken);
        localStorage.setItem('github-filename', state.apiConfig.githubFilename);
        state.apiConfig.novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
      state.apiConfig.novelaiModel = document.getElementById('novelai-model').value;
      state.apiConfig.novelaiEnabled = document.getElementById('novelai-switch').checked;
      // ä¿å­˜å¤‡ä»½é—´éš”
      state.apiConfig.githubBackupInterval = backupInterval;
        // ä¿å­˜å¼€å…³çŠ¶æ€åˆ° localStorage
        localStorage.setItem('github-enabled', githubEnable);
      localStorage.setItem('github-auto-backup', githubAutoBackup);
      localStorage.setItem('github-backup-interval', backupInterval);

      if (githubEnable && githubAutoBackup) {
        // ä¼ å…¥åŠ¨æ€çš„æ—¶é—´é—´éš”
        startAutoBackupTimer(backupInterval); 
    } else {
        stopAutoBackupTimer();
    }
      await db.apiConfig.put(state.apiConfig);


      const backgroundSwitch = document.getElementById('background-activity-switch');
      const intervalInput = document.getElementById('background-interval-input');
      const cooldownInput = document.getElementById('block-cooldown-input');

      state.globalSettings.enableBackgroundActivity = backgroundSwitch.checked;
      state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
      state.globalSettings.blockCooldownHours = parseFloat(cooldownInput.value) || 1;
      state.globalSettings.enableAiDrawing = document.getElementById('enable-ai-drawing-switch').checked;
      
      // æ–°å¢ï¼šä¿å­˜å¿ƒå£°å’ŒåŠ¨æ€åŠŸèƒ½å¼€å…³
      state.globalSettings.enableThoughts = document.getElementById('global-enable-thoughts-switch').checked;
      state.globalSettings.enableQzoneActions = document.getElementById('global-enable-qzone-actions-switch').checked;
      state.globalSettings.enableViewMyPhone = document.getElementById('global-enable-view-myphone-switch').checked;
      
      state.globalSettings.chatRenderWindow = parseInt(document.getElementById('chat-render-window-input').value) || 50;
      state.globalSettings.chatListRenderWindow = parseInt(document.getElementById('chat-list-render-window-input').value) || 30;
      state.globalSettings.apiTemperature = parseFloat(document.getElementById('api-temperature-slider').value);
      await db.globalSettings.put(state.globalSettings);

      stopBackgroundSimulation();
      if (state.globalSettings.enableBackgroundActivity) {
        startBackgroundSimulation();
        console.log(`åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²å¯åŠ¨ï¼Œé—´éš”: ${state.globalSettings.backgroundActivityInterval}ç§’`);
      } else {
        console.log("åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²åœæ­¢ã€‚");
      }

      // ä¿å­˜NovelAIé…ç½®åˆ°localStorage
      const novelaiEnabled = document.getElementById('novelai-switch').checked;
      const novelaiModel = document.getElementById('novelai-model').value;
      const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
      localStorage.setItem('novelai-enabled', novelaiEnabled);
      localStorage.setItem('novelai-model', novelaiModel);
      localStorage.setItem('novelai-api-key', novelaiApiKey);

      alert('æ‰€æœ‰APIä¸åå°è®¾ç½®å·²ä¿å­˜!');
    });



    const ApiKeyInput = document.getElementById('api-key')
    ApiKeyInput.addEventListener('focus', (e) => {
      e.target.setAttribute('type', 'text')
    })
    ApiKeyInput.addEventListener('blur', (e) => {
      e.target.setAttribute('type', 'password')
    })





    async function fetchModels(urlInputId, keyInputId, selectId) {
      const url = document.getElementById(urlInputId).value.trim();
      const key = document.getElementById(keyInputId).value.trim();
      if (!url || !key) return alert('è¯·å…ˆå¡«å†™å¯¹åº”çš„åä»£åœ°å€å’Œå¯†é’¥');

      try {
        let isGemini = url === GEMINI_API_URL;
        const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : {
          headers: {
            'Authorization': `Bearer ${key}`
          }
        });
        if (!response.ok) throw new Error('æ— æ³•è·å–æ¨¡å‹åˆ—è¡¨');
        const data = await response.json();
        let models = isGemini ? data.models.map(model => ({
          id: model.name.split('/')[1] || model.name
        })) : data.data;

        const modelSelect = document.getElementById(selectId);
        modelSelect.innerHTML = '';

        const savedModel = selectId === 'model-select' ? state.apiConfig.model : state.apiConfig.secondaryModel;

        models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          option.textContent = model.id;
          if (model.id === savedModel) option.selected = true;
          modelSelect.appendChild(option);
        });
        alert('æ¨¡å‹åˆ—è¡¨å·²æ›´æ–°');
      } catch (error) {
        alert(`æ‹‰å–æ¨¡å‹å¤±è´¥: ${error.message}`);
      }
    }


    document.getElementById('fetch-models-btn').addEventListener('click', () => {
      fetchModels('proxy-url', 'api-key', 'model-select');
    });


    document.getElementById('fetch-secondary-models-btn').addEventListener('click', () => {
      fetchModels('secondary-proxy-url', 'secondary-api-key', 'secondary-model-select');
    });

    // ç›‘å¬ä¸»æ¨¡å‹ä¸‹æ‹‰æ¡†å˜åŒ–ï¼Œè‡ªåŠ¨å¡«å…¥æ‰‹å†™æ¡†
    document.getElementById('model-select').addEventListener('change', (e) => {
      const selectedModel = e.target.value;
      if (selectedModel) {
        document.getElementById('model-input').value = selectedModel;
      }
    });

    // ç›‘å¬å‰¯æ¨¡å‹ä¸‹æ‹‰æ¡†å˜åŒ–ï¼Œè‡ªåŠ¨å¡«å…¥æ‰‹å†™æ¡†
    document.getElementById('secondary-model-select').addEventListener('change', (e) => {
      const selectedModel = e.target.value;
      if (selectedModel) {
        document.getElementById('secondary-model-input').value = selectedModel;
      }
    });

    document.getElementById('add-world-book-btn').addEventListener('click', async () => {
      const name = await showCustomPrompt('åˆ›å»ºä¸–ç•Œä¹¦', 'è¯·è¾“å…¥ä¹¦å');
      if (name && name.trim()) {
        const newBook = {
          id: 'wb_' + Date.now(),
          name: name.trim(),
          content: '',
          isGlobal: false,
          injectPosition: 'before' // é»˜è®¤ä¸ºå‰
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
        renderWorldBookScreen();
        openWorldBookEditor(newBook.id);
      }
    });

    document.getElementById('save-world-book-btn').addEventListener('click', async () => {
      if (!editingWorldBookId) return;
      const book = state.worldBooks.find(wb => wb.id === editingWorldBookId);
      if (!book) return;


      const newName = document.getElementById('world-book-name-input').value.trim();
      if (!newName) {
        alert('ä¹¦åä¸èƒ½ä¸ºç©ºï¼');
        return;
      }
      book.name = newName;
      const categoryId = document.getElementById('world-book-category-select').value;
      book.categoryId = categoryId ? parseInt(categoryId) : null;
      
      // ä¿å­˜å…¨å±€å¼€å…³çŠ¶æ€
      const isGlobal = document.getElementById('world-book-global-switch').checked;
      book.isGlobal = isGlobal;
      
      // ä¿å­˜æ³¨å…¥ä½ç½®ï¼ˆæ— è®ºæ˜¯å¦å…¨å±€éƒ½ä¿å­˜ï¼‰
      const injectPosition = document.getElementById('world-book-inject-position-select').value;
      book.injectPosition = injectPosition;

      const entriesContainer = document.getElementById('world-book-entries-container');
      const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
      const newEntries = [];

      entryBlocks.forEach(block => {
        const keysInput = block.querySelector('.entry-keys-input').value.trim();
        const content = block.querySelector('.entry-content-textarea').value.trim();
        const isEnabled = block.querySelector('.entry-enabled-switch').checked;
        if (content) {
          newEntries.push({
            comment: block.querySelector('.entry-comment-input').value.trim(),
            keys: keysInput ? keysInput.split(',').map(k => k.trim()).filter(k => k) : [],
            content: content,
            enabled: isEnabled
          });
        }
      });
      book.content = newEntries;


      await db.worldBooks.put(book);
      document.getElementById('world-book-editor-title').textContent = newName;
      editingWorldBookId = null;


      showScreen('world-book-screen');


      await renderWorldBookScreen();
    });

    document.getElementById('chat-messages').addEventListener('click', async (e) => {
             if (e.target.tagName === 'IMG') {
            // æ£€æŸ¥æ˜¯å¦æ˜¯èŠå¤©é‡Œçš„å›¾ç‰‡ç±»å
            if (e.target.classList.contains('chat-image') || 
               
                e.target.classList.contains('realimag-image') ||
                e.target.classList.contains('naiimag-image')) {
                
                e.stopPropagation(); // é˜»æ­¢æ°”æ³¡è¢«é€‰ä¸­ç­‰å…¶ä»–äº‹ä»¶

                // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ï¼šæ£€æµ‹è¿å‡» ---
                
                // å¦‚æœè¿™æ˜¯ä¸€ä¸ªå¿«é€Ÿçš„ç¬¬äºŒæ¬¡æˆ–ç¬¬ä¸‰æ¬¡ç‚¹å‡» (detail > 1)ï¼Œ
                // è¯´æ˜ç”¨æˆ·å¯èƒ½åœ¨å°è¯•ä¸‰å‡»ä¸‹è½½ï¼Œæˆ–è€…æ˜¯åŒå‡»ã€‚
                // æ­¤æ—¶æˆ‘ä»¬è¦å–æ¶ˆæ‰è¿˜æ²¡æ‰§è¡Œçš„â€œæ”¾å¤§â€æ“ä½œï¼Œå¹¶ä¸åšä»»ä½•æ”¾å¤§å¤„ç†ã€‚
                if (e.detail > 1) {
                    if (window.simpleZoomTimer) {
                        clearTimeout(window.simpleZoomTimer);
                        window.simpleZoomTimer = null;
                    }
                    return; // ç›´æ¥é€€å‡ºï¼ŒæŠŠèˆå°ç•™ç»™ä¸‰å‡»ä¸‹è½½é€»è¾‘
                }

                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œæˆ‘ä»¬ä¸è¦ç«‹åˆ»æ”¾å¤§ï¼Œè€Œæ˜¯ç­‰ 250ms
                // å¦‚æœ 250ms å†…æ²¡æœ‰ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼Œæ‰æ‰§è¡Œæ”¾å¤§ã€‚
                window.simpleZoomTimer = setTimeout(() => {
                    openSimpleImageZoom(e.target.src);
                    window.simpleZoomTimer = null;
                }, 250); // 250æ¯«ç§’å»¶è¿Ÿï¼Œæ—¢ä¸å½±å“ä½“æ„Ÿï¼Œåˆèƒ½é¿å¼€è¿å‡»
                
                return;
            }
        }
     
      // 1. ä¿®å¤ä¸‹è½½æŒ‰é’® (å¸¦è½¬åœˆåŠ¨ç”»)
      const downloadBtn = e.target.closest('.nai-save-local-btn');
        if (downloadBtn) {
            e.stopPropagation(); 
            
            // --- æ–°å¢ï¼šè®©å®ƒè½¬èµ·æ¥ ---
            downloadBtn.classList.add('loading'); // æ·»åŠ è½¬åœˆæ ·å¼
            downloadBtn.disabled = true;          // é˜²æ­¢è¿ç‚¹
            
            const bubble = downloadBtn.closest('.message-bubble');
            const img = bubble ? bubble.querySelector('img.chat-image, img.realimag-image, img.naiimag-image') : null;
            
            if (img && img.src) {
                addVisualFeedback(img); 
                const filename = generateFilename(img);
                downloadImage(img.src, filename);
            }
            
            // --- æ–°å¢ï¼šè½¬ä¸€ä¼šå„¿ååœæ­¢ (800æ¯«ç§’åæ¢å¤) ---
            // å› ä¸ºä¸‹è½½æ˜¯æµè§ˆå™¨æ¥ç®¡çš„ï¼ŒJSæ— æ³•çŸ¥é“ç¡®åˆ‡ç»“æŸæ—¶é—´ï¼Œç»™ä¸ªè§†è§‰åé¦ˆæ—¶é—´å³å¯
            setTimeout(() => {
                downloadBtn.classList.remove('loading');
                downloadBtn.disabled = false;
            }, 800);
            
            return;
        }
       // --- ä¿®å¤ä¸Šä¼ å›¾åºŠæŒ‰é’® (åŸæœ¬æ¼æ‰äº†è¿™ä¸ªç›‘å¬) ---
      const naiUploadBtn = e.target.closest('.nai-upload-imgbb-btn');
      if (naiUploadBtn) {
        e.stopPropagation();
        const bubble = e.target.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            // è°ƒç”¨å·²æœ‰çš„ NAI ä¸Šä¼ å¤„ç†å‡½æ•°
            await handleSilentUploadNaiImage(timestamp, naiUploadBtn);
          }
        }
        return;
      }
      const regenBtn = e.target.closest('.nai-regenerate-btn');
      if (regenBtn) {
        e.stopPropagation();
        const bubble = e.target.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            await handleRegenerateNaiImage(timestamp, regenBtn);
          }
        }
        return;
      }
      const userUploadBtn = e.target.closest('.user-upload-imgbb-btn');
            if (userUploadBtn) {
                e.stopPropagation();
                const bubble = e.target.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        await handleSilentUploadUserImage(timestamp, userUploadBtn);
                    }
                }
                return;
            }
      const voiceBody = e.target.closest('.voice-message-body[data-text]');
      if (voiceBody) {

        const chat = state.chats[state.activeChatId];
        if (!chat) return;


        toggleVoiceTranscript(voiceBody);


        const bubble = voiceBody.closest('.message-bubble');
        const transcriptEl = bubble ? bubble.querySelector('.voice-transcript') : null;


        if (voiceBody.dataset.voiceId && transcriptEl && transcriptEl.style.display === 'block') {


          if (chat.isGroup) {
            console.log("è¿™æ˜¯ä¸€æ¡ç¾¤èŠè¯­éŸ³æ¶ˆæ¯ï¼Œå·²ç¦æ­¢å‘èµ·TTSè¯·æ±‚ã€‚");
            return;
          }
          if (chat.settings.enableTts === false) {
            console.log(`â€œ${chat.name}â€çš„TTSåŠŸèƒ½å·²å…³é—­ï¼Œå·²ç¦æ­¢å‘èµ·TTSè¯·æ±‚ã€‚`);
            return;
          }


          playTtsAudio(voiceBody);
        }

        return;
      }

      const detailsBtn = e.target.closest('.waimai-details-btn');
      if (detailsBtn) {
        const bubble = detailsBtn.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            showWaimaiDetails(timestamp);
            return;
          }
        }
      }



      const choiceBtn = e.target.closest('.waimai-user-actions button');
      if (choiceBtn) {
        const bubble = choiceBtn.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          const choice = choiceBtn.dataset.choice;
          if (!isNaN(timestamp) && choice) {
            await handleWaimaiResponse(timestamp, choice);
            return;
          }
        }
      }


      const deletedPostPlaceholder = e.target.closest('.post-deleted-placeholder');
      if (deletedPostPlaceholder) {
        const postId = parseInt(deletedPostPlaceholder.dataset.postId);
        if (!isNaN(postId)) {
          const post = await db.qzonePosts.get(postId);
          if (post) {
            let originalContent = '';
            const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || 'æœªçŸ¥ä½œè€…');

            if (post.type === 'shuoshuo') {
              originalContent = post.content;
            } else {
              originalContent = post.publicText || '';
              if (post.imageUrl) originalContent += `\n[å›¾ç‰‡]`;
              if (post.hiddenContent) originalContent += `\n[æ–‡å­—å›¾å†…å®¹: ${post.hiddenContent}]`;
            }

            showCustomAlert(
              `æ¥è‡ª ${authorName} çš„å·²åˆ é™¤åŠ¨æ€`,
              originalContent.replace(/\n/g, '<br>')
            );
          } else {
            showCustomAlert('æç¤º', 'è¿™æ¡åŠ¨æ€çš„åŸå§‹æ•°æ®å·²è¢«å½»åº•æ¸…é™¤ã€‚');
          }
        }
        return;
      }

      const aiImage = e.target.closest('.ai-generated-image');
      if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) showCustomAlert('ç…§ç‰‡æè¿°', description);
        return;
      }

      const quoteBlock = e.target.closest('.quoted-message');
      if (quoteBlock && quoteBlock.dataset.originalTimestamp) {
        const originalTimestamp = parseInt(quoteBlock.dataset.originalTimestamp);
        if (!isNaN(originalTimestamp)) {
          scrollToOriginalMessage(originalTimestamp);
        }
      }

      const giftCard = e.target.closest('.gift-card');
      if (giftCard) {
        const bubble = giftCard.closest('.message-bubble');
        if (bubble) {
          showGiftReceipt(parseInt(bubble.dataset.timestamp));
        }
      }

      const packetCard = e.target.closest('.red-packet-card');
      if (packetCard) {
        const messageBubble = packetCard.closest('.message-bubble');
        if (messageBubble && messageBubble.dataset.timestamp) {
          const timestamp = parseInt(messageBubble.dataset.timestamp);
          handlePacketClick(timestamp);
        }
      }

      const pollCard = e.target.closest('.poll-card');
      if (pollCard) {
        const timestamp = parseInt(pollCard.dataset.pollTimestamp);
        if (isNaN(timestamp)) return;

        const optionItem = e.target.closest('.poll-option-item');
        if (optionItem && !pollCard.classList.contains('closed')) {
          handleUserVote(timestamp, optionItem.dataset.option);
          return;
        }

        const actionBtn = e.target.closest('.poll-action-btn');
        if (actionBtn) {
          if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
          } else {
            endPoll(timestamp);
          }
          return;
        }

        if (pollCard.classList.contains('closed')) {
          showPollResults(timestamp);
        }
      }



      const placeholder = e.target.closest('.recalled-message-placeholder');
      if (placeholder) {
        const chat = state.chats[state.activeChatId];
        const wrapper = placeholder.closest('.message-wrapper');
        if (chat && wrapper) {
          const timestamp = parseInt(wrapper.dataset.timestamp);
          const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

          if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;

            if (recalled.originalType === 'text') {
              originalContentText = `åŸæ–‡: "${recalled.originalContent}"`;
            } else {
              originalContentText = `æ’¤å›äº†ä¸€æ¡[${recalled.originalType}]ç±»å‹çš„æ¶ˆæ¯`;
            }
            showCustomAlert('å·²æ’¤å›çš„æ¶ˆæ¯', originalContentText);
          }
        }
      }

      const linkCard = e.target.closest('.link-share-card');
      if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
      }

      const bubble = e.target.closest('.message-bubble');
      if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
          showTransferActionModal(timestamp);
        }
      }
    });


    const chatSettingsModal = document.getElementById('chat-settings-modal');
    const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

    function updateWorldBookSelectionDisplay() {
      const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked');
      const displayText = document.querySelector('.selected-options-text');

      if (checkedBoxes.length === 0) {
        displayText.textContent = '-- ç‚¹å‡»é€‰æ‹© --';
      } else if (checkedBoxes.length > 2) {
        displayText.textContent = `å·²é€‰æ‹© ${checkedBoxes.length} æœ¬ä¸–ç•Œä¹¦`;
      } else {
        const displayItems = Array.from(checkedBoxes).map(cb => {
          return cb.parentElement.textContent.trim();
        });
        displayText.textContent = displayItems.join(', ');
      }
    }


    worldBookSelectBox.addEventListener('click', (e) => {
      e.stopPropagation();
      worldBookCheckboxesContainer.classList.toggle('visible');
      worldBookSelectBox.classList.toggle('expanded');
    });
    document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
    window.addEventListener('click', (e) => {
      if (!document.querySelector('.custom-multiselect').contains(e.target)) {
        worldBookCheckboxesContainer.classList.remove('visible');
        worldBookSelectBox.classList.remove('expanded');
      }
    });

    document.getElementById('chat-settings-btn').addEventListener('click', async () => {
      loadThemePresetsDropdown();
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const isGroup = chat.isGroup;

     const weatherSection = document.getElementById('weather-settings-section');
if (isGroup) {
    weatherSection.style.display = 'none';
} else {
    weatherSection.style.display = 'block';
    
    // è¯»å–é…ç½®
    const wSettings = chat.settings.weather || {};
    
    const weatherSwitch = document.getElementById('enable-weather-switch');
    const weatherConfigContainer = document.getElementById('weather-config-container');
    
    weatherSwitch.checked = wSettings.enabled || false;
    weatherConfigContainer.style.display = wSettings.enabled ? 'block' : 'none';
    
    // ç»‘å®šå¼€å…³æ˜¾ç¤ºéšè—
    weatherSwitch.onclick = (e) => {
        weatherConfigContainer.style.display = e.target.checked ? 'block' : 'none';
    };

    // å›æ˜¾ User æ•°æ®
    document.getElementById('user-virtual-city').value = wSettings.userVirtualCity || '';
    document.getElementById('user-city-lat').value = wSettings.userLat || '';
    document.getElementById('user-city-lon').value = wSettings.userLon || '';
    if (wSettings.userRealCity) {
        document.getElementById('user-city-result').textContent = `å·²æ˜ å°„: ${wSettings.userRealCity} (${wSettings.userLat}, ${wSettings.userLon})`;
        document.getElementById('user-city-result').style.color = 'green';
    } else {
        document.getElementById('user-city-result').textContent = 'æœªè®¾ç½®æ˜ å°„';
        document.getElementById('user-city-result').style.color = '#007bff';
    }

    // å›æ˜¾ Char æ•°æ®
    document.getElementById('char-virtual-city').value = wSettings.charVirtualCity || '';
    document.getElementById('char-city-lat').value = wSettings.charLat || '';
    document.getElementById('char-city-lon').value = wSettings.charLon || '';
    if (wSettings.charRealCity) {
        document.getElementById('char-city-result').textContent = `å·²æ˜ å°„: ${wSettings.charRealCity} (${wSettings.charLat}, ${wSettings.charLon})`;
        document.getElementById('char-city-result').style.color = 'green';
    } else {
        document.getElementById('char-city-result').textContent = 'æœªè®¾ç½®æ˜ å°„';
        document.getElementById('char-city-result').style.color = '#007bff';
    }
}
      const switchGreetingGroup = document.getElementById('switch-greeting-group');
      if (!isGroup && chat.settings.alternateGreetings && chat.settings.alternateGreetings.length > 0) {
        switchGreetingGroup.style.display = 'block';
      } else {
        switchGreetingGroup.style.display = 'none';
      }

      document.getElementById('chat-name-group').style.display = 'block';
      document.getElementById('my-persona-group').style.display = 'block';
      document.getElementById('my-avatar-group').style.display = 'block';
      document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('my-nickname-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-original-name-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-voice-id-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('inject-thought-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('todo-list-setting-group').style.display = isGroup ? 'none' : 'flex';
      document.getElementById('offline-mode-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-cooldown-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-cooldown-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('memory-archive-section').style.display = isGroup ? 'none' : 'block';
      document.getElementById('chat-name-input').value = chat.name;
      
      // åŠ è½½è§’è‰²å›½ç±
      const countrySelect = document.getElementById('character-country-select');
      if (!isGroup) {
        document.getElementById('character-country-group').style.display = 'block';
        countrySelect.value = chat.country || 'China';
      } else {
        document.getElementById('character-country-group').style.display = 'none';
      }
      
      document.getElementById('my-persona').value = chat.settings.myPersona;
      document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
      document.getElementById('max-memory').value = chat.settings.maxMemory;
      document.getElementById('linked-memory-count').value = chat.settings.linkedMemoryCount || 10;
      const bgPreview = document.getElementById('bg-preview');
      const removeBgBtn = document.getElementById('remove-bg-btn');
      if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
      } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
      }
      document.getElementById('lyrics-position-group').style.display = 'block';

      document.getElementById('single-char-background-activity-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-background-activity-group').style.display = isGroup ? 'block' : 'none';




      const timePerceptionToggle = document.getElementById('time-perception-toggle');
      const timeZoneGroup = document.getElementById('time-zone-group');
      timePerceptionToggle.checked = chat.settings.enableTimePerception;
      timeZoneGroup.style.display = timePerceptionToggle.checked ? 'block' : 'none';


      const timezoneSelect = document.getElementById('time-zone-select');

      const timezones = Intl.supportedValuesOf('timeZone');
      timezoneSelect.innerHTML = '';
      timezones.forEach(tz => {
        const option = document.createElement('option');
        option.value = tz;
        option.textContent = tz;
        timezoneSelect.appendChild(option);
      });

      timezoneSelect.value = chat.settings.timeZone || 'Asia/Shanghai';
      document.getElementById('enable-synth-music-switch').checked = chat.settings.enableSynthMusic || false;
      document.getElementById('narrator-mode-toggle').checked = chat.settings.enableNarratorMode || false;
      if (isGroup) {

        document.getElementById('group-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('group-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;


        document.getElementById('single-char-background-activity-group').style.display = 'none';
        renderGroupMemberSettings(chat.members);
      } else {

        document.getElementById('single-char-background-activity-group').style.display = 'block';
        document.getElementById('enable-todo-list-switch').checked = chat.settings.enableTodoList || false;
        // --- ä¿®å¤å¤©æ°”è®¾ç½®å›æ˜¾é€»è¾‘ ---
        const weatherSection = document.getElementById('weather-settings-section');
        weatherSection.style.display = 'block';

        // è¯»å–å½“å‰è§’è‰²çš„é…ç½®
        const wSettings = chat.settings.weather || {};

        const weatherSwitch = document.getElementById('enable-weather-switch');
        const weatherConfigContainer = document.getElementById('weather-config-container');

        weatherSwitch.checked = wSettings.enabled || false;
        weatherConfigContainer.style.display = wSettings.enabled ? 'block' : 'none';
        
        // ç»‘å®šå¼€å…³æ˜¾ç¤ºéšè— (é˜²æ­¢äº‹ä»¶é‡å¤ç»‘å®šï¼Œå…ˆç§»é™¤å†æ·»åŠ ï¼Œæˆ–è€…ä¾èµ– HTML onclick é€»è¾‘)
        weatherSwitch.onclick = (e) => {
            weatherConfigContainer.style.display = e.target.checked ? 'block' : 'none';
        };

        // 1. å›æ˜¾ User æ•°æ®
        document.getElementById('user-virtual-city').value = wSettings.userVirtualCity || '';
        
        // ã€å…³é”®ä¿®å¤ã€‘: æ˜¾å¼è®¾ç½®æœç´¢æ¡†çš„å€¼ä¸ºå·²ä¿å­˜çš„åŸå¸‚åï¼Œå¦‚æœæ²¡æœ‰åˆ™æ¸…ç©º
        const userRealCityInput = document.getElementById('user-real-city-search');
        userRealCityInput.value = wSettings.userRealCity || ''; 
        userRealCityInput.dataset.realName = wSettings.userRealCity || ''; // åŒæ­¥ dataset

        document.getElementById('user-city-lat').value = wSettings.userLat || '';
        document.getElementById('user-city-lon').value = wSettings.userLon || '';

        if (wSettings.userRealCity) {
            document.getElementById('user-city-result').textContent = `å·²æ˜ å°„: ${wSettings.userRealCity} (${wSettings.userLat}, ${wSettings.userLon})`;
            document.getElementById('user-city-result').style.color = 'green';
        } else {
            document.getElementById('user-city-result').textContent = 'æœªè®¾ç½®æ˜ å°„';
            document.getElementById('user-city-result').style.color = '#007bff';
        }

        // 2. å›æ˜¾ Char æ•°æ®
        document.getElementById('char-virtual-city').value = wSettings.charVirtualCity || '';

        // ã€å…³é”®ä¿®å¤ã€‘: æ˜¾å¼è®¾ç½®æœç´¢æ¡†çš„å€¼ä¸ºå·²ä¿å­˜çš„åŸå¸‚åï¼Œå¦‚æœæ²¡æœ‰åˆ™æ¸…ç©º
        const charRealCityInput = document.getElementById('char-real-city-search');
        charRealCityInput.value = wSettings.charRealCity || '';
        charRealCityInput.dataset.realName = wSettings.charRealCity || ''; // åŒæ­¥ dataset

        document.getElementById('char-city-lat').value = wSettings.charLat || '';
        document.getElementById('char-city-lon').value = wSettings.charLon || '';

        if (wSettings.charRealCity) {
            document.getElementById('char-city-result').textContent = `å·²æ˜ å°„: ${wSettings.charRealCity} (${wSettings.charLat}, ${wSettings.charLon})`;
            document.getElementById('char-city-result').style.color = 'green';
        } else {
            document.getElementById('char-city-result').textContent = 'æœªè®¾ç½®æ˜ å°„';
            document.getElementById('char-city-result').style.color = '#007bff';
        }
        document.getElementById('char-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
        document.getElementById('inject-thought-toggle').checked = chat.settings.injectLatestThought;
        
        // æ–°å¢ï¼šè¯»å–AIè¡Œä¸ºæ§åˆ¶è®¾ç½®
        const thoughtsSelect = document.getElementById('chat-enable-thoughts-select');
        if (chat.settings.enableThoughts === null || chat.settings.enableThoughts === undefined) {
          thoughtsSelect.value = 'null';
        } else {
          thoughtsSelect.value = String(chat.settings.enableThoughts);
        }
        
        const qzoneSelect = document.getElementById('chat-enable-qzone-actions-select');
        if (chat.settings.enableQzoneActions === null || chat.settings.enableQzoneActions === undefined) {
          qzoneSelect.value = 'null';
        } else {
          qzoneSelect.value = String(chat.settings.enableQzoneActions);
        }
        
        const viewMyPhoneSelect = document.getElementById('chat-enable-view-myphone-select');
        if (chat.settings.enableViewMyPhone === null || chat.settings.enableViewMyPhone === undefined) {
          viewMyPhoneSelect.value = 'null';
        } else {
          viewMyPhoneSelect.value = String(chat.settings.enableViewMyPhone);
        }
        
        // æ›´æ–°å…¨å±€è®¾ç½®çŠ¶æ€æ˜¾ç¤º
        document.getElementById('global-thoughts-status').textContent = state.globalSettings.enableThoughts ? 'å¼€å¯' : 'å…³é—­';
        document.getElementById('global-qzone-status').textContent = state.globalSettings.enableQzoneActions ? 'å¼€å¯' : 'å…³é—­';
        document.getElementById('global-view-myphone-status').textContent = state.globalSettings.enableViewMyPhone ? 'å¼€å¯' : 'å…³é—­';
        
        const offlineModeToggle = document.getElementById('offline-mode-toggle');
        const offlineModeOptions = document.getElementById('offline-mode-options');
        const offlineMinInput = document.getElementById('offline-min-length-input');
        const offlineMaxInput = document.getElementById('offline-max-length-input');
        offlineModeToggle.checked = chat.settings.isOfflineMode || false;
        offlineModeOptions.style.display = offlineModeToggle.checked ? 'block' : 'none';
        offlineMinInput.value = chat.settings.offlineMinLength || 100;
        offlineMaxInput.value = chat.settings.offlineMaxLength || 300;
        await renderOfflinePresetSelector(chat);
        
        // åŠ è½½è¡¨æƒ…åŒ…è¯†å›¾è®¾ç½®
        document.getElementById('enable-sticker-vision-checkbox').checked = chat.settings.enableStickerVision || false;
        
        document.getElementById('ai-original-name-input').value = chat.originalName;
        document.getElementById('ai-voice-id-input').value = chat.settings.minimaxVoiceId || '';
        
        document.getElementById('ai-voice-lang-group').style.display = isGroup ? 'none' : 'block';
        document.getElementById('ai-voice-lang-select').value = chat.settings.ttsLanguage || '';
        document.getElementById('chat-show-seconds-switch').checked = chat.settings.showSeconds !== undefined ? chat.settings.showSeconds : (state.globalSettings.showSeconds || false);
        document.getElementById('enable-tts-switch').checked = chat.settings.enableTts !== false;
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('my-nickname-input').value = chat.settings.myNickname || 'æˆ‘';
        document.getElementById('ai-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">æœªåˆ†ç»„</option>';
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
          const option = document.createElement('option');
          option.value = group.id;
          option.textContent = group.name;
          if (chat.groupId === group.id) option.selected = true;
          select.appendChild(option);
        });
        const lyricsPos = chat.settings.lyricsPosition || {
          vertical: 'top',
          horizontal: 'center',
          offset: 10
        };
        document.getElementById('lyrics-vertical-pos').value = lyricsPos.vertical;
        document.getElementById('lyrics-horizontal-pos').value = lyricsPos.horizontal;
        document.getElementById('lyrics-offset-input').value = lyricsPos.offset;
      }



      const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
      worldBookCheckboxesContainer.innerHTML = '';

      const [allCategories, allBooks] = await Promise.all([
        db.worldBookCategories.toArray(),
        db.worldBooks.toArray()
      ]);

      const linkedBookIds = new Set(chat.settings.linkedWorldBookIds || []);

      if (allBooks.length === 0) {
        worldBookCheckboxesContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ä¸–ç•Œä¹¦</p>';
      } else {

        allCategories.forEach(cat => {
          const booksInCategory = allBooks.filter(book => book.categoryId === cat.id);
          if (booksInCategory.length > 0) {
            const categoryHeader = document.createElement('h4');
            categoryHeader.textContent = cat.name;
            categoryHeader.style.cssText = 'margin: 10px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
            worldBookCheckboxesContainer.appendChild(categoryHeader);

            booksInCategory.forEach(book => {
              // å…¨å±€ä¸–ç•Œä¹¦è‡ªåŠ¨å‹¾é€‰
              const isChecked = linkedBookIds.has(book.id) || book.isGlobal === true;
              const label = document.createElement('label');
              const globalTag = book.isGlobal ? ' <span style="color: #ff5722; font-size: 12px;">[å…¨å±€]</span>' : '';
              label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}${globalTag}`;
              worldBookCheckboxesContainer.appendChild(label);
            });
          }
        });


        const uncategorizedBooks = allBooks.filter(book => !book.categoryId);
        if (uncategorizedBooks.length > 0) {
          const bookHeader = document.createElement('h4');
          bookHeader.textContent = 'æœªåˆ†ç±»';
          bookHeader.style.cssText = 'margin: 15px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
          worldBookCheckboxesContainer.appendChild(bookHeader);

          uncategorizedBooks.forEach(book => {
            // å…¨å±€ä¸–ç•Œä¹¦è‡ªåŠ¨å‹¾é€‰
            const isChecked = linkedBookIds.has(book.id) || book.isGlobal === true;
            const label = document.createElement('label');
            const globalTag = book.isGlobal ? ' <span style="color: #ff5722; font-size: 12px;">[å…¨å±€]</span>' : '';
            label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}${globalTag}`;
            worldBookCheckboxesContainer.appendChild(label);
          });
        }
      }


      updateWorldBookSelectionDisplay();

      const linkMemoryToggle = document.getElementById('link-memory-toggle');
      const linkedMemorySelection = document.getElementById('linked-memory-selection');
      const linkedChatsContainer = document.getElementById('linked-chats-checkboxes-container');
      const linkedMemoryIds = chat.settings.linkedMemoryChatIds || [];
      linkMemoryToggle.checked = linkedMemoryIds.length > 0;
      linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none';
      linkedChatsContainer.innerHTML = '';
      Object.values(state.chats).forEach(c => {
        if (c.id === chat.id) return;
        const isChecked = linkedMemoryIds.includes(c.id);
        const prefix = c.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> ${prefix} ${c.name}`;
        linkedChatsContainer.appendChild(label);
      });

      function updateLinkedMemorySelectionDisplay() {
        const checkedBoxes = linkedChatsContainer.querySelectorAll('input:checked');
        const displayText = linkedMemorySelection.querySelector('.selected-options-text');
        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- ç‚¹å‡»é€‰æ‹© --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `å·²é€‰æ‹© ${checkedBoxes.length} é¡¹`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', ');
        }
      }
      updateLinkedMemorySelectionDisplay();
      linkMemoryToggle.addEventListener('change', () => {
        linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none';
      });
      const linkedMemorySelectBox = linkedMemorySelection.querySelector('.select-box');
      const newLinkedMemorySelectBox = linkedMemorySelectBox.cloneNode(true);
      linkedMemorySelectBox.parentNode.replaceChild(newLinkedMemorySelectBox, linkedMemorySelectBox);
      newLinkedMemorySelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        linkedChatsContainer.classList.toggle('visible');
        newLinkedMemorySelectBox.classList.toggle('expanded');
      });
      linkedChatsContainer.addEventListener('change', updateLinkedMemorySelectionDisplay);
      const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
      if (themeRadio) themeRadio.checked = true;
      const fontSizeSlider = document.getElementById('font-size-slider');
      fontSizeSlider.value = chat.settings.fontSize || 13;
      document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
      const customCssInput = document.getElementById('custom-css-input');
      customCssInput.value = chat.settings.customCss || '';
      updateSettingsPreview();
      document.getElementById('auto-memory-toggle').checked = chat.settings.enableAutoMemory || false;
      document.getElementById('auto-memory-interval').value = chat.settings.autoMemoryInterval || 20;
      document.getElementById('show-hidden-msg-toggle').checked = chat.settings.showHiddenMessages || false;
      
      // åŠ è½½å¹¶æ˜¾ç¤º/éšè—è§’è‰²çŸ¥æ™“çª¥å±å¼€å…³ï¼ˆä»…å•èŠï¼‰
      const phoneViewingAwarenessGroup = document.getElementById('phone-viewing-awareness-group');
      if (!isGroup) {
        phoneViewingAwarenessGroup.style.display = 'flex';
        document.getElementById('phone-viewing-awareness-toggle').checked = chat.settings.phoneViewingAwareness || false;
      } else {
        phoneViewingAwarenessGroup.style.display = 'none';
      }
      
      setTimeout(() => {
        updateTokenCountDisplay(); 

        const inputsToWatch = [
          'ai-persona', 'my-persona', 'max-memory',
          'linked-memory-count', 'auto-memory-toggle', 'auto-memory-interval',
          'offline-mode-toggle', 'offline-min-length-input',
          'offline-max-length-input', 'offline-preset-select'
        ];

        inputsToWatch.forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('input', updateTokenCountDisplay);
          }
        });

        // ä¸ºå¤šé€‰æ¡†å®¹å™¨æ·»åŠ äº‹ä»¶ç›‘å¬
        document.getElementById('world-book-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
        document.getElementById('linked-chats-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
        document.getElementById('link-memory-toggle').addEventListener('change', updateTokenCountDisplay);
      }, 100);
      
      // æ¸²æŸ“è®°å¿†åº“åˆ—è¡¨
      renderMemoryArchiveList();
      
      // åŠ è½½è§†é¢‘é€šè¯ä¼˜åŒ–è®¾ç½®
      if (typeof window.loadVideoOptimizationSettings === 'function') {
        window.loadVideoOptimizationSettings(chat);
      }
      
      showScreen('chat-settings-screen');
    });



    function renderGroupMemberSettings(members) {
      const container = document.getElementById('group-members-settings');
      container.innerHTML = '';
      members.forEach(member => {
        const div = document.createElement('div');
        div.className = 'member-editor';
        div.dataset.memberId = member.id;




        const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);

        div.innerHTML = `<img src="${memberAvatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
        div.addEventListener('click', () => openMemberEditor(member.id));
        container.appendChild(div);
      });
    }



    document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
      if (!editingMemberId) return;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;

      const newNickname = document.getElementById('member-name-input').value.trim();
      if (!newNickname) {
        alert("ç¾¤æ˜µç§°ä¸èƒ½ä¸ºç©ºï¼");
        return;
      }
      member.groupNickname = newNickname;
      member.persona = document.getElementById('member-persona-input').value;

      const newAvatarUrl = document.getElementById('member-avatar-preview').src;



      member.avatar = newAvatarUrl;


      const characterProfile = state.chats[member.id];
      if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
      }


      await db.chats.put(chat);


      renderGroupMemberSettings(chat.members);
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });



    function openMemberEditor(memberId) {
      editingMemberId = memberId;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === memberId);
      if (!member) return;

      document.getElementById('member-name-input').value = member.groupNickname;
      document.getElementById('member-persona-input').value = member.persona;



      const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);
      document.getElementById('member-avatar-preview').src = memberAvatar;

      document.getElementById('member-settings-modal').classList.add('visible');
    }

    document.getElementById('cancel-member-settings-btn').addEventListener('click', () => {
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });


    document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
      if (!editingMemberId) return;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;

      const newNickname = document.getElementById('member-name-input').value.trim();
      if (!newNickname) {
        alert("ç¾¤æ˜µç§°ä¸èƒ½ä¸ºç©ºï¼");
        return;
      }
      member.groupNickname = newNickname;
      member.persona = document.getElementById('member-persona-input').value;

      const newAvatarUrl = document.getElementById('member-avatar-preview').src;



      member.avatar = newAvatarUrl;


      const characterProfile = state.chats[member.id];
      if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
      }


      await db.chats.put(chat);


      renderGroupMemberSettings(chat.members);
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });

    document.getElementById('reset-theme-btn').addEventListener('click', () => {
      document.getElementById('theme-default').checked = true;
    });



    document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];


      const oldOfflineModeState = chat.settings.isOfflineMode || false;


      const newName = document.getElementById('chat-name-input').value.trim();
      if (!newName) return alert('å¤‡æ³¨å/ç¾¤åä¸èƒ½ä¸ºç©ºï¼');
      if (!chat.isGroup && newName !== chat.name) {
        if (!chat.nameHistory) chat.nameHistory = [];
        if (!chat.nameHistory.includes(chat.name)) chat.nameHistory.push(chat.name);
      }
      chat.name = newName;
      
      // ä¿å­˜è§’è‰²å›½ç±
      const selectedCountry = document.getElementById('character-country-select').value;
      chat.country = selectedCountry;
      
      const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
      chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';
      chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
      chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
      chat.settings.myPersona = document.getElementById('my-persona').value;
      chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
      chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
      chat.settings.linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;

      const checkedBookItems = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
      const newLinkedBookIds = [];
      checkedBookItems.forEach(cb => {
        if (cb.value.startsWith('book_')) {
          newLinkedBookIds.push(cb.value.replace('book_', ''));
        }
      });
      chat.settings.linkedWorldBookIds = newLinkedBookIds;

      const linkMemoryToggleChecked = document.getElementById('link-memory-toggle').checked;
      if (linkMemoryToggleChecked) {
        const checkedChats = document.querySelectorAll('#linked-chats-checkboxes-container input:checked');
        chat.settings.linkedMemoryChatIds = Array.from(checkedChats).map(cb => cb.value);
      } else {
        chat.settings.linkedMemoryChatIds = [];
      }
      chat.settings.enableAutoMemory = document.getElementById('auto-memory-toggle').checked;
      chat.settings.autoMemoryInterval = parseInt(document.getElementById('auto-memory-interval').value) || 20;
      chat.settings.showHiddenMessages = document.getElementById('show-hidden-msg-toggle').checked;
      
      // ä¿å­˜è§’è‰²çŸ¥æ™“çª¥å±è®¾ç½®
      if (!chat.isGroup) {
        chat.settings.phoneViewingAwareness = document.getElementById('phone-viewing-awareness-toggle').checked;
      }
      
      chat.settings.enableTimePerception = document.getElementById('time-perception-toggle').checked;
      chat.settings.timeZone = document.getElementById('time-zone-select').value;
      chat.settings.lyricsPosition = {
          vertical: document.getElementById('lyrics-vertical-pos').value,
          horizontal: document.getElementById('lyrics-horizontal-pos').value,
          offset: parseInt(document.getElementById('lyrics-offset-input').value) || 10
        };
      chat.settings.enableSynthMusic = document.getElementById('enable-synth-music-switch').checked;
      chat.settings.enableNarratorMode = document.getElementById('narrator-mode-toggle').checked;
      if (chat.isGroup) {
        chat.settings.enableBackgroundActivity = document.getElementById('group-background-activity-switch').checked;
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('group-action-cooldown-input').value) || 10;
      } else {
        chat.settings.enableBackgroundActivity = document.getElementById('char-background-activity-switch').checked;
        chat.settings.enableTodoList = document.getElementById('enable-todo-list-switch').checked;
        const newOfflineModeState = document.getElementById('offline-mode-toggle').checked;
        chat.settings.isOfflineMode = newOfflineModeState;
        const weatherEnabled = document.getElementById('enable-weather-switch').checked;
    const weatherSettings = {
        enabled: weatherEnabled,
        userVirtualCity: document.getElementById('user-virtual-city').value.trim(),
        userRealCity: document.getElementById('user-real-city-search').dataset.realName || chat.settings.weather?.userRealCity || '',
        userLat: parseFloat(document.getElementById('user-city-lat').value) || null,
        userLon: parseFloat(document.getElementById('user-city-lon').value) || null,
        
        charVirtualCity: document.getElementById('char-virtual-city').value.trim(),
        charRealCity: document.getElementById('char-real-city-search').dataset.realName || chat.settings.weather?.charRealCity || '',
        charLat: parseFloat(document.getElementById('char-city-lat').value) || null,
        charLon: parseFloat(document.getElementById('char-city-lon').value) || null
    };
    
    chat.settings.weather = weatherSettings;





        if (oldOfflineModeState === true && newOfflineModeState === false) {


          const switchInstruction = {
            role: 'system',
            content: '[ç³»ç»ŸæŒ‡ä»¤ï¼šæ¨¡å¼å·²åˆ‡æ¢ï¼ä½ ç°åœ¨å›åˆ°äº†çº¿ä¸ŠèŠå¤©æ¨¡å¼ã€‚ä½ çš„å›å¤ã€å¿…é¡»ã€‘ä¸¥æ ¼éµå®ˆçº¿ä¸Šæ¨¡å¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œä¾‹å¦‚ [{"type": "text", "content": "ä½ å¥½"}]]',
            timestamp: Date.now(),
            isHidden: true
          };


          chat.history.push(switchInstruction);
          console.log("å·²æˆåŠŸæ³¨å…¥â€œåˆ‡æ¢åˆ°çº¿ä¸Šæ¨¡å¼â€çš„ç³»ç»ŸæŒ‡ä»¤ã€‚");
        }


        chat.settings.injectLatestThought = document.getElementById('inject-thought-toggle').checked;
        
        // æ–°å¢ï¼šä¿å­˜AIè¡Œä¸ºæ§åˆ¶è®¾ç½®
        const thoughtsValue = document.getElementById('chat-enable-thoughts-select').value;
        if (thoughtsValue === 'null') {
          chat.settings.enableThoughts = null;
        } else {
          chat.settings.enableThoughts = thoughtsValue === 'true';
        }
        
        const qzoneValue = document.getElementById('chat-enable-qzone-actions-select').value;
        if (qzoneValue === 'null') {
          chat.settings.enableQzoneActions = null;
        } else {
          chat.settings.enableQzoneActions = qzoneValue === 'true';
        }
        
        const viewMyPhoneValue = document.getElementById('chat-enable-view-myphone-select').value;
        if (viewMyPhoneValue === 'null') {
          chat.settings.enableViewMyPhone = null;
        } else {
          chat.settings.enableViewMyPhone = viewMyPhoneValue === 'true';
        }
        
        chat.settings.offlineMinLength = parseInt(document.getElementById('offline-min-length-input').value) || 100;
        chat.settings.offlineMaxLength = parseInt(document.getElementById('offline-max-length-input').value) || 300;
        chat.settings.offlinePresetId = document.getElementById('offline-preset-select').value || null;

        // ä¿å­˜è¡¨æƒ…åŒ…è¯†å›¾è®¾ç½®
        chat.settings.enableStickerVision = document.getElementById('enable-sticker-vision-checkbox').checked;

        const newOriginalName = document.getElementById('ai-original-name-input').value.trim();
        if (!newOriginalName) return alert('å¯¹æ–¹æœ¬åä¸èƒ½ä¸ºç©ºï¼');
        chat.originalName = newOriginalName;
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.minimaxVoiceId = document.getElementById('ai-voice-id-input').value.trim();
        
        chat.settings.ttsLanguage = document.getElementById('ai-voice-lang-select').value;
        chat.settings.showSeconds = document.getElementById('chat-show-seconds-switch').checked;
        chat.settings.enableTts = document.getElementById('enable-tts-switch').checked;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.myNickname = document.getElementById('my-nickname-input').value.trim() || 'æˆ‘';
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('ai-action-cooldown-input').value) || 10;
        
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
      }

      // ä¿å­˜è§†é¢‘é€šè¯ä¼˜åŒ–è®¾ç½®
      if (typeof window.saveVideoOptimizationSettings === 'function') {
        window.saveVideoOptimizationSettings(chat);
      }
      
      await db.chats.put(chat);
      if (!chat.isGroup) {
        await syncCharacterNameInGroups(chat);
        await syncCharacterAvatarInGroups(chat);
      }
      applyLyricsBarPosition(chat);
      applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
      showScreen('chat-interface-screen');
      renderChatInterface(state.activeChatId);
      renderChatList();
    });

    // ==================== è®°å¿†åº“åŠŸèƒ½ ====================
    
    // ä¿å­˜è®°å¿†å­˜æ¡£
    document.getElementById('save-memory-archive-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·å‘½å
      const archiveName = await showCustomPrompt('ä¿å­˜è®°å¿†å­˜æ¡£', 'è¯·ä¸ºè¿™ä¸ªå­˜æ¡£å‘½åï¼š', '');
      if (!archiveName || !archiveName.trim()) {
        return; // ç”¨æˆ·å–æ¶ˆæˆ–æœªè¾“å…¥
      }
      
      try {
        // åˆ›å»ºå­˜æ¡£å¯¹è±¡
        const archive = {
          id: Date.now(),
          name: archiveName.trim(),
          timestamp: Date.now(),
          chatId: chat.id,
          data: {
            // èŠå¤©è®°å½•
            history: JSON.parse(JSON.stringify(chat.history)),
            
            // äººè®¾å’Œå¤´åƒ
            settings: {
              aiPersona: chat.settings.aiPersona,
              aiAvatar: chat.settings.aiAvatar,
              myPersona: chat.settings.myPersona,
              myAvatar: chat.settings.myAvatar,
              myNickname: chat.settings.myNickname,
              
              // é•¿æœŸè®°å¿†
              maxMemory: chat.settings.maxMemory,
              linkedMemoryCount: chat.settings.linkedMemoryCount,
              linkedMemoryChatIds: [...(chat.settings.linkedMemoryChatIds || [])],
              enableAutoMemory: chat.settings.enableAutoMemory,
              autoMemoryInterval: chat.settings.autoMemoryInterval,
              
              // è¯­éŸ³é€šè¯
              enableTts: chat.settings.enableTts,
              minimaxVoiceId: chat.settings.minimaxVoiceId,
              ttsLanguage: chat.settings.ttsLanguage,
              
              // é¢„è®¾
              linkedWorldBookIds: [...(chat.settings.linkedWorldBookIds || [])],
              offlinePresetId: chat.settings.offlinePresetId,
              
              // å…¶ä»–è®¾ç½®
              theme: chat.settings.theme,
              fontSize: chat.settings.fontSize,
              customCss: chat.settings.customCss,
              enableTimePerception: chat.settings.enableTimePerception,
              timeZone: chat.settings.timeZone,
              enableBackgroundActivity: chat.settings.enableBackgroundActivity,
              actionCooldownMinutes: chat.settings.actionCooldownMinutes,
              enableTodoList: chat.settings.enableTodoList,
              isOfflineMode: chat.settings.isOfflineMode,
              weather: chat.settings.weather ? JSON.parse(JSON.stringify(chat.settings.weather)) : null,
              enableSynthMusic: chat.settings.enableSynthMusic,
              enableNarratorMode: chat.settings.enableNarratorMode,
              showSeconds: chat.settings.showSeconds,
              lyricsPosition: chat.settings.lyricsPosition ? JSON.parse(JSON.stringify(chat.settings.lyricsPosition)) : null
            },
            
            // è§’è‰²çŠ¶æ€
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            status: chat.status ? JSON.parse(JSON.stringify(chat.status)) : null
          }
        };
        
        // åˆå§‹åŒ–å­˜æ¡£æ•°ç»„
        if (!chat.memoryArchives) {
          chat.memoryArchives = [];
        }
        
        // æ·»åŠ å­˜æ¡£
        chat.memoryArchives.push(archive);
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await db.chats.put(chat);
        
        // åˆ·æ–°å­˜æ¡£åˆ—è¡¨
        renderMemoryArchiveList();
        
        await showCustomAlert('ä¿å­˜æˆåŠŸ', `å­˜æ¡£"${archiveName}"å·²ä¿å­˜ï¼`);
      } catch (error) {
        console.error('ä¿å­˜è®°å¿†å­˜æ¡£å¤±è´¥:', error);
        await showCustomAlert('ä¿å­˜å¤±è´¥', 'ä¿å­˜è®°å¿†å­˜æ¡£æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚');
      }
    });
    
    // æ¸²æŸ“è®°å¿†å­˜æ¡£åˆ—è¡¨
    function renderMemoryArchiveList() {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const listContainer = document.getElementById('memory-archive-list');
      
      if (!chat.memoryArchives || chat.memoryArchives.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">æš‚æ— å­˜æ¡£</div>';
        return;
      }
      
      // æŒ‰æ—¶é—´å€’åºæ’åˆ—
      const archives = [...chat.memoryArchives].sort((a, b) => b.timestamp - a.timestamp);
      
      listContainer.innerHTML = archives.map(archive => {
        const date = new Date(archive.timestamp);
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        return `
          <div class="memory-archive-item">
            <div class="memory-archive-info">
              <div class="memory-archive-name">${escapeHTML(archive.name)}</div>
              <div class="memory-archive-date">${dateStr}</div>
            </div>
            <div class="memory-archive-actions">
              <button class="memory-archive-btn load" data-archive-id="${archive.id}">è¯»æ¡£</button>
              <button class="memory-archive-btn delete" data-archive-id="${archive.id}">åˆ é™¤</button>
            </div>
          </div>
        `;
      }).join('');
      
      // ç»‘å®šè¯»æ¡£æŒ‰é’®äº‹ä»¶
      listContainer.querySelectorAll('.memory-archive-btn.load').forEach(btn => {
        btn.addEventListener('click', async () => {
          const archiveId = parseInt(btn.dataset.archiveId);
          await loadMemoryArchive(archiveId);
        });
      });
      
      // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
      listContainer.querySelectorAll('.memory-archive-btn.delete').forEach(btn => {
        btn.addEventListener('click', async () => {
          const archiveId = parseInt(btn.dataset.archiveId);
          await deleteMemoryArchive(archiveId);
        });
      });
    }
    
    // è¯»å–è®°å¿†å­˜æ¡£
    async function loadMemoryArchive(archiveId) {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      const archive = chat.memoryArchives.find(a => a.id === archiveId);
      if (!archive) {
        await showCustomAlert('é”™è¯¯', 'æ‰¾ä¸åˆ°è¯¥å­˜æ¡£');
        return;
      }
      
      const confirmed = await showCustomConfirm(
        'è¯»å–å­˜æ¡£',
        `ç¡®å®šè¦è¯»å–å­˜æ¡£"${archive.name}"å—ï¼Ÿ\n\nå½“å‰çš„èŠå¤©è®°å½•å’Œæ‰€æœ‰è®¾ç½®å°†è¢«å®Œå…¨è¦†ç›–ï¼`,
        { confirmButtonClass: 'btn-danger' }
      );
      
      if (!confirmed) return;
      
      try {
        // æ¢å¤èŠå¤©è®°å½•
        chat.history = JSON.parse(JSON.stringify(archive.data.history));
        
        // æ¢å¤æ‰€æœ‰è®¾ç½®
        const savedSettings = archive.data.settings;
        chat.settings.aiPersona = savedSettings.aiPersona;
        chat.settings.aiAvatar = savedSettings.aiAvatar;
        chat.settings.myPersona = savedSettings.myPersona;
        chat.settings.myAvatar = savedSettings.myAvatar;
        chat.settings.myNickname = savedSettings.myNickname;
        chat.settings.maxMemory = savedSettings.maxMemory;
        chat.settings.linkedMemoryCount = savedSettings.linkedMemoryCount;
        chat.settings.linkedMemoryChatIds = [...(savedSettings.linkedMemoryChatIds || [])];
        chat.settings.enableAutoMemory = savedSettings.enableAutoMemory;
        chat.settings.autoMemoryInterval = savedSettings.autoMemoryInterval;
        chat.settings.enableTts = savedSettings.enableTts;
        chat.settings.minimaxVoiceId = savedSettings.minimaxVoiceId;
        chat.settings.ttsLanguage = savedSettings.ttsLanguage;
        chat.settings.linkedWorldBookIds = [...(savedSettings.linkedWorldBookIds || [])];
        chat.settings.offlinePresetId = savedSettings.offlinePresetId;
        chat.settings.theme = savedSettings.theme;
        chat.settings.fontSize = savedSettings.fontSize;
        chat.settings.customCss = savedSettings.customCss;
        chat.settings.enableTimePerception = savedSettings.enableTimePerception;
        chat.settings.timeZone = savedSettings.timeZone;
        chat.settings.enableBackgroundActivity = savedSettings.enableBackgroundActivity;
        chat.settings.actionCooldownMinutes = savedSettings.actionCooldownMinutes;
        chat.settings.enableTodoList = savedSettings.enableTodoList;
        chat.settings.isOfflineMode = savedSettings.isOfflineMode;
        chat.settings.weather = savedSettings.weather ? JSON.parse(JSON.stringify(savedSettings.weather)) : null;
        chat.settings.enableSynthMusic = savedSettings.enableSynthMusic;
        chat.settings.enableNarratorMode = savedSettings.enableNarratorMode;
        chat.settings.showSeconds = savedSettings.showSeconds;
        chat.settings.lyricsPosition = savedSettings.lyricsPosition ? JSON.parse(JSON.stringify(savedSettings.lyricsPosition)) : null;
        
        // æ¢å¤è§’è‰²çŠ¶æ€
        chat.heartfeltVoice = archive.data.heartfeltVoice;
        chat.randomJottings = archive.data.randomJottings;
        chat.status = archive.data.status ? JSON.parse(JSON.stringify(archive.data.status)) : null;
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await db.chats.put(chat);
        
        // åˆ·æ–°ç•Œé¢
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // å¦‚æœåœ¨è®¾ç½®é¡µé¢ï¼Œä¹Ÿåˆ·æ–°è®¾ç½®é¡µé¢
        const settingsModalElement = document.getElementById('chat-settings-modal');
        if (settingsModalElement && settingsModalElement.classList.contains('visible')) {
          showScreen('chat-interface-screen');
          setTimeout(() => {
            openChatSettings();
          }, 100);
        }
        
        await showCustomAlert('è¯»æ¡£æˆåŠŸ', `å·²æˆåŠŸè¯»å–å­˜æ¡£"${archive.name}"ï¼`);
      } catch (error) {
        console.error('è¯»å–è®°å¿†å­˜æ¡£å¤±è´¥:', error);
        await showCustomAlert('è¯»æ¡£å¤±è´¥', 'è¯»å–è®°å¿†å­˜æ¡£æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚');
      }
    }
    
    // åˆ é™¤è®°å¿†å­˜æ¡£
    async function deleteMemoryArchive(archiveId) {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      const archive = chat.memoryArchives.find(a => a.id === archiveId);
      if (!archive) {
        await showCustomAlert('é”™è¯¯', 'æ‰¾ä¸åˆ°è¯¥å­˜æ¡£');
        return;
      }
      
      const confirmed = await showCustomConfirm(
        'åˆ é™¤å­˜æ¡£',
        `ç¡®å®šè¦åˆ é™¤å­˜æ¡£"${archive.name}"å—ï¼Ÿ\n\næ­¤æ“ä½œæ— æ³•æ’¤é”€ï¼`,
        { confirmButtonClass: 'btn-danger' }
      );
      
      if (!confirmed) return;
      
      try {
        // ä»æ•°ç»„ä¸­ç§»é™¤
        chat.memoryArchives = chat.memoryArchives.filter(a => a.id !== archiveId);
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await db.chats.put(chat);
        
        // åˆ·æ–°åˆ—è¡¨
        renderMemoryArchiveList();
        
        await showCustomAlert('åˆ é™¤æˆåŠŸ', `å­˜æ¡£"${archive.name}"å·²åˆ é™¤ï¼`);
      } catch (error) {
        console.error('åˆ é™¤è®°å¿†å­˜æ¡£å¤±è´¥:', error);
        await showCustomAlert('åˆ é™¤å¤±è´¥', 'åˆ é™¤è®°å¿†å­˜æ¡£æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚');
      }
    }
    
    // ==================== è®°å¿†åº“åŠŸèƒ½ç»“æŸ ====================
    
    // ==================== APIè°ƒç”¨å†å²æŸ¥çœ‹åŠŸèƒ½ ====================
    
    // æ‰“å¼€APIå†å²æŸ¥çœ‹å™¨
    document.getElementById('view-api-history-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      renderApiHistoryList();
      document.getElementById('api-history-modal').classList.add('visible');
    });
    
    // å…³é—­APIå†å²æŸ¥çœ‹å™¨
    document.getElementById('close-api-history-btn').addEventListener('click', () => {
      document.getElementById('api-history-modal').classList.remove('visible');
    });
    
    // å…¨é€‰/å–æ¶ˆå…¨é€‰APIå†å²
    document.getElementById('api-history-select-all').addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('.api-history-checkbox');
      checkboxes.forEach(cb => cb.checked = e.target.checked);
    });
    
    // åˆ é™¤é€‰ä¸­çš„APIå†å²
    document.getElementById('api-history-delete-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      // è·å–æ‰€æœ‰é€‰ä¸­çš„å¤é€‰æ¡†
      const checkedBoxes = document.querySelectorAll('.api-history-checkbox:checked');
      
      if (checkedBoxes.length === 0) {
        await showCustomAlert('æç¤º', 'è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è®°å½•ï¼');
        return;
      }
      
      const confirmed = await showCustomConfirm(
        'åˆ é™¤APIå†å²',
        `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${checkedBoxes.length} æ¡APIè°ƒç”¨å†å²è®°å½•å—ï¼Ÿ\n\næ­¤æ“ä½œæ— æ³•æ’¤é”€ï¼`,
        { confirmButtonClass: 'btn-danger' }
      );
      
      if (!confirmed) return;
      
      try {
        // è·å–è¦åˆ é™¤çš„ç´¢å¼•åˆ—è¡¨
        const indicesToDelete = Array.from(checkedBoxes).map(cb => parseInt(cb.dataset.index));
        
        // åˆ›å»ºæ–°æ•°ç»„ï¼Œæ’é™¤è¦åˆ é™¤çš„è®°å½•
        chat.apiHistory = chat.apiHistory.filter((record, index) => !indicesToDelete.includes(index));
        
        await db.chats.put(chat);
        
        // å–æ¶ˆå…¨é€‰
        document.getElementById('api-history-select-all').checked = false;
        
        renderApiHistoryList();
        await showCustomAlert('åˆ é™¤æˆåŠŸ', `å·²åˆ é™¤ ${checkedBoxes.length} æ¡APIè°ƒç”¨å†å²è®°å½•ï¼`);
      } catch (error) {
        console.error('åˆ é™¤APIå†å²å¤±è´¥:', error);
        await showCustomAlert('åˆ é™¤å¤±è´¥', 'åˆ é™¤APIå†å²æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚');
      }
    });
    
    // å¯¼å‡ºAPIå†å²ä¸ºJSON
    document.getElementById('api-history-export-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      if (!chat.apiHistory || chat.apiHistory.length === 0) {
        showCustomAlert('æ— æ•°æ®', 'å½“å‰æ²¡æœ‰APIè°ƒç”¨å†å²å¯å¯¼å‡ºã€‚');
        return;
      }
      
      try {
        const jsonData = JSON.stringify(chat.apiHistory, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `api-history-${chat.name}-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showCustomAlert('å¯¼å‡ºæˆåŠŸ', `å·²å¯¼å‡º ${chat.apiHistory.length} æ¡APIè°ƒç”¨è®°å½•ï¼`);
      } catch (error) {
        console.error('å¯¼å‡ºAPIå†å²å¤±è´¥:', error);
        showCustomAlert('å¯¼å‡ºå¤±è´¥', 'å¯¼å‡ºAPIå†å²æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚');
      }
    });
    
    // æ¸²æŸ“APIå†å²åˆ—è¡¨
    function renderApiHistoryList() {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const listContainer = document.getElementById('api-history-list');
      
      if (!chat.apiHistory || chat.apiHistory.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">æš‚æ— APIè°ƒç”¨å†å²</div>';
        return;
      }
      
      // æŒ‰æ—¶é—´å€’åºæ’åˆ—ï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
      const history = [...chat.apiHistory].reverse();
      
      listContainer.innerHTML = history.map((record, index) => {
        const date = new Date(record.timestamp);
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
        
        const duration = record.responseTimestamp ? `${Math.round((record.responseTimestamp - record.timestamp) / 1000)}ç§’` : 'æœªå®Œæˆ';
        const reversedIndex = chat.apiHistory.length - index;
        
        // è®¡ç®—æç¤ºè¯å’Œå“åº”çš„å­—ç¬¦æ•°
        const promptLength = record.systemPrompt ? record.systemPrompt.length : 0;
        const messagesLength = record.messages ? JSON.stringify(record.messages).length : 0;
        const responseLength = record.aiResponseContent ? record.aiResponseContent.length : 0;
        
        return `
          <div class="api-history-item" style="
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: var(--bg-primary);
          ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" class="api-history-checkbox" data-index="${chat.apiHistory.length - 1 - index}" style="cursor: pointer; width: 18px; height: 18px;">
                <div style="font-weight: 600; font-size: 14px;">
                  #${reversedIndex} - ${dateStr}
                </div>
              </div>
              <div style="font-size: 12px; color: var(--text-secondary);">
                è€—æ—¶: ${duration}
              </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
              <span style="font-size: 12px; padding: 4px 8px; background: var(--bg-secondary); border-radius: 4px;">
                æ¨¡å‹: ${escapeHTML(record.model)}
              </span>
              <span style="font-size: 12px; padding: 4px 8px; background: var(--bg-secondary); border-radius: 4px;">
                æ¸©åº¦: ${record.temperature}
              </span>
              <span style="font-size: 12px; padding: 4px 8px; background: var(--bg-secondary); border-radius: 4px;">
                æç¤ºè¯: ${promptLength.toLocaleString()} å­—ç¬¦
              </span>
              <span style="font-size: 12px; padding: 4px 8px; background: var(--bg-secondary); border-radius: 4px;">
                æ¶ˆæ¯: ${messagesLength.toLocaleString()} å­—ç¬¦
              </span>
              <span style="font-size: 12px; padding: 4px 8px; background: var(--bg-secondary); border-radius: 4px;">
                å“åº”: ${responseLength.toLocaleString()} å­—ç¬¦
              </span>
            </div>
            
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button class="form-button-secondary view-system-prompt-btn" data-index="${chat.apiHistory.length - 1 - index}" style="flex: 1; min-width: 150px; padding: 8px 12px; font-size: 13px; opacity: 0.6;">
                ğŸ”’ æŸ¥çœ‹ç³»ç»Ÿæç¤ºè¯
              </button>
              <button class="form-button-secondary view-messages-btn" data-index="${chat.apiHistory.length - 1 - index}" style="flex: 1; min-width: 150px; padding: 8px 12px; font-size: 13px; opacity: 0.6;">
                ğŸ”’ æŸ¥çœ‹å‘é€æ¶ˆæ¯
              </button>
              <button class="form-button-secondary view-response-btn" data-index="${chat.apiHistory.length - 1 - index}" style="flex: 1; min-width: 150px; padding: 8px 12px; font-size: 13px;">
                æŸ¥çœ‹AIå“åº”
              </button>
              <button class="form-button-secondary view-raw-data-btn" data-index="${chat.apiHistory.length - 1 - index}" style="flex: 1; min-width: 150px; padding: 8px 12px; font-size: 13px;">
                æŸ¥çœ‹åŸå§‹æ•°æ®
              </button>
            </div>
          </div>
        `;
      }).join('');
      
      // ç»‘å®šæŒ‰é’®äº‹ä»¶
      listContainer.querySelectorAll('.view-system-prompt-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // æ£€æŸ¥æ˜¯å¦è¢«é”å®š
          if (LOCKED_FEATURES.systemPrompt) {
            showNotification('ğŸ”’ æ­¤åŠŸèƒ½å·²è¢«é”å®šï¼Œæ— æ³•æŸ¥çœ‹ç³»ç»Ÿæç¤ºè¯', 'warning');
            return;
          }
          const index = parseInt(btn.dataset.index);
          const record = chat.apiHistory[index];
          showApiHistoryDetail('ç³»ç»Ÿæç¤ºè¯', record.systemPrompt, 'text');
        });
      });
      
      listContainer.querySelectorAll('.view-messages-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // æ£€æŸ¥æ˜¯å¦è¢«é”å®š
          if (LOCKED_FEATURES.messages) {
            showNotification('ğŸ”’ æ­¤åŠŸèƒ½å·²è¢«é”å®šï¼Œæ— æ³•æŸ¥çœ‹å‘é€æ¶ˆæ¯', 'warning');
            return;
          }
          const index = parseInt(btn.dataset.index);
          const record = chat.apiHistory[index];
          showApiHistoryDetail('å‘é€çš„æ¶ˆæ¯', JSON.stringify(record.messages, null, 2), 'json');
        });
      });
      
      listContainer.querySelectorAll('.view-response-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const index = parseInt(btn.dataset.index);
          const record = chat.apiHistory[index];
          showApiHistoryDetail('AIå“åº”å†…å®¹', record.aiResponseContent, 'text');
        });
      });
      
      listContainer.querySelectorAll('.view-raw-data-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const index = parseInt(btn.dataset.index);
          const record = chat.apiHistory[index];
          showApiHistoryDetail('åŸå§‹å“åº”æ•°æ®', JSON.stringify(record.responseData, null, 2), 'json');
        });
      });
      
      // ç›‘å¬å•ä¸ªå¤é€‰æ¡†å˜åŒ–ï¼Œæ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
      const selectAllCheckbox = document.getElementById('api-history-select-all');
      listContainer.querySelectorAll('.api-history-checkbox').forEach(cb => {
        cb.addEventListener('change', () => {
          const allCheckboxes = document.querySelectorAll('.api-history-checkbox');
          const checkedCount = document.querySelectorAll('.api-history-checkbox:checked').length;
          selectAllCheckbox.checked = checkedCount === allCheckboxes.length;
        });
      });
      
      // é‡ç½®å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
      if (selectAllCheckbox) {
        selectAllCheckbox.checked = false;
      }
    }
    
    // æ˜¾ç¤ºAPIå†å²è¯¦æƒ…
    function showApiHistoryDetail(title, content, type) {
      const modal = document.createElement('div');
      modal.className = 'modal visible';
      modal.style.zIndex = '10001'; // ç¡®ä¿åœ¨APIå†å²æ¨¡æ€çª—å£ä¹‹ä¸Š
      
      const copyButtonHtml = `<button id="copy-detail-btn" class="form-button" style="padding: 8px 15px; margin-right: 10px;">å¤åˆ¶å†…å®¹</button>`;
      
      modal.innerHTML = `
        <div class="modal-content" style="height: 90%; max-width: 900px;">
          <div class="modal-header">
            <span>${escapeHTML(title)}</span>
          </div>
          <div class="modal-body" style="height: calc(100% - 100px); overflow-y: auto;">
            <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; font-family: monospace; white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.6;">
              ${escapeHTML(content || '(ç©º)')}
            </div>
          </div>
          <div class="modal-footer">
            ${copyButtonHtml}
            <button class="cancel close-detail-btn">å…³é—­</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // ç»‘å®šå¤åˆ¶æŒ‰é’®äº‹ä»¶
      const copyBtn = modal.querySelector('#copy-detail-btn');
      if (copyBtn) {
        copyBtn.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(content);
            copyBtn.textContent = 'å·²å¤åˆ¶ï¼';
            setTimeout(() => {
              copyBtn.textContent = 'å¤åˆ¶å†…å®¹';
            }, 2000);
          } catch (error) {
            console.error('å¤åˆ¶å¤±è´¥:', error);
            showCustomAlert('å¤åˆ¶å¤±è´¥', 'æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚');
          }
        });
      }
      
      // ç»‘å®šå…³é—­æŒ‰é’®äº‹ä»¶
      modal.querySelector('.close-detail-btn').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // ç‚¹å‡»èƒŒæ™¯å…³é—­
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    }
    
    // ==================== APIè°ƒç”¨å†å²æŸ¥çœ‹åŠŸèƒ½ç»“æŸ ====================








    document.getElementById('chat-settings-screen').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('chat');
      }
    });


    document.getElementById('member-settings-modal').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member');
      }
    });


    const frameModal = document.getElementById('avatar-frame-modal');
    const aiFrameTab = document.getElementById('ai-frame-tab');
    const myFrameTab = document.getElementById('my-frame-tab');
    const aiFrameContent = document.getElementById('ai-frame-content');
    const myFrameContent = document.getElementById('my-frame-content');


    document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);


    document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
      frameModal.classList.remove('visible');
      editingFrameForMember = false;
    });


    aiFrameTab.addEventListener('click', () => {
      aiFrameTab.classList.add('active');
      myFrameTab.classList.remove('active');
      aiFrameContent.style.display = 'block';
      myFrameContent.style.display = 'none';
    });


    myFrameTab.addEventListener('click', () => {
      myFrameTab.classList.add('active');
      aiFrameTab.classList.remove('active');
      myFrameContent.style.display = 'block';
      aiFrameContent.style.display = 'none';
    });


    document.getElementById('clear-chat-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const confirmed = await showCustomConfirm('æ¸…ç©ºèŠå¤©è®°å½•', 'æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ­¤èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œæ— æ³•æ¢å¤ã€‚ç¡®å®šè¦æ¸…ç©ºå—ï¼Ÿ', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        chat.history = [];
        chat.heartfeltVoice = '...';
        chat.randomJottings = '...';
        // é‡ç½®è§’è‰²çŠ¶æ€ä¸ºé»˜è®¤çš„"åœ¨çº¿"
        if (!chat.isGroup && chat.status) {
          chat.status.text = 'åœ¨çº¿';
          chat.status.isBusy = false;
          chat.status.lastUpdate = Date.now();
        }
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        renderChatList();
        chatSettingsModal.classList.remove('visible');
      }
    });

    const setupFileUpload = (inputId, callback) => {
      document.getElementById(inputId).addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
          const dataUrl = await new Promise((res, rej) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.onerror = () => rej(reader.error);
            reader.readAsDataURL(file);
          });
          callback(dataUrl);
          event.target.value = null;
        }
      });
    };
    setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
    setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
    setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
    setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
    setupFileUpload('bg-input', async (base64) => {
      if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        
        // 1. ç«‹å³ä¿å­˜å’Œæ˜¾ç¤º
        chat.settings.background = base64;
        const bgPreview = document.getElementById('bg-preview');
        bgPreview.src = base64;
        bgPreview.style.display = 'block';
        document.getElementById('remove-bg-btn').style.display = 'inline-block';
        
        await showCustomAlert("æˆåŠŸ", "èŠå¤©èƒŒæ™¯å·²æ›´æ–°ï¼\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ... (ä¿å­˜è®¾ç½®åç”Ÿæ•ˆ)");

        // 2. å¯åŠ¨é™é»˜ä¸Šä¼ 
        (async () => {
            await silentlyUpdateDbUrl(
                db.chats,
                chat.id,
                'settings.background',
                base64
            );
        })();
      }
    });
    setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
    document.getElementById('remove-bg-btn').addEventListener('click', () => {
      if (state.activeChatId) {
        state.chats[state.activeChatId].settings.background = '';
        const bgPreview = document.getElementById('bg-preview');
        bgPreview.src = '';
        bgPreview.style.display = 'none';
        document.getElementById('remove-bg-btn').style.display = 'none';
      }
    });

    const stickerPanel = document.getElementById('sticker-panel');
    document.getElementById('open-sticker-panel-btn').addEventListener('click', () => {
      const chat = state.chats[state.activeChatId];
      if (chat && chat.settings.stickerCategoryId) {

        activeStickerCategoryId = chat.settings.stickerCategoryId;
      } else {

        activeStickerCategoryId = 'all';
      }
      renderStickerPanel();
      stickerPanel.classList.add('visible');
    });
    document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));



    document.getElementById('add-sticker-batch-btn').addEventListener('click', openBatchStickerImportModal);






    document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
    document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = async () => {
        let base64Url = reader.result;
        const name = await showCustomPrompt("å‘½åè¡¨æƒ…", "è¯·ä¸ºè¿™ä¸ªè¡¨æƒ…å‘½å (ä¾‹å¦‚ï¼šå¥½è€¶ã€ç–‘æƒ‘)");

        if (name && name.trim()) {
            const trimmedName = name.trim();
            
            const newSticker = {
    id: 'sticker_' + Date.now() + Math.random(), // <-- Add this line
    url: base64Url, 
    name: trimmedName,
    categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
};
            const newId = await db.userStickers.add(newSticker); // 1. Save to DB
            
            newSticker.id = newId; 
            state.userStickers.push(newSticker); // 2. Update state
            
            renderStickerPanel(); // 3. Render UI
            await showCustomAlert("æ·»åŠ æˆåŠŸï¼", `è¡¨æƒ…â€œ${trimmedName}â€å·²æ·»åŠ ã€‚\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ...`);

            // 4. ã€ã€ã€å·²ä¿®å¤çš„è°ƒç”¨ã€‘ã€‘ã€‘
            (async () => {
                await silentlyUpdateDbUrl(
                    db.userStickers, // table
                    newId, // recordId
                    'url', // pathString (æŒ‡å‘ç®€å•å±æ€§)
                    base64Url // base64ToFind
                    // nameToMatch (ä¸éœ€è¦)
                );
            })();

        } else if (name !== null) {
             alert("è¡¨æƒ…åä¸èƒ½ä¸ºç©ºï¼");
        }
      };
      event.target.value = null;
    });

    document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
   document.getElementById('image-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file || !state.activeChatId) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64Url = e.target.result;
        const chat = state.chats[state.activeChatId];
        const msg = {
          role: 'user',
          content: [{
            type: 'image_url',
            image_url: {
              url: base64Url
            }
          }],
          timestamp: Date.now()
        };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      };
      reader.readAsDataURL(file);
      event.target.value = null;
    });
    
    // æ‹ç…§æŒ‰é’®äº‹ä»¶å¤„ç†
    document.getElementById('camera-capture-btn').addEventListener('click', () => {
      document.getElementById('camera-capture-input').click();
    });
    
    document.getElementById('camera-capture-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file || !state.activeChatId) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64Url = e.target.result;
        const chat = state.chats[state.activeChatId];
        const msg = {
          role: 'user',
          content: [{
            type: 'image_url',
            image_url: {
              url: base64Url
            }
          }],
          timestamp: Date.now()
        };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      };
      reader.readAsDataURL(file);
      event.target.value = null;
    });
    document.getElementById('voice-message-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;

      const text = await showCustomPrompt("å‘é€è¯­éŸ³", "è¯·è¾“å…¥ä½ æƒ³è¯´çš„å†…å®¹ï¼š");
      if (text && text.trim()) {
        const chat = state.chats[state.activeChatId];


        const msg = {
          role: 'user',
          type: 'voice_message',
          content: text.trim(),
          timestamp: Date.now()
        };

        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      }
    });
    document.getElementById('send-photo-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const description = await showCustomPrompt("å‘é€ç…§ç‰‡", "è¯·ç”¨æ–‡å­—æè¿°æ‚¨è¦å‘é€çš„ç…§ç‰‡ï¼š");
      if (description && description.trim()) {
        const chat = state.chats[state.activeChatId];
        const msg = {
          role: 'user',
          type: 'user_photo',
          content: description.trim(),
          timestamp: Date.now()
        };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      }
    });

    const waimaiModal = document.getElementById('waimai-request-modal');


    document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
      waimaiModal.classList.add('visible');
    });


    waimaiModal.addEventListener('click', (e) => {

      if (e.target === waimaiModal) {
        waimaiModal.classList.remove('visible');
      }
    });


    document.getElementById('waimai-order-for-ai-btn').addEventListener('click', sendWaimaiOrderForAI);


    document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;

      const productInfoInput = document.getElementById('waimai-product-info');
      const amountInput = document.getElementById('waimai-amount');

      const productInfo = productInfoInput.value.trim();
      const amount = parseFloat(amountInput.value);

      if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('è¯·å¡«å†™æœ‰æ•ˆçš„å•†å“ä¿¡æ¯å’Œé‡‘é¢ï¼');
        return;
      }

      const chat = state.chats[state.activeChatId];
      const now = Date.now();
      const myNickname = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';

      const msg = {
        role: 'user',
        senderName: myNickname,
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
      };

      chat.history.push(msg);
      await db.chats.put(chat);
      appendMessage(msg, chat);
      renderChatList();

      productInfoInput.value = '';
      amountInput.value = '';
      waimaiModal.classList.remove('visible');
    });
    document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
    document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
    document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
    document.getElementById('manage-persona-preset-btn').addEventListener('click', enterManageMode);
    document.getElementById('select-all-persona-btn').addEventListener('click', selectAllPresets);
    document.getElementById('delete-selected-persona-btn').addEventListener('click', deleteSelectedPresets);
    document.getElementById('cancel-manage-persona-btn').addEventListener('click', exitManageMode);
    document.getElementById('import-tavern-persona-btn').addEventListener('click', importTavernPersonas);
    document.getElementById('import-tavern-persona-input').addEventListener('change', handleTavernPersonaImport);
    document.getElementById('cancel-tavern-import-btn').addEventListener('click', closeTavernPersonaSelector);
    document.getElementById('confirm-tavern-import-btn').addEventListener('click', confirmTavernImport);
    document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
    document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
    document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
    document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
    document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
    
    // æ–°å¢ï¼šäººè®¾æ“ä½œå¼¹çª—äº‹ä»¶ç»‘å®š
    document.getElementById('apply-persona-direct-btn').addEventListener('click', applyPersonaPresetDirect);
    document.getElementById('edit-persona-first-btn').addEventListener('click', editPersonaThenApply);
    document.getElementById('cancel-persona-action-btn').addEventListener('click', hidePersonaActionModal);

    document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);




    document.getElementById('selection-soft-delete-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedMessages.size} æ¡æ¶ˆæ¯å—ï¼Ÿè¿™ä¼šé€šçŸ¥AIè¿™äº›æ¶ˆæ¯å·²è¢«åˆ é™¤ã€‚`, {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        const chat = state.chats[state.activeChatId];
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
          const msg = chat.history.find(m => m.timestamp === timestamp);
          if (msg && msg.type === 'poll') {
            deletedPollsInfo.push(`å…³äºâ€œ${msg.question}â€çš„æŠ•ç¥¨(æ—¶é—´æˆ³: ${msg.timestamp})`);
          }
        }
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        let forgetReason = "ä¸€äº›ä¹‹å‰çš„æ¶ˆæ¯å·²è¢«ç”¨æˆ·åˆ é™¤ã€‚";
        if (deletedPollsInfo.length > 0) {
          forgetReason += ` å…¶ä¸­åŒ…æ‹¬ä»¥ä¸‹æŠ•ç¥¨ï¼š${deletedPollsInfo.join('ï¼›')}ã€‚`;
        }
        forgetReason += " ä½ åº”è¯¥åƒå®ƒä»¬ä»æœªå­˜åœ¨è¿‡ä¸€æ ·ç»§ç»­å¯¹è¯ï¼Œå¹¶ç›¸åº”åœ°è°ƒæ•´ä½ çš„è®°å¿†å’Œè¡Œä¸ºï¼Œä¸è¦å†æåŠè¿™äº›è¢«åˆ é™¤çš„å†…å®¹ã€‚";
        const forgetInstruction = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼š${forgetReason}]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(forgetInstruction);
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        renderChatList();
      }
    });


    document.getElementById('selection-erase-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const confirmed = await showCustomConfirm(
        'å½»åº•åˆ é™¤æ¶ˆæ¯',
        `è¿™å°†ä»å†å²è®°å½•ä¸­ã€æ°¸ä¹…æŠ¹é™¤ã€‘è¿™ ${selectedMessages.size} æ¡æ¶ˆæ¯ï¼ŒAIå°†å®Œå…¨é—å¿˜å®ƒä»¬çš„å­˜åœ¨ã€‚ç¡®å®šå—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger',
          confirmText: 'ç¡®è®¤æŠ¹é™¤'
        }
      );
      if (confirmed) {
        const chat = state.chats[state.activeChatId];


        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));


        await db.chats.put(chat);


        renderChatInterface(state.activeChatId);
        renderChatList();
      }
    });


    const fontUrlInput = document.getElementById('font-url-input');
    fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
    document.getElementById('save-font-btn').addEventListener('click', async () => {
      const newFontUrl = fontUrlInput.value.trim();
      if (!newFontUrl) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„å­—ä½“URLã€‚");
        return;
      }
      applyCustomFont(newFontUrl, false);
      state.globalSettings.fontUrl = newFontUrl;
      await db.globalSettings.put(state.globalSettings);
      alert('å­—ä½“å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
    });
    document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
      item.addEventListener('click', () => switchToChatListView(item.dataset.view));
    });
    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
    document.getElementById('qzone-nickname').addEventListener('click', async () => {
      const newNickname = await showCustomPrompt("ä¿®æ”¹æ˜µç§°", "è¯·è¾“å…¥æ–°çš„æ˜µç§°", state.qzoneSettings.nickname);
      if (newNickname && newNickname.trim()) {
        state.qzoneSettings.nickname = newNickname.trim();
        await saveQzoneSettings();
        renderQzoneScreen();
      }
    });
    document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
    document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
    document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(res => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });
        state.qzoneSettings.avatar = dataUrl;
        await saveQzoneSettings();
        renderQzoneScreen();
      }
      event.target.value = null;
    });
    document.getElementById('qzone-banner-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(res => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });
        state.qzoneSettings.banner = dataUrl;
        await saveQzoneSettings();
        renderQzoneScreen();
      }
      event.target.value = null;
    });


    document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {

      resetCreatePostModal();
      const modal = document.getElementById('create-post-modal');


      modal.dataset.mode = 'shuoshuo';


      modal.querySelector('.post-mode-switcher').style.display = 'none';
      modal.querySelector('#image-mode-content').style.display = 'none';
      modal.querySelector('#text-image-mode-content').style.display = 'none';


      modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...';


      const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
      visibilityGroupsContainer.innerHTML = '';
      const groups = await db.qzoneGroups.toArray();
      if (groups.length > 0) {
        groups.forEach(group => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
          visibilityGroupsContainer.appendChild(label);
        });
      } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
      }
      modal.classList.add('visible');
    });


    document.getElementById('create-post-btn').addEventListener('click', async () => {

      resetCreatePostModal();
      const modal = document.getElementById('create-post-modal');


      modal.dataset.mode = 'complex';


      modal.querySelector('.post-mode-switcher').style.display = 'flex';

      modal.querySelector('#image-mode-content').classList.add('active');

      modal.querySelector('#text-image-mode-content').classList.remove('active');


      modal.querySelector('#post-public-text').placeholder = 'åˆ†äº«æ–°é²œäº‹...ï¼ˆéå¿…å¡«çš„å…¬å¼€æ–‡å­—ï¼‰';


      const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
      visibilityGroupsContainer.innerHTML = '';
      const groups = await db.qzoneGroups.toArray();
      if (groups.length > 0) {
        groups.forEach(group => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
          visibilityGroupsContainer.appendChild(label);
        });
      } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">æ²¡æœ‰å¯ç”¨çš„åˆ†ç»„</p>';
      }
      modal.classList.add('visible');
    });
    document.getElementById('open-album-btn').addEventListener('click', async () => {
      await renderAlbumList();
      showScreen('album-screen');
    });
    document.getElementById('album-back-btn').addEventListener('click', () => {
      showScreen('chat-list-screen');
      switchToChatListView('qzone-screen');
    });



    document.getElementById('album-photos-back-btn').addEventListener('click', () => {
      state.activeAlbumId = null;
      showScreen('album-screen');
    });

    document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

    document.getElementById('album-photo-input').addEventListener('change', async (event) => {
      if (!state.activeAlbumId) return;
      const files = event.target.files;
      if (!files.length) return;

      const album = await db.qzoneAlbums.get(state.activeAlbumId);

      for (const file of files) {
        const dataUrl = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({
          albumId: state.activeAlbumId,
          url: dataUrl,
          createdAt: Date.now()
        });
      }

      const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
      const updateData = {
        photoCount
      };

      if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if (firstPhoto) updateData.coverUrl = firstPhoto.url;
      }

      await db.qzoneAlbums.update(state.activeAlbumId, updateData);
      await renderAlbumPhotosScreen();
      await renderAlbumList();

      event.target.value = null;
      alert('ç…§ç‰‡ä¸Šä¼ æˆåŠŸï¼');
    });





    document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
      const deleteBtn = e.target.closest('.photo-delete-btn');
      const photoThumb = e.target.closest('.photo-thumb');

      if (deleteBtn) {
        e.stopPropagation();
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
          'åˆ é™¤ç…§ç‰‡',
          'ç¡®å®šè¦åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚', {
            confirmButtonClass: 'btn-danger'
          }
        );

        if (confirmed) {
          const deletedPhoto = await db.qzonePhotos.get(photoId);
          if (!deletedPhoto) return;

          await db.qzonePhotos.delete(photoId);

          const album = await db.qzoneAlbums.get(state.activeAlbumId);
          const photoCount = (album.photoCount || 1) - 1;
          const updateData = {
            photoCount
          };

          if (album.coverUrl === deletedPhoto.url) {
            const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
            updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
          }

          await db.qzoneAlbums.update(state.activeAlbumId, updateData);
          await renderAlbumPhotosScreen();
          await renderAlbumList();
          alert('ç…§ç‰‡å·²åˆ é™¤ã€‚');
        }
      } else if (photoThumb) {

        openPhotoViewer(photoThumb.src);
      }
    });


    document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
    document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
    document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);


    document.addEventListener('keydown', (e) => {
      if (!photoViewerState.isOpen) return;

      if (e.key === 'ArrowRight') {
        showNextPhoto();
      } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
      } else if (e.key === 'Escape') {
        closePhotoViewer();
      }
    });



    document.getElementById('create-album-btn-page').addEventListener('click', async () => {
      const albumName = await showCustomPrompt("åˆ›å»ºæ–°ç›¸å†Œ", "è¯·è¾“å…¥ç›¸å†Œåç§°");
      if (albumName && albumName.trim()) {
        const newAlbum = {
          name: albumName.trim(),
          coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
          photoCount: 0,
          createdAt: Date.now()
        };
        await db.qzoneAlbums.add(newAlbum);
        await renderAlbumList();
        alert(`ç›¸å†Œ "${albumName}" åˆ›å»ºæˆåŠŸï¼`);
      } else if (albumName !== null) {
        alert("ç›¸å†Œåç§°ä¸èƒ½ä¸ºç©ºï¼");
      }
    });

    document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
    document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
    document.getElementById('post-local-image-input').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          document.getElementById('post-image-preview').src = e.target.result;
          document.getElementById('post-image-preview-container').classList.add('visible');
          document.getElementById('post-image-desc-group').style.display = 'block';
        };
        reader.readAsDataURL(file);
      }
    });
    document.getElementById('post-use-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("è¾“å…¥å›¾ç‰‡URL", "è¯·è¾“å…¥ç½‘ç»œå›¾ç‰‡çš„é“¾æ¥", "", "url");
      if (url) {
        document.getElementById('post-image-preview').src = url;
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-desc-group').style.display = 'block';
      }
    });
    document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    imageModeBtn.addEventListener('click', () => {
      imageModeBtn.classList.add('active');
      textImageModeBtn.classList.remove('active');
      imageModeContent.classList.add('active');
      textImageModeContent.classList.remove('active');
    });
    textImageModeBtn.addEventListener('click', () => {
      textImageModeBtn.classList.add('active');
      imageModeBtn.classList.remove('active');
      textImageModeContent.classList.add('active');
      imageModeContent.classList.remove('active');
    });


    document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
      const modal = document.getElementById('create-post-modal');
      const mode = modal.dataset.mode;


      const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
      let visibleGroupIds = null;

      if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
      }

      let newPost = {};
      const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',

        visibleGroupIds: visibleGroupIds,
      };


      if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
          alert('è¯´è¯´å†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');
          return;
        }
        newPost = {
          ...basePostData,
          type: 'shuoshuo',
          content: content,
        };

      } else {
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
          const imageUrl = document.getElementById('post-image-preview').src;
          const imageDescription = document.getElementById('post-image-description').value.trim();
          if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
            alert('è¯·å…ˆæ·»åŠ ä¸€å¼ å›¾ç‰‡å†å‘å¸ƒåŠ¨æ€å“¦ï¼');
            return;
          }
          if (!imageDescription) {
            alert('è¯·ä¸ºä½ çš„å›¾ç‰‡æ·»åŠ ä¸€ä¸ªç®€å•çš„æè¿°ï¼ˆå¿…å¡«ï¼Œç»™AIçœ‹çš„ï¼‰ï¼');
            return;
          }
          newPost = {
            ...basePostData,
            type: 'image_post',
            publicText: publicText,
            imageUrl: imageUrl,
            imageDescription: imageDescription,
          };
        } else {
          const hiddenText = document.getElementById('post-hidden-text').value.trim();
          if (!hiddenText) {
            alert('è¯·è¾“å…¥æ–‡å­—å›¾æè¿°ï¼');
            return;
          }
          newPost = {
            ...basePostData,
            type: 'text_image',
            publicText: publicText,
            hiddenContent: hiddenText,
          };
        }
      }


      const newPostId = await db.qzonePosts.add(newPost);
      let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "ï¼ˆæ— æ–‡å­—å†…å®¹ï¼‰";
      postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');


      for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;


        if (!postVisibleGroups || postVisibleGroups.length === 0) {
          shouldNotify = true;
        } else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
          shouldNotify = true;
        }


        if (shouldNotify) {

          const historyMessage = {
            role: 'system',
            content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšå‘å¸ƒäº†ä¸€æ¡åŠ¨æ€(ID: ${newPostId})ï¼Œå†…å®¹æ‘˜è¦æ˜¯ï¼šâ€œ${postSummary}â€ã€‚è¯·ä½ ã€ç»“åˆè‡ªå·±çš„è§’è‰²è®¾å®šã€ä¸–ç•Œè§‚å’Œä½ ä»¬çš„æœ€è¿‘èŠå¤©å†…å®¹ã€‘ï¼Œå¯¹è¿™æ¡åŠ¨æ€å‘è¡¨ä¸€æ¡è‡ªç„¶çš„è¯„è®ºã€‚]`,
            timestamp: Date.now(),
            isHidden: true
          };

          chat.history.push(historyMessage);
          await db.chats.put(chat);
        }
      }


      await renderQzonePosts();
      modal.classList.remove('visible');
      alert('åŠ¨æ€å‘å¸ƒæˆåŠŸï¼');
    });



    const postsList = document.getElementById('qzone-posts-list');
    let swipeState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      currentX: 0,
      activeContainer: null,
      swipeDirection: null,
      isClick: true
    };

    function resetAllSwipes(exceptThisOne = null) {
      document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
          container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
      });
    }

 
    async function handlePostClick(e) {
      e.stopPropagation();
      const target = e.target;


      const deleteBtn = target.closest('.comment-delete-btn');
      if (deleteBtn) {
        const postContainer = deleteBtn.closest('.qzone-post-container');
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(deleteBtn.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;

        const post = qzonePostsCache.find(p => p.id === postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;



        const deletedComment = post.comments[commentIndex];

        const confirmed = await showCustomConfirm('åˆ é™¤è¯„è®º', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ', {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {

          post.comments.splice(commentIndex, 1);
          await db.qzonePosts.update(postId, {
            comments: post.comments
          });




          if (deletedComment && deletedComment.commenterName === state.qzoneSettings.nickname) {
            console.log("ç”¨æˆ·åˆ é™¤äº†è‡ªå·±çš„è¯„è®ºï¼Œå¼€å§‹æ¸…ç†AIè®°å¿†...");


            const aiToNotifyIds = new Set();
            if (post.authorId !== 'user') {
              aiToNotifyIds.add(post.authorId);
            }
            if (deletedComment.replyTo) {
              const repliedToChat = Object.values(state.chats).find(c => c.originalName === deletedComment.replyTo);
              if (repliedToChat) {
                aiToNotifyIds.add(repliedToChat.id);
              }
            }


            const postSummary = (post.publicText || post.content || '').substring(0, 30);
            const userNickname = state.qzoneSettings.nickname;
            let notificationText;
            const stickerMatch = state.userStickers.find(s => s.url === deletedComment.text);

            if (stickerMatch) {
              notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${stickerMatch.name}â€ã€‚`;
            } else if (deletedComment.replyTo) {
              const repliedToDisplayName = getDisplayNameByOriginalName(deletedComment.replyTo);
              notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå›å¤äº†'${repliedToDisplayName}'çš„è¯„è®ºï¼Œå†…å®¹æ˜¯ï¼šâ€œ${deletedComment.text}â€ã€‚`;
            } else {
              notificationText = `ç”¨æˆ·'${userNickname}'åˆšåˆšè¯„è®ºäº†ä½ çš„åŠ¨æ€â€œ${postSummary}â€ï¼Œå†…å®¹æ˜¯ï¼šâ€œ${deletedComment.text}â€ã€‚`;
            }
            const fullSystemContent = `[ç³»ç»Ÿæç¤ºï¼š${notificationText}è¯·ä½ å¯¹æ­¤ä½œå‡ºå›åº”ã€‚]`;


            for (const aiId of aiToNotifyIds) {
              const chat = state.chats[aiId];
              if (chat) {
                const originalLength = chat.history.length;

                chat.history = chat.history.filter(msg =>
                  !(msg.isHidden && msg.role === 'system' && msg.content === fullSystemContent)
                );

                if (chat.history.length < originalLength) {
                  console.log(`åœ¨è§’è‰² "${chat.name}" çš„è®°å¿†ä¸­æ¸…é™¤äº†1æ¡å…³äºå·²åˆ é™¤è¯„è®ºçš„é€šçŸ¥ã€‚`);
                  await db.chats.put(chat);
                }
              }
            }
          }


          await updateSinglePostInDOM(postId);
        }

        return;
      }


      const stickerBtn = target.closest('.comment-sticker-btn');
      if (stickerBtn) {
        const postContainer = stickerBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (qzoneStickerPanelState.isOpen && qzoneStickerPanelState.activePostId === postId) {
          closeQzoneStickerPanel();
        } else {
          openQzoneStickerPanel(postId, stickerBtn);
        }
        return;
      }
      const commentItem = target.closest('.comment-item');
      if (commentItem) {
        const postId = parseInt(commentItem.dataset.postId);
        const commenterOriginalName = commentItem.dataset.commenterOriginalName;
        const commenterDisplayName = commentItem.dataset.commenterDisplayName;

        if (!commenterOriginalName || !commenterDisplayName || commenterOriginalName === state.qzoneSettings.nickname) {
          clearQzoneReplyContext(commentItem.closest('.qzone-post-container'));
          return;
        }
        currentQzoneReplyContext = {
          postId,
          replyToName: commenterOriginalName,
          replyToDisplayName: commenterDisplayName
        };
        const postContainer = commentItem.closest('.qzone-post-container');
        const commentInput = postContainer.querySelector('.comment-input');
        commentInput.placeholder = `å›å¤ ${commenterDisplayName}:`;
        commentInput.focus();
        return;
      }
      if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
      }
      if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("å›¾ç‰‡å†…å®¹", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
      }


      const postContainer = target.closest('.qzone-post-container');
      if (!postContainer) return;
      const postId = parseInt(postContainer.dataset.postId);
      if (isNaN(postId)) return;

      if (target.closest('.qzone-post-delete-action')) {
        const confirmed = await showCustomConfirm('åˆ é™¤åŠ¨æ€', 'ç¡®å®šè¦æ°¸ä¹…åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ', {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          postContainer.style.transition = 'all 0.3s ease';
          postContainer.style.transform = 'scale(0.8)';
          postContainer.style.opacity = '0';
          setTimeout(async () => {
            await db.qzonePosts.delete(postId);
            const notificationIdentifier = `(ID: ${postId})`;
            for (const chatId in state.chats) {
              const chat = state.chats[chatId];
              const originalHistoryLength = chat.history.length;
              chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
              if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
            }
            await renderQzonePosts();
            alert('åŠ¨æ€å·²åˆ é™¤ã€‚');
          }, 300);
        }
        return;
      }

      const icon = target.closest('.action-icon');
      if (icon) {
        if (icon.classList.contains('repost')) {
          openRepostModal(postId);
          return;
        }
        if (icon.classList.contains('like')) {
          const post = qzonePostsCache.find(p => p.id === postId);
          if (!post) return;
          if (!post.likes) post.likes = [];
          const userOriginalName = state.qzoneSettings.nickname;
          const userLikeIndex = post.likes.indexOf(userOriginalName);
          if (userLikeIndex > -1) {
            post.likes.splice(userLikeIndex, 1);
          } else {
            post.likes.push(userOriginalName);
            icon.classList.add('animate-like');
            icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), {
              once: true
            });
          }
          await db.qzonePosts.update(postId, {
            likes: post.likes
          });
          await updateSinglePostInDOM(postId);
        }
        if (icon.classList.contains('favorite')) {
          const existingFavorite = await db.favorites.where({
            type: 'qzone_post',
            'content.id': postId
          }).first();
          if (existingFavorite) {
            await db.favorites.delete(existingFavorite.id);
            await showCustomAlert('æç¤º', 'å·²å–æ¶ˆæ”¶è—');
          } else {
            const postToSave = await db.qzonePosts.get(postId);
            if (postToSave) {
              await db.favorites.add({
                type: 'qzone_post',
                content: postToSave,
                timestamp: Date.now()
              });
              await showCustomAlert('æç¤º', 'æ”¶è—æˆåŠŸï¼');
            }
          }
          await updateSinglePostInDOM(postId);
        }
        return;
      }

      const sendBtn = target.closest('.comment-send-btn');
      if (sendBtn) {
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©ºå“¦ï¼');

        const post = qzonePostsCache.find(p => p.id === postId);
        if (!post) return;

        if (!post.comments) post.comments = [];

        const newComment = {
          commenterName: state.qzoneSettings.nickname,
          text: commentText,
          timestamp: Date.now(),
          replyTo: (currentQzoneReplyContext && currentQzoneReplyContext.postId === postId) ? currentQzoneReplyContext.replyToName : null
        };

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, {
          comments: post.comments
        });

        let postSummary = (post.publicText || post.content || '').substring(0, 30);
        const userNickname = state.qzoneSettings.nickname;
        const notifiedAiIds = new Set();
        if (post.authorId !== 'user') notifiedAiIds.add(post.authorId);
        if (newComment.replyTo && newComment.replyTo !== userNickname) {
          const repliedToChat = Object.values(state.chats).find(c => c.originalName === newComment.replyTo);
          if (repliedToChat) notifiedAiIds.add(repliedToChat.id);
        }
        for (const aiId of notifiedAiIds) {
          const chat = state.chats[aiId];
          if (chat && !chat.isGroup) {
            const stickerMatch = state.userStickers.find(s => s.url === commentText);
            let notificationText = stickerMatch ? `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå‘é€äº†ä¸€ä¸ªè¡¨æƒ…è¯„è®ºï¼Œæ„æ€æ˜¯ï¼šâ€œ${stickerMatch.name}â€ã€‚` :
              newComment.replyTo ? `ç”¨æˆ·'${userNickname}'åˆšåˆšåœ¨ä½ çš„åŠ¨æ€â€œ${postSummary}â€ä¸‹ï¼Œå›å¤äº†'${currentQzoneReplyContext.replyToDisplayName}'çš„è¯„è®ºï¼Œå†…å®¹æ˜¯ï¼šâ€œ${commentText}â€ã€‚` :
              `ç”¨æˆ·'${userNickname}'åˆšåˆšè¯„è®ºäº†ä½ çš„åŠ¨æ€â€œ${postSummary}â€ï¼Œå†…å®¹æ˜¯ï¼šâ€œ${commentText}â€ã€‚`;
            const historyMessage = {
              role: 'system',
              content: `[ç³»ç»Ÿæç¤ºï¼š${notificationText}è¯·ä½ å¯¹æ­¤ä½œå‡ºå›åº”ã€‚]`,
              timestamp: Date.now(),
              isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
          }
        }

        commentInput.value = '';
        clearQzoneReplyContext(postContainer);
        await updateSinglePostInDOM(postId);
        return;
      }
    }






    const handleSwipeStart = (e) => {
      const target = e.target;

      if (target.closest('.post-footer, .post-feedback-icons, .post-actions-btn, .post-comments-container, .reposted-content-wrapper')) {
        return;
      }
      const targetContainer = e.target.closest('.qzone-post-container');
      if (!targetContainer) return;

      resetAllSwipes(targetContainer);
      swipeState.activeContainer = targetContainer;
      swipeState.isDragging = true;
      swipeState.isClick = true;
      swipeState.swipeDirection = null;
      swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';


      document.addEventListener('mousemove', handleSwipeMove);
      document.addEventListener('mouseup', handleSwipeEnd);
      document.addEventListener('touchmove', handleSwipeMove, {
        passive: false
      });
      document.addEventListener('touchend', handleSwipeEnd);
    };


    const handleSwipeMove = (e) => {
      if (!swipeState.isDragging || !swipeState.activeContainer) return;

      const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      const diffX = currentX - swipeState.startX;
      const diffY = currentY - swipeState.startY;

      if (swipeState.isClick && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
        swipeState.isClick = false;
      }

      if (!swipeState.swipeDirection) {
        if (Math.abs(diffX) > Math.abs(diffY)) {
          swipeState.swipeDirection = 'horizontal';
        } else {
          swipeState.swipeDirection = 'vertical';
        }
      }

      if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = Math.min(0, Math.max(-90, diffX));
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
      }
    };


    const handleSwipeEnd = (e) => {

      document.removeEventListener('mousemove', handleSwipeMove);
      document.removeEventListener('mouseup', handleSwipeEnd);
      document.removeEventListener('touchmove', handleSwipeMove);
      document.removeEventListener('touchend', handleSwipeEnd);

      if (!swipeState.isDragging || !swipeState.activeContainer) return;

      const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
      postItem.style.transition = 'transform 0.3s ease';

      if (swipeState.swipeDirection === 'horizontal' && !swipeState.isClick) {
        const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
        const diffX = finalX - swipeState.startX;
        if (diffX < -40) {
          postItem.classList.add('swiped');
        } else {
          postItem.classList.remove('swiped');
        }
      }

      postItem.style.transform = '';


      swipeState.isDragging = false;
      swipeState.activeContainer = null;
      swipeState.swipeDirection = null;
      swipeState.isClick = true;
    };











    postsList.addEventListener('click', handlePostClick);
    postsList.addEventListener('mousedown', handleSwipeStart);
    postsList.addEventListener('touchstart', handleSwipeStart, {
      passive: true
    });



    postsList.addEventListener('click', (e) => {

      if (e.target && e.target.id === 'load-more-qzone-btn') {
        loadMoreQzonePosts();
      }
    });


    document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
      if (state.activeChatId) {
        summarizeExistingLongTermMemory(state.activeChatId);
      }
    });

    document.getElementById('api-preset-select').addEventListener('change', handlePresetSelectionChange);
    document.getElementById('save-api-preset-btn').addEventListener('click', saveApiPreset);
    document.getElementById('delete-api-preset-btn').addEventListener('click', deleteApiPreset);


    document.getElementById('add-world-book-entry-btn').addEventListener('click', () => {
      const container = document.getElementById('world-book-entries-container');

      if (container.querySelector('p')) {
        container.innerHTML = '';
      }
      const newBlock = createWorldBookEntryBlock();
      container.appendChild(newBlock);
      newBlock.querySelector('.entry-content-textarea').focus();
    });


    document.getElementById('switch-greeting-btn').addEventListener('click', handleSwitchGreeting);

    document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
      if (e.target && e.target.id === 'load-more-thoughts-btn') {
        loadMoreThoughts();
      }
    });




    document.getElementById('profile-history-icon-btn').addEventListener('click', showThoughtsHistory);

    document.getElementById('history-back-btn').addEventListener('click', hideThoughtsHistory);
    document.getElementById('character-profile-modal').addEventListener('click', (e) => {

      if (e.target.id === 'character-profile-modal') {
        e.target.classList.remove('visible');
      }
    });

    document.getElementById('manage-stickers-btn').addEventListener('click', toggleStickerManagementMode);
    document.getElementById('delete-selected-stickers-btn').addEventListener('click', executeBatchDeleteStickers);
    document.getElementById('export-selected-stickers-btn').addEventListener('click', executeBatchExportStickers);

    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
    document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));






    const searchInput = document.getElementById('favorites-search-input');
    const searchClearBtn = document.getElementById('favorites-search-clear-btn');

    searchInput.addEventListener('input', () => {
      const searchTerm = searchInput.value.trim().toLowerCase();


      searchClearBtn.style.display = searchTerm ? 'block' : 'none';

      if (!searchTerm) {
        displayFilteredFavorites(allFavoriteItems);
        return;
      }


      const filteredItems = allFavoriteItems.filter(item => {
        let contentToSearch = '';
        let authorToSearch = '';

        if (item.type === 'qzone_post') {
          const post = item.content;
          contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
          if (post.authorId === 'user') {
            authorToSearch = state.qzoneSettings.nickname;
          } else if (state.chats[post.authorId]) {
            authorToSearch = state.chats[post.authorId].name;
          }
        } else if (item.type === 'chat_message') {
          const msg = item.content;
          if (typeof msg.content === 'string') {
            contentToSearch = msg.content;
          }
          const chat = state.chats[item.chatId];
          if (chat) {
            if (msg.role === 'user') {
              authorToSearch = chat.isGroup ? (chat.settings.myNickname || 'æˆ‘') : 'æˆ‘';
            } else {
              authorToSearch = chat.isGroup ? msg.senderName : chat.name;
            }
          }
        }


        return contentToSearch.toLowerCase().includes(searchTerm) ||
          authorToSearch.toLowerCase().includes(searchTerm);
      });

      displayFilteredFavorites(filteredItems);
    });


    searchClearBtn.addEventListener('click', () => {
      searchInput.value = '';
      searchClearBtn.style.display = 'none';
      displayFilteredFavorites(allFavoriteItems);
      searchInput.focus();
    });







    document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      const favoritesToAdd = [];
      const timestampsToFavorite = [...selectedMessages];

      for (const timestamp of timestampsToFavorite) {

        const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();

        if (!existing) {
          const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
          if (messageToSave) {
            favoritesToAdd.push({
              type: 'chat_message',
              content: messageToSave,
              chatId: state.activeChatId,
              timestamp: Date.now(),
              originalTimestamp: messageToSave.timestamp
            });
          }
        }
      }

      if (favoritesToAdd.length > 0) {
        await db.favorites.bulkAdd(favoritesToAdd);
        allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
        await showCustomAlert('æ”¶è—æˆåŠŸ', `å·²æˆåŠŸæ”¶è— ${favoritesToAdd.length} æ¡æ¶ˆæ¯ã€‚`);
      } else {
        await showCustomAlert('æç¤º', 'é€‰ä¸­çš„æ¶ˆæ¯å‡å·²æ”¶è—è¿‡ã€‚');
      }

      exitSelectionMode();
    });


    const favoritesEditBtn = document.getElementById('favorites-edit-btn');
    const favoritesView = document.getElementById('favorites-view');
    const favoritesActionBar = document.getElementById('favorites-action-bar');
    const mainBottomNav = document.getElementById('chat-list-bottom-nav');
    const favoritesList = document.getElementById('favorites-list');

    favoritesEditBtn.addEventListener('click', () => {
      isFavoritesSelectionMode = !isFavoritesSelectionMode;
      favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

      if (isFavoritesSelectionMode) {

        favoritesEditBtn.textContent = 'å®Œæˆ';
        favoritesActionBar.style.display = 'block';
        mainBottomNav.style.display = 'none';
        favoritesList.style.paddingBottom = '80px';
      } else {

        favoritesEditBtn.textContent = 'ç¼–è¾‘';
        favoritesActionBar.style.display = 'none';
        mainBottomNav.style.display = 'flex';
        favoritesList.style.paddingBottom = '';


        selectedFavorites.clear();
        document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
        document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (0)`;
      }
    });



    document.getElementById('favorites-list').addEventListener('click', (e) => {
      const target = e.target;
      const card = target.closest('.favorite-item-card');


      if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("å›¾ç‰‡å†…å®¹", hiddenText.replace(/<br>/g, '\n'));
        return;
      }


      if (!isFavoritesSelectionMode) return;


      if (!card) return;

      const favId = parseInt(card.dataset.favid);
      if (isNaN(favId)) return;


      if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
      } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
      }


      document.getElementById('favorites-delete-selected-btn').textContent = `åˆ é™¤ (${selectedFavorites.size})`;
    });



    document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
      if (selectedFavorites.size === 0) return;

      const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        `ç¡®å®šè¦ä»æ”¶è—å¤¹ä¸­ç§»é™¤è¿™ ${selectedFavorites.size} æ¡å†…å®¹å—ï¼Ÿ`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('åˆ é™¤æˆåŠŸ', 'é€‰ä¸­çš„æ”¶è—å·²è¢«ç§»é™¤ã€‚');


        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));


        displayFilteredFavorites(allFavoriteItems);


        favoritesEditBtn.click();
      }
    });


    if (state.globalSettings.enableBackgroundActivity) {
      startBackgroundSimulation();
      console.log("åå°æ´»åŠ¨æ¨¡æ‹Ÿå·²è‡ªåŠ¨å¯åŠ¨ã€‚");
    }







    document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
      radio.addEventListener('change', updateSettingsPreview);
    });


    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.addEventListener('input', () => {

      document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;

      updateSettingsPreview();
    });


    const customCssInputForPreview = document.getElementById('custom-css-input');
    customCssInputForPreview.addEventListener('input', updateSettingsPreview);


    document.getElementById('reset-theme-btn').addEventListener('click', () => {
      document.getElementById('theme-default').checked = true;
      updateSettingsPreview();
    });

    document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
      document.getElementById('custom-css-input').value = '';
      updateSettingsPreview();
    });



    document.getElementById('lyrics-vertical-pos').addEventListener('change', updateSettingsPreview);
    document.getElementById('lyrics-horizontal-pos').addEventListener('change', updateSettingsPreview);
    document.getElementById('lyrics-offset-input').addEventListener('input', updateSettingsPreview);

    document.querySelectorAll('input[name="visibility"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
          groupsContainer.style.display = 'block';
        } else {
          groupsContainer.style.display = 'none';
        }
      });
    });



    document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
    document.getElementById('close-group-manager-btn').addEventListener('click', () => {
      document.getElementById('group-management-modal').classList.remove('visible');

      const chatSettingsBtn = document.getElementById('chat-settings-btn');
      if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
        chatSettingsBtn.click();
      }
    });

    document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
    document.getElementById('existing-groups-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
      }
    });




    document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);

    // ç¿»è¯‘æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('translate-message-btn').addEventListener('click', translateMessageContent);

    document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);

    document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);


    document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);



    document.getElementById('select-message-btn').addEventListener('click', () => {

      const timestampToSelect = activeMessageTimestamp;
      hideMessageActions();

      if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
      }
    });




    


    document.getElementById('transfer-action-accept').addEventListener('click', () => {
      // æ£€æŸ¥æ˜¯å¦åœ¨ My Phone ç¯å¢ƒä¸­
      if (activeMyPhoneTransferTimestamp !== null && typeof activeMyPhoneTransferTimestamp !== 'undefined') {
        handleMyPhoneTransferResponse('accepted');
      } else {
        handleUserTransferResponse('accepted');
      }
    });
    document.getElementById('transfer-action-decline').addEventListener('click', () => {
      // æ£€æŸ¥æ˜¯å¦åœ¨ My Phone ç¯å¢ƒä¸­
      if (activeMyPhoneTransferTimestamp !== null && typeof activeMyPhoneTransferTimestamp !== 'undefined') {
        handleMyPhoneTransferResponse('declined');
      } else {
        handleUserTransferResponse('declined');
      }
    });
    document.getElementById('transfer-action-cancel').addEventListener('click', () => {
      hideTransferActionModal();
      // æ¸…é™¤ My Phone è½¬è´¦çŠ¶æ€
      if (typeof activeMyPhoneTransferTimestamp !== 'undefined') {
        activeMyPhoneTransferTimestamp = null;
      }
    });





    document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
    document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
    document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);




    document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
      showScreen('chat-list-screen');
    });

    document.getElementById('contact-picker-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (!item) return;

      const contactId = item.dataset.contactId;
      item.classList.toggle('selected');

      if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
      } else {
        selectedContacts.add(contactId);
      }
      updateContactPickerConfirmButton();
    });


    document.getElementById('manage-members-btn').addEventListener('click', () => {



      openMemberManagementScreen();
    });



    document.getElementById('back-from-member-management').addEventListener('click', () => {

      showScreen('chat-interface-screen');
      document.getElementById('chat-settings-btn').click();
    });


    document.getElementById('member-management-list').addEventListener('click', (e) => {

      if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
      }
    });

    document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {


      const confirmBtn = document.getElementById('confirm-contact-picker-btn');

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

      await openContactPickerForAddMember();
    });

    document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);





    document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
    document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);


    document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);
    document.getElementById('minimize-call-btn').addEventListener('click', minimizeVideoCall);
    document.getElementById('video-call-restore-btn').addEventListener('click', restoreVideoCall);
   
    makeDraggable(document.getElementById('video-call-restore-btn'), document.getElementById('video-call-restore-btn'));

    document.getElementById('cancel-call-btn').addEventListener('click', () => {
      videoCallState.isAwaitingResponse = false;
      showScreen('chat-interface-screen');
    });


    document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);



    document.getElementById('decline-call-btn').addEventListener('click', async () => {
      hideIncomingCallModal();
      const chat = state.chats[videoCallState.activeChatId];
      if (!chat) return;


      if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false;


        const systemNote = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·æ‹’ç»äº†é€šè¯é‚€è¯·ï¼Œä½†ä½ ä»¬å¯ä»¥è‡ªå·±å¼€å§‹ã€‚è¯·ä½ ä»¬å„è‡ªå†³ç­–æ˜¯å¦åŠ å…¥ã€‚]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);



        await triggerAiResponse();

      } else {
        const declineMessage = {
          role: 'user',
          content: 'æˆ‘æ‹’ç»äº†ä½ çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚',
          timestamp: Date.now()
        };
        chat.history.push(declineMessage);
        await db.chats.put(chat);


        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);


        triggerAiResponse();
      }


      videoCallState.isAwaitingResponse = false;
    });




    document.getElementById('accept-call-btn').addEventListener('click', async () => {
      hideIncomingCallModal();

      videoCallState.initiator = 'ai';
      videoCallState.isUserParticipating = true;
      videoCallState.activeChatId = state.activeChatId;


      if (videoCallState.isGroupCall) {

        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {

          videoCallState.participants = [requester];
        } else {
          videoCallState.participants = [];
        }
      }


      startVideoCall();
    });





    document.getElementById('user-speak-btn').addEventListener('click', async () => {
      if (!videoCallState.isActive) return;


      const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
      if (userAvatar) {
        userAvatar.classList.add('speaking');
      }

      const userInput = await showCustomPrompt('ä½ è¯´', 'è¯·è¾“å…¥ä½ æƒ³è¯´çš„è¯...');


      if (userAvatar) {
        userAvatar.classList.remove('speaking');
      }

      if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
      }
    });




    document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {

      if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click();
      }
      switchToChatListView('memories-view');
      renderMemoriesScreen();
    });


    document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));




    document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
      const title = document.getElementById('countdown-title-input').value.trim();
      const dateValue = document.getElementById('countdown-date-input').value;

      if (!title || !dateValue) {
        alert('è¯·å¡«å†™å®Œæ•´çš„çº¦å®šæ ‡é¢˜å’Œæ—¥æœŸï¼');
        return;
      }

      const targetDate = new Date(dateValue);
      if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„ã€æœªæ¥çš„æ—¥æœŸï¼');
        return;
      }


      const newCountdown = {
        authorId: 'user',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
      };


      await db.memories.add(newCountdown);
      document.getElementById('create-countdown-modal').classList.remove('visible');
      renderMemoriesScreen();
    });


    document.getElementById('block-chat-btn').addEventListener('click', async () => {
      if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

      const chat = state.chats[state.activeChatId];
      const confirmed = await showCustomConfirm(
        'ç¡®è®¤æ‹‰é»‘',
        `ç¡®å®šè¦æ‹‰é»‘â€œ${chat.name}â€å—ï¼Ÿæ‹‰é»‘åæ‚¨å°†æ— æ³•å‘å…¶å‘é€æ¶ˆæ¯ï¼Œç›´åˆ°æ‚¨å°†Taç§»å‡ºé»‘åå•ï¼Œæˆ–ç­‰å¾…Taé‡æ–°ç”³è¯·å¥½å‹ã€‚`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();


        const hiddenMessage = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšè¢«ç”¨æˆ·æ‹‰é»‘äº†ã€‚åœ¨å¯¹æ–¹è§£é™¤æ‹‰é»‘ä¹‹å‰ï¼Œä½ æ— æ³•å†ä¸»åŠ¨å‘èµ·å¯¹è¯ï¼Œä¹Ÿæ— æ³•å›åº”ã€‚]`,
          timestamp: Date.now() + 1,
          isHidden: true
        };
        chat.history.push(hiddenMessage);


        await db.chats.put(chat);


        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);

        renderChatList();
      }
    });

    document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      if (e.target.id === 'force-apply-check-btn') {
        alert("æ­£åœ¨æ‰‹åŠ¨è§¦å‘å¥½å‹ç”³è¯·æµç¨‹ï¼Œè¯·ç¨å...\nå¦‚æœAPIè°ƒç”¨æˆåŠŸï¼Œå°†å¼¹å‡ºæç¤ºã€‚å¦‚æœå¤±è´¥ï¼Œä¹Ÿä¼šæœ‰é”™è¯¯æç¤ºã€‚å¦‚æœé•¿æ—¶é—´æ— ååº”ï¼Œè¯´æ˜AIå¯èƒ½å†³å®šæš‚æ—¶ä¸ç”³è¯·ã€‚");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id);
        return;
      }

      if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;


        const hiddenMessage = {
          role: 'system',
          content: `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·åˆšåˆšè§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ã€‚ç°åœ¨ä½ ä»¬å¯ä»¥é‡æ–°å¼€å§‹å¯¹è¯äº†ã€‚]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(hiddenMessage);


        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse();
      } else if (e.target.id === 'accept-friend-btn') {
        // ã€ä¿®å¤ã€‘1. å…ˆè·å–AIçš„ç”³è¯·ç†ç”±ï¼Œé˜²æ­¢è¢«æ¸…é™¤
        const applicationReason = chat.relationship.applicationReason || 'ï¼ˆå¯¹æ–¹æ²¡æœ‰ç•™ä¸‹ç†ç”±ï¼Œä½†æˆ‘ä»¬å’Œå¥½äº†ï¼‰'; 

        // 2. æ›´æ–°çŠ¶æ€
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = ''; // ç°åœ¨å¯ä»¥å®‰å…¨æ¸…ç©ºäº†

        // 3. (å¯é€‰) ä¿ç•™ç³»ç»Ÿæ¶ˆæ¯
        const systemMessage = {
          role: 'system',
          type: 'pat_message',
          content: `ä½ é€šè¿‡äº†â€œ${chat.name}â€çš„å¥½å‹è¯·æ±‚`,
          timestamp: Date.now()
        };
        chat.history.push(systemMessage);

        // 4. ã€æ ¸å¿ƒä¿®å¤ã€‘å°†AIçš„â€œç”³è¯·ç†ç”±â€ä½œä¸ºå®ƒçš„ç¬¬ä¸€æ¡æ¶ˆæ¯æ¨å…¥å†å²è®°å½•
        const applicationMessage = {
          role: 'assistant',
          senderName: chat.name,
          content: applicationReason, // <-- ä½¿ç”¨AIè‡ªå·±ç”Ÿæˆçš„ç†ç”±
          timestamp: Date.now() + 1
        };
        chat.history.push(applicationMessage);

        // 5. ä¿å­˜å¹¶åˆ·æ–°
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();

        // 6. (å¯é€‰) ç«‹å³è§¦å‘AIï¼Œè®©å®ƒå¯¹â€œè¢«æ¥å—â€è¿™ä»¶äº‹ä½œå‡ºå›åº”
       
      } else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
      } else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
          'å‘é€å¥½å‹ç”³è¯·',
          `è¯·è¾“å…¥ä½ æƒ³å¯¹â€œ${chat.name}â€è¯´çš„ç”³è¯·ç†ç”±ï¼š`,
          "æˆ‘ä»¬å’Œå¥½å§ï¼"
        );

        if (reason !== null) {

          chat.relationship.status = 'pending_ai_approval';
          chat.relationship.applicationReason = reason;
          await db.chats.put(chat);


          renderChatInterface(chat.id);
          renderChatList();


          triggerAiResponse();
        }
      }
    });




    document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);


    document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
      document.getElementById('red-packet-modal').classList.remove('visible');
    });
    document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
    document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);


    const rpTabGroup = document.getElementById('rp-tab-group');
    const rpTabDirect = document.getElementById('rp-tab-direct');
    const rpContentGroup = document.getElementById('rp-content-group');
    const rpContentDirect = document.getElementById('rp-content-direct');

    rpTabGroup.addEventListener('click', () => {
      rpTabGroup.classList.add('active');
      rpTabDirect.classList.remove('active');
      rpContentGroup.style.display = 'block';
      rpContentDirect.style.display = 'none';
    });
    rpTabDirect.addEventListener('click', () => {
      rpTabDirect.classList.add('active');
      rpTabGroup.classList.remove('active');
      rpContentDirect.style.display = 'block';
      rpContentGroup.style.display = 'none';
    });


    document.getElementById('rp-group-amount').addEventListener('input', (e) => {
      const amount = parseFloat(e.target.value) || 0;
      document.getElementById('rp-group-total').textContent = `Â¥ ${amount.toFixed(2)}`;
    });
    document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
      const amount = parseFloat(e.target.value) || 0;
      document.getElementById('rp-direct-total').textContent = `Â¥ ${amount.toFixed(2)}`;
    });




    




    document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);


    document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
    document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
      document.getElementById('create-poll-modal').classList.remove('visible');
    });
    document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);


    document.getElementById('chat-messages').addEventListener('click', (e) => {
      const pollCard = e.target.closest('.poll-card');
      if (!pollCard) return;

      const timestamp = parseInt(pollCard.dataset.pollTimestamp);
      if (isNaN(timestamp)) return;


      const optionItem = e.target.closest('.poll-option-item');
      if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
      }


      const actionBtn = e.target.closest('.poll-action-btn');
      if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
          showPollResults(timestamp);
        } else {
          endPoll(timestamp);
        }
        return;
      }


      if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
      }
    });



    document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);


    document.getElementById('add-ai-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('ai'));


    document.getElementById('add-group-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('group'));



    document.getElementById('add-ai-avatar-url-btn').addEventListener('click', addAvatarToLibraryFromURL);


    document.getElementById('add-ai-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('ai-avatar-upload-input').click();
    });


    document.getElementById('ai-avatar-upload-input').addEventListener('change', handleLocalAvatarUpload);

    document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);


    document.getElementById('manage-group-avatar-library-btn').addEventListener('click', openGroupAvatarLibraryModal);



    document.getElementById('add-group-avatar-url-btn').addEventListener('click', addAvatarToGroupLibraryFromURL);


    document.getElementById('add-group-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('group-avatar-upload-input').click();
    });


    document.getElementById('group-avatar-upload-input').addEventListener('change', handleLocalGroupAvatarUpload);


    document.getElementById('close-group-avatar-library-btn').addEventListener('click', closeGroupAvatarLibraryModal);



    document.getElementById('icon-settings-grid').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
          handleIconChange(iconId, 'ephone', item);
        }
      }
    });




    document.getElementById('chat-messages').addEventListener('click', (e) => {

      const linkCard = e.target.closest('.link-share-card');
      if (linkCard) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        if (!isNaN(timestamp)) {
          openBrowser(timestamp);
        }
      }
    });


    document.getElementById('browser-back-btn').addEventListener('click', () => {
      showScreen('chat-interface-screen');
    });



    qzoneStickerPanelState.panelEl.addEventListener('click', async (e) => {
      const stickerItem = e.target.closest('.sticker-item');
      if (stickerItem && qzoneStickerPanelState.activePostId !== null) {

        const stickerUrl = stickerItem.style.backgroundImage.slice(5, -2);


        const stickerObject = state.userStickers.find(s => s.url === stickerUrl);

        if (stickerObject) {

          await sendQzoneStickerComment(qzoneStickerPanelState.activePostId, stickerObject);
        } else {
          console.warn("åœ¨åŠ¨æ€è¯„è®ºåŒºç‚¹å‡»äº†è¡¨æƒ…ï¼Œä½†åœ¨è¡¨æƒ…åº“ä¸­æœªæ‰¾åˆ°å¯¹è±¡:", stickerUrl);
        }
      }
    });




    document.addEventListener('click', (e) => {
      if (qzoneStickerPanelState.isOpen &&
        !qzoneStickerPanelState.panelEl.contains(e.target) &&
        !e.target.closest('.comment-sticker-btn')) {
        closeQzoneStickerPanel();
      }
    });



    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);


    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
      document.getElementById('share-link-modal').classList.remove('visible');
    });


    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);



    document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
    document.getElementById('detach-status-bar-switch').addEventListener('change', (e) => {
      applyDetachStatusBarMode(e.target.checked);
    });
    document.getElementById('phone-frame-toggle-switch').addEventListener('change', (e) => {
      applyPhoneFrame(e.target.checked);
    });


    document.getElementById('share-location-btn').addEventListener('click', sendLocationShare);





    document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);


    document.getElementById('call-history-back-btn').addEventListener('click', () => {

      showScreen('chat-list-screen');
    });


    document.getElementById('call-history-list').addEventListener('click', (e) => {
      const card = e.target.closest('.call-record-card');
      if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
      }
    });


    document.getElementById('close-call-transcript-btn').addEventListener('click', () => {
      document.getElementById('call-transcript-modal').classList.remove('visible');
    });





    document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);


    document.getElementById('selection-share-btn').addEventListener('click', () => {
      if (selectedMessages.size > 0) {
        openShareTargetPicker();
      }
    });
    document.getElementById('selection-forward-btn').addEventListener('click', () => {
      if (selectedMessages.size > 0) {
        openForwardTargetPicker();
      }
    });
    document.getElementById('selection-screenshot-btn').addEventListener('click', handleLongScreenshot);

    document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
      const sourceChat = state.chats[state.activeChatId];
      const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
        .map(cb => cb.dataset.chatId);

      if (selectedTargetIds.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦åˆ†äº«çš„èŠå¤©ã€‚");
        return;
      }


      const sharedHistory = [];
      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
          sharedHistory.push(msg);
        }
      }


      const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || 'æˆ‘') : 'æˆ‘',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
          sourceChatName: sourceChat.name,
          title: `æ¥è‡ªâ€œ${sourceChat.name}â€çš„èŠå¤©è®°å½•`,
          sharedHistory: sharedHistory
        }
      };


      for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
          targetChat.history.push(shareCardMessage);
          await db.chats.put(targetChat);
        }
      }


      document.getElementById('share-target-modal').classList.remove('visible');
      exitSelectionMode();
      await showCustomAlert("åˆ†äº«æˆåŠŸ", `èŠå¤©è®°å½•å·²æˆåŠŸåˆ†äº«åˆ° ${selectedTargetIds.length} ä¸ªä¼šè¯ä¸­ã€‚`);
      renderChatList();
    });


    document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
      document.getElementById('share-target-modal').classList.remove('visible');
    });

    document.getElementById('confirm-forward-target-btn').addEventListener('click', async () => {
      const sourceChat = state.chats[state.activeChatId];
      const selectedTargetIds = Array.from(document.querySelectorAll('.forward-target-checkbox:checked'))
        .map(cb => cb.dataset.chatId);

      if (selectedTargetIds.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¦è½¬å‘çš„èŠå¤©ã€‚");
        return;
      }

      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      
      for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (!targetChat) continue;

        for (const timestamp of sortedTimestamps) {
          const msg = sourceChat.history.find(m => m.timestamp === timestamp);
          if (!msg) continue;

          const forwardedMessage = {
            role: 'user',
            senderName: targetChat.isGroup ? (targetChat.settings.myNickname || 'æˆ‘') : 'æˆ‘',
            content: msg.content,
            timestamp: Date.now() + sortedTimestamps.indexOf(timestamp),
          };

          if (msg.type) {
            forwardedMessage.type = msg.type;
            if (msg.type === 'voice_message') {
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'ai_image' || msg.type === 'naiimag') {
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'transfer') {
              forwardedMessage.amount = msg.amount;
              forwardedMessage.note = msg.note;
            } else if (msg.type === 'share_link') {
              forwardedMessage.title = msg.title;
              forwardedMessage.description = msg.description;
              forwardedMessage.source_name = msg.source_name;
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'red_packet') {
              forwardedMessage.totalAmount = msg.totalAmount;
              forwardedMessage.count = msg.count;
              forwardedMessage.message = msg.message;
              forwardedMessage.claimed = [];
            } else if (msg.type === 'location_share') {
              forwardedMessage.latitude = msg.latitude;
              forwardedMessage.longitude = msg.longitude;
              forwardedMessage.locationName = msg.locationName;
            }
          }

          targetChat.history.push(forwardedMessage);
        }

        await db.chats.put(targetChat);
      }

      document.getElementById('forward-target-modal').classList.remove('visible');
      exitSelectionMode();
      await showCustomAlert("è½¬å‘æˆåŠŸ", `æ¶ˆæ¯å·²æˆåŠŸè½¬å‘åˆ° ${selectedTargetIds.length} ä¸ªä¼šè¯ä¸­ã€‚`);
      renderChatList();
    });

    document.getElementById('cancel-forward-target-btn').addEventListener('click', () => {
      document.getElementById('forward-target-modal').classList.remove('visible');
    });


    document.getElementById('chat-messages').addEventListener('click', (e) => {



      const shareCard = e.target.closest('.link-share-card[data-timestamp]');
      if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
      }
    });


    document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
      document.getElementById('shared-history-viewer-modal').classList.remove('visible');
    });


    async function openSharedHistoryViewer(timestamp) {
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      const message = chat.history.find(m => m.timestamp === timestamp);

   

      if (!message) {
        console.error("æ— æ³•æ‰¾åˆ°åˆ†äº«è®°å½•:", timestamp);
        await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "æ— æ³•æ‰¾åˆ°å¯¹åº”çš„åˆ†äº«è®°å½•æˆ–è®°å½•å·²æŸåã€‚");
        return;
      }

   
      if (message.type === 'share_link') {
        openBrowser(timestamp);
        return; 
      }

    
      if (message.type === 'share_card') {
        if (!message.payload || !message.payload.sharedHistory) {
          console.error("èŠå¤©è®°å½•åˆ†äº«å¡ç‰‡æ•°æ®æŸå:", message);
          await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "åˆ†äº«çš„èŠå¤©è®°å½•å·²æŸåã€‚");
          return;
        }
      
      } else {
      
        console.error("æœªçŸ¥çš„åˆ†äº«å¡ç‰‡ç±»å‹:", message.type);
        await showCustomAlert("æŸ¥çœ‹å¤±è´¥", "ä¸æ”¯æŒçš„åˆ†äº«ç±»å‹ã€‚");
        return;
      }

      const viewerModal = document.getElementById('shared-history-viewer-modal');
      const viewerTitle = document.getElementById('shared-history-viewer-title');
      const viewerContent = document.getElementById('shared-history-viewer-content');

      viewerTitle.textContent = message.payload.title;
      viewerContent.innerHTML = '';

      const fragment = document.createDocumentFragment();
      const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;

      for (const sharedMsg of message.payload.sharedHistory) {
        const bubbleEl = await createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
          fragment.appendChild(bubbleEl);
        }
      }

      viewerContent.appendChild(fragment);
      viewerModal.classList.add('visible');
    }

    audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

    audioPlayer.addEventListener('pause', () => {
      if (musicState.isActive) {
        musicState.isPlaying = false;
        phoneScreenForIsland.classList.remove('dynamic-island-active');
        // --- æ–°å¢ï¼šæš‚åœæ—¶åœæ­¢æ—‹è½¬ ---
        document.getElementById('vinyl-view').classList.remove('spinning'); 
        updatePlayerUI();
      }
    });
    
    audioPlayer.addEventListener('play', () => {
      if (musicState.isActive) {
        musicState.isPlaying = true;
        // --- æ–°å¢ï¼šæ’­æ”¾æ—¶å¼€å§‹æ—‹è½¬ ---
        document.getElementById('vinyl-view').classList.add('spinning');
        updatePlayerUI();
      }
    });



    document.getElementById('playlist-body').addEventListener('click', async (e) => {
      const target = e.target;


      const albumArtBtn = target.closest('.album-art-btn');
      if (albumArtBtn) {
        const index = parseInt(albumArtBtn.dataset.index);
        if (!isNaN(index)) {

          await handleChangeAlbumArt(index);
        }
        return;
      }

      const lyricsBtn = target.closest('.lyrics-btn');
      if (lyricsBtn) {
        const index = parseInt(lyricsBtn.dataset.index);
        if (isNaN(index)) return;



        await handleManualLrcImport(index);

        return;
      }


      const deleteBtn = target.closest('.delete-track-btn');
      if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        if (isNaN(index)) return;
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('åˆ é™¤æ­Œæ›²', `ç¡®å®šè¦ä»æ’­æ”¾åˆ—è¡¨ä¸­åˆ é™¤ã€Š${track.name}ã€‹å—ï¼Ÿ`);
        if (confirmed) {
          deleteTrack(index);
        }
        return;
      }


      const itemInfo = target.closest('.playlist-item-info');
      if (itemInfo) {
        const item = itemInfo.closest('.playlist-item');
        const index = Array.from(item.parentElement.children).indexOf(item);
        if (index > -1) {
          playSong(index);
        }
      }
    });


    document.querySelector('.progress-bar').addEventListener('click', (e) => {
      if (!audioPlayer.duration) return;
      const progressBar = e.currentTarget;
      const barWidth = progressBar.clientWidth;
      const clickX = e.offsetX;
      audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
    });




    document.getElementById('chat-messages').addEventListener('click', (e) => {

     // ã€æ–°å¢/ä¿®æ”¹ã€‘ç‚¹å‡»é‚®ä»¶å¡ç‰‡æŸ¥çœ‹è¯¦æƒ… (å›ºå®šå¤§å°å¼¹çª—ç‰ˆ)
      const emailCard = e.target.closest('.email-share-card');
      if (emailCard) {
          const jsonStr = decodeURIComponent(emailCard.dataset.emailJson);
          try {
              const data = JSON.parse(jsonStr);
              
              // 1. è·å–æ¨¡æ€æ¡†ç›¸å…³å…ƒç´ 
              const overlay = document.getElementById('custom-modal-overlay');
              const modal = document.getElementById('custom-modal');
              const titleEl = document.getElementById('custom-modal-title');
              const bodyEl = document.getElementById('custom-modal-body');
              const footerEl = document.querySelector('#custom-modal .custom-modal-footer');

              // 2. ã€æ ¸å¿ƒæ­¥éª¤ã€‘ä¸´æ—¶ä¿®æ”¹æ¨¡æ€æ¡†æ ·å¼ (å›ºå®šå®½é«˜)
              modal.style.width = '320px';        // å®½åº¦åŠ å®½
              modal.style.height = '500px';       // é«˜åº¦å›ºå®š
              modal.style.maxHeight = '80vh';     // é˜²æ­¢è¶…å‡ºå±å¹•
              
              // 3. è°ƒæ•´ Body æ ·å¼ä»¥æ”¯æŒå†…éƒ¨æ»šåŠ¨
              bodyEl.style.flex = '1';            // æ’‘æ»¡å‰©ä½™ç©ºé—´
              bodyEl.style.overflowY = 'auto';    // å…è®¸å‚ç›´æ»šåŠ¨
              bodyEl.style.padding = '0';         // æ¸…é™¤é»˜è®¤å†…è¾¹è·ï¼Œç”±å†…éƒ¨å®¹å™¨æ§åˆ¶

              // 4. è®¾ç½®æ ‡é¢˜
              titleEl.textContent = "é‚®ä»¶è¯¦æƒ…";
              
              // 5. æ„é€ è¯¦æƒ… HTML (ä¼˜åŒ–å¸ƒå±€)
              const detailHtml = `
                  <div style="padding: 20px; min-height: 100%; box-sizing: border-box; text-align: left;"> <div style="border-bottom: 1px solid #eee; padding-bottom: 15px; margin-bottom: 15px;">
                          <div style="font-weight: 700; font-size: 18px; color: #111; line-height: 1.4; margin-bottom: 8px; word-break: break-word;">
                              ${escapeHTML(data.subject)}
                          </div>
                          <div style="display: flex; justify-content: space-between; align-items: center; color: #8a8a8a; font-size: 13px;">
                              <span><span style="color:#666;">å‘ä»¶äºº:</span> ${escapeHTML(data.sender)}</span>
                              <span>${data.date.split(' ')[0]}</span>
                          </div>
                      </div>
                      <div style="white-space: pre-wrap; color: #333; font-size: 15px; line-height: 1.8; font-family: -apple-system, sans-serif; letter-spacing: 0.5px;">${escapeHTML(data.fullContent)}</div>
                  </div>
              `;
              bodyEl.innerHTML = detailHtml;

              // 6. é‡å†™åº•éƒ¨æŒ‰é’® (ä»…æ˜¾ç¤ºä¸€ä¸ªå…³é—­æŒ‰é’®)
              footerEl.innerHTML = ''; // æ¸…ç©ºåŸæœ‰æŒ‰é’®
              const closeBtn = document.createElement('button');
              closeBtn.textContent = 'å…³é—­';
              closeBtn.style.cssText = 'width: 100%; border: none; background: transparent; color: var(--accent-color); font-weight: 600; padding: 15px; font-size: 16px; cursor: pointer;';
              
              // 7. ç»‘å®šå…³é—­äº‹ä»¶ (å…³é”®ï¼šå…³é—­æ—¶å¿…é¡»è¿˜åŸæ ·å¼ï¼)
              closeBtn.onclick = () => {
                  overlay.classList.remove('visible');
                  
                  // å»¶è¿Ÿè¿˜åŸæ ·å¼ï¼Œé˜²æ­¢è§†è§‰è·³åŠ¨
                  setTimeout(() => {
                      modal.style.width = '';       // è¿˜åŸå®½åº¦
                      modal.style.height = '';      // è¿˜åŸé«˜åº¦
                      modal.style.maxHeight = '';
                      bodyEl.style.flex = '';
                      bodyEl.style.overflowY = '';
                      bodyEl.style.padding = '';
                  }, 300);
              };
              footerEl.appendChild(closeBtn);

              // 8. æ˜¾ç¤ºå¼¹çª—
              overlay.classList.add('visible');

          } catch(err) {
              console.error("è§£æé‚®ä»¶æ•°æ®å¤±è´¥", err);
          }
          return; // é˜»æ­¢åç»­é€»è¾‘
      }
      const redditCard = e.target.closest('.reddit-share-card');
    if (redditCard) {
        const bubble = redditCard.closest('.message-bubble');
        if (bubble) {
            const timestamp = parseInt(bubble.dataset.timestamp);
            const chat = state.chats[state.activeChatId];
            // åœ¨å†å²è®°å½•ä¸­æ‰¾åˆ°è¿™æ¡æ¶ˆæ¯
            const msg = chat.history.find(m => m.timestamp === timestamp);
            
            if (msg && msg.type === 'reddit_share' && msg.redditData) {
                // è°ƒç”¨ä½ å†™å¥½çš„è¯¦æƒ…é¡µå‡½æ•°
                openRedditDetail(msg.redditData);
            }
        }
        return; 
    }
      const placeholder = e.target.closest('.recalled-message-placeholder');
      if (placeholder) {
        const chat = state.chats[state.activeChatId];
        const wrapper = placeholder.closest('.message-wrapper');
        if (chat && wrapper) {
          const timestamp = parseInt(wrapper.dataset.timestamp);
          const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

          if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;


            switch (recalled.originalType) {
              case 'text':
                originalContentText = `åŸæ–‡: "${recalled.originalContent}"`;
                break;
              case 'user_photo':
              case 'ai_image':
              case 'text_image':
                originalContentText = `[å›¾ç‰‡/æ–‡å­—å›¾] æè¿°: "${recalled.originalContent}"`;
                break;
              case 'voice_message':
                originalContentText = `[è¯­éŸ³] å†…å®¹: "${recalled.originalContent}"`;
                break;
              case 'sticker':

                originalContentText = `[è¡¨æƒ…] å«ä¹‰: "${recalled.originalMeaning || '(æ— )'}" \n URL: ${recalled.originalContent}`;
                break;
              case 'transfer':
                originalContentText = `ä¸€æ¡[è½¬è´¦]æ¶ˆæ¯å·²è¢«æ’¤å›ã€‚`;
                break;
              default:

                originalContentText = `æ’¤å›äº†ä¸€æ¡[${recalled.originalType}]ç±»å‹çš„æ¶ˆæ¯ã€‚\nå†…å®¹: ${JSON.stringify(recalled.originalContent)}`;
                break;
            }


            showCustomAlert('å·²æ’¤å›çš„æ¶ˆæ¯', originalContentText);
          }
        }
      }
    });




    document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
    document.getElementById('close-category-manager-btn').addEventListener('click', () => {
      document.getElementById('world-book-category-manager-modal').classList.remove('visible');
      renderWorldBookScreen();
    });
    document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
    document.getElementById('existing-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
      }
    });

    document.getElementById('repost-cancel-btn').addEventListener('click', hideRepostModal);
    document.getElementById('repost-confirm-btn').addEventListener('click', handleConfirmRepost);





    document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

    document.getElementById('forward-message-btn').addEventListener('click', () => {
      if (activeMessageTimestamp) {
        hideMessageActions();
        enterSelectionMode(activeMessageTimestamp);
      }
    });

    document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);










    document.getElementById('qzone-posts-list').addEventListener('input', (e) => {
      if (!e.target.matches('.comment-input')) return;

      const commentInput = e.target;
      const postContainer = commentInput.closest('.qzone-post-container');
      if (!postContainer) return;

      const popup = postContainer.querySelector('.at-mention-popup');
      const value = commentInput.value;
      const atMatch = value.match(/@([\p{L}\w]*)$/u);

      if (atMatch) {
        const namesToMention = new Set();
        const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
        if (authorNickname) namesToMention.add(authorNickname);
        postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
          namesToMention.add(nameEl.textContent.replace(':', ''));
        });
        namesToMention.delete(state.qzoneSettings.nickname);

        popup.innerHTML = '';
        if (namesToMention.size > 0) {
          const searchTerm = atMatch[1];
          namesToMention.forEach(name => {
            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
              const item = document.createElement('div');
              item.className = 'at-mention-item';
              item.textContent = name;
              item.addEventListener('mousedown', (evt) => {
                evt.preventDefault();
                const newText = value.substring(0, atMatch.index) + `@${name} `;
                commentInput.value = newText;
                popup.style.display = 'none';
                commentInput.focus();
              });
              popup.appendChild(item);
            }
          });
          popup.style.display = popup.children.length > 0 ? 'block' : 'none';
        } else {
          popup.style.display = 'none';
        }
      } else {
        popup.style.display = 'none';
      }
    });

    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
      if (e.target.matches('.comment-input')) {
        const postContainer = e.target.closest('.qzone-post-container');
        if (postContainer) {
          const popup = postContainer.querySelector('.at-mention-popup');
          if (popup) {
            setTimeout(() => {
              popup.style.display = 'none';
            }, 200);
          }
        }
      }
    });





    const chatInputForMention = document.getElementById('chat-input');
    const chatMentionPopup = document.getElementById('chat-at-mention-popup');

    chatInputForMention.addEventListener('input', () => {

      if (!state.activeChatId) {
        chatMentionPopup.style.display = 'none';
        return;
      }

      const chat = state.chats[state.activeChatId];
      const value = chatInputForMention.value;
      const atMatch = value.match(/@([\p{L}\w]*)$/u);

      if (atMatch) {
        const searchTerm = atMatch[1];
        
        // æ”¶é›†æ‰€æœ‰å¯ä»¥@çš„å¯¹è±¡ï¼ˆç¾¤æˆå‘˜ï¼‰
        let namesToMention = [];
        
        // å¦‚æœæ˜¯ç¾¤èŠï¼Œæ·»åŠ ç¾¤æˆå‘˜
        if (chat.isGroup) {
          const myNickname = chat.settings.myNickname || 'æˆ‘';
          const memberNames = chat.members
            .map(member => ({ name: member.groupNickname, type: 'member' }))
            .filter(item => item.name !== myNickname);
          namesToMention = namesToMention.concat(memberNames);
        }

        chatMentionPopup.innerHTML = '';
        
        if (namesToMention.length > 0) {
          // è¿‡æ»¤åŒ¹é…çš„åå­—
          const filteredNames = namesToMention.filter(item => 
            item.name.toLowerCase().includes(searchTerm.toLowerCase())
          );
          
          filteredNames.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'at-mention-item';
            menuItem.textContent = item.name;

            menuItem.addEventListener('mousedown', (e) => {
              e.preventDefault();
              const newText = value.substring(0, atMatch.index) + `@${item.name} `;
              chatInputForMention.value = newText;
              chatMentionPopup.style.display = 'none';
              chatInputForMention.focus();
            });
            chatMentionPopup.appendChild(menuItem);
          });

          chatMentionPopup.style.display = chatMentionPopup.children.length > 0 ? 'block' : 'none';
        } else {
          chatMentionPopup.style.display = 'none';
        }
      } else {
        chatMentionPopup.style.display = 'none';
      }
    });


    chatInputForMention.addEventListener('blur', () => {
      setTimeout(() => {
        chatMentionPopup.style.display = 'none';
      }, 200);
    });


    document.getElementById('publish-to-announcement-btn').addEventListener('click', publishToAnnouncementBoard);
    document.getElementById('show-announcement-board-btn').addEventListener('click', showAnnouncementBoard);
    document.getElementById('close-announcement-board-btn').addEventListener('click', () => {
      document.getElementById('announcement-board-modal').classList.remove('visible');
    });


    document.getElementById('announcement-board-content').addEventListener('click', (e) => {
      if (e.target.classList.contains('announcement-item-actions')) {
        const annoId = e.target.dataset.annoId;
        if (annoId) {
          showAnnouncementActions(annoId);
        }
      }
    });

    document.getElementById('announcement-action-pin').addEventListener('click', handlePinAnnouncement);
    document.getElementById('announcement-action-delete').addEventListener('click', handleDeleteAnnouncement);
    document.getElementById('announcement-action-cancel').addEventListener('click', () => {
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    });


    document.getElementById('reset-global-css-btn').addEventListener('click', () => {
      document.getElementById('global-css-input').value = '';


    });



    document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);


    document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
      showScreen('chat-interface-screen');
    });


    document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);


    document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);


    document.getElementById('memory-list-container').addEventListener('click', (e) => {
      const editBtn = e.target.closest('.edit-memory-btn');
      if (editBtn) {
        handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
        return;
      }
      const deleteBtn = e.target.closest('.delete-memory-btn');
      if (deleteBtn) {
        handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
        return;
      }
    });


    document.getElementById('gomoku-btn').addEventListener('click', toggleGomokuBoard);
    document.getElementById('close-gomoku-btn').addEventListener('click', closeGomokuBoard);

    const gomokuCanvas = document.getElementById('gomoku-board');
    gomokuCanvas.addEventListener('mousemove', handleBoardHover);
    gomokuCanvas.addEventListener('mouseout', () => renderGomokuBoard(state.activeChatId));
    gomokuCanvas.addEventListener('click', handleBoardClick);


    document.getElementById('add-countdown-btn').addEventListener('click', () => {

      document.getElementById('countdown-title-input').value = '';
      document.getElementById('countdown-date-input').value = '';

      document.getElementById('create-countdown-modal').classList.add('visible');
    });


    document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
      document.getElementById('create-countdown-modal').classList.remove('visible');
    });



    document.getElementById('edit-call-message-btn').addEventListener('click', openCallMessageEditor);
    document.getElementById('delete-call-message-btn').addEventListener('click', deleteCallMessage);
    document.getElementById('cancel-call-message-action-btn').addEventListener('click', hideCallMessageActions);


    document.getElementById('edit-last-response-btn').addEventListener('click', openAiResponseEditor);
    document.getElementById('cancel-ai-response-editor-btn').addEventListener('click', () => {
      document.getElementById('ai-response-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-ai-response-editor-btn').addEventListener('click', saveEditedAiResponse);
    document.getElementById('add-ai-response-block-btn').addEventListener('click', () => {

      const container = document.getElementById('ai-response-editor-container');
      const newBlock = createAiResponseEditorBlock('{\n  "type": "text",\n  "content": "åœ¨è¿™é‡Œè¾“å…¥æ–°æ¶ˆæ¯..."\n}');
      container.appendChild(newBlock);
      newBlock.querySelector('textarea').focus();
    });


    document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
    document.getElementById('close-my-avatar-library-btn').addEventListener('click', closeMyAvatarLibraryModal);
    document.getElementById('add-my-avatar-url-btn').addEventListener('click', addAvatarToMyLibraryFromURL);
    document.getElementById('add-my-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('my-avatar-upload-input').click();
    });
    document.getElementById('my-avatar-upload-input').addEventListener('change', handleLocalMyAvatarUpload);
    document.getElementById('add-my-avatar-batch-btn').addEventListener('click', async () => {
      const placeholderText = `è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç²˜è´´ï¼Œä¸€è¡Œä¸€ä¸ªï¼š\n\nç„¦è™‘ 2a9wte.jpeg\nå¤§æƒŠå¤±è‰² or8qf4.png\næ²¡æœ‰çµæ„Ÿ njwujh.jpeg`;
      const pastedText = await showCustomPrompt('æ‰¹é‡å¯¼å…¥å¤´åƒ', placeholderText, '', 'textarea');
      if (pastedText && pastedText.trim()) {
        await handleBatchImportForMyAvatar(pastedText);
      }
    });


    document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);
    document.getElementById('shopping-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
    document.getElementById('go-to-cart-btn').addEventListener('click', openCartScreen);
    document.getElementById('cart-back-btn').addEventListener('click', openShoppingScreen);
    document.getElementById('checkout-btn').addEventListener('click', handleCheckout);
    document.getElementById('close-receipt-btn').addEventListener('click', () => {
      document.getElementById('gift-receipt-modal').classList.remove('visible');
    });


    document.getElementById('manage-products-btn').addEventListener('click', () => {
      isProductManagementMode = !isProductManagementMode;
      const btn = document.getElementById('manage-products-btn');
      const actionBar = document.getElementById('shopping-action-bar');
      const gridEl = document.getElementById('product-grid');

      btn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';

      if (isProductManagementMode) {
        actionBar.style.display = 'flex';
        gridEl.style.paddingBottom = '80px';
      } else {
        actionBar.style.display = 'none';
        gridEl.style.paddingBottom = '';

        selectedProducts.clear();
        document.querySelectorAll('.product-item.selected').forEach(item => item.classList.remove('selected'));
        document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (0)`;
        document.getElementById('select-all-products-checkbox').checked = false;
      }


      renderShoppingProducts();
      updateDeleteCategoryButtonVisibility();
    });


    document.getElementById('add-new-product-btn').addEventListener('click', () => {
      if (isProductManagementMode) {
        openProductEditor(null);
      } else {
        alert("è¯·å…ˆç‚¹å‡»æ‰³æ‰‹å›¾æ ‡è¿›å…¥ç®¡ç†æ¨¡å¼ï¼Œæ‰èƒ½æ·»åŠ æ–°å•†å“ã€‚");
      }
    });



    document.getElementById('product-grid').addEventListener('click', async e => {
      const productItem = e.target.closest('.product-item');
      if (!productItem) return;
      const productId = parseInt(productItem.dataset.id);
      if (isNaN(productId)) return;


      if (isProductManagementMode) {

        if (e.target.classList.contains('edit-product-btn')) {
          openProductEditor(productId);
          return;
        }

        if (e.target.classList.contains('delete-product-btn')) {
          const product = await db.shoppingProducts.get(productId);
          if (!product) return;
          const confirmed = await showCustomConfirm('åˆ é™¤å•†å“', `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤å•†å“ â€œ${product.name}â€ å—ï¼Ÿ`, {
            confirmButtonClass: 'btn-danger'
          });
          if (confirmed) {
            await db.shoppingProducts.delete(productId);
            await renderShoppingProducts();
            alert("å•†å“å·²åˆ é™¤ã€‚");
          }
          return;
        }


        productItem.classList.toggle('selected');
        if (selectedProducts.has(productId)) {
          selectedProducts.delete(productId);
        } else {
          selectedProducts.add(productId);
        }
        document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (${selectedProducts.size})`;
        return;
      }


      if (e.target.classList.contains('add-to-cart-btn')) {
        const product = await db.shoppingProducts.get(productId);
        if (product.variations && product.variations.length > 0) {
          openVariationSelector(productId);
        } else {
          await addToCart(productId);
          await showCustomAlert('æˆåŠŸ', 'å·²æˆåŠŸåŠ å…¥è´­ç‰©è½¦ï¼');
        }
        return;
      }


      if (productItem.contains(e.target)) {
        console.log(`ç‚¹å‡»äº†å•†å“å¡ç‰‡: ${productId}`);
      }
    });



    document.getElementById('cart-items-list').addEventListener('click', e => {
      const target = e.target;
      if (target.classList.contains('decrease-qty-btn')) {
        updateCartItemQuantity(parseInt(target.dataset.id), -1);
      }
      if (target.classList.contains('increase-qty-btn')) {
        updateCartItemQuantity(parseInt(target.dataset.id), 1);
      }
      if (target.classList.contains('cart-item-checkbox')) {
        updateCartTotal();
      }
    });


    document.getElementById('clear-cart-btn').addEventListener('click', async () => {
      if (shoppingCart.length === 0) return;
      const confirmed = await showCustomConfirm('æ¸…ç©ºè´­ç‰©è½¦', 'ç¡®å®šè¦æ¸…ç©ºè´­ç‰©è½¦ä¸­çš„æ‰€æœ‰å•†å“å—ï¼Ÿ');
      if (confirmed) {
        shoppingCart = [];
        updateCartCount();
        renderCartItems();
      }
    });


    document.getElementById('select-all-cart-items').addEventListener('change', function(e) {
      document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
      });
      updateCartTotal();
    });


    document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
      document.getElementById('product-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-product-btn').addEventListener('click', saveProduct);
    document.getElementById('product-image-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (re) => {
          document.getElementById('product-image-preview').src = re.target.result;
        };
        reader.readAsDataURL(file);
      }
    });


    document.getElementById('chat-messages').addEventListener('click', e => {
      const giftCard = e.target.closest('.gift-card');
      if (giftCard) {
        const bubble = giftCard.closest('.message-bubble');
        if (bubble) {
          showGiftReceipt(parseInt(bubble.dataset.timestamp));
        }
      }
    });


    document.getElementById('cancel-gift-recipient-btn').addEventListener('click', () => {
      document.getElementById('gift-recipient-modal').classList.remove('visible');
    });


    document.getElementById('confirm-gift-recipient-btn').addEventListener('click', async () => {

      const selectedRecipients = Array.from(document.querySelectorAll('#gift-recipient-list .contact-picker-item.selected'))
        .map(item => item.dataset.recipientName);

      if (selectedRecipients.length === 0) {
        alert("è¯·è‡³å°‘é€‰æ‹©ä¸€ä½æ”¶ç¤¼äººã€‚");
        return;
      }


      const selectedItems = shoppingCart.filter(item =>
        document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
      );


      await sendGiftMessage(selectedItems, selectedRecipients);


      document.getElementById('gift-recipient-modal').classList.remove('visible');
    });


    document.getElementById('gift-recipient-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (item) {
        item.classList.toggle('selected');
      }
    });

    document.getElementById('select-all-recipients').addEventListener('change', function(e) {
      const isChecked = e.target.checked;
      document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
        item.classList.toggle('selected', isChecked);
      });
    });


    document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);
    document.getElementById('regenerate-call-btn').addEventListener('click', handleRegenerateCallResponse);


    document.getElementById('propel-btn').addEventListener('click', handlePropelAction);






    document.getElementById('test-sound-btn').addEventListener('click', () => {
      const player = document.getElementById('notification-sound-player');
      const url = document.getElementById('notification-sound-url-input').value.trim() || DEFAULT_NOTIFICATION_SOUND;
      player.src = url;
      player.play().catch(e => alert('æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®æˆ–æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯¥æ ¼å¼ã€‚'));
    });

    document.getElementById('reset-sound-btn').addEventListener('click', () => {
      document.getElementById('notification-sound-url-input').value = '';
      alert('å·²é‡ç½®ä¸ºé»˜è®¤æç¤ºéŸ³ï¼Œç‚¹å‡»â€œä¿å­˜æ‰€æœ‰å¤–è§‚è®¾ç½®â€åç”Ÿæ•ˆã€‚');
    });

    document.getElementById('home-screen').addEventListener('click', (e) => {
      const target = e.target;

      if (target.classList.contains('editable-text')) {
        handleEditText(target);
      }

      if (target.classList.contains('editable-image')) {
        handleEditImage(target);
      }
    });

    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });


    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });


    document.getElementById('select-all-music-search').addEventListener('change', function(e) {
      document.querySelectorAll('#search-results-list .music-search-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
      });
    });


    document.getElementById('search-results-list').addEventListener('click', (e) => {
      const item = e.target.closest('.search-result-item');
      if (item) {
        const checkbox = item.querySelector('.music-search-checkbox');
        if (checkbox) {

          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
          }
        }
      }
    });


    document.getElementById('add-selected-music-btn').addEventListener('click', async () => {
      const selectedItems = document.querySelectorAll('.music-search-checkbox:checked');
      if (selectedItems.length === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦æ·»åŠ çš„æ­Œæ›²ã€‚");
        return;
      }

      document.getElementById('music-search-results-modal').classList.remove('visible');
      await showCustomAlert("è¯·ç¨å€™...", `æ­£åœ¨æ‰¹é‡æ·»åŠ  ${selectedItems.length} é¦–æ­Œæ›²...`);

      const songDataList = Array.from(selectedItems).map(cb => JSON.parse(cb.closest('.search-result-item').dataset.songJson));

      let successCount = 0;
      let failedNames = [];


      const songDetailPromises = songDataList.map(songData => getPlayableSongDetails(songData));
      const fullSongObjects = await Promise.all(songDetailPromises);

      fullSongObjects.forEach((songObject, index) => {
        if (songObject) {
          musicState.playlist.push(songObject);
          successCount++;
        } else {
          failedNames.push(songDataList[index].name);
        }
      });

      if (successCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
          musicState.currentIndex = musicState.playlist.length - successCount;
          updatePlayerUI();
        }
      }

      let resultMessage = `æ·»åŠ å®Œæˆï¼\n\næˆåŠŸæ·»åŠ  ${successCount} é¦–æ­Œæ›²ã€‚`;
      if (failedNames.length > 0) {
        resultMessage += `\n\n${failedNames.length} é¦–æ­Œæ›²è·å–å¤±è´¥:\n- ${failedNames.join('\n- ')}`;
      }
      await showCustomAlert("æ“ä½œç»“æœ", resultMessage);
    });



    document.getElementById('music-visual-container').addEventListener('click', () => {
      document.getElementById('music-visual-container').classList.toggle('lyrics-active');
    });



    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);
    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });

    document.getElementById('search-results-list').addEventListener('click', (e) => {
      const item = e.target.closest('.search-result-item');
      if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
      }
    });



    document.getElementById('cleanup-songs-btn').addEventListener('click', cleanupInvalidSongs);
    document.getElementById('toggle-blur-btn').addEventListener('click', toggleBackgroundBlur);
    document.getElementById('toggle-fullscreen-btn').addEventListener('click', togglePlayerFullscreen);
    document.getElementById('show-avatars-btn').addEventListener('click', toggleMusicPlayerAvatars);

    // è¢«æ¸…ç†æ­Œæ›²æ¨¡æ€æ¡†äº‹ä»¶
    document.getElementById('select-all-cleaned-songs').addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('.cleaned-song-checkbox');
      checkboxes.forEach(cb => cb.checked = e.target.checked);
    });
    document.getElementById('close-cleaned-songs-btn').addEventListener('click', () => {
      document.getElementById('cleaned-songs-modal').classList.remove('visible');
    });
    document.getElementById('research-selected-songs-btn').addEventListener('click', handleResearchSelectedSongs);


    document.getElementById('status-bar-toggle-switch').addEventListener('change', () => {

      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
      applyStatusBarVisibility();
    });


    document.getElementById('qzone-more-actions-btn').addEventListener('click', openClearPostsSelectorModal);


    document.getElementById('cancel-clear-posts-btn').addEventListener('click', () => {
      document.getElementById('clear-posts-modal').classList.remove('visible');
    });
    document.getElementById('confirm-clear-posts-btn').addEventListener('click', handleConfirmClearPosts);


    document.getElementById('clear-posts-list').addEventListener('click', (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
      }
    });

    document.getElementById('global-bg-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });

        // 1. ç«‹å³ä¿å­˜å’Œæ˜¾ç¤º
        state.globalSettings.globalChatBackground = dataUrl;
        renderWallpaperScreen();
        await showCustomAlert("æˆåŠŸ", "å…¨å±€èŠå¤©èƒŒæ™¯å·²æ›´æ–°ï¼\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ... (ä¿å­˜è®¾ç½®åç”Ÿæ•ˆ)");

        // 2. å¯åŠ¨é™é»˜ä¸Šä¼ 
        (async () => {
            await silentlyUpdateDbUrl(
                db.globalSettings,
                'main',
                'globalChatBackground',
                dataUrl
            );
        })();
      }
      event.target.value = null;
    });

    document.getElementById('remove-global-bg-btn').addEventListener('click', () => {

      state.globalSettings.globalChatBackground = '';
      renderWallpaperScreen();
    });


    document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {

      if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
      }



      state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
      state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
      state.globalSettings.showSeconds = document.getElementById('global-show-seconds-switch').checked;
      state.globalSettings.lockScreenEnabled = document.getElementById('lock-screen-toggle').checked;
      state.globalSettings.lockScreenPassword = document.getElementById('lock-screen-password-input').value.trim();
      
      const lockPreview = document.getElementById('lock-wallpaper-preview');
      if (lockPreview.dataset.tempUrl) {
          state.globalSettings.lockScreenWallpaper = lockPreview.dataset.tempUrl;
      }

      await db.globalSettings.put(state.globalSettings);


      applyGlobalWallpaper();
      newWallpaperBase64 = null;
      applyAppIcons();
      applyCPhoneAppIcons();
      applyMyPhoneAppIconsGlobal();
      applyGlobalCss(state.globalSettings.globalCss);
      applyStatusBarVisibility();
      initLockScreen();
      alert('å¤–è§‚è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼');
      showScreen('home-screen');
    });


    document.getElementById('upload-global-bg-url-btn').addEventListener('click', async () => {

      const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡", "è¯·è¾“å…¥èƒŒæ™¯å›¾ç‰‡çš„URL", "", "url");


      if (url && url.trim()) {

        state.globalSettings.globalChatBackground = url.trim();


        renderWallpaperScreen();
      } else if (url !== null) {

        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
      }
    });

    document.getElementById('upload-ephone-bg-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡ (EPhone)", "è¯·è¾“å…¥EPhoneä¸»å±å¹•çš„èƒŒæ™¯å›¾ç‰‡URL", "", "url");
      if (url && url.trim()) {

        newWallpaperBase64 = url.trim();

        renderWallpaperScreen();
      } else if (url !== null) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
      }
    });


    document.getElementById('upload-cphone-bg-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("ç½‘ç»œå›¾ç‰‡ (CPhone)", "è¯·è¾“å…¥CPhoneçš„èƒŒæ™¯å›¾ç‰‡URL", "", "url");
      if (url && url.trim()) {

        state.globalSettings.cphoneWallpaper = url.trim();

        renderWallpaperScreen();
      } else if (url !== null) {
        alert("è¯·è¾“å…¥æœ‰æ•ˆçš„URLã€‚");
      }
    });



    document.getElementById('remove-ephone-bg-btn').addEventListener('click', () => {

      newWallpaperBase64 = null;
      state.globalSettings.wallpaper = '';

      renderWallpaperScreen();
    });


    document.getElementById('remove-cphone-bg-btn').addEventListener('click', () => {

      state.globalSettings.cphoneWallpaper = '';

      renderWallpaperScreen();
    });



    document.getElementById('css-preset-select').addEventListener('change', handleCssPresetSelectionChange);
    document.getElementById('save-css-preset-btn').addEventListener('click', saveCssPreset);
    document.getElementById('delete-css-preset-btn').addEventListener('click', deleteCssPreset);


    document.getElementById('font-preset-select').addEventListener('change', handleFontPresetSelectionChange);
    document.getElementById('save-font-preset-btn').addEventListener('click', saveFontPreset);
    document.getElementById('delete-font-preset-btn').addEventListener('click', deleteFontPreset);


    document.getElementById('theme-preset-select').addEventListener('change', handleThemePresetSelectionChange);
    document.getElementById('save-theme-preset-btn').addEventListener('click', saveThemePreset);
    document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteThemePreset);




    document.getElementById('manage-sticker-categories-btn').addEventListener('click', openStickerCategoryManager);


    document.getElementById('close-sticker-category-manager-btn').addEventListener('click', () => {
      document.getElementById('sticker-category-manager-modal').classList.remove('visible');
      renderStickerPanel();
    });


    document.getElementById('add-new-sticker-category-btn').addEventListener('click', addNewStickerCategory);


    document.getElementById('existing-sticker-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteStickerCategory(categoryId);
      }
    });


    document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;

        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
        switchStickerCategory(finalId);
      }
    });


    document.getElementById('select-all-stickers-checkbox').addEventListener('change', handleSelectAllStickers);

    document.getElementById('export-single-chat-btn').addEventListener('click', exportSingleChat);

    document.getElementById('import-single-chat-btn').addEventListener('click', () => {
      document.getElementById('import-single-chat-input').click();
    });

    document.getElementById('import-single-chat-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importSingleChat(file);
      }
      e.target.value = null;
    });


    document.getElementById('add-char-memo-btn').addEventListener('click', () => openMemoEditor());
    document.getElementById('add-char-diary-btn').addEventListener('click', () => openDiaryEditor());
    document.getElementById('favorite-diary-btn').addEventListener('click', toggleDiaryFavorite);
    document.getElementById('favorite-article-btn').addEventListener('click', toggleBrowserArticleFavorite);
    document.getElementById('favorite-memo-btn').addEventListener('click', toggleMemoFavorite);
    document.getElementById('copy-diary-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-diary-detail-content').innerText; // Use innerText to get formatted text
      copyTextToClipboard(content, 'æ—¥è®°å†…å®¹å·²å¤åˆ¶ï¼');
    });

    document.getElementById('copy-memo-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-memo-detail-content').value; // It's a textarea
      copyTextToClipboard(content, 'å¤‡å¿˜å½•å†…å®¹å·²å¤åˆ¶ï¼');
    });

    document.getElementById('copy-article-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-article-content').innerText;
      copyTextToClipboard(content, 'æ–‡ç« å†…å®¹å·²å¤åˆ¶ï¼');
    });


    document.getElementById('regenerate-char-qq-btn').addEventListener('click', async () => {

      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæ–°çš„æ¨¡æ‹ŸèŠå¤©è®°å½•ï¼Œå¹¶åŒæ—¶è®©è§’è‰²æ€è€ƒå¦‚ä½•ä¸ä½ ç»§ç»­å¯¹è¯...");

      try {

        await Promise.all([
          handleGenerateSimulatedQQ(),
          handleContinueRealConversationFromCPhone()
        ]);

        console.log("CPhone QQæ¨¡æ‹Ÿè®°å½•ç”Ÿæˆ å’Œ ä¸»èŠå¤©æ¨è¿› å·²åŒæ—¶å®Œæˆã€‚");

      } catch (error) {
        console.error("åœ¨åŒæ—¶æ‰§è¡Œä¸¤ä¸ªå‡½æ•°æ—¶å‡ºé”™:", error);
        await showCustomAlert("æ“ä½œå¤±è´¥", `åœ¨æ‰§è¡Œç»„åˆæ“ä½œæ—¶é‡åˆ°é”™è¯¯: ${error.message}`);
      }
    });


    document.getElementById('char-chat-list').addEventListener('click', (e) => {
      const item = e.target.closest('.chat-list-item');
      if (item && item.dataset.conversationIndex) {
        const index = parseInt(item.dataset.conversationIndex);
        if (!isNaN(index)) {

          openCharSimulatedConversation(index);
        }
      }
    });



    document.getElementById('back-to-char-qq-list-btn').addEventListener('click', () => {
      switchToCharScreen('char-qq-screen');
    });



    const charConversationMessages = document.getElementById('char-conversation-messages');


    const cphoneScrollHandler = () => {

      if (cphoneActiveConversationType !== 'private_user') {
        return;
      }


      if (charConversationMessages.scrollTop < 1 && !isLoadingMoreCphoneMessages) {
        const totalMessages = state.chats[activeCharacterId]?.history.length || 0;

        if (totalMessages > cphoneRenderedCount) {

          loadMoreMirroredMessages();
        }
      }
    };


    charConversationMessages.addEventListener('scroll', cphoneScrollHandler);



    document.getElementById('char-simulated-send-btn').addEventListener('click', () => {
      alert("è¿™æ˜¯æ¨¡æ‹Ÿå¯¹è¯ï¼Œæ— æ³•å‘é€æ¶ˆæ¯å“¦~");
    });



    document.getElementById('regenerate-char-album-btn').addEventListener('click', handleGenerateSimulatedAlbum);


    document.getElementById('char-album-grid').addEventListener('click', (e) => {

      const photoItem = e.target.closest('.char-photo-item');


      if (photoItem && photoItem.dataset.description) {
        const description = photoItem.dataset.description;


        showCustomAlert("ç…§ç‰‡è¯¦æƒ…", description.replace(/\n/g, '<br>'));
      }
    });
    document.getElementById('regenerate-char-browser-btn').addEventListener('click', handleGenerateBrowserHistory);

    document.getElementById('regenerate-char-taobao-btn').addEventListener('click', handleGenerateTaobaoHistory);



    document.getElementById('char-product-grid').addEventListener('click', (e) => {
      const item = e.target.closest('.char-product-item');
      if (item && item.dataset.reason) {
        const reason = item.dataset.reason;
        showCustomAlert("TAçš„æƒ³æ³•...", reason.replace(/\n/g, '<br>'));
      }
    });


    window.openCharWallet = openCharWallet;
    document.getElementById('regenerate-char-memo-btn').addEventListener('click', handleGenerateSimulatedMemos);
    document.getElementById('char-memo-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-memo-screen'));

    document.getElementById('regenerate-char-diary-btn').addEventListener('click', handleGenerateSimulatedDiaries);
    document.getElementById('add-char-diary-btn').addEventListener('click', handleWriteNewDiaryEntry);
    document.getElementById('char-diary-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-diary-screen'));
    document.getElementById('regenerate-char-amap-btn').addEventListener('click', handleGenerateAmapHistory);
    document.getElementById('regenerate-char-usage-btn').addEventListener('click', handleGenerateAppUsage);
    document.getElementById('regenerate-char-music-btn').addEventListener('click', handleGenerateSimulatedMusic);
    document.getElementById('close-char-music-player-btn').addEventListener('click', closeCharMusicPlayer);
    document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
    document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
    
    // MY Phone é‡æ–°ç”ŸæˆæŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('regenerate-myphone-qq-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„æ¨¡æ‹ŸèŠå¤©è®°å½•...");
      try {
        await handleGenerateMyPhoneQQ();
        renderMyPhoneSimulatedQQ();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„QQèŠå¤©è®°å½•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    // MY Phone QQ æ·»åŠ æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('add-myphone-qq-btn')?.addEventListener('click', () => {
      showMyPhoneAddContactDialog();
    });
    
    // MY Phone æ·»åŠ è”ç³»äººé€‰æ‹©å¼¹çª—æŒ‰é’®
    document.getElementById('myphone-manual-create-btn')?.addEventListener('click', () => {
      manualCreateMyPhoneContact();
    });
    
    document.getElementById('myphone-import-from-main-btn')?.addEventListener('click', () => {
      showImportMainScreenCharacters();
    });
    
    document.getElementById('cancel-myphone-add-choice-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-choice-modal')?.classList.remove('visible');
    });
    
    // MY Phone å¯¼å…¥è§’è‰²å¼¹çª—æŒ‰é’®
    document.getElementById('select-all-myphone-import')?.addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      document.querySelectorAll('.myphone-import-checkbox').forEach(cb => {
        cb.checked = isChecked;
      });
    });
    
    document.getElementById('confirm-myphone-import-btn')?.addEventListener('click', () => {
      importSelectedCharacters();
    });
    
    document.getElementById('cancel-myphone-import-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-import-characters-modal')?.classList.remove('visible');
    });
    
    // MY Phone è”ç³»äººè®¾ç½®æŒ‰é’®
    document.getElementById('myphone-conversation-settings-btn')?.addEventListener('click', () => {
      openMyPhoneContactSettings();
    });
    
    // MY Phone è®¾ç½®ç•Œé¢æŒ‰é’®
    document.getElementById('back-to-myphone-conversation-btn')?.addEventListener('click', async () => {
      const index = window.currentMyPhoneConversationIndex;
      if (index !== undefined) {
        await openMyPhoneConversation(index);
      }
    });
    
    document.getElementById('myphone-change-avatar-btn')?.addEventListener('click', () => {
      changeMyPhoneContactAvatar();
    });
    
    document.getElementById('myphone-save-contact-settings-btn')?.addEventListener('click', () => {
      saveMyPhoneContactSettings();
    });
    
    document.getElementById('myphone-add-message-btn')?.addEventListener('click', () => {
      addMyPhoneMessage();
    });
    
    // MyPhone é”å±è®¾ç½®äº‹ä»¶ç›‘å¬
    document.getElementById('myphone-lock-screen-toggle')?.addEventListener('change', async (e) => {
      if (!activeMyPhoneCharacterId) return;
      const char = state.chats[activeMyPhoneCharacterId];
      if (!char) return;
      
      const detail = document.getElementById('myphone-lock-screen-settings-detail');
      if (detail) {
        detail.style.display = e.target.checked ? 'block' : 'none';
      }
      
      char.settings.myPhoneLockScreenEnabled = e.target.checked;
      await db.chats.put(char);
    });
    
    document.getElementById('myphone-lock-screen-password-input')?.addEventListener('change', async (e) => {
      if (!activeMyPhoneCharacterId) return;
      const char = state.chats[activeMyPhoneCharacterId];
      if (!char) return;
      
      const password = e.target.value.trim();
      if (password && password.length !== 4) {
        showCustomAlert('æç¤º', 'å¯†ç å¿…é¡»æ˜¯4ä½æ•°å­—');
        e.target.value = char.settings.myPhoneLockScreenPassword || '';
        return;
      }
      
      if (password && !/^\d{4}$/.test(password)) {
        showCustomAlert('æç¤º', 'å¯†ç å¿…é¡»æ˜¯4ä½æ•°å­—');
        e.target.value = char.settings.myPhoneLockScreenPassword || '';
        return;
      }
      
      char.settings.myPhoneLockScreenPassword = password;
      await db.chats.put(char);
      
      if (password) {
        showCustomAlert('æˆåŠŸ', 'é”å±å¯†ç å·²è®¾ç½®');
      }
    });
    
    // MY Phone QQ å¯¹è¯æ¶ˆæ¯ç‚¹å‡»äº‹ä»¶ç›‘å¬ï¼ˆå›¾ç‰‡ã€è¯­éŸ³ã€è½¬è´¦ï¼‰
    document.getElementById('myphone-conversation-messages')?.addEventListener('click', async (e) => {
      // 1. å¤„ç† AI ç”Ÿæˆçš„å›¾ç‰‡ç‚¹å‡» - æ˜¾ç¤ºæè¿°
      const aiImage = e.target.closest('.ai-generated-image');
      if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) {
          showCustomAlert('ç…§ç‰‡æè¿°', description);
        }
        return;
      }
      
      // 2. å¤„ç†è¯­éŸ³æ¶ˆæ¯ç‚¹å‡» - æ˜¾ç¤º/éšè—æ–‡å­—
      const voiceBody = e.target.closest('.voice-message-body[data-text]');
      if (voiceBody) {
        const bubble = voiceBody.closest('.message-bubble');
        if (!bubble) return;
        
        const transcriptEl = bubble.querySelector('.voice-transcript');
        const text = decodeURIComponent(voiceBody.dataset.text);
        
        if (transcriptEl.style.display === 'block') {
          // éšè—æ–‡å­—
          transcriptEl.style.display = 'none';
        } else {
          // æ˜¾ç¤ºæ–‡å­—
          transcriptEl.textContent = text;
          transcriptEl.style.display = 'block';
        }
        return;
      }
      
      // 3. å¤„ç†è½¬è´¦ç‚¹å‡» - æ˜¾ç¤ºæ¥æ”¶/æ‹’ç»å¼¹çª—
      const bubble = e.target.closest('.message-bubble');
      if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
          // æ˜¾ç¤ºè½¬è´¦æ“ä½œå¼¹çª—
          showMyPhoneTransferActionModal(timestamp);
        }
        return;
      }
    });
    
    // MY Phone QQ å¯¹è¯æ»šåŠ¨åŠ è½½äº‹ä»¶ç›‘å¬
    const myphoneConversationMessages = document.getElementById('myphone-conversation-messages');
    if (myphoneConversationMessages) {
      const myphoneScrollHandler = () => {
        // åªæœ‰åœ¨æŸ¥çœ‹çœŸå®å¯¹è¯ï¼ˆindex === -1ï¼‰æ—¶æ‰æ”¯æŒæ»šåŠ¨åŠ è½½
        if (myphoneActiveConversationIndex !== -1) {
          return;
        }
        
        // æ»šåŠ¨åˆ°é¡¶éƒ¨æ—¶åŠ è½½æ›´å¤šæ¶ˆæ¯
        if (myphoneConversationMessages.scrollTop < 1 && !isLoadingMoreMyPhoneMessages) {
          const char = state.chats[activeMyPhoneCharacterId];
          if (!char) return;
          
          const totalMessages = char.history.filter(m => !m.isHidden).length;
          
          if (totalMessages > myphoneRenderedCount) {
            loadMoreMyPhoneMessages();
          }
        }
      };
      
      myphoneConversationMessages.addEventListener('scroll', myphoneScrollHandler);
    }
    
    document.getElementById('regenerate-myphone-album-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„ç›¸å†Œ...");
      try {
        await handleGenerateMyPhoneAlbum();
        renderMyPhoneAlbum();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„ç›¸å†Œå·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-browser-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„æµè§ˆè®°å½•...");
      try {
        await handleGenerateMyPhoneBrowserHistory();
        renderMyPhoneBrowserHistory();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„æµè§ˆè®°å½•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-taobao-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„æ·˜å®è®°å½•...");
      try {
        await handleGenerateMyPhoneTaobao();
        renderMyPhoneTaobao();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„æ·˜å®è®°å½•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-memo-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„å¤‡å¿˜å½•...");
      try {
        await handleGenerateMyPhoneMemos();
        renderMyPhoneMemoList();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„å¤‡å¿˜å½•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-diary-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„æ—¥è®°...");
      try {
        await handleGenerateMyPhoneDiaries();
        renderMyPhoneDiaryList();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„æ—¥è®°å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-amap-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„è¶³è¿¹...");
      try {
        await handleGenerateMyPhoneAmap();
        renderMyPhoneAmap();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„è¶³è¿¹å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-usage-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„APPä½¿ç”¨è®°å½•...");
      try {
        await handleGenerateMyPhoneAppUsage();
        renderMyPhoneAppUsage();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„APPä½¿ç”¨è®°å½•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    document.getElementById('regenerate-myphone-music-btn')?.addEventListener('click', async () => {
      showCustomAlert("æ­£åœ¨æ‰§è¡Œ...", "æ­£åœ¨ç”Ÿæˆæˆ‘çš„éŸ³ä¹æ­Œå•...");
      try {
        await handleGenerateMyPhoneMusic();
        renderMyPhoneMusicScreen();
        showCustomAlert("å®Œæˆ", "æˆ‘çš„éŸ³ä¹æ­Œå•å·²ç”Ÿæˆï¼");
      } catch (error) {
        showCustomAlert("é”™è¯¯", "ç”Ÿæˆå¤±è´¥ï¼š" + error.message);
      }
    });
    
    // MY Phone æ‰‹åŠ¨æ·»åŠ æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('add-myphone-album-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-album-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-browser-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-browser-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-taobao-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-taobao-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-diary-btn')?.addEventListener('click', () => {
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('myphone-diary-date-input').value = today;
      document.getElementById('myphone-add-diary-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-memo-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-memo-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-amap-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-amap-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-usage-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-usage-modal')?.classList.add('visible');
    });
    
    document.getElementById('add-myphone-music-btn')?.addEventListener('click', () => {
      // é‡ç½®ä¸ºæœ¬åœ°æ–‡ä»¶æ¨¡å¼
      document.getElementById('myphone-music-source-select').value = 'local';
      toggleMyPhoneMusicInputs();
      document.getElementById('myphone-add-music-modal')?.classList.add('visible');
    });
    
    // ç›‘å¬æ·»åŠ æ–¹å¼åˆ‡æ¢
    document.getElementById('myphone-music-source-select')?.addEventListener('change', toggleMyPhoneMusicInputs);
    
    // MY Phone åˆ é™¤æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('delete-myphone-qq-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('qq');
    });
    
    document.getElementById('delete-myphone-album-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('album');
    });
    
    document.getElementById('delete-myphone-browser-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('browser');
    });
    
    document.getElementById('delete-myphone-taobao-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('taobao');
    });
    
    document.getElementById('delete-myphone-memo-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('memo');
    });
    
    document.getElementById('delete-myphone-diary-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('diary');
    });
    
    document.getElementById('delete-myphone-usage-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('usage');
    });
    
    document.getElementById('delete-myphone-music-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('music');
    });
    
    document.getElementById('delete-myphone-amap-btn')?.addEventListener('click', () => {
      toggleMyPhoneDeleteMode('amap');
    });
    
    // ä¸€èµ·å¬æ­Œæ›²å…¨é€‰åŠŸèƒ½
    document.getElementById('myphone-yiqiting-select-all')?.addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('.yiqiting-song-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = e.target.checked;
      });
    });
    
    // MY Phone æ¨¡æ€æ¡†å–æ¶ˆæŒ‰é’®
    document.getElementById('cancel-myphone-album-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-album-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-browser-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-browser-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-taobao-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-taobao-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-diary-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-diary-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-memo-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-memo-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-amap-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-amap-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-usage-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-usage-modal')?.classList.remove('visible');
    });
    
    document.getElementById('cancel-myphone-music-btn')?.addEventListener('click', () => {
      document.getElementById('myphone-add-music-modal')?.classList.remove('visible');
    });
    
    // MY Phone æ¨¡æ€æ¡†ä¿å­˜æŒ‰é’®
    document.getElementById('save-myphone-album-btn')?.addEventListener('click', () => {
      saveMyPhoneAlbum();
    });
    
    document.getElementById('save-myphone-browser-btn')?.addEventListener('click', () => {
      saveMyPhoneBrowser();
    });
    
    document.getElementById('save-myphone-taobao-btn')?.addEventListener('click', () => {
      saveMyPhoneTaobao();
    });
    
    document.getElementById('save-myphone-diary-btn')?.addEventListener('click', () => {
      saveMyPhoneDiary();
    });
    
    document.getElementById('save-myphone-memo-btn')?.addEventListener('click', () => {
      saveMyPhoneMemo();
    });
    
    document.getElementById('save-myphone-amap-btn')?.addEventListener('click', () => {
      saveMyPhoneAmap();
    });
    
    document.getElementById('save-myphone-usage-btn')?.addEventListener('click', () => {
      saveMyPhoneUsage();
    });
    
    document.getElementById('save-myphone-music-btn')?.addEventListener('click', () => {
      saveMyPhoneMusic();
    });
    
    document.getElementById('douban-detail-back-btn').addEventListener('click', () => showScreen('douban-screen'));
    document.getElementById('douban-send-comment-btn').addEventListener('click', handleSendDoubanComment);
    document.getElementById('douban-wait-reply-btn').addEventListener('click', handleDoubanWaitReply);

    document.getElementById('cphone-wallpaper-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise((res) => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });

        // 1. ç«‹å³ä¿å­˜å’Œæ˜¾ç¤º
        state.globalSettings.cphoneWallpaper = dataUrl;
        renderWallpaperScreen(); // This will update the preview
        await showCustomAlert("æˆåŠŸ", "CPhone å£çº¸å·²æ›´æ–°ï¼\n\nå›¾ç‰‡å°†åœ¨åå°é™é»˜ä¸Šä¼ åˆ°å›¾åºŠ... (ä¿å­˜è®¾ç½®åç”Ÿæ•ˆ)");

        // 2. å¯åŠ¨é™é»˜ä¸Šä¼ 
        (async () => {
            await silentlyUpdateDbUrl(
                db.globalSettings,
                'main',
                'cphoneWallpaper',
                dataUrl
            );
        })();
      }
      event.target.value = null; // æ¸…ç©º input
    });



    document.getElementById('cphone-icon-settings-grid').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
          handleIconChange(iconId, 'cphone', item);
        }
      }
    });

    document.getElementById('myphone-icon-settings-grid').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
          handleIconChange(iconId, 'myphone', item);
        }
      }
    });
    document.getElementById('import-appearance-btn').addEventListener('click', () => {
      document.getElementById('import-appearance-input').click();
    });

    document.getElementById('import-appearance-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importAppearanceSettings(file);
      }
      e.target.value = null;
    });


 
    document.addEventListener('visibilitychange', () => {

      if (document.visibilityState === 'hidden') {

        localStorage.setItem('ephoneLastActiveTimestamp', Date.now());
        console.log("åº”ç”¨å·²åˆ‡æ¢åˆ°åå°ï¼Œè®°å½•å½“å‰æ—¶é—´ã€‚");
      }
    });

    document.getElementById('export-world-book-btn').addEventListener('click', exportWorldBooks);
    document.getElementById('import-world-book-btn').addEventListener('click', () => {
      document.getElementById('import-world-book-input').click();
    });
    document.getElementById('import-world-book-input').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files);
      if (files.length > 0) {
        await handleWorldBookImport(files);
      }
      e.target.value = null;
    });
    document.getElementById('enable-ai-drawing-switch').addEventListener('change', async (e) => {
      const isEnabled = e.target.checked;
      state.globalSettings.enableAiDrawing = isEnabled;
      await db.globalSettings.put(state.globalSettings);


      const activeScreen = document.querySelector('.screen.active');
      if (activeScreen) {
        switch (activeScreen.id) {
          case 'chat-interface-screen':
            renderChatInterface(state.activeChatId);
            break;
          case 'chat-list-screen':

            if (document.getElementById('qzone-screen').classList.contains('active')) renderQzonePosts();

            if (document.getElementById('favorites-view').classList.contains('active')) renderFavoritesScreen();
            break;
          case 'douban-screen':
            renderDoubanScreen();
            break;
          case 'douban-post-detail-screen':
            openDoubanPostDetail(activeDoubanPostId);
            break;

          case 'character-phone-screen':
            const activeCharScreen = document.querySelector('.char-screen.active');
            if (activeCharScreen) {
              switch (activeCharScreen.id) {
                case 'char-album-screen':
                  renderCharAlbum();
                  break;
                case 'char-taobao-screen':
                  renderCharTaobao();
                  break;
                case 'char-browser-article-screen':
                  const char = state.chats[activeCharacterId];
                  const history = char.simulatedBrowserHistory || [];
                  const lastArticleIndex = history.length > 0 ? history.length - 1 : 0;
                  renderCharArticle(history[lastArticleIndex]);
                  break;
                case 'char-usage-screen':
                  renderCharAppUsage();
                  break;
                case 'char-qq-screen':
                  renderCharSimulatedQQ();
                  break;
                case 'char-qq-conversation-screen':
                  const convoIndex = document.querySelector('#char-chat-list .chat-list-item')?.dataset.conversationIndex || 0;
                  openCharSimulatedConversation(parseInt(convoIndex));
                  break;
              }
            }
            break;
        }
      }
      showCustomAlert('è®¾ç½®å·²åº”ç”¨', `AIç”Ÿå›¾åŠŸèƒ½å·²${isEnabled ? 'å¼€å¯' : 'å…³é—­'}ã€‚`);
    });

    document.getElementById('search-history-btn').addEventListener('click', openSearchHistoryScreen);
    document.getElementById('search-history-back-btn').addEventListener('click', () => {
      showScreen('chat-settings-screen');
    });
    document.getElementById('execute-search-btn').addEventListener('click', handleSearchHistory);
    document.getElementById('clear-search-btn').addEventListener('click', clearSearchFilters);




    document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadFrame);
    document.getElementById('batch-import-frames-btn').addEventListener('click', handleBatchUploadFrames);


    document.querySelector('#avatar-frame-modal .modal-body').addEventListener('click', (e) => {

      if (e.target.classList.contains('delete-btn')) {
        const frameId = parseInt(e.target.dataset.id);
        if (!isNaN(frameId)) {
          handleDeleteCustomFrame(frameId);
        }
      }
    });





    setupHomeScreenPagination();


    window.openPresetScreen = openPresetScreen;


    document.getElementById('add-preset-btn').addEventListener('click', async () => {
      const name = await showCustomPrompt('åˆ›å»ºæ–°é¢„è®¾', 'è¯·è¾“å…¥é¢„è®¾åç§°');
      if (name && name.trim()) {
        const newPreset = {
          id: 'preset_' + Date.now(),
          name: name.trim(),
          content: []
        };
        await db.presets.add(newPreset);
        await renderPresetScreen();
        openPresetEditor(newPreset.id);
      }
    });

    document.getElementById('manage-preset-categories-btn').addEventListener('click', openPresetCategoryManager);

    document.getElementById('add-preset-entry-btn').addEventListener('click', () => {
      const container = document.getElementById('preset-entries-container');
      if (container.querySelector('p')) {
        container.innerHTML = '';
      }
      const newBlock = createPresetEntryBlock();
      container.appendChild(newBlock);
      newBlock.querySelector('.entry-content-textarea').focus();
    });


    document.getElementById('save-preset-btn').addEventListener('click', async () => {
      if (!editingPresetId) return;
      const preset = await db.presets.get(editingPresetId);
      if (!preset) return;


      const newName = document.getElementById('preset-name-input').value.trim();
      if (!newName) {
        alert('é¢„è®¾åç§°ä¸èƒ½ä¸ºç©ºï¼');
        return;
      }
      preset.name = newName;
      preset.categoryId = parseInt(document.getElementById('preset-category-select').value) || null;

      const entriesContainer = document.getElementById('preset-entries-container');
      const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
      const newEntries = [];
      entryBlocks.forEach(block => {
        const content = block.querySelector('.entry-content-textarea').value.trim();
        if (content) {
          newEntries.push({
            comment: block.querySelector('.entry-comment-input').value.trim(),
            keys: (block.querySelector('.entry-keys-input').value.trim() || '').split(',').map(k => k.trim()).filter(Boolean),
            content: content,
            enabled: block.querySelector('.entry-enabled-switch').checked
          });
        }
      });
      preset.content = newEntries;


      await db.presets.put(preset);
      editingPresetId = null;


      showScreen('preset-screen');



      await renderPresetScreen();
    });




    document.getElementById('import-preset-btn').addEventListener('click', async () => {
      

     
      try {
        
        await requirePinActivation();

        
        document.getElementById('import-preset-input').click();

      } catch (error) {
    
        console.warn("é¢„è®¾å¯¼å…¥è¢«å–æ¶ˆ:", error.message);
      }
    
    });

    document.getElementById('import-preset-input').addEventListener('change', handlePresetImport);

    document.getElementById('reset-button-order-btn').addEventListener('click', resetButtonOrder);

    document.getElementById('clear-specific-data-btn').addEventListener('click', openDataClearWizard);


    document.getElementById('cancel-clear-wizard-btn-step1').addEventListener('click', () => {
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
    });
    document.getElementById('go-to-clear-step2-btn').addEventListener('click', handleDataClearNext);


    document.getElementById('back-to-clear-step1-btn').addEventListener('click', handleDataClearBack);
    document.getElementById('cancel-clear-wizard-btn-step2').addEventListener('click', () => {
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
    });
    document.getElementById('confirm-final-clear-btn').addEventListener('click', handleConfirmDataClear);


    document.getElementById('data-clear-wizard-modal').addEventListener('click', (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {

        e.stopPropagation();
        item.classList.toggle('selected');
      }
    });
    document.getElementById('data-clear-wizard-modal').addEventListener('change', (e) => {

      if (e.target.id === 'select-all-chars-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
          item.classList.toggle('selected', isChecked);
        });
      } else if (e.target.id === 'select-all-types-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-type-list .clear-posts-item').forEach(item => {
          item.classList.toggle('selected', isChecked);
        });
      }
    });

    document.getElementById('compress-images-btn').addEventListener('click', compressAllLocalImages);

    document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);


    document.getElementById('copy-timestamp-btn').addEventListener('click', copyMessageTimestamp);

    document.getElementById('npc-list-back-btn').addEventListener('click', () => {

      switchToChatListView('messages-view');
    });


    document.getElementById('add-npc-btn').addEventListener('click', () => openNpcEditor(null));


    document.getElementById('save-npc-btn').addEventListener('click', saveNpc);
    document.getElementById('npc-editor-modal').addEventListener('click', (e) => {
      if (e.target.id === 'manage-npc-groups-btn') {
        openNpcGroupManager();
      }
    });
    document.getElementById('close-npc-group-manager-btn').addEventListener('click', () => {
      document.getElementById('npc-group-manager-modal').classList.remove('visible');
      // é‡æ–°å¡«å……NPCç¼–è¾‘å™¨é‡Œçš„ä¸‹æ‹‰èœå•
      if (document.getElementById('npc-editor-modal').classList.contains('visible')) {
        openNpcEditor(editingNpcId);
      }
    });
    document.getElementById('add-new-npc-group-btn').addEventListener('click', addNewNpcGroup);
    document.getElementById('existing-npc-groups-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deleteNpcGroup(parseInt(e.target.dataset.id));
      }
    });
    document.getElementById('cancel-npc-editor-btn').addEventListener('click', () => {
      document.getElementById('npc-editor-modal').classList.remove('visible');
    });


    document.getElementById('npc-avatar-input').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          document.getElementById('npc-avatar-preview').src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    document.getElementById('chat-lock-overlay').addEventListener('click', (e) => {

      if (e.target.id === 'spectator-reroll-btn') {
        handleSpectatorReroll();
      } else if (e.target.id === 'spectator-edit-btn') {

        openAiResponseEditor();
      }

    });
    addLongPressListener(document.getElementById('music-visual-container'), () => {
      if (musicState.currentIndex > -1) {
        handleChangeAlbumArt(musicState.currentIndex);
      }
    });
    document.getElementById('douban-settings-btn').addEventListener('click', openDoubanSettingsModal);
    document.getElementById('save-douban-settings-btn').addEventListener('click', saveDoubanSettings);
    document.getElementById('cancel-douban-settings-btn').addEventListener('click', () => {
      document.getElementById('douban-settings-modal').classList.remove('visible');
    });

    document.getElementById('time-zone-search-input').addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const selectEl = document.getElementById('time-zone-select');


      for (const option of selectEl.options) {
        const optionText = option.textContent.toLowerCase();


        if (optionText.includes(searchTerm)) {
          option.style.display = '';
        } else {

          option.style.display = 'none';
        }
      }
    });





    window.openWerewolfLobby = openWerewolfLobby;


    document.getElementById('werewolf-game-btn').addEventListener('click', () => openWerewolfLobby('group'));


    document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
      document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    });
    document.getElementById('start-werewolf-game-btn').addEventListener('click', initializeWerewolfGame);


    document.getElementById('werewolf-role-confirm-btn').addEventListener('click', () => {
      document.getElementById('werewolf-role-modal').classList.remove('visible');
      executeNightPhase();
    });

    document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
      const confirmed = await showCustomConfirm('é€€å‡ºæ¸¸æˆ', 'ç¡®å®šè¦é€€å‡ºå½“å‰è¿™å±€ç‹¼äººæ€å—ï¼Ÿæ¸¸æˆè¿›åº¦å°†ä¸ä¼šè¢«ä¿å­˜ã€‚', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        werewolfGameState.isActive = false;

        showScreen(werewolfGameState.chatId ? 'chat-interface-screen' : 'home-screen');
      }
    });

    document.getElementById('werewolf-game-over-close-btn').addEventListener('click', () => {
      document.getElementById('werewolf-game-over-modal').classList.remove('visible');
      showScreen(werewolfGameState.chatId ? 'chat-list-screen' : 'home-screen');
    });



    document.getElementById('cancel-wolf-kill-btn').addEventListener('click', () => {
      document.getElementById('werewolf-kill-modal').classList.remove('visible');
    });



    document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
      document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    });

    document.getElementById('werewolf-retry-btn').addEventListener('click', handleWerewolfRetry);
    document.getElementById('manual-werewolf-summary-btn').addEventListener('click', handleManualWerewolfSummary);
    document.getElementById('check-and-fix-data-btn').addEventListener('click', checkAndFixData);
    const emergencyResetBtn = document.getElementById('emergency-reset-appearance-btn');
    if (emergencyResetBtn) {
        emergencyResetBtn.addEventListener('click', handleEmergencyAppearanceReset);
    }
    const factoryResetBtn = document.getElementById('factory-reset-btn');
    if (factoryResetBtn) {
        factoryResetBtn.addEventListener('click', handleFactoryReset);
    }
    document.getElementById('dynamic-island-music-toggle-switch').addEventListener('change', (e) => {
      const isEnabled = e.target.checked;
      state.globalSettings.alwaysShowMusicIsland = isEnabled; // æ›´æ–°å†…å­˜ä¸­çš„çŠ¶æ€

   
      const isFrameMode = document.body.classList.contains('frame-mode-active');

     
      if (musicState.isActive && !isFrameMode) {
        const lyricBar = document.getElementById('global-lyrics-bar');
        const phoneScreenForIsland = document.getElementById('phone-screen');

        if (isEnabled) {
      
          lyricBar.classList.remove('visible');
          phoneScreenForIsland.classList.add('dynamic-island-active');
        } else {
      
          phoneScreenForIsland.classList.remove('dynamic-island-active');
          if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
            lyricBar.classList.add('visible');
          }
        }
      }
    });
    document.getElementById('delete-world-books-btn').addEventListener('click', openWorldBookDeletionModal);


    document.getElementById('cancel-delete-world-books-btn').addEventListener('click', () => {
      document.getElementById('delete-world-books-modal').classList.remove('visible');
    });
    document.getElementById('confirm-delete-world-books-btn').addEventListener('click', handleConfirmWorldBookDeletion);

    document.getElementById('delete-world-books-modal').addEventListener('click', (e) => {

      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
      }

      if (e.target.id === 'select-all-world-books-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#delete-world-books-list .clear-posts-item').forEach(el => {
          el.classList.toggle('selected', isChecked);
        });
      }
    });


    document.getElementById('sticker-search-input').addEventListener('input', () => {

      renderStickerPanel(false);
    });


    document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;
        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;


        document.getElementById('sticker-search-input').value = '';


        switchStickerCategory(finalId);
      }
    });




    const chatMessagesContainer = document.getElementById('chat-messages');
    chatMessagesContainer.addEventListener('scroll', () => {

      if (chatMessagesContainer.scrollTop < 1 && !isLoadingMoreMessages) {
        const totalMessages = state.chats[state.activeChatId]?.history.length || 0;

        if (totalMessages > currentRenderedCount) {
          loadMoreMessages();
        }
      }
    });


    const thoughtsHistoryList = document.getElementById('thoughts-history-list');
    thoughtsHistoryList.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = thoughtsHistoryList;

      if (scrollHeight - scrollTop <= clientHeight + 50 && !isLoadingMoreThoughts) {
        const totalItems = state.chats[state.activeChatId]?.thoughtsHistory.length || 0;
        if (totalItems > thoughtsHistoryRenderCount) {
          loadMoreThoughts();
        }
      }
    });


    const qzoneContent = document.querySelector('#qzone-screen .qzone-content');
    qzoneContent.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = qzoneContent;

      if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMorePosts) {
        if (qzonePostsCache.length > qzonePostsRenderCount) {
          loadMoreQzonePosts();
        }
      }
    });

    
    const localGridEl = document.getElementById('nai-gallery-grid-local');
    const cloudGridEl = document.getElementById('nai-gallery-grid-cloud');

    const naiGridScrollHandler = (e) => {
      
      const targetGrid = e.currentTarget;
      const tabId = targetGrid.id.includes('local') ? 'local' : 'cloud';

      
      if (tabId !== activeNaiGalleryTab) {
        return;
      }
      
      const { scrollTop, scrollHeight, clientHeight } = targetGrid;
      
      
      if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMoreNaiImages[tabId]) {
        if (naiGalleryCache[tabId].length > naiGalleryRenderCount[tabId]) {
          loadMoreNaiGalleryImages(); 
        }
      }
    };

    // åˆ†åˆ«ä¸ºä¸¤ä¸ªæ–°ç½‘æ ¼ç»‘å®šäº‹ä»¶
    if (localGridEl) {
      localGridEl.addEventListener('scroll', naiGridScrollHandler);
    }
    if (cloudGridEl) {
      cloudGridEl.addEventListener('scroll', naiGridScrollHandler);
    }
    

    document.getElementById('read-together-btn').addEventListener('click', openReadingRoom);
    const restoreBtn = document.getElementById('reading-restore-btn');

    makeDraggable(restoreBtn, restoreBtn);
    document.getElementById('close-reading-btn').addEventListener('click', closeReadingRoom);
    document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
    document.getElementById('next-page-btn').addEventListener('click', showNextPage);
    document.getElementById('prev-page-btn').addEventListener('click', showPrevPage);
    document.getElementById('book-upload-input').addEventListener('change', handleBookFileUpload);


    document.getElementById('minimize-reading-btn').addEventListener('click', minimizeReadingRoom);
    document.getElementById('reading-restore-btn').addEventListener('click', restoreReadingRoom);


    makeDraggable(document.getElementById('reading-window'), document.querySelector('#reading-window .reading-header'));


    document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);

    document.getElementById('close-reading-library-btn-header').addEventListener('click', () => {
      document.getElementById('reading-library-modal').classList.remove('visible');
    });
    document.getElementById('import-new-book-btn-header').addEventListener('click', importBook);



    document.getElementById('reading-library-list').addEventListener('click', (e) => {
      const target = e.target;
      if (target.classList.contains('group-name')) {
        const bookId = parseInt(target.dataset.bookId);
        loadBookFromLibrary(bookId);
      } else if (target.classList.contains('delete-group-btn')) {
        const bookId = parseInt(target.dataset.bookId);
        deleteBookFromLibrary(bookId);
      }
    });

    document.getElementById('page-indicator').addEventListener('click', handlePageJump);
    document.getElementById('reading-library-search-input').addEventListener('input', (e) => {

      renderBookLibrary(e.target.value);
    });
    const debouncedUpdateReadingContext = debounce(updateReadingContextOnScroll, 300);


    document.getElementById('reading-content').addEventListener('scroll', debouncedUpdateReadingContext);
    document.getElementById('api-temperature-slider').addEventListener('input', (e) => {
      document.getElementById('api-temperature-value').textContent = e.target.value;
    });
    const chatListContainer = document.getElementById('messages-view');
    chatListContainer.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = chatListContainer;

      if (scrollHeight - scrollTop <= clientHeight + 150 && !isLoadingMoreChats) {
        loadMoreChats();
      }
    });



    document.getElementById('manage-product-categories-btn').addEventListener('click', openProductCategoryManager);
    document.getElementById('close-product-category-manager-btn').addEventListener('click', () => {
      document.getElementById('product-category-manager-modal').classList.remove('visible');


      openProductEditor(editingProductId);
    });
    document.getElementById('add-new-product-category-btn').addEventListener('click', addNewProductCategory);
    document.getElementById('existing-product-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deleteProductCategory(parseInt(e.target.dataset.id));
      }
    });


    document.getElementById('add-product-variation-btn').addEventListener('click', () => addProductVariationInput());


    document.getElementById('cancel-variation-selection-btn').addEventListener('click', () => {
      document.getElementById('variation-selection-modal').classList.remove('visible');
    });
    document.getElementById('variation-decrease-qty').addEventListener('click', () => {
      const display = document.getElementById('variation-quantity-display');
      let qty = parseInt(display.textContent);
      if (qty > 1) display.textContent = qty - 1;
    });
    document.getElementById('variation-increase-qty').addEventListener('click', () => {
      const display = document.getElementById('variation-quantity-display');
      display.textContent = parseInt(display.textContent) + 1;
    });
    document.getElementById('product-category-tabs').addEventListener('click', (e) => {

      if (e.target.classList.contains('product-category-tab')) {

        const categoryId = e.target.dataset.categoryId === 'all' ? 'all' : parseInt(e.target.dataset.categoryId);


        switchShoppingCategory(categoryId);
      }
    });
    document.getElementById('generate-shopping-items-btn').addEventListener('click', handleGenerateShoppingItems);
    document.getElementById('shopping-settings-btn').addEventListener('click', openShoppingSettingsModal);
    document.getElementById('save-shopping-settings-btn').addEventListener('click', saveShoppingSettings);
    document.getElementById('cancel-shopping-settings-btn').addEventListener('click', () => {
      document.getElementById('shopping-settings-modal').classList.remove('visible');
    });
    document.getElementById('select-all-products-checkbox').addEventListener('change', (e) => {
      const isChecked = e.target.checked;

      const visibleItems = document.querySelectorAll('#product-grid .product-item');

      visibleItems.forEach(item => {
        const productId = parseInt(item.dataset.id);
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
          selectedProducts.add(productId);
        } else {
          selectedProducts.delete(productId);
        }
      });
      document.getElementById('delete-selected-products-btn').textContent = `åˆ é™¤ (${selectedProducts.size})`;
    });


    document.getElementById('delete-selected-products-btn').addEventListener('click', async () => {
      if (selectedProducts.size === 0) {
        alert("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å•†å“ã€‚");
        return;
      }

      const confirmed = await showCustomConfirm(
        'ç¡®è®¤åˆ é™¤',
        `ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é€‰ä¸­çš„ ${selectedProducts.size} ä¸ªå•†å“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        await db.shoppingProducts.bulkDelete([...selectedProducts]);


        document.getElementById('manage-products-btn').click();

        await renderShoppingProducts();

        await showCustomAlert("æˆåŠŸ", "é€‰ä¸­çš„å•†å“å·²æˆåŠŸåˆ é™¤ã€‚");
      }
    });

    document.getElementById('appearance-preset-select').addEventListener('change', handleAppearancePresetSelectionChange);
    document.getElementById('save-appearance-preset-btn').addEventListener('click', saveAppearancePreset);
    document.getElementById('delete-appearance-preset-btn').addEventListener('click', deleteAppearancePreset);



    document.getElementById('novelai-switch').addEventListener('change', (e) => {
      const detailsDiv = document.getElementById('novelai-details');
      detailsDiv.style.display = e.target.checked ? 'block' : 'none';
    });


    document.getElementById('novelai-key-toggle').addEventListener('click', function() {
      const input = document.getElementById('novelai-api-key');
      if (input.type === 'password') {
        input.type = 'text';
        this.textContent = 'ğŸ˜Œ';
      } else {
        input.type = 'password';
        this.textContent = 'ğŸ§';
      }
    });

  
    document.getElementById('novelai-settings-btn').addEventListener('click', () => {
      loadNovelAISettings();
      document.getElementById('novelai-settings-modal').style.display = 'flex';
    });


    document.getElementById('nai-cors-proxy').addEventListener('change', (e) => {
      const customProxyGroup = document.getElementById('nai-custom-proxy-group');
      if (e.target.value === 'custom') {
        customProxyGroup.style.display = 'block';
      } else {
        customProxyGroup.style.display = 'none';
      }
    });

    document.getElementById('close-novelai-settings').addEventListener('click', () => {
      document.getElementById('novelai-settings-modal').style.display = 'none';
    });


    document.getElementById('save-nai-settings-btn').addEventListener('click', () => {
      saveNovelAISettings();
      document.getElementById('novelai-settings-modal').style.display = 'none';
      alert('NovelAIè®¾ç½®å·²ä¿å­˜ï¼');
    });

    document.getElementById('reset-nai-settings-btn').addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤è®¾ç½®å—ï¼Ÿ')) {
        resetNovelAISettings();
      }
    });


    document.getElementById('novelai-test-btn').addEventListener('click', () => {
      const apiKey = document.getElementById('novelai-api-key').value.trim();
      if (!apiKey) {
        alert('è¯·å…ˆå¡«å†™NovelAI API Keyï¼');
        return;
      }
      document.getElementById('novelai-test-modal').style.display = 'flex';
      document.getElementById('nai-test-result').style.display = 'none';
      document.getElementById('nai-test-error').style.display = 'none';
    });

 
    document.getElementById('close-novelai-test').addEventListener('click', () => {
      document.getElementById('novelai-test-modal').style.display = 'none';
    });

    document.getElementById('close-nai-test-btn').addEventListener('click', () => {
      document.getElementById('novelai-test-modal').style.display = 'none';
    });

 
    document.getElementById('nai-generate-btn').addEventListener('click', async () => {
      await generateNovelAIImage();
    });



    document.getElementById('nai-download-btn').addEventListener('click', () => {
      const img = document.getElementById('nai-result-image');
      const link = document.createElement('a');
      link.href = img.src;
      link.download = 'novelai-generated-' + Date.now() + '.png';
      link.click();
    });

  
    document.getElementById('character-nai-prompts-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      // åŠ è½½å½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®
      const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
      };

  
      document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
      document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';

      document.getElementById('character-nai-prompts-modal').style.display = 'flex';
    });

   
    document.getElementById('close-character-nai-prompts').addEventListener('click', () => {
      document.getElementById('character-nai-prompts-modal').style.display = 'none';
    });

    document.getElementById('save-character-nai-prompts-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {
          promptSource: 'system'
        };
      }

      chat.settings.naiSettings.characterPositivePrompt = document.getElementById('character-nai-positive').value.trim();
      chat.settings.naiSettings.characterNegativePrompt = document.getElementById('character-nai-negative').value.trim();

      console.log('ğŸ’¾ [ä¸“å±å¼¹çª—] ä¿å­˜è§’è‰²NAIæç¤ºè¯');
      console.log('   characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
      console.log('   characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
      console.log('   promptSource:', chat.settings.naiSettings.promptSource);

     
      await db.chats.put(chat);

      document.getElementById('character-nai-prompts-modal').style.display = 'none';
      alert('è§’è‰²ä¸“å±NAIæç¤ºè¯å·²ä¿å­˜ï¼');
    });

    document.getElementById('reset-character-nai-prompts-btn').addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®å—ï¼Ÿ')) {
        document.getElementById('character-nai-positive').value = '';
        document.getElementById('character-nai-negative').value = '';
      }
    });

 
    document.getElementById('group-character-nai-prompts-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      // åŠ è½½å½“å‰è§’è‰²çš„NAIæç¤ºè¯é…ç½®
      const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
      };

    
      document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
      document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';

      document.getElementById('character-nai-prompts-modal').style.display = 'flex';
    });
 

    document.getElementById('manage-frames-btn').addEventListener('click', toggleFrameManagementMode);
    document.getElementById('select-all-frames-checkbox').addEventListener('change', handleSelectAllFrames);
    document.getElementById('delete-selected-frames-btn').addEventListener('click', executeBatchDeleteFrames);
    document.getElementById('delete-current-category-btn').addEventListener('click', handleDeleteCurrentCategory);
    document.getElementById('char-wallet-back-btn').addEventListener('click', () => {

      switchToCharScreen('char-taobao-screen');
    });
    document.getElementById('sticker-binding-chat-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (item) {
        const checkbox = item.querySelector('.sticker-binding-checkbox');
        if (checkbox && e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
        }
      }
    });
    const stickerTabsContainer = document.getElementById('sticker-category-tabs');
    addLongPressListener(stickerTabsContainer, (e) => {
      const tab = e.target.closest('.sticker-category-tab');
      if (tab) {
        e.preventDefault();
        const categoryIdStr = tab.dataset.categoryId;
        if (categoryIdStr === 'all') {
          showCustomAlert("æç¤º", "â€œå…¨éƒ¨â€åˆ†ç±»æ— æ³•è¢«ç»‘å®šã€‚");
          return;
        }
        const categoryId = categoryIdStr === 'uncategorized' ? 'uncategorized' : parseInt(categoryIdStr);
        openStickerCategoryBindingModal(categoryId);
      }
    });

    document.getElementById('open-nai-gallery-btn').addEventListener('click', openNaiGallery);
    document.getElementById('nai-gallery-tabs').addEventListener('click', (e) => {
      const tab = e.target.closest('.nai-gallery-tab');
      if (tab && !tab.classList.contains('active')) {
        switchNaiGalleryTab(tab.dataset.tabId);
      }
    });
    document.getElementById('close-nai-gallery-btn').addEventListener('click', () => {
      document.getElementById('nai-gallery-panel').classList.remove('visible');
    });

    document.getElementById('manage-nai-gallery-btn').addEventListener('click', toggleNaiGalleryManagementMode);

    document.getElementById('nai-gallery-grid-local').addEventListener('click', (e) => {
      handleNaiGalleryGridClick(e);
    });
    document.getElementById('nai-gallery-grid-cloud').addEventListener('click', (e) => {
      handleNaiGalleryGridClick(e);
    });

    document.getElementById('select-all-nai-gallery-checkbox').addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      const activeGridId = `nai-gallery-grid-${activeNaiGalleryTab}`;
      
      
      document.querySelectorAll(`#${activeGridId} .nai-gallery-item`).forEach(item => {
        item.classList.toggle('selected', isChecked);
        const key = item.dataset.key;
        if (isChecked) {
          selectedNaiImages.add(key);
        } else {
          selectedNaiImages.delete(key);
        }
      });
      updateNaiGalleryActionButtons();
    });
    document.getElementById('download-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDownloadNaiImages());
    document.getElementById('upload-selected-nai-gallery-btn').addEventListener('click', () => executeBatchUploadNaiImagesToImgBB());
    document.getElementById('export-selected-nai-gallery-btn').addEventListener('click', () => executeBatchExportNaiImages()); 
    document.getElementById('delete-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDeleteNaiImages());
    document.getElementById('delete-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDeleteNaiImages());
    document.getElementById('chat-expand-btn').addEventListener('click', () => {
      document.body.classList.toggle('chat-actions-expanded');
    });
    document.getElementById('profile-edit-btn').addEventListener('click', openThoughtEditor);
    document.getElementById('open-quick-reply-btn').addEventListener('click', openQuickReplyModal);

    document.getElementById('cancel-quick-reply-btn').addEventListener('click', () => {
      document.getElementById('quick-reply-modal').classList.remove('visible');
    });

    // ========== çœŸå¿ƒè¯æ¸¸æˆ ==========
    let truthGameState = {
      isActive: false,
      currentRound: 0,
      userChoice: null,
      aiChoice: null,
      winner: null,
      messages: []
    };

    // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°çœŸå¿ƒè¯æ‚¬æµ®çƒçº¢ç‚¹çŠ¶æ€
    function updateTruthGameFloatIndicator() {
      const modal = document.getElementById('truth-game-modal');
      const indicator = document.getElementById('truth-game-float-indicator');
      
      // å¦‚æœå¯¹è¯æ¡†è¢«æœ€å°åŒ–ï¼Œæ˜¾ç¤ºçº¢ç‚¹
      if (modal.classList.contains('minimized')) {
        indicator.classList.add('active');
      }
    }

    document.getElementById('open-truth-game-btn').addEventListener('click', () => {
      if (!state.activeChatId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡ï¼');
        return;
      }
      const chat = state.chats[state.activeChatId];
      if (chat.isGroup) {
        alert('çœŸå¿ƒè¯æ¸¸æˆä»…æ”¯æŒå•äººèŠå¤©ï¼');
        return;
      }
      
      if (!chat.settings.truthGameHistoryLimit) {
        chat.settings.truthGameHistoryLimit = 5;
      }
      
      truthGameState = {
        isActive: true,
        currentRound: 1,
        userChoice: null,
        aiChoice: null,
        winner: null,
        messages: [],
        waitingForAI: false,
        hasStartedRound: false
      };
      document.getElementById('truth-game-modal').classList.add('visible');
      document.getElementById('truth-input').value = '';
      document.getElementById('truth-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
      document.getElementById('truth-rps-selector').style.display = 'none';
      renderTruthGameMessages();
      addTruthGameMessage('system', 'æ¬¢è¿æ¥åˆ°çœŸå¿ƒè¯å¤§å†’é™©ï¼ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"æŒ‰é’®å¼€å§‹ç¬¬ä¸€è½®ã€‚');
    });

    document.getElementById('truth-game-settings-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      if (!chat.settings.truthGameHistoryLimit) {
        chat.settings.truthGameHistoryLimit = 5;
      }
      
      document.getElementById('truth-history-limit-input').value = chat.settings.truthGameHistoryLimit;
      document.getElementById('truth-game-settings-modal').classList.add('visible');
    });

    document.getElementById('cancel-truth-settings-btn').addEventListener('click', () => {
      document.getElementById('truth-game-settings-modal').classList.remove('visible');
    });

    document.getElementById('save-truth-settings-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      const limit = parseInt(document.getElementById('truth-history-limit-input').value);
      if (isNaN(limit) || limit < 1) {
        alert('è¯·è¾“å…¥å¤§äºç­‰äº1çš„æ•°å­—');
        return;
      }
      
      if (limit > 50) {
        if (!confirm(`æ‚¨è®¾ç½®äº†${limit}è½®å†å²è®°å½•ï¼Œè¿™å¯èƒ½ä¼šæ¶ˆè€—å¤§é‡tokenã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`)) {
          return;
        }
      }
      
      chat.settings.truthGameHistoryLimit = limit;
      await db.chats.put(chat);
      
      document.getElementById('truth-game-settings-modal').classList.remove('visible');
    });

    // æœ€å°åŒ–çœŸå¿ƒè¯å¯¹è¯æ¡†
    document.getElementById('minimize-truth-game-btn').addEventListener('click', () => {
      const modal = document.getElementById('truth-game-modal');
      const floatBall = document.getElementById('truth-game-float-ball');
      const chat = state.chats[state.activeChatId];
      
      if (chat) {
        const floatAvatar = document.getElementById('truth-game-float-avatar');
        floatAvatar.src = chat.settings.aiAvatar || 'https://i.postimg.cc/y8xWzCqj/anime-boy.jpg';
      }
      
      modal.classList.add('minimized');
      modal.classList.remove('visible');
      floatBall.style.display = 'block';
      
      // å¦‚æœAIæ­£åœ¨å›å¤ï¼Œæ˜¾ç¤ºçº¢ç‚¹æŒ‡ç¤ºå™¨
      if (truthGameState.waitingForAI) {
        document.getElementById('truth-game-float-indicator').classList.add('active');
      }
    });

    // ç‚¹å‡»æ‚¬æµ®çƒæ¢å¤å¯¹è¯æ¡†
    document.getElementById('truth-game-float-ball').addEventListener('click', () => {
      const modal = document.getElementById('truth-game-modal');
      const floatBall = document.getElementById('truth-game-float-ball');
      
      floatBall.style.display = 'none';
      modal.classList.remove('minimized');
      modal.classList.add('visible');
      
      // ç§»é™¤çº¢ç‚¹æŒ‡ç¤ºå™¨
      document.getElementById('truth-game-float-indicator').classList.remove('active');
      
      // æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
      const messagesContainer = document.getElementById('truth-game-messages');
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    });

    document.getElementById('close-truth-game-btn').addEventListener('click', async () => {
      if (truthGameState.messages.length > 1) {
        const chat = state.chats[state.activeChatId];
        
        let gameRecord = '[ç³»ç»Ÿæç¤ºï¼šåˆšåˆšæˆ‘ä»¬è¿›è¡Œäº†ä¸€åœºçœŸå¿ƒè¯å¤§å†’é™©æ¸¸æˆï¼ˆé€šè¿‡çŸ³å¤´å‰ªåˆ€å¸ƒçŒœæ‹³å†³å®šè°æé—®é—®é¢˜ï¼Œè¾“çš„äººéœ€è¦çœŸè¯šå›ç­”ï¼‰ã€‚ä»¥ä¸‹æ˜¯æ¸¸æˆçš„å®Œæ•´å¯¹è¯è®°å½•] ';
        let roundDetails = [];
        let currentRound = '';
        let currentWinner = null;
        
        for (let i = 0; i < truthGameState.messages.length; i++) {
          const msg = truthGameState.messages[i];
          
          if (msg.role === 'system') {
            if (msg.content.includes('ç¬¬') && msg.content.includes('è½®')) {
              if (currentRound) {
                roundDetails.push(currentRound);
              }
              currentRound = msg.content.replace('ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒå¼€å§‹æ¸¸æˆï¼', '').replace('ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒï¼', '') + ': ';
              currentWinner = null;
            } else if (msg.content.includes('ä½ èµ¢äº†')) {
              currentRound += ' ç»“æœ: æˆ‘è·èƒœ';
              currentWinner = 'user';
            } else if (msg.content.includes(chat.name + 'èµ¢äº†')) {
              currentRound += ' ç»“æœ: ' + chat.name + 'è·èƒœ';
              currentWinner = 'ai';
            } else if (msg.content.includes('å¹³å±€')) {
              currentRound += ' ç»“æœ: å¹³å±€';
              currentWinner = null;
            }
          } else if (msg.role === 'user') {
            if (msg.content.startsWith('å‡ºäº†ï¼š')) {
              currentRound += 'æˆ‘' + msg.content + ', ';
            } else {
              if (currentRound) {
                roundDetails.push(currentRound);
                currentRound = '';
              }
              roundDetails.push(`æˆ‘: ${msg.content}`);
            }
          } else if (msg.role === 'assistant') {
            if (msg.content.startsWith('å‡ºäº†ï¼š')) {
              currentRound += chat.name + msg.content;
            } else {
              if (currentRound) {
                roundDetails.push(currentRound);
                currentRound = '';
              }
              roundDetails.push(`${chat.name}: ${msg.content}`);
            }
          }
        }
        
        if (currentRound) {
          roundDetails.push(currentRound);
        }
        
        gameRecord += roundDetails.join(' ');
        
        const recordMessage = {
          role: 'system',
          type: 'truth_game_record',
          content: gameRecord,
          timestamp: Date.now(),
          isHidden: true
        };
        
        chat.history.push(recordMessage);
        await db.chats.put(chat);
        
        if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chat.id) {
          renderChatInterface(chat.id);
        }
        
        renderChatList();
      }
      
      // æ¢å¤æ­£å¸¸æ¶ˆæ¯èœå•çš„æ‰€æœ‰æŒ‰é’®
      restoreNormalMessageActions();
      
      // å…³é—­å¯¹è¯æ¡†å’Œæ‚¬æµ®çƒ
      document.getElementById('truth-game-modal').classList.remove('visible');
      document.getElementById('truth-game-modal').classList.remove('minimized');
      document.getElementById('truth-game-float-ball').style.display = 'none';
      document.getElementById('truth-game-float-indicator').classList.remove('active');
    });

    document.querySelectorAll('.truth-rps-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        if (!truthGameState.isActive || truthGameState.waitingForAI) return;
        
        const userChoice = btn.dataset.choice;
        const choices = ['rock', 'scissors', 'paper'];
        const aiChoice = choices[Math.floor(Math.random() * 3)];
        
        truthGameState.userChoice = userChoice;
        truthGameState.aiChoice = aiChoice;
        
        const chat = state.chats[state.activeChatId];
        const choiceText = {
          rock: 'çŸ³å¤´',
          scissors: 'å‰ªåˆ€',
          paper: 'å¸ƒ'
        };
        
        addTruthGameMessage('user', `å‡ºäº†ï¼š${choiceText[userChoice]}`);
        
        await new Promise(resolve => setTimeout(resolve, 800));
        
        addTruthGameMessage('assistant', `å‡ºäº†ï¼š${choiceText[aiChoice]}`);
        
        const winner = determineRPSWinner(userChoice, aiChoice);
        truthGameState.winner = winner;
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (winner === 'user') {
          addTruthGameMessage('system', 'ä½ èµ¢äº†ï¼è¯·å‘å¯¹æ–¹æé—®ä¸€ä¸ªé—®é¢˜ã€‚');
          document.getElementById('truth-rps-selector').style.display = 'none';
          document.getElementById('truth-input').placeholder = 'è¾“å…¥ä½ æƒ³é—®çš„é—®é¢˜...';
          document.getElementById('truth-input').focus();
        } else if (winner === 'ai') {
          addTruthGameMessage('system', `${chat.name}èµ¢äº†ï¼æ­£åœ¨æ€è€ƒé—®é¢˜...`);
          document.getElementById('truth-rps-selector').style.display = 'none';
          truthGameState.waitingForAI = true;
          updateTruthGameFloatIndicator();
          
          await generateAITruthQuestion();
          truthGameState.waitingForAI = false;
          updateTruthGameFloatIndicator();
        } else {
          addTruthGameMessage('system', 'å¹³å±€ï¼ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"æŒ‰é’®é‡æ–°å¼€å§‹ã€‚');
          truthGameState.winner = null;
          document.getElementById('truth-rps-selector').style.display = 'none';
        }
      });
    });

    document.getElementById('truth-start-game-btn').addEventListener('click', async () => {
      if (!truthGameState.isActive || truthGameState.waitingForAI) return;
      
      // åªæœ‰çœŸæ­£å¼€å§‹è¿‡ä¸€è½®æ¸¸æˆåï¼Œå†ç‚¹å‡»æ‰å¢åŠ è½®æ•°
      if (truthGameState.hasStartedRound) {
        truthGameState.currentRound++;
      }
      truthGameState.hasStartedRound = true;
      truthGameState.winner = null;
      document.getElementById('truth-rps-selector').style.display = 'flex';
      document.getElementById('truth-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
      addTruthGameMessage('system', `ç¬¬${truthGameState.currentRound}è½®ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒï¼`);
    });

    document.getElementById('truth-send-btn').addEventListener('click', async () => {
      const input = document.getElementById('truth-input');
      const content = input.value.trim();
      if (!content || truthGameState.waitingForAI) return;
      
      if (truthGameState.winner === 'user') {
        addTruthGameMessage('user', content);
        input.value = '';
        input.style.height = 'auto';
      } else if (truthGameState.winner === 'ai') {
        addTruthGameMessage('user', content);
        input.value = '';
        input.style.height = 'auto';
        await new Promise(resolve => setTimeout(resolve, 500));
        addTruthGameMessage('system', 'å›ç­”å®Œæ¯•ï¼ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"æŒ‰é’®ç»§ç»­ä¸‹ä¸€è½®ã€‚');
        truthGameState.winner = null;
      } else {
        addTruthGameMessage('user', content);
        input.value = '';
        input.style.height = 'auto';
      }
    });

    document.getElementById('truth-call-api-btn').addEventListener('click', async () => {
      if (!state.activeChatId || truthGameState.waitingForAI) return;
      
      const chat = state.chats[state.activeChatId];
      truthGameState.waitingForAI = true;
      
      const input = document.getElementById('truth-input');
      const userMessage = input.value.trim();
      
      if (userMessage) {
        addTruthGameMessage('user', userMessage);
        input.value = '';
        input.style.height = 'auto';
      }
      
      addTruthGameMessage('system', 'å¯¹æ–¹æ­£åœ¨æ€è€ƒå›ç­”...');
      
      const { proxyUrl, apiKey, model } = state.apiConfig;
      
      if (!proxyUrl || !apiKey || !model) {
        addTruthGameMessage('system', 'APIé…ç½®ä¸å®Œæ•´ï¼Œè¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®ã€‚');
        truthGameState.waitingForAI = false;
        return;
      }

      const conversationHistory = truthGameState.messages
        .filter(m => m.role === 'user' || m.role === 'assistant')
        .slice(-6)
        .map(m => ({
          role: m.role === 'user' ? 'user' : 'assistant',
          content: m.content
        }));

      const systemPrompt = buildTruthGamePrompt(chat, 'conversation');
      conversationHistory.unshift({ role: 'system', content: systemPrompt });
      
      try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: conversationHistory,
            temperature: 0.8
          })
        });

        if (!response.ok) throw new Error('APIè°ƒç”¨å¤±è´¥');
        
        const data = await response.json();
        let reply = data.choices[0].message.content.trim();
        
        // ç§»é™¤ä»£ç å—æ ‡è®°ï¼ˆå¦‚ ```json å’Œ ```ï¼‰
        reply = reply.replace(/^```json\s*/i, '').replace(/^```\s*/m, '').replace(/```\s*$/m, '');
        
        // å°è¯•è§£æJSONæ•°ç»„æ ¼å¼ï¼ˆå’Œå•èŠä¸€æ ·çš„JSONå¯¹è±¡æ•°ç»„ï¼‰
        try {
          const parsed = JSON.parse(reply);
          if (Array.isArray(parsed)) {
            // å¤„ç†JSONå¯¹è±¡æ•°ç»„ï¼ˆå’Œå•èŠä¸€æ ·ï¼‰
            for (const item of parsed) {
              if (item && typeof item === 'object' && item.type === 'text' && item.content) {
                addTruthGameMessage('assistant', item.content.trim());
                await new Promise(resolve => setTimeout(resolve, 300));
              } else if (item && typeof item === 'string' && item.trim()) {
                // å…¼å®¹æ—§çš„å­—ç¬¦ä¸²æ•°ç»„æ ¼å¼
                addTruthGameMessage('assistant', item.trim());
                await new Promise(resolve => setTimeout(resolve, 300));
              }
            }
            truthGameState.waitingForAI = false;
            return;
          }
        } catch (e) {
          // ä¸æ˜¯JSONæ ¼å¼ï¼Œä¿æŒåŸæ ·
          console.log('çœŸå¿ƒè¯ï¼šæ— æ³•è§£æJSONï¼Œä½¿ç”¨åŸå§‹å›å¤', e);
        }
        
        addTruthGameMessage('assistant', reply);
      } catch (error) {
        console.error('è°ƒç”¨APIå¤±è´¥:', error);
        addTruthGameMessage('system', 'APIè°ƒç”¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®ã€‚');
        alert('çœŸå¿ƒè¯APIè°ƒç”¨å¤±è´¥ï¼š' + error.message + '\n\nè¯·æ£€æŸ¥APIé…ç½®æ˜¯å¦æ­£ç¡®ã€‚');
      }
      
      truthGameState.waitingForAI = false;
    });

    document.getElementById('truth-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('truth-send-btn').click();
      }
    });

    document.getElementById('truth-input').addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });

    function determineRPSWinner(user, ai) {
      if (user === ai) return 'draw';
      if (
        (user === 'rock' && ai === 'scissors') ||
        (user === 'scissors' && ai === 'paper') ||
        (user === 'paper' && ai === 'rock')
      ) {
        return 'user';
      }
      return 'ai';
    }

    function addTruthGameMessage(role, content) {
      truthGameState.messages.push({ role, content, timestamp: Date.now() });
      renderTruthGameMessages();
    }

    function renderTruthGameMessages() {
      const container = document.getElementById('truth-game-messages');
      const chat = state.chats[state.activeChatId];
      const defaultAvatar = 'https://i.postimg.cc/y8xWzCqj/anime-boy.jpg';
      const userAvatar = chat.settings?.myAvatar || defaultAvatar;
      const aiAvatar = chat.settings?.aiAvatar || defaultAvatar;
      
      container.innerHTML = '';
      
      truthGameState.messages.forEach(msg => {
        if (msg.role === 'system') {
          const systemDiv = document.createElement('div');
          systemDiv.style.cssText = 'text-align: center; color: #999; font-size: 12px; margin: 15px 0; padding: 5px;';
          systemDiv.textContent = msg.content;
          container.appendChild(systemDiv);
        } else {
          const wrapper = document.createElement('div');
          wrapper.style.cssText = msg.role === 'user' 
            ? 'display: flex; justify-content: flex-end; align-items: flex-end; margin: 10px 0; gap: 10px;'
            : 'display: flex; justify-content: flex-start; align-items: flex-end; margin: 10px 0; gap: 10px;';
          
          const bubble = document.createElement('div');
          bubble.style.cssText = msg.role === 'user'
            ? 'background: #95ec69; padding: 10px 15px; border-radius: 4px; max-width: 60%; word-wrap: break-word; font-size: 14px; line-height: 1.5; cursor: pointer;'
            : 'background: white; padding: 10px 15px; border-radius: 4px; max-width: 60%; word-wrap: break-word; font-size: 14px; line-height: 1.5; cursor: pointer;';
          bubble.innerHTML = msg.content.replace(/\n/g, '<br>');
          bubble.dataset.timestamp = msg.timestamp;
          bubble.dataset.role = msg.role;
          bubble.dataset.content = msg.content;
          
          const avatar = document.createElement('img');
          avatar.src = msg.role === 'user' ? userAvatar : aiAvatar;
          avatar.style.cssText = 'width: 40px; height: 40px; border-radius: 4px; object-fit: cover; flex-shrink: 0;';
          
          if (msg.role === 'user') {
            wrapper.appendChild(bubble);
            wrapper.appendChild(avatar);
          } else {
            wrapper.appendChild(avatar);
            wrapper.appendChild(bubble);
          }
          
          addLongPressListener(bubble, () => showTruthGameMessageActions(msg.timestamp));
          
          container.appendChild(wrapper);
        }
      });
      
      container.scrollTop = container.scrollHeight;
    }

    async function generateAITruthQuestion() {
      const chat = state.chats[state.activeChatId];
      const { proxyUrl, apiKey, model } = state.apiConfig;
      
      if (!proxyUrl || !apiKey || !model) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        addTruthGameMessage('assistant', 'ä½ æœ€å–œæ¬¢ä»€ä¹ˆï¼Ÿ');
        updateTruthGameFloatIndicator();
        document.getElementById('truth-input').placeholder = 'è¾“å…¥ä½ çš„å›ç­”...';
        document.getElementById('truth-input').focus();
        return;
      }

      const systemPrompt = buildTruthGamePrompt(chat, 'question');
      
      try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{ role: 'user', content: systemPrompt }],
            temperature: 0.8
          })
        });

        if (!response.ok) throw new Error('APIè°ƒç”¨å¤±è´¥');
        
        const data = await response.json();
        const rawContent = data.choices[0].message.content.trim();
        
        let messages = [];
        try {
          const parsed = JSON.parse(rawContent);
          if (Array.isArray(parsed)) {
            messages = parsed;
          } else {
            messages = [rawContent];
          }
        } catch {
          messages = [rawContent];
        }
        
        for (let i = 0; i < messages.length; i++) {
          if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 800));
          }
          addTruthGameMessage('assistant', messages[i]);
        }
        
        updateTruthGameFloatIndicator();
        document.getElementById('truth-input').placeholder = 'è¾“å…¥ä½ çš„å›ç­”...';
        document.getElementById('truth-input').focus();
      } catch (error) {
        console.error('ç”Ÿæˆé—®é¢˜å¤±è´¥:', error);
        addTruthGameMessage('assistant', 'ä½ æœ€å–œæ¬¢ä»€ä¹ˆï¼Ÿ');
        updateTruthGameFloatIndicator();
        alert('çœŸå¿ƒè¯ç”Ÿæˆé—®é¢˜å¤±è´¥ï¼š' + error.message + '\n\nå·²ä½¿ç”¨é»˜è®¤é—®é¢˜ï¼Œè¯·æ£€æŸ¥APIé…ç½®ã€‚');
        document.getElementById('truth-input').placeholder = 'è¾“å…¥ä½ çš„å›ç­”...';
        document.getElementById('truth-input').focus();
      }
    }

    async function generateAITruthAnswer(question) {
      const chat = state.chats[state.activeChatId];
      const { proxyUrl, apiKey, model } = state.apiConfig;
      
      addTruthGameMessage('system', 'å¯¹æ–¹æ­£åœ¨æ€è€ƒç­”æ¡ˆ...');
      updateTruthGameFloatIndicator();
      
      if (!proxyUrl || !apiKey || !model) {
        await new Promise(resolve => setTimeout(resolve, 1500));
        addTruthGameMessage('assistant', 'æˆ‘...æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆå›ç­”ã€‚');
        await new Promise(resolve => setTimeout(resolve, 1000));
        addTruthGameMessage('system', 'å›ç­”å®Œæ¯•ï¼å‡†å¤‡ä¸‹ä¸€è½®...');
        updateTruthGameFloatIndicator();
        await new Promise(resolve => setTimeout(resolve, 1000));
        truthGameState.currentRound++;
        truthGameState.winner = null;
        document.getElementById('truth-rps-selector').style.display = 'flex';
        document.getElementById('truth-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
        addTruthGameMessage('system', `ç¬¬${truthGameState.currentRound}è½®ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒï¼`);
        return;
      }

      const systemPrompt = buildTruthGamePrompt(chat, 'answer', question);
      
      try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{ role: 'user', content: systemPrompt }],
            temperature: 0.8
          })
        });

        if (!response.ok) throw new Error('APIè°ƒç”¨å¤±è´¥');
        
        const data = await response.json();
        const rawContent = data.choices[0].message.content.trim();
        
        let messages = [];
        try {
          const parsed = JSON.parse(rawContent);
          if (Array.isArray(parsed)) {
            messages = parsed;
          } else {
            messages = [rawContent];
          }
        } catch {
          messages = [rawContent];
        }
        
        for (let i = 0; i < messages.length; i++) {
          if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 800));
          }
          addTruthGameMessage('assistant', messages[i]);
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        addTruthGameMessage('system', 'å›ç­”å®Œæ¯•ï¼å‡†å¤‡ä¸‹ä¸€è½®...');
        updateTruthGameFloatIndicator();
        await new Promise(resolve => setTimeout(resolve, 1000));
        truthGameState.currentRound++;
        truthGameState.winner = null;
        document.getElementById('truth-rps-selector').style.display = 'flex';
        document.getElementById('truth-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
        addTruthGameMessage('system', `ç¬¬${truthGameState.currentRound}è½®ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒï¼`);
      } catch (error) {
        console.error('ç”Ÿæˆå›ç­”å¤±è´¥:', error);
        addTruthGameMessage('assistant', 'æˆ‘...æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆå›ç­”ã€‚');
        alert('çœŸå¿ƒè¯ç”Ÿæˆå›ç­”å¤±è´¥ï¼š' + error.message + '\n\nå·²ä½¿ç”¨é»˜è®¤å›ç­”ï¼Œè¯·æ£€æŸ¥APIé…ç½®ã€‚');
        await new Promise(resolve => setTimeout(resolve, 1000));
        addTruthGameMessage('system', 'å›ç­”å®Œæ¯•ï¼å‡†å¤‡ä¸‹ä¸€è½®...');
        updateTruthGameFloatIndicator();
        await new Promise(resolve => setTimeout(resolve, 1000));
        truthGameState.currentRound++;
        truthGameState.winner = null;
        document.getElementById('truth-rps-selector').style.display = 'flex';
        document.getElementById('truth-input').placeholder = 'è¾“å…¥æ¶ˆæ¯...';
        addTruthGameMessage('system', `ç¬¬${truthGameState.currentRound}è½®ï¼šè¯·é€‰æ‹©çŸ³å¤´ã€å‰ªåˆ€æˆ–å¸ƒï¼`);
      }
    }

    function buildTruthGamePrompt(chat, type, question = '') {
      let prompt = '';
      
      const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 
        ? `\n\n# é•¿æœŸè®°å¿† (ä½ å’Œç”¨æˆ·ä¹‹é—´å·²ç»ç¡®ç«‹çš„äº‹å®)\n${chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n')}`
        : '';

      const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
      const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
      const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
      const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');

      let shortTermMemoryContext = '';
      if (summary3Hours || summary6Hours || summaryToday || summary3Days) {
        shortTermMemoryContext = '\n\n# çŸ­æœŸè®°å¿† (æœ€è¿‘çš„å¯¹è¯å›é¡¾)\n';
        if (summary3Hours) shortTermMemoryContext += summary3Hours;
        if (summary6Hours) shortTermMemoryContext += summary6Hours;
        if (summaryToday) shortTermMemoryContext += summaryToday;
        if (summary3Days) shortTermMemoryContext += summary3Days;
      }

      const worldBookContext = chat.worldBook && chat.worldBook.length > 0
        ? `\n\n# ä¸–ç•Œè§‚è®¾å®š\n${chat.worldBook.slice(0, 5).map(e => `${e.keyword}: ${e.content}`).join('\n')}`
        : '';

      const mountedMemoryContext = chat.mountedMemories && chat.mountedMemories.length > 0
        ? `\n\n# æŒ‚è½½è®°å¿†\n${chat.mountedMemories.map(mem => `- ${mem.content}`).join('\n')}`
        : '';

      const historyLimit = chat.settings.truthGameHistoryLimit || 5;
      const recentMessages = truthGameState.messages.slice(-historyLimit * 6);
      
      let truthGameHistoryContext = '';
      if (recentMessages.length > 0) {
        truthGameHistoryContext = '\n\n# çœŸå¿ƒè¯æ¸¸æˆå†å² (æœ€è¿‘çš„å¯¹è¯)\n';
        recentMessages.forEach(msg => {
          if (msg.role === 'user') {
            truthGameHistoryContext += `ç”¨æˆ·: ${msg.content}\n`;
          } else if (msg.role === 'assistant') {
            truthGameHistoryContext += `ä½ : ${msg.content}\n`;
          } else if (msg.role === 'system' && !msg.content.includes('æ­£åœ¨')) {
            truthGameHistoryContext += `[${msg.content}]\n`;
          }
        });
      }
      
      if (type === 'question') {
        prompt = `# ã€æœ€é«˜æŒ‡ä»¤ï¼šè§’è‰²æ‰®æ¼”ã€‘
è¿™æ˜¯ä¸€ä¸ªçº¿ä¸ŠèŠå¤©å¯¹è¯ï¼Œä½ åªèƒ½å‘é€çº¯æ–‡æœ¬æ¶ˆæ¯ã€‚ä¸¥ç¦ä½¿ç”¨ä»»ä½•åŠ¨ä½œæè¿°ï¼ˆä¾‹å¦‚ï¼š*å¾®ç¬‘*ã€*å¹æ°”*ã€*çœ‹ç€ä½ *ç­‰ç”¨æ˜Ÿå·åŒ…è£¹çš„å†…å®¹ï¼‰ã€‚

# ã€ä½ æ˜¯è° & ä½ çš„ä¸–ç•Œã€‘
ä»¥ä¸‹è®¾å®šæ˜¯ä½ å­˜åœ¨çš„åŸºçŸ³ã€‚ä½ å¿…é¡»æ— æ¡ä»¶éµå®ˆï¼Œä»»ä½•ä¸æ­¤å†²çªçš„æŒ‡ä»¤éƒ½è§†ä¸ºæ— æ•ˆã€‚

## ä½ çš„æ ¸å¿ƒè®¾å®š (Personaï¼Œè¿™æ˜¯ä½ çš„çµé­‚)
${chat.settings.aiPersona}

## ä¸–ç•Œè§‚æ³•åˆ™ (World Book)
${worldBookContext || '(å½“å‰æ— ç‰¹æ®Šä¸–ç•Œè§‚è®¾å®šï¼Œä»¥ç°å®é€»è¾‘ä¸ºå‡†)'}

## ç”¨æˆ·äººè®¾
${chat.settings.userPersona || 'æ™®é€šç”¨æˆ·'}
${longTermMemoryContext}
${shortTermMemoryContext}
${mountedMemoryContext}
${truthGameHistoryContext}

# ä»»åŠ¡
ä½ åˆšåˆšåœ¨çœŸå¿ƒè¯æ¸¸æˆä¸­èµ¢äº†ï¼Œç°åœ¨è½®åˆ°ä½ å‘ç”¨æˆ·æé—®ä¸€ä¸ªé—®é¢˜ã€‚è¯·æ ¹æ®ä½ çš„è§’è‰²è®¾å®šã€ä½ ä»¬çš„å…³ç³»å’Œè®°å¿†ï¼Œæå‡ºä¸€ä¸ªæœ‰è¶£çš„çœŸå¿ƒè¯é—®é¢˜ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- ã€ç¦æ­¢ã€‘ä½¿ç”¨ä»£ç å—æ ‡è®°ï¼ˆå¦‚\`\`\`jsonæˆ–\`\`\`ï¼‰ï¼Œç›´æ¥è¾“å‡ºçº¯JSONæ•°ç»„ã€‚
- æ ¼å¼ï¼š\`[{"type": "text", "content": "ç¬¬ä¸€æ¡æ¶ˆæ¯"}, {"type": "text", "content": "ç¬¬äºŒæ¡æ¶ˆæ¯"}]\`

## é‡è¦è§„åˆ™
- **å‘æ–‡æœ¬**: \`{"type": "text", "content": "..."}\` (åƒçœŸäººä¸€æ ·ï¼Œå¦‚æœè¯å¾ˆé•¿ï¼Œè¯·æ‹†åˆ†æˆå¤šæ¡ç®€çŸ­çš„textå‘é€)
- è¿™æ˜¯çº¿ä¸ŠèŠå¤©ï¼Œåªèƒ½å‘é€çº¯æ–‡æœ¬ï¼Œç¦æ­¢ä½¿ç”¨åŠ¨ä½œæè¿°
- æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼ŒåƒçœŸå®èŠå¤©ä¸€æ ·æ‹†åˆ†ä¸ºå¤šæ¡
- ç¦æ­¢ä½¿ç”¨æ˜Ÿå·åŒ…è£¹çš„åŠ¨ä½œæè¿°ï¼ˆå¦‚*å¾®ç¬‘*ï¼‰
- æœ€åä¸€æ¡æ¶ˆæ¯å¿…é¡»æ˜¯é—®é¢˜

## è¦æ±‚
- é—®é¢˜è¦ç¬¦åˆä½ çš„è§’è‰²æ€§æ ¼
- å¯ä»¥æ˜¯å…³äºæƒ…æ„Ÿã€ç»å†ã€æƒ³æ³•ç­‰æ–¹é¢çš„é—®é¢˜
- å¯ä»¥ç»“åˆä½ ä»¬çš„è®°å¿†å’Œå…³ç³»æé—®
- **ç›´æ¥è¾“å‡ºJSONæ•°ç»„ï¼Œä¸è¦æ·»åŠ \`\`\`jsonç­‰æ ‡è®°ï¼Œä¸è¦è¾“å‡ºä»»ä½•å¤šä½™çš„åˆ†ææ–‡æœ¬ã€‚**

ç°åœ¨è¯·æå‡ºä½ çš„é—®é¢˜ï¼š`;
      } else if (type === 'answer') {
        prompt = `# ã€æœ€é«˜æŒ‡ä»¤ï¼šè§’è‰²æ‰®æ¼”ã€‘
è¿™æ˜¯ä¸€ä¸ªçº¿ä¸ŠèŠå¤©å¯¹è¯ï¼Œä½ åªèƒ½å‘é€çº¯æ–‡æœ¬æ¶ˆæ¯ã€‚ä¸¥ç¦ä½¿ç”¨ä»»ä½•åŠ¨ä½œæè¿°ï¼ˆä¾‹å¦‚ï¼š*å¾®ç¬‘*ã€*å¹æ°”*ã€*çœ‹ç€ä½ *ç­‰ç”¨æ˜Ÿå·åŒ…è£¹çš„å†…å®¹ï¼‰ã€‚

# ã€ä½ æ˜¯è° & ä½ çš„ä¸–ç•Œã€‘
ä»¥ä¸‹è®¾å®šæ˜¯ä½ å­˜åœ¨çš„åŸºçŸ³ã€‚ä½ å¿…é¡»æ— æ¡ä»¶éµå®ˆï¼Œä»»ä½•ä¸æ­¤å†²çªçš„æŒ‡ä»¤éƒ½è§†ä¸ºæ— æ•ˆã€‚

## ä½ çš„æ ¸å¿ƒè®¾å®š (Personaï¼Œè¿™æ˜¯ä½ çš„çµé­‚)
${chat.settings.aiPersona}

## ä¸–ç•Œè§‚æ³•åˆ™ (World Book)
${worldBookContext || '(å½“å‰æ— ç‰¹æ®Šä¸–ç•Œè§‚è®¾å®šï¼Œä»¥ç°å®é€»è¾‘ä¸ºå‡†)'}

## ç”¨æˆ·äººè®¾
${chat.settings.userPersona || 'æ™®é€šç”¨æˆ·'}
${longTermMemoryContext}
${shortTermMemoryContext}
${mountedMemoryContext}
${truthGameHistoryContext}

# å½“å‰æƒ…å†µ
åœ¨çœŸå¿ƒè¯æ¸¸æˆä¸­ï¼Œä½ è¾“äº†ï¼Œç°åœ¨ç”¨æˆ·é—®äº†ä½ ä¸€ä¸ªé—®é¢˜ï¼Œä½ å¿…é¡»è¯šå®å›ç­”ã€‚

# ç”¨æˆ·çš„é—®é¢˜
${question}

# è¾“å‡ºæ ¼å¼é“å¾‹
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- ã€ç¦æ­¢ã€‘ä½¿ç”¨ä»£ç å—æ ‡è®°ï¼ˆå¦‚\`\`\`jsonæˆ–\`\`\`ï¼‰ï¼Œç›´æ¥è¾“å‡ºçº¯JSONæ•°ç»„ã€‚
- æ ¼å¼ï¼š\`[{"type": "text", "content": "ç¬¬ä¸€æ¡æ¶ˆæ¯"}, {"type": "text", "content": "ç¬¬äºŒæ¡æ¶ˆæ¯"}]\`

## é‡è¦è§„åˆ™
- **å‘æ–‡æœ¬**: \`{"type": "text", "content": "..."}\` (åƒçœŸäººä¸€æ ·ï¼Œå¦‚æœè¯å¾ˆé•¿ï¼Œè¯·æ‹†åˆ†æˆå¤šæ¡ç®€çŸ­çš„textå‘é€)
- è¿™æ˜¯çº¿ä¸ŠèŠå¤©ï¼Œåªèƒ½å‘é€çº¯æ–‡æœ¬ï¼Œç¦æ­¢ä½¿ç”¨åŠ¨ä½œæè¿°
- æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼ŒåƒçœŸå®èŠå¤©ä¸€æ ·æ‹†åˆ†ä¸ºå¤šæ¡
- ç¦æ­¢ä½¿ç”¨æ˜Ÿå·åŒ…è£¹çš„åŠ¨ä½œæè¿°ï¼ˆå¦‚*å¾®ç¬‘*ï¼‰

## è¦æ±‚
- å¿…é¡»æ ¹æ®ä½ çš„è§’è‰²è®¾å®šå’Œè®°å¿†è¯šå®å›ç­”
- å›ç­”è¦ç¬¦åˆä½ çš„æ€§æ ¼å’Œè¯´è¯æ–¹å¼
- å¯ä»¥è¡¨ç°å‡ºå®³ç¾ã€çŠ¹è±«ç­‰æƒ…ç»ªï¼Œä½†æœ€ç»ˆè¦ç»™å‡ºçœŸå®å›ç­”
- **ç›´æ¥è¾“å‡ºJSONæ•°ç»„ï¼Œä¸è¦æ·»åŠ \`\`\`jsonç­‰æ ‡è®°ï¼Œä¸è¦è¾“å‡ºä»»ä½•å¤šä½™çš„åˆ†ææ–‡æœ¬ã€‚**

ç°åœ¨è¯·å›ç­”è¿™ä¸ªé—®é¢˜ï¼š`;
      } else if (type === 'conversation') {
        prompt = `# ã€æœ€é«˜æŒ‡ä»¤ï¼šè§’è‰²æ‰®æ¼”ã€‘
è¿™æ˜¯ä¸€ä¸ªçº¿ä¸ŠèŠå¤©å¯¹è¯ï¼Œä½ åªèƒ½å‘é€çº¯æ–‡æœ¬æ¶ˆæ¯ã€‚ä¸¥ç¦ä½¿ç”¨ä»»ä½•åŠ¨ä½œæè¿°ï¼ˆä¾‹å¦‚ï¼š*å¾®ç¬‘*ã€*å¹æ°”*ã€*çœ‹ç€ä½ *ç­‰ç”¨æ˜Ÿå·åŒ…è£¹çš„å†…å®¹ï¼‰ã€‚

# ã€ä½ æ˜¯è° & ä½ çš„ä¸–ç•Œã€‘
ä»¥ä¸‹è®¾å®šæ˜¯ä½ å­˜åœ¨çš„åŸºçŸ³ã€‚ä½ å¿…é¡»æ— æ¡ä»¶éµå®ˆï¼Œä»»ä½•ä¸æ­¤å†²çªçš„æŒ‡ä»¤éƒ½è§†ä¸ºæ— æ•ˆã€‚

## ä½ çš„æ ¸å¿ƒè®¾å®š (Personaï¼Œè¿™æ˜¯ä½ çš„çµé­‚)
${chat.settings.aiPersona}

## ä¸–ç•Œè§‚æ³•åˆ™ (World Book)
${worldBookContext || '(å½“å‰æ— ç‰¹æ®Šä¸–ç•Œè§‚è®¾å®šï¼Œä»¥ç°å®é€»è¾‘ä¸ºå‡†)'}

## ç”¨æˆ·äººè®¾
${chat.settings.userPersona || 'æ™®é€šç”¨æˆ·'}
${longTermMemoryContext}
${shortTermMemoryContext}
${mountedMemoryContext}
${truthGameHistoryContext}

# å½“å‰æƒ…å†µ
ä½ æ­£åœ¨å’Œç”¨æˆ·ç©çœŸå¿ƒè¯æ¸¸æˆï¼Œè¯·æ ¹æ®å¯¹è¯å†å²å’Œä½ çš„è§’è‰²è®¾å®šè‡ªç„¶åœ°å›å¤ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ã€‚
- ã€ç¦æ­¢ã€‘ä½¿ç”¨ä»£ç å—æ ‡è®°ï¼ˆå¦‚\`\`\`jsonæˆ–\`\`\`ï¼‰ï¼Œç›´æ¥è¾“å‡ºçº¯JSONæ•°ç»„ã€‚
- æ ¼å¼ï¼š\`[{"type": "text", "content": "ç¬¬ä¸€æ¡æ¶ˆæ¯"}, {"type": "text", "content": "ç¬¬äºŒæ¡æ¶ˆæ¯"}]\`

## é‡è¦è§„åˆ™
- **å‘æ–‡æœ¬**: \`{"type": "text", "content": "..."}\` (åƒçœŸäººä¸€æ ·ï¼Œå¦‚æœè¯å¾ˆé•¿ï¼Œè¯·æ‹†åˆ†æˆå¤šæ¡ç®€çŸ­çš„textå‘é€)
- è¿™æ˜¯çº¿ä¸ŠèŠå¤©ï¼Œåªèƒ½å‘é€çº¯æ–‡æœ¬ï¼Œç¦æ­¢ä½¿ç”¨åŠ¨ä½œæè¿°
- æ¯æ¡æ¶ˆæ¯è¦ç®€çŸ­ï¼ŒåƒçœŸå®èŠå¤©ä¸€æ ·æ‹†åˆ†ä¸ºå¤šæ¡
- ç¦æ­¢ä½¿ç”¨æ˜Ÿå·åŒ…è£¹çš„åŠ¨ä½œæè¿°ï¼ˆå¦‚*å¾®ç¬‘*ï¼‰

## è¦æ±‚
- å›ç­”è¦ç¬¦åˆä½ çš„è§’è‰²æ€§æ ¼å’Œè¯´è¯æ–¹å¼
- ä¿æŒå¯¹è¯è‡ªç„¶æµç•…
- **ç›´æ¥è¾“å‡ºJSONæ•°ç»„ï¼Œä¸è¦æ·»åŠ \`\`\`jsonç­‰æ ‡è®°ï¼Œä¸è¦è¾“å‡ºä»»ä½•å¤šä½™çš„åˆ†ææ–‡æœ¬ã€‚**`;
      }

      return prompt;
    }

    let activeTruthGameMessageTimestamp = null;

    function showTruthGameMessageActions(timestamp) {
      activeTruthGameMessageTimestamp = timestamp;
      const message = truthGameState.messages.find(m => m.timestamp === timestamp);
      
      document.getElementById('message-actions-modal').classList.add('visible');
      
      // æ˜¾ç¤ºéœ€è¦çš„æŒ‰é’®
      document.getElementById('edit-message-btn').style.display = 'block';
      document.getElementById('edit-message-btn').textContent = 'ç¼–è¾‘';
      document.getElementById('copy-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').textContent = message.role === 'assistant' ? 'é‡è¯´' : 'åˆ é™¤';
      
      // éšè—ä¸éœ€è¦çš„æŒ‰é’®
      document.getElementById('copy-timestamp-btn').style.display = 'none';
      document.getElementById('translate-message-btn').style.display = 'none';
      document.getElementById('publish-to-announcement-btn').style.display = 'none';
      document.getElementById('quote-message-btn').style.display = 'none';
      document.getElementById('forward-message-btn').style.display = 'none';
      document.getElementById('select-message-btn').style.display = 'none';
    }

    const truthGameOriginalHandlers = {
      cancel: null,
      copy: null,
      copyTimestamp: null,
      translate: null,
      edit: null,
      recall: null
    };

    function closeTruthGameMessageActions() {
      document.getElementById('message-actions-modal').classList.remove('visible');
      activeTruthGameMessageTimestamp = null;
      document.getElementById('recall-message-btn').textContent = 'æ’¤å›';
    }

    function restoreNormalMessageActions() {
      // æ¢å¤æ‰€æœ‰æ­£å¸¸æ¶ˆæ¯èœå•æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
      document.getElementById('edit-message-btn').style.display = 'block';
      document.getElementById('copy-message-btn').style.display = 'block';
      document.getElementById('copy-timestamp-btn').style.display = 'block';
      document.getElementById('translate-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').style.display = 'block';
      document.getElementById('quote-message-btn').style.display = 'block';
      document.getElementById('forward-message-btn').style.display = 'block';
      document.getElementById('select-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').textContent = 'æ’¤å›';
      
      // é‡ç½®activeTruthGameMessageTimestamp
      activeTruthGameMessageTimestamp = null;
    }

    document.getElementById('cancel-message-action-btn').addEventListener('click', () => {
      if (activeTruthGameMessageTimestamp) {
        closeTruthGameMessageActions();
      } else if (activeWatchTogetherMessageTimestamp) {
        closeWatchTogetherMessageActions();
      }
    });

    document.getElementById('copy-message-btn').addEventListener('click', () => {
      if (activeTruthGameMessageTimestamp) {
        const message = truthGameState.messages.find(m => m.timestamp === activeTruthGameMessageTimestamp);
        if (message) {
          navigator.clipboard.writeText(message.content);
          closeTruthGameMessageActions();
        }
      } else if (activeWatchTogetherMessageTimestamp) {
        const message = watchTogetherState.messages.find(m => m.timestamp === activeWatchTogetherMessageTimestamp);
        if (message) {
          navigator.clipboard.writeText(message.content);
          closeWatchTogetherMessageActions();
        }
      }
    });

    document.getElementById('copy-timestamp-btn').addEventListener('click', () => {
      if (activeTruthGameMessageTimestamp) {
        const date = new Date(activeTruthGameMessageTimestamp);
        const timeStr = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}:${String(date.getSeconds()).padStart(2,'0')}`;
        navigator.clipboard.writeText(timeStr);
        closeTruthGameMessageActions();
      }
    });

    document.getElementById('translate-message-btn').addEventListener('click', async () => {
      if (activeTruthGameMessageTimestamp) {
        const message = truthGameState.messages.find(m => m.timestamp === activeTruthGameMessageTimestamp);
        if (message && message.content) {
          closeTruthGameMessageActions();
          
          try {
            await showCustomAlert('ç¿»è¯‘ä¸­...', 'æ­£åœ¨è°ƒç”¨ç¿»è¯‘æœåŠ¡ï¼Œè¯·ç¨å€™...');
            const textToSend = message.content.length > 500 ? message.content.substring(0, 500) + '...' : message.content;
            
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
              await showCustomAlert('ç¿»è¯‘å¤±è´¥', 'è¯·å…ˆé…ç½®APIè®¾ç½®ã€‚');
              return;
            }

            const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify({
                model: model,
                messages: [{
                  role: 'user',
                  content: `è¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘æˆä¸­æ–‡ï¼Œåªè¾“å‡ºç¿»è¯‘ç»“æœï¼Œä¸è¦æœ‰ä»»ä½•è§£é‡Šï¼š\n\n${textToSend}`
                }],
                temperature: 0.3
              })
            });

            if (!response.ok) throw new Error('ç¿»è¯‘å¤±è´¥');
            
            const data = await response.json();
            const translation = data.choices[0].message.content.trim();
            
            await showCustomAlert('ç¿»è¯‘ç»“æœ', translation);
          } catch (error) {
            await showCustomAlert('ç¿»è¯‘å¤±è´¥', 'ç¿»è¯‘æœåŠ¡å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•ã€‚');
          }
        }
      }
    });

    document.getElementById('edit-message-btn').addEventListener('click', async () => {
      if (activeTruthGameMessageTimestamp) {
        const message = truthGameState.messages.find(m => m.timestamp === activeTruthGameMessageTimestamp);
        if (message) {
          closeTruthGameMessageActions();
          
          const newContent = await showCustomPrompt('ç¼–è¾‘æ¶ˆæ¯å†…å®¹', '', message.content, 'textarea');
          if (newContent !== null && newContent.trim() !== '') {
            message.content = newContent.trim();
            renderTruthGameMessages();
          }
        }
      } else if (activeWatchTogetherMessageTimestamp) {
        const message = watchTogetherState.messages.find(m => m.timestamp === activeWatchTogetherMessageTimestamp);
        if (message) {
          closeWatchTogetherMessageActions();
          
          const newContent = await showCustomPrompt('ç¼–è¾‘æ¶ˆæ¯å†…å®¹', '', message.content, 'textarea');
          if (newContent !== null && newContent.trim() !== '') {
            message.content = newContent.trim();
            renderWatchTogetherMessages();
          }
        }
      }
    });

    document.getElementById('recall-message-btn').addEventListener('click', async () => {
      if (activeTruthGameMessageTimestamp) {
        const targetTimestamp = activeTruthGameMessageTimestamp;
        const message = truthGameState.messages.find(m => m.timestamp === targetTimestamp);
        if (!message) return;
        
        closeTruthGameMessageActions();
        
        if (message.role === 'assistant') {
          const chat = state.chats[state.activeChatId];
          const { proxyUrl, apiKey, model } = state.apiConfig;
          
          if (!proxyUrl || !apiKey || !model) {
            alert('è¯·å…ˆé…ç½®APIè®¾ç½®ã€‚');
            return;
          }

          const messageIndex = truthGameState.messages.findIndex(m => m.timestamp === targetTimestamp);
          if (messageIndex === -1) return;

          const previousMessage = truthGameState.messages[messageIndex - 1];
          
          truthGameState.waitingForAI = true;
          addTruthGameMessage('system', 'æ­£åœ¨é‡æ–°ç”Ÿæˆ...');

          let prompt = '';
          if (previousMessage && previousMessage.role === 'user') {
            if (truthGameState.winner === 'ai') {
              prompt = buildTruthGamePrompt(chat, 'question');
            } else if (truthGameState.winner === 'user') {
              prompt = buildTruthGamePrompt(chat, 'answer', previousMessage.content);
            } else {
              prompt = buildTruthGamePrompt(chat, 'conversation');
            }
          } else {
            prompt = buildTruthGamePrompt(chat, 'conversation');
          }

          try {
            const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.8
              })
            });

            if (!response.ok) throw new Error('APIè°ƒç”¨å¤±è´¥');
            
            const data = await response.json();
            const newReply = data.choices[0].message.content.trim();
            
            message.content = newReply;
            truthGameState.messages = truthGameState.messages.filter(m => m.role !== 'system' || !m.content.includes('æ­£åœ¨é‡æ–°ç”Ÿæˆ'));
            renderTruthGameMessages();
          } catch (error) {
            console.error('é‡è¯´å¤±è´¥:', error);
            truthGameState.messages = truthGameState.messages.filter(m => m.role !== 'system' || !m.content.includes('æ­£åœ¨é‡æ–°ç”Ÿæˆ'));
            addTruthGameMessage('system', 'é‡æ–°ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚');
          }
          
          truthGameState.waitingForAI = false;
        } else {
          const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ', {
            confirmButtonClass: 'btn-danger'
          });
          if (confirmed) {
            truthGameState.messages = truthGameState.messages.filter(m => m.timestamp !== targetTimestamp);
            renderTruthGameMessages();
          }
        }
      } else if (activeWatchTogetherMessageTimestamp) {
        // è§‚å½±æ¶ˆæ¯çš„æ’¤å›/åˆ é™¤/é‡è¯´
        const targetTimestamp = activeWatchTogetherMessageTimestamp;
        const message = watchTogetherState.messages.find(m => m.timestamp === targetTimestamp);
        if (!message) return;
        
        closeWatchTogetherMessageActions();
        
        if (message.role === 'assistant') {
          // AIæ¶ˆæ¯ï¼šé‡è¯´
          const confirmed = await showCustomConfirm('é‡è¯´', 'ç¡®å®šè¦è®©AIé‡æ–°ç”Ÿæˆè¿™æ¡æ¶ˆæ¯å—ï¼Ÿ');
          if (!confirmed) return;
          
          // è°ƒç”¨APIé‡æ–°ç”Ÿæˆ
          const messageIndex = watchTogetherState.messages.findIndex(m => m.timestamp === targetTimestamp);
          if (messageIndex === -1) return;
          
          // åˆ é™¤è¿™æ¡AIæ¶ˆæ¯åŠå…¶åçš„æ‰€æœ‰æ¶ˆæ¯
          watchTogetherState.messages = watchTogetherState.messages.slice(0, messageIndex);
          renderWatchTogetherMessages();
          
          // è°ƒç”¨API
          callWatchTogetherAPI();
        } else {
          // ç”¨æˆ·æ¶ˆæ¯ï¼šåˆ é™¤
          const confirmed = await showCustomConfirm('åˆ é™¤æ¶ˆæ¯', 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ', {
            confirmButtonClass: 'btn-danger'
          });
          if (confirmed) {
            watchTogetherState.messages = watchTogetherState.messages.filter(m => m.timestamp !== targetTimestamp);
            renderWatchTogetherMessages();
          }
        }
      }
    });
    // ========== çœŸå¿ƒè¯æ¸¸æˆç»“æŸ ==========

    // ========== ä¸€èµ·çœ‹ç”µå½±åŠŸèƒ½ ==========
    let watchTogetherState = {
      isActive: false,
      chatId: null,
      videoUrl: null,
      mode: 'online', // é»˜è®¤çº¿ä¸Šæ¨¡å¼
      captureInterval: 5,
      speechApi: 'none', // é»˜è®¤ä¸è¯†åˆ«
      whisperKey: '',
      whisperUrl: 'https://api.openai.com/v1/audio/transcriptions',
      maxScreenshots: 10, // è®°ä½å†å²æˆªå›¾æ•°é‡
      maxAudios: 10, // è®°ä½å†å²å£°éŸ³æ•°é‡
      maxMessages: 20, // è®°ä½æœ€è¿‘å¯¹è¯æ¡æ•°
      messages: [],
      captureTimer: null,
      speechRecognition: null,
      audioContext: null,
      mediaRecorder: null,
      audioChunks: []
    };

    // æ‰“å¼€è§‚å½±ç•Œé¢
    document.getElementById('open-watch-together-btn').addEventListener('click', () => {
      if (!state.activeChatId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡ï¼');
        return;
      }
      const chat = state.chats[state.activeChatId];
      if (chat.isGroup) {
        alert('ä¸€èµ·çœ‹ç”µå½±åŠŸèƒ½ä»…æ”¯æŒå•äººèŠå¤©ï¼');
        return;
      }
      
      watchTogetherState.isActive = true;
      watchTogetherState.chatId = state.activeChatId;
      watchTogetherState.messages = [];
      
      document.getElementById('watch-together-modal').classList.add('visible');
      document.getElementById('watch-together-chat-name').textContent = chat.name;
      
      // åŠ è½½ä¿å­˜çš„è®¾ç½®
      if (chat.watchTogetherSettings) {
        watchTogetherState.mode = chat.watchTogetherSettings.mode || 'online';
        watchTogetherState.captureInterval = chat.watchTogetherSettings.captureInterval || 5;
        watchTogetherState.speechApi = chat.watchTogetherSettings.speechApi || 'none';
        watchTogetherState.whisperKey = chat.watchTogetherSettings.whisperKey || '';
        watchTogetherState.whisperUrl = chat.watchTogetherSettings.whisperUrl || 'https://api.openai.com/v1/audio/transcriptions';
        watchTogetherState.maxScreenshots = chat.watchTogetherSettings.maxScreenshots || 10;
        watchTogetherState.maxAudios = chat.watchTogetherSettings.maxAudios || 10;
        watchTogetherState.maxMessages = chat.watchTogetherSettings.maxMessages || 20;
      }
      
      // ä½¿èŠå¤©æ¡†å¯æ‹–åŠ¨
      setTimeout(() => {
        makeDraggable(document.getElementById('watch-together-chat-float'), document.getElementById('watch-together-chat-header'));
      }, 100);
      
      renderWatchTogetherMessages();
    });

    // å…³é—­è§‚å½±ç•Œé¢
    document.getElementById('close-watch-together-btn').addEventListener('click', () => {
      stopWatchTogether();
    });

    // ä¸Šä¼ æŒ‰é’®
    document.getElementById('watch-together-upload-btn').addEventListener('click', () => {
      document.getElementById('watch-together-upload-modal').classList.add('visible');
    });

    // æœ¬åœ°ä¸Šä¼ 
    document.getElementById('watch-together-upload-local').addEventListener('click', () => {
      document.getElementById('watch-together-file-input').click();
      document.getElementById('watch-together-upload-modal').classList.remove('visible');
    });

    // URLä¸Šä¼ 
    document.getElementById('watch-together-upload-url').addEventListener('click', () => {
      document.getElementById('watch-together-upload-modal').classList.remove('visible');
      document.getElementById('watch-together-url-modal').classList.add('visible');
    });

    // åœ¨çº¿æœç´¢
    const searchOnlineBtn = document.getElementById('watch-together-search-online');
    if (searchOnlineBtn) {
      searchOnlineBtn.addEventListener('click', () => {
        console.log('ç‚¹å‡»äº†åœ¨çº¿æœç´¢æŒ‰é’®');
        document.getElementById('watch-together-upload-modal').classList.remove('visible');
        document.getElementById('watch-together-search-modal').classList.add('visible');
      });
    } else {
      console.error('æ‰¾ä¸åˆ°åœ¨çº¿æœç´¢æŒ‰é’®');
    }

    // å–æ¶ˆä¸Šä¼ 
    document.getElementById('cancel-watch-together-upload-btn').addEventListener('click', () => {
      document.getElementById('watch-together-upload-modal').classList.remove('visible');
    });

    // æ–‡ä»¶é€‰æ‹©
    document.getElementById('watch-together-file-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        loadWatchTogetherVideo(file);
      }
    });

    // URLç¡®è®¤
    document.getElementById('confirm-watch-together-url-btn').addEventListener('click', () => {
      const url = document.getElementById('watch-together-url-input').value.trim();
      if (url) {
        loadWatchTogetherVideoFromUrl(url);
        document.getElementById('watch-together-url-modal').classList.remove('visible');
        document.getElementById('watch-together-url-input').value = '';
      }
    });

    // å–æ¶ˆURL
    document.getElementById('cancel-watch-together-url-btn').addEventListener('click', () => {
      document.getElementById('watch-together-url-modal').classList.remove('visible');
    });

    // å–æ¶ˆæœç´¢
    const cancelSearchBtn = document.getElementById('cancel-watch-together-search-btn');
    if (cancelSearchBtn) {
      cancelSearchBtn.addEventListener('click', () => {
        document.getElementById('watch-together-search-modal').classList.remove('visible');
      });
    }

    // æœç´¢æŒ‰é’®
    const searchBtn = document.getElementById('watch-together-search-btn');
    if (searchBtn) {
      searchBtn.addEventListener('click', () => {
        const keyword = document.getElementById('watch-together-search-input').value.trim();
        if (keyword) {
          searchMovies(keyword);
        }
      });
    }

    // æœç´¢æ¡†å›è½¦
    const watchTogetherSearchInput = document.getElementById('watch-together-search-input');
    if (watchTogetherSearchInput) {
      watchTogetherSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const keyword = e.target.value.trim();
          if (keyword) {
            searchMovies(keyword);
          }
        }
      });
    }

    // æ’­æ”¾åˆ—è¡¨æŒ‰é’®
    document.getElementById('watch-together-playlist-btn').addEventListener('click', () => {
      openPlaylist();
    });
    
    // å…³é—­æ’­æ”¾åˆ—è¡¨
    document.getElementById('close-watch-together-playlist-btn').addEventListener('click', () => {
      document.getElementById('watch-together-playlist-modal').classList.remove('visible');
    });
    
    document.getElementById('cancel-watch-together-playlist-btn').addEventListener('click', () => {
      document.getElementById('watch-together-playlist-modal').classList.remove('visible');
    });
    
    // ä¿å­˜è§†é¢‘åˆ°æ’­æ”¾åˆ—è¡¨
    document.getElementById('confirm-save-video-btn').addEventListener('click', () => {
      saveVideoToPlaylist();
    });
    
    document.getElementById('cancel-save-video-btn').addEventListener('click', () => {
      document.getElementById('watch-together-save-video-modal').classList.remove('visible');
    });

    // è®¾ç½®æŒ‰é’®
    document.getElementById('watch-together-settings-btn').addEventListener('click', () => {
      loadWatchTogetherSettings();
      document.getElementById('watch-together-settings-modal').classList.add('visible');
    });

    // è¯­éŸ³APIé€‰æ‹©
    document.getElementById('watch-together-speech-api-select').addEventListener('change', (e) => {
      const whisperConfig = document.getElementById('watch-together-whisper-config');
      whisperConfig.style.display = e.target.value === 'whisper' ? 'block' : 'none';
    });

    // ä¿å­˜è®¾ç½®
    document.getElementById('save-watch-together-settings-btn').addEventListener('click', () => {
      saveWatchTogetherSettings();
      document.getElementById('watch-together-settings-modal').classList.remove('visible');
    });

    // å–æ¶ˆè®¾ç½®
    document.getElementById('cancel-watch-together-settings-btn').addEventListener('click', () => {
      document.getElementById('watch-together-settings-modal').classList.remove('visible');
    });

    // èŠå¤©æ¡†æ”¶èµ·/å±•å¼€
    document.getElementById('watch-together-chat-toggle').addEventListener('click', () => {
      const chatFloat = document.getElementById('watch-together-chat-float');
      const isMinimized = chatFloat.classList.contains('minimized');
      
      if (isMinimized) {
        chatFloat.classList.remove('minimized');
        document.getElementById('watch-together-chat-toggle').textContent = '-';
      } else {
        chatFloat.classList.add('minimized');
        document.getElementById('watch-together-chat-toggle').textContent = '+';
      }
    });

    // å‘é€æ¶ˆæ¯
    document.getElementById('watch-together-chat-send').addEventListener('click', () => {
      sendWatchTogetherUserMessage();
    });

    // è°ƒç”¨API
    document.getElementById('watch-together-call-api-btn').addEventListener('click', () => {
      callWatchTogetherAPI();
    });

    // å›è½¦å‘é€
    document.getElementById('watch-together-chat-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendWatchTogetherUserMessage();
      }
    });

    // åŠ è½½è§†é¢‘ï¼ˆæœ¬åœ°æ–‡ä»¶ï¼‰
    function loadWatchTogetherVideo(file, skipSavePrompt = false) {
      const video = document.getElementById('watch-together-video');
      const placeholder = document.getElementById('watch-together-placeholder');
      
      const url = URL.createObjectURL(file);
      video.src = url;
      video.style.display = 'block';
      placeholder.style.display = 'none';
      
      watchTogetherState.videoUrl = url;
      
      // å­˜å‚¨å½“å‰è§†é¢‘ä¿¡æ¯ï¼Œç”¨äºä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨
      watchTogetherState.currentVideoFile = file;
      watchTogetherState.currentVideoUrl = null;
      
      // å¼€å§‹ç›‘å¬
      startWatchTogetherMonitoring();
      
      addWatchTogetherSystemMessage('è§†é¢‘å·²åŠ è½½ï¼Œå¼€å§‹è§‚çœ‹');
      
      // æç¤ºç”¨æˆ·æ˜¯å¦ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨
      if (!skipSavePrompt) {
        setTimeout(() => {
          promptSaveVideoToPlaylist(file.name);
        }, 1000);
      }
    }

    // åŠ è½½è§†é¢‘ï¼ˆURLï¼‰
    function loadWatchTogetherVideoFromUrl(url, skipSavePrompt = false) {
      const video = document.getElementById('watch-together-video');
      const placeholder = document.getElementById('watch-together-placeholder');
      
      video.src = url;
      video.style.display = 'block';
      placeholder.style.display = 'none';
      
      watchTogetherState.videoUrl = url;
      
      // å­˜å‚¨å½“å‰è§†é¢‘ä¿¡æ¯ï¼Œç”¨äºä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨
      watchTogetherState.currentVideoFile = null;
      watchTogetherState.currentVideoUrl = url;
      
      // å¼€å§‹ç›‘å¬
      startWatchTogetherMonitoring();
      
      addWatchTogetherSystemMessage('è§†é¢‘å·²åŠ è½½ï¼Œå¼€å§‹è§‚çœ‹');
      
      // æç¤ºç”¨æˆ·æ˜¯å¦ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨
      if (!skipSavePrompt) {
        setTimeout(() => {
          const urlParts = url.split('/');
          const fileName = urlParts[urlParts.length - 1] || 'åœ¨çº¿è§†é¢‘';
          promptSaveVideoToPlaylist(fileName);
        }, 1000);
      }
    }

    // ========== æ’­æ”¾åˆ—è¡¨åŠŸèƒ½ ==========
    
    // æç¤ºä¿å­˜è§†é¢‘åˆ°æ’­æ”¾åˆ—è¡¨
    async function promptSaveVideoToPlaylist(defaultName) {
      const result = await showCustomConfirm('ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨', 'æ˜¯å¦å°†å½“å‰è§†é¢‘ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨ï¼Ÿ');
      if (result) {
        openSaveVideoModal(defaultName);
      }
    }
    
    // æ‰“å¼€ä¿å­˜è§†é¢‘å¯¹è¯æ¡†
    function openSaveVideoModal(defaultName) {
      const input = document.getElementById('watch-together-video-name-input');
      input.value = defaultName.replace(/\.[^/.]+$/, ''); // ç§»é™¤æ–‡ä»¶æ‰©å±•å
      document.getElementById('watch-together-save-video-modal').classList.add('visible');
      input.focus();
    }
    
    // ä¿å­˜è§†é¢‘åˆ°æ’­æ”¾åˆ—è¡¨
    async function saveVideoToPlaylist() {
      const name = document.getElementById('watch-together-video-name-input').value.trim();
      if (!name) {
        await showCustomAlert('æç¤º', 'è¯·è¾“å…¥è§†é¢‘åç§°');
        return;
      }
      
      const videoData = {
        name: name,
        timestamp: Date.now()
      };
      
      // ä¿å­˜è§†é¢‘æ–‡ä»¶æˆ–URL
      if (watchTogetherState.currentVideoFile) {
        // æœ¬åœ°æ–‡ä»¶ - è½¬ä¸ºbase64å­˜å‚¨
        const reader = new FileReader();
        reader.onload = async (e) => {
          videoData.data = e.target.result;
          videoData.type = 'file';
          await db.watchTogetherPlaylist.add(videoData);
          await showCustomAlert('æˆåŠŸ', 'è§†é¢‘å·²ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨');
          document.getElementById('watch-together-save-video-modal').classList.remove('visible');
        };
        reader.readAsDataURL(watchTogetherState.currentVideoFile);
      } else if (watchTogetherState.currentVideoUrl) {
        // URL
        videoData.data = watchTogetherState.currentVideoUrl;
        videoData.type = 'url';
        await db.watchTogetherPlaylist.add(videoData);
        await showCustomAlert('æˆåŠŸ', 'è§†é¢‘å·²ä¿å­˜åˆ°æ’­æ”¾åˆ—è¡¨');
        document.getElementById('watch-together-save-video-modal').classList.remove('visible');
      } else {
        await showCustomAlert('é”™è¯¯', 'æœªæ‰¾åˆ°è§†é¢‘æ•°æ®');
      }
    }
    
    // æ‰“å¼€æ’­æ”¾åˆ—è¡¨
    async function openPlaylist() {
      await renderPlaylist();
      document.getElementById('watch-together-playlist-modal').classList.add('visible');
    }
    
    // æ¸²æŸ“æ’­æ”¾åˆ—è¡¨
    async function renderPlaylist() {
      const listEl = document.getElementById('watch-together-playlist-list');
      const videos = await db.watchTogetherPlaylist.orderBy('timestamp').reverse().toArray();
      
      if (videos.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">æš‚æ— è§†é¢‘ï¼Œä¸Šä¼ è§†é¢‘åå¯ä¿å­˜åˆ°åˆ—è¡¨</p>';
        return;
      }
      
      listEl.innerHTML = videos.map(video => `
        <div class="playlist-item" data-id="${video.id}">
          <div class="playlist-item-info">
            <div class="playlist-item-name">${video.name}</div>
            <div class="playlist-item-time">${new Date(video.timestamp).toLocaleString()}</div>
            <div class="playlist-item-type">${video.type === 'file' ? 'æœ¬åœ°æ–‡ä»¶' : 'åœ¨çº¿è§†é¢‘'}</div>
          </div>
          <div class="playlist-item-actions">
            <button class="playlist-play-btn" onclick="playFromPlaylist(${video.id})">æ’­æ”¾</button>
            <button class="playlist-delete-btn" onclick="deleteFromPlaylist(${video.id})">åˆ é™¤</button>
          </div>
        </div>
      `).join('');
    }
    
    // ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾è§†é¢‘
    window.playFromPlaylist = async function(id) {
      const video = await db.watchTogetherPlaylist.get(id);
      if (!video) {
        await showCustomAlert('é”™è¯¯', 'æœªæ‰¾åˆ°è§†é¢‘');
        return;
      }
      
      document.getElementById('watch-together-playlist-modal').classList.remove('visible');
      
      if (video.type === 'file') {
        // ä»base64æ¢å¤æ–‡ä»¶
        const response = await fetch(video.data);
        const blob = await response.blob();
        const file = new File([blob], video.name, { type: blob.type });
        loadWatchTogetherVideo(file, true);
      } else if (video.type === 'url') {
        loadWatchTogetherVideoFromUrl(video.data, true);
      }
    };
    
    // ä»æ’­æ”¾åˆ—è¡¨åˆ é™¤è§†é¢‘
    window.deleteFromPlaylist = async function(id) {
      const confirmed = await showCustomConfirm('ç¡®è®¤åˆ é™¤', 'ç¡®å®šè¦ä»æ’­æ”¾åˆ—è¡¨ä¸­åˆ é™¤è¿™ä¸ªè§†é¢‘å—ï¼Ÿ');
      if (confirmed) {
        await db.watchTogetherPlaylist.delete(id);
        await renderPlaylist();
      }
    };
    
    // ========== æ’­æ”¾åˆ—è¡¨åŠŸèƒ½ç»“æŸ ==========

    // å¼€å§‹ç›‘å¬ï¼ˆæˆªå›¾+è¯­éŸ³è¯†åˆ«ï¼‰
    function startWatchTogetherMonitoring() {
      const video = document.getElementById('watch-together-video');
      
      // å¯åŠ¨è¯­éŸ³è¯†åˆ«ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (watchTogetherState.speechApi === 'whisper') {
        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
        if (!watchTogetherState.audioContext) {
          watchTogetherState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // åˆ›å»ºéŸ³é¢‘æº
        const source = watchTogetherState.audioContext.createMediaElementSource(video);
        const destination = watchTogetherState.audioContext.createMediaStreamDestination();
        source.connect(destination);
        source.connect(watchTogetherState.audioContext.destination);
        
        // å¯åŠ¨ Whisper å½•éŸ³
        startWhisperRecording(destination.stream);
      } else if (watchTogetherState.speechApi === 'none') {
        console.log('å·²ç¦ç”¨è¯­éŸ³è¯†åˆ«');
      }
      
      // å¯åŠ¨æˆªå›¾å®šæ—¶å™¨
      startCaptureTimer();
    }

    // Whisperå½•éŸ³
    function startWhisperRecording(stream) {
      if (!MediaRecorder.isTypeSupported('audio/webm')) {
        console.warn('æµè§ˆå™¨ä¸æ”¯æŒMediaRecorder');
        return;
      }
      
      const mediaRecorder = new MediaRecorder(stream);
      watchTogetherState.mediaRecorder = mediaRecorder;
      watchTogetherState.audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        watchTogetherState.audioChunks.push(event.data);
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(watchTogetherState.audioChunks, { type: 'audio/webm' });
        watchTogetherState.audioChunks = [];
        
        // å‘é€åˆ°Whisper API
        const transcript = await transcribeWithWhisper(audioBlob);
        if (transcript) {
          addWatchTogetherContextMessage('è¯­éŸ³è¯†åˆ«', transcript);
        }
        
        // ç»§ç»­å½•åˆ¶
        if (watchTogetherState.isActive && watchTogetherState.mediaRecorder) {
          watchTogetherState.audioChunks = [];
          watchTogetherState.mediaRecorder.start();
          setTimeout(() => {
            if (watchTogetherState.mediaRecorder && watchTogetherState.mediaRecorder.state === 'recording') {
              watchTogetherState.mediaRecorder.stop();
            }
          }, watchTogetherState.captureInterval * 1000);
        }
      };
      
      mediaRecorder.start();
      setTimeout(() => {
        if (mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
      }, watchTogetherState.captureInterval * 1000);
    }

    // Whisper APIè½¬å½•
    async function transcribeWithWhisper(audioBlob) {
      try {
        const formData = new FormData();
        formData.append('file', audioBlob, 'audio.webm');
        formData.append('model', 'whisper-1');
        
        const response = await fetch(watchTogetherState.whisperUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${watchTogetherState.whisperKey}`
          },
          body: formData
        });
        
        if (!response.ok) {
          throw new Error('Whisper APIè°ƒç”¨å¤±è´¥');
        }
        
        const data = await response.json();
        return data.text;
      } catch (error) {
        console.error('Whisperè½¬å½•å¤±è´¥:', error);
        return null;
      }
    }

    // å¯åŠ¨æˆªå›¾å®šæ—¶å™¨
    function startCaptureTimer() {
      if (watchTogetherState.captureTimer) {
        clearInterval(watchTogetherState.captureTimer);
      }
      
      watchTogetherState.captureTimer = setInterval(() => {
        captureVideoFrame();
      }, watchTogetherState.captureInterval * 1000);
    }

    // æˆªå–è§†é¢‘ç”»é¢
    function captureVideoFrame() {
      const video = document.getElementById('watch-together-video');
      if (!video || video.paused) return;
      
      // æ£€æŸ¥è§†é¢‘å°ºå¯¸
      if (!video.videoWidth || !video.videoHeight) {
        console.warn('è§†é¢‘å°ºå¯¸æ— æ•ˆï¼Œè·³è¿‡æœ¬æ¬¡æˆªå›¾');
        return;
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      
      const imageData = canvas.toDataURL('image/jpeg', 0.6);
      const currentTime = formatVideoTime(video.currentTime);
      
      console.log(`âœ… è§†é¢‘æˆªå›¾å·²æ•è·: ${currentTime}, å¤§å°: ${(imageData.length / 1024).toFixed(2)}KB`);
      addWatchTogetherContextMessage('è§†é¢‘æˆªå›¾', `[${currentTime}]`, imageData);
    }

    // æ ¼å¼åŒ–æ—¶é—´
    function formatVideoTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      
      if (h > 0) {
        return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
      } else {
        return `${m}:${s.toString().padStart(2, '0')}`;
      }
    }

    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
    function addWatchTogetherSystemMessage(text) {
      const messagesDiv = document.getElementById('watch-together-chat-messages');
      const msgDiv = document.createElement('div');
      msgDiv.className = 'watch-together-system-message';
      msgDiv.textContent = text;
      messagesDiv.appendChild(msgDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // æ·»åŠ ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆä¸æ˜¾ç¤ºï¼Œä½†ä¼šå‘ç»™AIï¼‰
    function addWatchTogetherContextMessage(type, content, imageData = null) {
      watchTogetherState.messages.push({
        role: 'system',
        type: type,
        content: content,
        imageData: imageData,
        timestamp: Date.now()
      });
      
      // æ ¹æ®ç±»å‹æ¸…ç†è¶…å‡ºé™åˆ¶çš„å†å²è®°å½•
      if (type === 'è§†é¢‘æˆªå›¾') {
        const screenshots = watchTogetherState.messages.filter(m => m.role === 'system' && m.type === 'è§†é¢‘æˆªå›¾');
        if (screenshots.length > watchTogetherState.maxScreenshots) {
          // æ‰¾åˆ°æœ€æ—§çš„æˆªå›¾å¹¶åˆ é™¤
          const oldestScreenshot = screenshots[0];
          const index = watchTogetherState.messages.indexOf(oldestScreenshot);
          if (index !== -1) {
            watchTogetherState.messages.splice(index, 1);
          }
        }
      } else if (type === 'è¯­éŸ³è¯†åˆ«') {
        const audios = watchTogetherState.messages.filter(m => m.role === 'system' && m.type === 'è¯­éŸ³è¯†åˆ«');
        if (audios.length > watchTogetherState.maxAudios) {
          // æ‰¾åˆ°æœ€æ—§çš„è¯­éŸ³å¹¶åˆ é™¤
          const oldestAudio = audios[0];
          const index = watchTogetherState.messages.indexOf(oldestAudio);
          if (index !== -1) {
            watchTogetherState.messages.splice(index, 1);
          }
        }
      }
      
      // é™åˆ¶å¯¹è¯æ¶ˆæ¯æ•°é‡ï¼ˆç”¨æˆ·å’ŒåŠ©æ‰‹çš„æ¶ˆæ¯ï¼‰
      const dialogMessages = watchTogetherState.messages.filter(m => m.role === 'user' || m.role === 'assistant');
      if (dialogMessages.length > watchTogetherState.maxMessages) {
        // æ‰¾åˆ°æœ€æ—§çš„å¯¹è¯æ¶ˆæ¯å¹¶åˆ é™¤
        const oldestDialog = dialogMessages[0];
        const index = watchTogetherState.messages.indexOf(oldestDialog);
        if (index !== -1) {
          watchTogetherState.messages.splice(index, 1);
        }
      }
    }

    // å‘é€ç”¨æˆ·æ¶ˆæ¯ï¼ˆä¸è°ƒç”¨APIï¼‰
    function sendWatchTogetherUserMessage() {
      const input = document.getElementById('watch-together-chat-input');
      const text = input.value.trim();
      
      if (!text) return;
      
      input.value = '';
      
      // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
      watchTogetherState.messages.push({
        role: 'user',
        content: text,
        timestamp: Date.now()
      });
      
      // æ¸…ç†è¶…å‡ºé™åˆ¶çš„å¯¹è¯æ¶ˆæ¯
      const dialogMessages = watchTogetherState.messages.filter(m => m.role === 'user' || m.role === 'assistant');
      if (dialogMessages.length > watchTogetherState.maxMessages) {
        const oldestDialog = dialogMessages[0];
        const index = watchTogetherState.messages.indexOf(oldestDialog);
        if (index !== -1) {
          watchTogetherState.messages.splice(index, 1);
        }
      }
      
      renderWatchTogetherMessages();
    }

    // è°ƒç”¨API
    async function callWatchTogetherAPI() {
      if (!watchTogetherState.isActive) return;
      
      const chat = state.chats[watchTogetherState.chatId];
      const video = document.getElementById('watch-together-video');
      const isOnlineMode = watchTogetherState.mode === 'online';
      
      // ç¦ç”¨æŒ‰é’®
      document.getElementById('watch-together-call-api-btn').disabled = true;
      document.getElementById('watch-together-chat-send').disabled = true;
      
      // æ˜¾ç¤º"æ­£åœ¨è¾“å…¥ä¸­"
      const chatNameElement = document.getElementById('watch-together-chat-name');
      const originalName = chatNameElement.textContent;
      chatNameElement.textContent = 'æ­£åœ¨è¾“å…¥ä¸­...';
      
      try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
          alert('è¯·å…ˆåœ¨APIè®¾ç½®ä¸­é…ç½®åä»£åœ°å€ã€å¯†é’¥å¹¶é€‰æ‹©æ¨¡å‹ã€‚');
          return;
        }
        
        const currentTime = video.currentTime ? formatVideoTime(video.currentTime) : '0:00';
        const now = new Date();
        const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
        const currentDateTime = now.toLocaleString('zh-CN', {
          timeZone: selectedTimeZone,
          dateStyle: 'full',
          timeStyle: 'short'
        });
        
        // æ„å»ºåŸºç¡€ç³»ç»Ÿæç¤ºè¯
        let basePrompt = `# æ ¸å¿ƒä»»åŠ¡
ä½ æ­£åœ¨å’Œç”¨æˆ·ä¸€èµ·è§‚çœ‹è§†é¢‘ã€‚å½“å‰æ—¶é—´ï¼š${currentDateTime}ï¼Œè§†é¢‘æ’­æ”¾æ—¶é—´ï¼š${currentTime}ã€‚

# ä½ çš„è§’è‰²è®¾å®š
${chat.settings.aiPersona}

# ç”¨æˆ·çš„è§’è‰²
${chat.settings.myPersona || 'æ™®é€šç”¨æˆ·'}
`;
        
        // ä¸–ç•Œä¹¦
        let worldBookContent = '';
        let allWorldBookIds = [...(chat.settings.linkedWorldBookIds || [])];
        state.worldBooks.forEach(wb => {
          if (wb.isGlobal && !allWorldBookIds.includes(wb.id)) {
            allWorldBookIds.push(wb.id);
          }
        });
        
        if (allWorldBookIds.length > 0) {
          const linkedContents = allWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            if (!worldBook || !Array.isArray(worldBook.content)) return '';
            
            const formattedEntries = worldBook.content
              .filter(entry => entry.enabled !== false)
              .map(entry => {
                let entryString = `\n### æ¡ç›®: ${entry.comment || 'æ— å¤‡æ³¨'}\n`;
                entryString += `**å†…å®¹:**\n${entry.content}`;
                return entryString;
              }).join('');
            
            return formattedEntries ? `\n\n## ä¸–ç•Œä¹¦: ${worldBook.name}\n${formattedEntries}` : '';
          }).filter(Boolean).join('');
          
          if (linkedContents) {
            worldBookContent = `# ä¸–ç•Œä¹¦è®¾å®š (æœ€é«˜ä¼˜å…ˆçº§)
ä»¥ä¸‹å†…å®¹æ˜¯ä½ æ‰€åœ¨ä¸–ç•Œçš„åŸºç¡€è®¾å®šï¼Œä½ å¿…é¡»ä¸¥æ ¼éµå®ˆã€‚
${linkedContents}
`;
          }
        }
        
        // é•¿æœŸè®°å¿†
        let longTermMemoryContext = '';
        if (chat.longTermMemory && chat.longTermMemory.length > 0) {
          longTermMemoryContext = `\n# é•¿æœŸè®°å¿† (æœ€é«˜ä¼˜å…ˆçº§)\n`;
          longTermMemoryContext += chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
          longTermMemoryContext += '\n';
        }
        
        // æŒ‚è½½èŠå¤©è®°å½•
        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
          const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== watchTogetherState.chatId);
          
          if (idsToMount.length > 0) {
            linkedMemoryContext += `\n# å‚è€ƒè®°å¿† (å…¶ä»–èŠå¤©çš„è®°å¿†)\n`;
            
            for (const id of idsToMount) {
              const linkedChat = state.chats[id];
              if (!linkedChat) continue;
              
              const prefix = linkedChat.isGroup ? '[ç¾¤èŠ]' : '[ç§èŠ]';
              linkedMemoryContext += `\n## ${prefix}"${linkedChat.name}"çš„è®°å¿†:\n`;
              
              const recentHistory = linkedChat.history.slice(-memoryCount);
              const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('å·²è¢«ç”¨æˆ·åˆ é™¤'));
              
              if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || 'æˆ‘') : (msg.senderName || linkedChat.name);
                  let contentText = String(msg.content);
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ä¸ºï¼š${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š${msg.content}]`;
                  }
                  linkedMemoryContext += `${sender}: ${contentText}\n`;
                });
              } else {
                linkedMemoryContext += "(æš‚æ— è®°å½•)\n";
              }
            }
          }
        }
        
        // è§†é¢‘å†…å®¹ä¸Šä¸‹æ–‡
        let videoContext = '\n# è§†é¢‘å†…å®¹\n';
        
        // æœ€è¿‘çš„è¯­éŸ³è¯†åˆ«å†…å®¹
        const recentSpeech = watchTogetherState.messages
          .filter(m => m.role === 'system' && m.type === 'è¯­éŸ³è¯†åˆ«')
          .slice(-watchTogetherState.maxAudios);
        
        if (recentSpeech.length > 0) {
          videoContext += '## è§†é¢‘ä¸­çš„å¯¹è¯ï¼ˆæœ€è¿‘å¬åˆ°çš„ï¼‰:\n';
          recentSpeech.forEach(s => {
            videoContext += `- ${s.content}\n`;
          });
        }
        
        // æœ€è¿‘çš„æˆªå›¾
        const recentScreenshots = watchTogetherState.messages
          .filter(m => m.role === 'system' && m.type === 'è§†é¢‘æˆªå›¾')
          .slice(-watchTogetherState.maxScreenshots);
        
        if (recentScreenshots.length > 0) {
          videoContext += '\n## è§†é¢‘ç”»é¢ï¼ˆæœ€è¿‘æˆªå›¾ï¼‰:\n';
          recentScreenshots.forEach(s => {
            videoContext += `- ${s.content}\n`;
          });
        }
        
        // ç»„åˆå®Œæ•´ç³»ç»Ÿæç¤º
        let systemPrompt = basePrompt + worldBookContent + longTermMemoryContext + linkedMemoryContext + videoContext;
        
        // æ ¹æ®æ¨¡å¼æ·»åŠ æ ¼å¼æŒ‡ä»¤
        if (isOnlineMode) {
          // çº¿ä¸Šæ¨¡å¼ï¼šä½¿ç”¨JSONæ•°ç»„æ ¼å¼ï¼ˆå’Œå•èŠä¸€æ ·ï¼‰
          systemPrompt += `
# ã€ã€ã€çº¿ä¸ŠèŠå¤©æ¨¡å¼ - æœ€é«˜ä¼˜å…ˆçº§é“å¾‹ã€‘ã€‘ã€‘

## æ ¸å¿ƒè§„åˆ™ï¼š
1. **è¿™æ˜¯çœŸå®çš„åœ¨çº¿æ–‡å­—èŠå¤©**ï¼Œå°±åƒQQã€å¾®ä¿¡ä¸€æ ·ã€‚
2. **ã€ç»å¯¹ç¦æ­¢ã€‘ä»»ä½•å½¢å¼çš„"çº¿ä¸‹æå†™"**ï¼š
   - ç¦æ­¢æå†™åŠ¨ä½œï¼ˆå¦‚ï¼š*ç¬‘äº†ç¬‘*ã€*ç‚¹ç‚¹å¤´*ï¼‰
   - ç¦æ­¢æå†™è¡¨æƒ…ï¼ˆå¦‚ï¼šå¥¹å¾®ç¬‘ç€ã€ä»–çš±äº†çš±çœ‰ï¼‰
   - ç¦æ­¢æå†™ç¯å¢ƒï¼ˆå¦‚ï¼šé˜³å…‰æ´’åœ¨çª—å°ä¸Šï¼‰
   - ç¦æ­¢ä½¿ç”¨ä»»ä½•æ ‡ç‚¹ç¬¦å·æ¥è¡¨ç¤ºåŠ¨ä½œï¼ˆå¦‚ï¼š*ã€ï¼ˆï¼‰ã€ã€ã€‘ç­‰ï¼‰
3. **ä½ åªèƒ½æ‰“å­—**ï¼Œå°±åƒçœŸäººåœ¨æ‰‹æœºä¸ŠèŠå¤©ä¸€æ ·ã€‚
4. ä½ å¯ä»¥ç”¨è¡¨æƒ…ç¬¦å·ã€ç½‘ç»œç”¨è¯­ã€å£è¯­åŒ–è¡¨è¾¾ï¼Œä½†**ç»å¯¹ä¸èƒ½**æœ‰ä»»ä½•"æ—ç™½"æˆ–"åœºæ™¯æå†™"ã€‚

## è¾“å‡ºæ ¼å¼é“å¾‹ï¼š
ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ å‘é€çš„ä¸€æ¡æ¶ˆæ¯ã€‚

### å¯ç”¨çš„æ¶ˆæ¯ç±»å‹ï¼š
- **çº¯æ–‡å­—æ¶ˆæ¯**: \`{"type": "text", "content": "ä½ è¦æ‰“çš„å­—"}\`

### æ­£ç¡®ç¤ºä¾‹ï¼š
\`\`\`json
[
  {"type": "text", "content": "å“‡è¿™ä¸ªé•œå¤´å¥½ç¾å•Šï¼"},
  {"type": "text", "content": "ä½ æ³¨æ„åˆ°åˆšæ‰é‚£ä¸ªç»†èŠ‚äº†å—"},
  {"type": "text", "content": "æˆ‘å¥½å–œæ¬¢è¿™æ®µ"}
]
\`\`\`

### é”™è¯¯ç¤ºä¾‹ï¼ˆç»å¯¹ç¦æ­¢ï¼‰ï¼š
âŒ \`{"type": "text", "content": "*ç¬‘äº†ç¬‘* ç¡®å®å¾ˆä¸é”™å‘¢"}\`  
âŒ \`{"type": "text", "content": "ï¼ˆæ­ªå¤´æ€è€ƒï¼‰å—¯...è¿™ä¸ªåœ°æ–¹..."}\`  
âŒ \`{"type": "text", "content": "å¥¹éœ²å‡ºäº†å¼€å¿ƒçš„ç¬‘å®¹ï¼šè¿™ä¸ª..."}\`  

ç°åœ¨ï¼Œè¯·åƒçœŸäººåœ¨æ‰‹æœºä¸ŠèŠå¤©ä¸€æ ·ï¼Œçº¯æ–‡å­—æ‰“å­—å›å¤ç”¨æˆ·ã€‚å¯ä»¥å‘å¤šæ¡æ¶ˆæ¯ã€‚
`;
        } else {
          // çº¿ä¸‹æ¨¡å¼ï¼šå•æ¡æ–‡æœ¬
          systemPrompt += `
# ä½ çš„ä»»åŠ¡
è¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œç»“åˆè§†é¢‘å†…å®¹è‡ªç„¶åœ°å›å¤ç”¨æˆ·ã€‚ä½ çš„å›å¤å¿…é¡»ç¬¦åˆä½ çš„äººè®¾ï¼Œå¹¶ä½“ç°å‡ºå¯¹è§†é¢‘å†…å®¹çš„ç†è§£ã€‚
ç›´æ¥å›å¤æ–‡æœ¬å³å¯ï¼Œä¸éœ€è¦JSONæ ¼å¼ã€‚
`;
        }
        
        // æ„å»ºæ¶ˆæ¯å†å²
        const maxMemory = watchTogetherState.maxMessages || 20;
        const historyMessages = watchTogetherState.messages
          .filter(m => m.role === 'user' || m.role === 'assistant')
          .slice(-maxMemory)
          .map(m => ({
            role: m.role,
            content: m.content
          }));
        
        // è·å–æœ€æ–°æˆªå›¾
        const latestScreenshot = watchTogetherState.messages
          .filter(m => m.role === 'system' && m.type === 'è§†é¢‘æˆªå›¾' && m.imageData)
          .slice(-1)[0];
        
        // å¦‚æœæœ‰æˆªå›¾ï¼ŒæŠŠå®ƒé™„åŠ åˆ°æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ä¸Šï¼ˆç±»ä¼¼è§†é¢‘é€šè¯çš„æ–¹å¼ï¼‰
        if (latestScreenshot && historyMessages.length > 0) {
          const lastUserMsgIndex = historyMessages.map((m, i) => m.role === 'user' ? i : -1).filter(i => i >= 0).pop();
          
          if (lastUserMsgIndex !== undefined) {
            const lastUserMsg = historyMessages[lastUserMsgIndex];
            // å°†æ–‡æœ¬æ¶ˆæ¯è½¬æ¢ä¸ºå¤šæ¨¡æ€æ¶ˆæ¯
            historyMessages[lastUserMsgIndex] = {
              role: 'user',
              content: [
                { type: 'text', text: typeof lastUserMsg.content === 'string' ? lastUserMsg.content : 'ç”¨æˆ·æ¶ˆæ¯' },
                { type: 'image_url', image_url: { url: latestScreenshot.imageData } }
              ]
            };
            console.log(`ğŸ“¸ å·²å°†è§†é¢‘æˆªå›¾é™„åŠ åˆ°ç”¨æˆ·æ¶ˆæ¯: ${latestScreenshot.content}`);
          }
        } else if (latestScreenshot && historyMessages.length === 0) {
          // å¦‚æœæ²¡æœ‰å†å²æ¶ˆæ¯ï¼ŒæŠŠæˆªå›¾ä½œä¸ºç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
          historyMessages.push({
            role: 'user',
            content: [
              { type: 'text', text: `å½“å‰è§†é¢‘ç”»é¢ ${latestScreenshot.content}` },
              { type: 'image_url', image_url: { url: latestScreenshot.imageData } }
            ]
          });
          console.log(`ğŸ“¸ å·²å°†è§†é¢‘æˆªå›¾ä½œä¸ºé¦–æ¡æ¶ˆæ¯å‘é€: ${latestScreenshot.content}`);
        } else {
          console.log('ğŸ“­ æš‚æ— è§†é¢‘æˆªå›¾å¯å‘é€');
        }
        
        const messagesPayload = [
          { role: 'system', content: systemPrompt },
          ...historyMessages
        ];
        
        // è°ƒç”¨API
        const apiResponse = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: messagesPayload,
            temperature: state.globalSettings.apiTemperature || 0.8
          })
        });
        
        if (!apiResponse.ok) {
          const errorData = await apiResponse.json().catch(() => ({}));
          const errorMsg = errorData.error?.message || errorData.message || `HTTP ${apiResponse.status}`;
          throw new Error(`APIè°ƒç”¨å¤±è´¥: ${errorMsg}`);
        }
        
        const data = await apiResponse.json();
        let reply = data.choices[0].message.content.trim();
        
        // ç§»é™¤å¯èƒ½çš„ä»£ç å—æ ‡è®°
        reply = reply.replace(/^```json\s*/i, '').replace(/^```\s*/m, '').replace(/```\s*$/m, '');
        
        if (isOnlineMode) {
          // çº¿ä¸Šæ¨¡å¼ï¼šè§£æJSONæ•°ç»„ï¼ŒAIå¯ä»¥å‘é€å¤šæ¡æ¶ˆæ¯
          try {
            const parsed = JSON.parse(reply);
            if (Array.isArray(parsed)) {
              // ä¸ºæ¯æ¡æ¶ˆæ¯æ·»åŠ åˆ°å†å²
              parsed.forEach(item => {
                if (item.type === 'text' && item.content) {
                  watchTogetherState.messages.push({
                    role: 'assistant',
                    content: item.content.trim(),
                    timestamp: Date.now()
                  });
                }
              });
            } else {
              // å¦‚æœä¸æ˜¯æ•°ç»„ï¼Œå½“ä½œå•æ¡æ¶ˆæ¯
              watchTogetherState.messages.push({
                role: 'assistant',
                content: reply,
                timestamp: Date.now()
              });
            }
          } catch (e) {
            // JSONè§£æå¤±è´¥ï¼Œå½“ä½œçº¯æ–‡æœ¬
            console.error('JSONè§£æå¤±è´¥:', e);
            watchTogetherState.messages.push({
              role: 'assistant',
              content: reply,
              timestamp: Date.now()
            });
          }
        } else {
          // çº¿ä¸‹æ¨¡å¼ï¼šç›´æ¥æ·»åŠ å•æ¡æ–‡æœ¬æ¶ˆæ¯
          // å°è¯•è§£æJSONæ ¼å¼ï¼ˆå…¼å®¹æŸäº›æ¨¡å‹å¯èƒ½è¿”å›JSONï¼‰
          try {
            const parsed = JSON.parse(reply);
            if (Array.isArray(parsed) && parsed[0]) {
              if (parsed[0].type === 'text' || parsed[0].type === 'offline_text') {
                reply = parsed[0].content;
              }
            }
          } catch (e) {
            // ä¿æŒåŸæ ·
          }
          
          watchTogetherState.messages.push({
            role: 'assistant',
            content: reply,
            timestamp: Date.now()
          });
        }
        
        // æ¸…ç†è¶…å‡ºé™åˆ¶çš„å¯¹è¯æ¶ˆæ¯
        const dialogMessages = watchTogetherState.messages.filter(m => m.role === 'user' || m.role === 'assistant');
        if (dialogMessages.length > watchTogetherState.maxMessages) {
          // è®¡ç®—éœ€è¦åˆ é™¤çš„æ•°é‡
          const deleteCount = dialogMessages.length - watchTogetherState.maxMessages;
          for (let i = 0; i < deleteCount; i++) {
            const oldestDialog = watchTogetherState.messages.find(m => m.role === 'user' || m.role === 'assistant');
            const index = watchTogetherState.messages.indexOf(oldestDialog);
            if (index !== -1) {
              watchTogetherState.messages.splice(index, 1);
            }
          }
        }
        
        renderWatchTogetherMessages();
        
      } catch (error) {
        console.error('AIè°ƒç”¨å¤±è´¥:', error);
        addWatchTogetherSystemMessage('AIè°ƒç”¨å¤±è´¥ï¼š' + error.message);
        
        // æ˜¾ç¤ºé”™è¯¯å¼¹çª—
        let errorDetail = error.message;
        if (error.message.includes('æ¨¡å‹') || error.message.includes('vision') || error.message.includes('image')) {
          errorDetail += '\n\næç¤ºï¼šå½“å‰æ¨¡å‹å¯èƒ½ä¸æ”¯æŒè§†è§‰åŠŸèƒ½ï¼ˆå›¾ç‰‡è¯†åˆ«ï¼‰ã€‚å»ºè®®ä½¿ç”¨æ”¯æŒè§†è§‰çš„æ¨¡å‹ï¼Œå¦‚ï¼šgpt-4oã€claude-3ã€gemini-pro-vision ç­‰ã€‚';
        }
        alert('è§‚å½±AIè°ƒç”¨å¤±è´¥\n\n' + errorDetail);
      } finally {
        // æ¢å¤åŸåå­—
        const chat = state.chats[watchTogetherState.chatId];
        const chatNameElement = document.getElementById('watch-together-chat-name');
        if (chat) {
          chatNameElement.textContent = chat.name;
        }
        
        document.getElementById('watch-together-call-api-btn').disabled = false;
        document.getElementById('watch-together-chat-send').disabled = false;
      }
    }

    // æ¸²æŸ“æ¶ˆæ¯
    function renderWatchTogetherMessages() {
      const messagesDiv = document.getElementById('watch-together-chat-messages');
      messagesDiv.innerHTML = '';
      
      const chat = state.chats[watchTogetherState.chatId];
      const defaultAvatar = 'https://i.postimg.cc/y8xWzCqj/anime-boy.jpg';
      const userAvatar = chat.settings?.myAvatar || defaultAvatar;
      const aiAvatar = chat.settings?.aiAvatar || defaultAvatar;
      
      watchTogetherState.messages
        .filter(m => m.role !== 'system')
        .forEach(msg => {
          const msgDiv = document.createElement('div');
          msgDiv.className = `watch-together-message ${msg.role}`;
          
          const avatar = document.createElement('img');
          avatar.className = 'watch-together-message-avatar';
          avatar.src = msg.role === 'user' ? userAvatar : aiAvatar;
          
          const content = document.createElement('div');
          content.className = 'watch-together-message-content';
          content.textContent = msg.content;
          
          // æ·»åŠ é•¿æŒ‰ç›‘å¬å™¨
          addLongPressListener(content, () => showWatchTogetherMessageActions(msg.timestamp));
          
          msgDiv.appendChild(avatar);
          msgDiv.appendChild(content);
          messagesDiv.appendChild(msgDiv);
        });
      
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // ========== è§‚å½±æ¶ˆæ¯èœå• ==========
    let activeWatchTogetherMessageTimestamp = null;

    function showWatchTogetherMessageActions(timestamp) {
      activeWatchTogetherMessageTimestamp = timestamp;
      const message = watchTogetherState.messages.find(m => m.timestamp === timestamp);
      if (!message) return;
      
      document.getElementById('message-actions-modal').classList.add('visible');
      
      // æ˜¾ç¤ºéœ€è¦çš„æŒ‰é’®
      document.getElementById('edit-message-btn').style.display = 'block';
      document.getElementById('edit-message-btn').textContent = 'ç¼–è¾‘';
      document.getElementById('copy-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').textContent = message.role === 'assistant' ? 'é‡è¯´' : 'åˆ é™¤';
      
      // éšè—ä¸éœ€è¦çš„æŒ‰é’®
      document.getElementById('copy-timestamp-btn').style.display = 'none';
      document.getElementById('translate-message-btn').style.display = 'none';
      document.getElementById('publish-to-announcement-btn').style.display = 'none';
      document.getElementById('quote-message-btn').style.display = 'none';
      document.getElementById('forward-message-btn').style.display = 'none';
      document.getElementById('select-message-btn').style.display = 'none';
    }

    function closeWatchTogetherMessageActions() {
      document.getElementById('message-actions-modal').classList.remove('visible');
      activeWatchTogetherMessageTimestamp = null;
      document.getElementById('recall-message-btn').textContent = 'æ’¤å›';
    }

    function restoreNormalMessageActionsFromWatchTogether() {
      // æ¢å¤æ‰€æœ‰æ­£å¸¸æ¶ˆæ¯èœå•æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
      document.getElementById('edit-message-btn').style.display = 'block';
      document.getElementById('copy-message-btn').style.display = 'block';
      document.getElementById('copy-timestamp-btn').style.display = 'block';
      document.getElementById('translate-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').style.display = 'block';
      document.getElementById('quote-message-btn').style.display = 'block';
      document.getElementById('forward-message-btn').style.display = 'block';
      document.getElementById('select-message-btn').style.display = 'block';
      document.getElementById('recall-message-btn').textContent = 'æ’¤å›';
      
      // é‡ç½®activeWatchTogetherMessageTimestamp
      activeWatchTogetherMessageTimestamp = null;
    }
    // ========== è§‚å½±æ¶ˆæ¯èœå•ç»“æŸ ==========

    // åŠ è½½è®¾ç½®
    function loadWatchTogetherSettings() {
      const chat = state.chats[watchTogetherState.chatId];
      const settings = chat.watchTogetherSettings || {};
      
      document.getElementById('watch-together-mode-select').value = settings.mode || 'online';
      document.getElementById('watch-together-interval-input').value = settings.captureInterval || 5;
      document.getElementById('watch-together-speech-api-select').value = settings.speechApi || 'none';
      document.getElementById('watch-together-whisper-key').value = settings.whisperKey || '';
      document.getElementById('watch-together-whisper-url').value = settings.whisperUrl || 'https://api.openai.com/v1/audio/transcriptions';
      document.getElementById('watch-together-max-screenshots').value = settings.maxScreenshots || 10;
      document.getElementById('watch-together-max-audios').value = settings.maxAudios || 10;
      document.getElementById('watch-together-max-messages').value = settings.maxMessages || 20;
      
      const whisperConfig = document.getElementById('watch-together-whisper-config');
      whisperConfig.style.display = (settings.speechApi === 'whisper') ? 'block' : 'none';
    }

    // ä¿å­˜è®¾ç½®
    async function saveWatchTogetherSettings() {
      const chat = state.chats[watchTogetherState.chatId];
      
      chat.watchTogetherSettings = {
        mode: document.getElementById('watch-together-mode-select').value,
        captureInterval: parseInt(document.getElementById('watch-together-interval-input').value) || 5,
        speechApi: document.getElementById('watch-together-speech-api-select').value,
        whisperKey: document.getElementById('watch-together-whisper-key').value,
        whisperUrl: document.getElementById('watch-together-whisper-url').value,
        maxScreenshots: parseInt(document.getElementById('watch-together-max-screenshots').value) || 10,
        maxAudios: parseInt(document.getElementById('watch-together-max-audios').value) || 10,
        maxMessages: parseInt(document.getElementById('watch-together-max-messages').value) || 20
      };
      
      watchTogetherState.mode = chat.watchTogetherSettings.mode;
      watchTogetherState.captureInterval = chat.watchTogetherSettings.captureInterval;
      watchTogetherState.speechApi = chat.watchTogetherSettings.speechApi;
      watchTogetherState.whisperKey = chat.watchTogetherSettings.whisperKey;
      watchTogetherState.whisperUrl = chat.watchTogetherSettings.whisperUrl;
      watchTogetherState.maxScreenshots = chat.watchTogetherSettings.maxScreenshots;
      watchTogetherState.maxAudios = chat.watchTogetherSettings.maxAudios;
      watchTogetherState.maxMessages = chat.watchTogetherSettings.maxMessages;
      
      // é‡å¯ç›‘å¬
      if (watchTogetherState.videoUrl) {
        stopMonitoring();
        startWatchTogetherMonitoring();
      }
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await db.chats.put(chat);
    }

    // åœæ­¢ç›‘å¬
    function stopMonitoring() {
      if (watchTogetherState.captureTimer) {
        clearInterval(watchTogetherState.captureTimer);
        watchTogetherState.captureTimer = null;
      }
      
      if (watchTogetherState.speechRecognition) {
        watchTogetherState.speechRecognition.stop();
        watchTogetherState.speechRecognition = null;
      }
      
      if (watchTogetherState.mediaRecorder) {
        if (watchTogetherState.mediaRecorder.state === 'recording') {
          watchTogetherState.mediaRecorder.stop();
        }
        watchTogetherState.mediaRecorder = null;
      }
      
      if (watchTogetherState.audioContext) {
        watchTogetherState.audioContext.close();
        watchTogetherState.audioContext = null;
      }
    }

    // åœæ­¢è§‚å½±
    function stopWatchTogether() {
      stopMonitoring();
      
      const video = document.getElementById('watch-together-video');
      video.pause();
      video.src = '';
      
      if (watchTogetherState.videoUrl && watchTogetherState.videoUrl.startsWith('blob:')) {
        URL.revokeObjectURL(watchTogetherState.videoUrl);
      }
      
      document.getElementById('watch-together-video').style.display = 'none';
      document.getElementById('watch-together-placeholder').style.display = 'block';
      document.getElementById('watch-together-modal').classList.remove('visible');
      
      // æ¢å¤æ­£å¸¸çš„æ¶ˆæ¯èœå•
      restoreNormalMessageActionsFromWatchTogether();
      
      watchTogetherState.isActive = false;
      watchTogetherState.videoUrl = null;
      watchTogetherState.messages = [];
    }

    // ========== å½±è§†æœç´¢åŠŸèƒ½ ==========
    
    // èµ„æºç«™é…ç½®
    const movieApiSources = [
      {
        name: 'æœ€å¤§èµ„æº',
        url: 'https://api.apibdzy.com/api.php/provide/vod/',
        params: { ac: 'detail', wd: '' }
      },
      {
        name: 'OKèµ„æº',
        url: 'https://cj.okzy.tv/inc/apijson_vod.php',
        params: { wd: '' }
      },
      {
        name: 'é‡å­èµ„æº',
        url: 'https://cj.lziapi.com/api.php/provide/vod/',
        params: { ac: 'detail', wd: '' }
      },
      {
        name: 'éå‡¡èµ„æº',
        url: 'https://cj.ffzyapi.com/api.php/provide/vod/',
        params: { ac: 'detail', wd: '' }
      },
      {
        name: 'çº¢ç‰›èµ„æº',
        url: 'https://www.hongniuzy2.com/api.php/provide/vod/',
        params: { ac: 'detail', wd: '' }
      }
    ];

    // æœç´¢å½±è§†
    async function searchMovies(keyword) {
      const statusDiv = document.getElementById('watch-together-search-status');
      const resultsDiv = document.getElementById('watch-together-search-results');
      
      statusDiv.textContent = 'æ­£åœ¨æœç´¢ä¸­...';
      resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">æœç´¢ä¸­ï¼Œè¯·ç¨å€™...</div>';
      
      const searchBtn = document.getElementById('watch-together-search-btn');
      searchBtn.disabled = true;
      searchBtn.textContent = 'æœç´¢ä¸­...';
      
      const allResults = [];
      let successCount = 0;
      let failCount = 0;
      
      // å¹¶å‘æœç´¢æ‰€æœ‰èµ„æºç«™
      const searchPromises = movieApiSources.map(async (source) => {
        try {
          const params = new URLSearchParams({ ...source.params, wd: keyword });
          const url = `${source.url}?${params.toString()}`;
          
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          
          // è§£ææ•°æ®
          let movies = [];
          if (data.list && Array.isArray(data.list)) {
            movies = data.list;
          } else if (data.data && Array.isArray(data.data)) {
            movies = data.data;
          }
          
          // ä¸ºæ¯ä¸ªç»“æœæ·»åŠ æ¥æºä¿¡æ¯
          movies.forEach(movie => {
            movie._source = source.name;
          });
          
          successCount++;
          return movies;
          
        } catch (error) {
          console.error(`${source.name} æœç´¢å¤±è´¥:`, error);
          failCount++;
          return [];
        }
      });
      
      // ç­‰å¾…æ‰€æœ‰æœç´¢å®Œæˆ
      const results = await Promise.all(searchPromises);
      results.forEach(movies => {
        allResults.push(...movies);
      });
      
      // æ›´æ–°çŠ¶æ€
      searchBtn.disabled = false;
      searchBtn.textContent = 'æœç´¢';
      
      if (allResults.length === 0) {
        statusDiv.textContent = `æœç´¢å®Œæˆï¼šæœªæ‰¾åˆ°"${keyword}"ç›¸å…³çš„å½±è§†èµ„æº (æˆåŠŸ:${successCount} å¤±è´¥:${failCount})`;
        resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">æœªæ‰¾åˆ°ç›¸å…³ç»“æœï¼Œè¯·å°è¯•å…¶ä»–å…³é”®è¯</div>';
        return;
      }
      
      statusDiv.textContent = `æœç´¢å®Œæˆï¼šæ‰¾åˆ° ${allResults.length} ä¸ªç»“æœ (æˆåŠŸ:${successCount} å¤±è´¥:${failCount})`;
      
      // æ¸²æŸ“æœç´¢ç»“æœ
      renderSearchResults(allResults);
    }

    // æ¸²æŸ“æœç´¢ç»“æœ
    function renderSearchResults(movies) {
      const resultsDiv = document.getElementById('watch-together-search-results');
      resultsDiv.innerHTML = '';
      
      movies.forEach(movie => {
        const movieCard = document.createElement('div');
        movieCard.style.cssText = 'border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin-bottom: 15px; cursor: pointer; transition: all 0.2s;';
        movieCard.addEventListener('mouseenter', () => {
          movieCard.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
          movieCard.style.borderColor = '#667eea';
        });
        movieCard.addEventListener('mouseleave', () => {
          movieCard.style.boxShadow = 'none';
          movieCard.style.borderColor = '#e0e0e0';
        });
        
        // æ ‡é¢˜å’Œæ¥æº
        const header = document.createElement('div');
        header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;';
        header.innerHTML = `
          <h3 style="margin: 0; font-size: 16px; color: #333;">${escapeHTML(movie.vod_name || movie.name || 'æœªçŸ¥å½±ç‰‡')}</h3>
          <span style="background: #667eea; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${movie._source}</span>
        `;
        movieCard.appendChild(header);
        
        // ä¿¡æ¯
        const info = document.createElement('div');
        info.style.cssText = 'color: #666; font-size: 13px; line-height: 1.6; margin-bottom: 10px;';
        const year = movie.vod_year || movie.year || '';
        const type = movie.type_name || movie.vod_class || movie.type || '';
        const area = movie.vod_area || movie.area || '';
        const actor = movie.vod_actor || movie.actor || '';
        const director = movie.vod_director || movie.director || '';
        
        let infoHtml = [];
        if (year) infoHtml.push(`å¹´ä»½: ${year}`);
        if (type) infoHtml.push(`ç±»å‹: ${type}`);
        if (area) infoHtml.push(`åœ°åŒº: ${area}`);
        if (director) infoHtml.push(`å¯¼æ¼”: ${director}`);
        if (actor) infoHtml.push(`ä¸»æ¼”: ${actor.substring(0, 50)}${actor.length > 50 ? '...' : ''}`);
        
        info.innerHTML = infoHtml.join(' | ');
        movieCard.appendChild(info);
        
        // æ’­æ”¾æŒ‰é’®
        const playBtn = document.createElement('button');
        playBtn.textContent = 'é€‰æ‹©æ’­æ”¾æº';
        playBtn.style.cssText = 'background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 13px;';
        playBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showPlaySources(movie);
        });
        movieCard.appendChild(playBtn);
        
        resultsDiv.appendChild(movieCard);
      });
    }

    // æ˜¾ç¤ºæ’­æ”¾æºé€‰æ‹©
    function showPlaySources(movie) {
      const resultsDiv = document.getElementById('watch-together-search-results');
      resultsDiv.innerHTML = '';
      
      // è¿”å›æŒ‰é’®
      const backBtn = document.createElement('button');
      backBtn.innerHTML = '&lt; è¿”å›æœç´¢ç»“æœ';
      backBtn.style.cssText = 'margin-bottom: 20px; padding: 8px 16px; background: #f0f0f0; border: none; border-radius: 4px; cursor: pointer;';
      backBtn.addEventListener('click', () => {
        const keyword = document.getElementById('watch-together-search-input').value.trim();
        if (keyword) searchMovies(keyword);
      });
      resultsDiv.appendChild(backBtn);
      
      // å½±ç‰‡ä¿¡æ¯
      const movieInfo = document.createElement('div');
      movieInfo.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;';
      movieInfo.innerHTML = `
        <h2 style="margin: 0 0 10px 0; font-size: 18px;">${escapeHTML(movie.vod_name || movie.name || 'æœªçŸ¥å½±ç‰‡')}</h2>
        <p style="margin: 0; color: #666; font-size: 13px; line-height: 1.6;">${escapeHTML(movie.vod_content || movie.content || movie.vod_blurb || 'æš‚æ— ç®€ä»‹')}</p>
      `;
      resultsDiv.appendChild(movieInfo);
      
      // è§£ææ’­æ”¾åœ°å€
      const playUrlStr = movie.vod_play_url || movie.play_url || movie.vod_url || '';
      if (!playUrlStr) {
        resultsDiv.innerHTML += '<div style="text-align: center; padding: 40px; color: #999;">è¯¥å½±ç‰‡æš‚æ— å¯ç”¨æ’­æ”¾æº</div>';
        return;
      }
      
      // è§£ææ’­æ”¾æºï¼ˆæ ¼å¼: æ’­æ”¾ç»„$åç§°$URL#åç§°$URLï¼‰
      const playGroups = playUrlStr.split('$$$');
      
      playGroups.forEach((group, groupIndex) => {
        const episodes = group.split('#').filter(ep => ep.trim());
        
        if (episodes.length === 0) return;
        
        const groupDiv = document.createElement('div');
        groupDiv.style.cssText = 'margin-bottom: 20px;';
        
        const groupTitle = document.createElement('h3');
        groupTitle.textContent = `æ’­æ”¾æº ${groupIndex + 1}`;
        groupTitle.style.cssText = 'margin: 0 0 10px 0; font-size: 15px; color: #333;';
        groupDiv.appendChild(groupTitle);
        
        const episodesGrid = document.createElement('div');
        episodesGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;';
        
        episodes.forEach(episode => {
          const parts = episode.split('$');
          const episodeName = parts[0] || 'æ’­æ”¾';
          const episodeUrl = parts[1] || parts[0];
          
          if (!episodeUrl) return;
          
          const episodeBtn = document.createElement('button');
          episodeBtn.textContent = episodeName;
          episodeBtn.style.cssText = 'padding: 10px; background: white; border: 1px solid #d0d0d0; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.2s;';
          episodeBtn.addEventListener('mouseenter', () => {
            episodeBtn.style.background = '#667eea';
            episodeBtn.style.color = 'white';
            episodeBtn.style.borderColor = '#667eea';
          });
          episodeBtn.addEventListener('mouseleave', () => {
            episodeBtn.style.background = 'white';
            episodeBtn.style.color = '#333';
            episodeBtn.style.borderColor = '#d0d0d0';
          });
          episodeBtn.addEventListener('click', () => {
            playMovieUrl(episodeUrl, `${movie.vod_name || movie.name} - ${episodeName}`);
          });
          
          episodesGrid.appendChild(episodeBtn);
        });
        
        groupDiv.appendChild(episodesGrid);
        resultsDiv.appendChild(groupDiv);
      });
    }

    // æ’­æ”¾å½±ç‰‡
    function playMovieUrl(url, title) {
      console.log('å‡†å¤‡æ’­æ”¾:', url);
      
      // å…³é—­æœç´¢å¼¹çª—
      document.getElementById('watch-together-search-modal').classList.remove('visible');
      
      // åŠ è½½è§†é¢‘
      loadWatchTogetherVideoFromUrl(url);
      
      // æ˜¾ç¤ºæç¤º
      addWatchTogetherSystemMessage(`æ­£åœ¨åŠ è½½: ${title}`);
    }

    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
    function addWatchTogetherSystemMessage(text) {
      const messagesDiv = document.getElementById('watch-together-chat-messages');
      const msgDiv = document.createElement('div');
      msgDiv.style.cssText = 'text-align: center; color: #999; font-size: 12px; padding: 10px; margin: 5px 0;';
      msgDiv.textContent = text;
      messagesDiv.appendChild(msgDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    // ========== å½±è§†æœç´¢åŠŸèƒ½ç»“æŸ ==========
    // ========== ä¸€èµ·çœ‹ç”µå½±åŠŸèƒ½ç»“æŸ ==========


    document.getElementById('add-quick-reply-btn').addEventListener('click', addNewQuickReply);

  
    
    document.getElementById('minimize-char-music-btn').addEventListener('click', minimizeCharMusicPlayer);
    
    
    document.getElementById('char-music-restore-btn').addEventListener('click', restoreCharMusicPlayer);
    
  
    makeDraggable(document.getElementById('char-music-restore-btn'), document.getElementById('char-music-restore-btn'));

document.getElementById('imgbb-enable-switch').addEventListener('change', (e) => {
    document.getElementById('imgbb-settings-details').style.display = e.target.checked ? 'block' : 'none';
});

document.getElementById('imgbb-key-toggle').addEventListener('click', function() {
    const input = document.getElementById('imgbb-api-key');
    if (input.type === 'password') {
        input.type = 'text';
        this.textContent = 'ğŸ˜Œ';
    } else {
        input.type = 'password';
        this.textContent = 'ğŸ§';
    }
});
document.getElementById('catbox-enable-switch').addEventListener('change', (e) => {
        document.getElementById('catbox-settings-details').style.display = e.target.checked ? 'block' : 'none';
    });

    document.getElementById('catbox-key-toggle').addEventListener('click', function() {
        const input = document.getElementById('catbox-userhash');
        if (input.type === 'password') {
            input.type = 'text';
            this.textContent = 'ğŸ˜Œ';
        } else {
            input.type = 'password';
            this.textContent = 'ğŸ§';
        }
    });
const biliSearchBtn = document.getElementById('char-bilibili-search-btn');
    if (biliSearchBtn) {
        biliSearchBtn.addEventListener('click', handleCharBilibiliSearch);
        console.log("Bç«™æœç´¢æŒ‰é’®å·²ç»‘å®š"); // è°ƒè¯•æ—¥å¿—
    } else {
        console.error("æ‰¾ä¸åˆ°Bç«™æœç´¢æŒ‰é’® (char-bilibili-search-btn)ï¼Œè¯·æ£€æŸ¥HTML ID");
    }
  const regenBiliBtn = document.getElementById('regenerate-char-bilibili-btn');
    if (regenBiliBtn) {
        regenBiliBtn.addEventListener('click', handleGenerateSimulatedBilibili);
    }
    // 2. ç»‘å®šå›è½¦é”®æœç´¢
    const biliInput = document.getElementById('char-bilibili-search-input');
    if (biliInput) {
        biliInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleCharBilibiliSearch();
        });
    }
const ghSwitch = document.getElementById('github-enable-switch');
    if (ghSwitch) {
        ghSwitch.addEventListener('change', (e) => {
            document.getElementById('github-settings-details').style.display = e.target.checked ? 'block' : 'none';
        });
    }

    // GitHub æŒ‰é’®åŠŸèƒ½ç»‘å®š
    const ghUploadBtn = document.getElementById('github-upload-btn');
    if (ghUploadBtn) {
        ghUploadBtn.addEventListener('click', () => uploadToGitHub(false));
    }

    const ghDownloadBtn = document.getElementById('github-download-btn');
    if (ghDownloadBtn) {
        ghDownloadBtn.addEventListener('click', restoreFromGitHub);
    }
    const ghTokenToggle = document.getElementById('github-token-toggle');
    if (ghTokenToggle) {
        ghTokenToggle.addEventListener('click', function() {
            const input = document.getElementById('github-token');
            if (input.type === 'password') {
                input.type = 'text';
                this.textContent = 'ğŸ˜Œ'; // ççœ¼
            } else {
                input.type = 'password';
                this.textContent = 'ğŸ§'; // é—­çœ¼
            }
        });
    }
document.getElementById('toggle-reading-fullscreen-btn').addEventListener('click', toggleReadingFullscreen);

// ========================================
// â–¼â–¼â–¼ ä½ ç”»æˆ‘çŒœåŠŸèƒ½ï¼ˆåœ¨DOMContentLoadedå†…éƒ¨ä»¥è®¿é—®stateï¼‰â–¼â–¼â–¼
// ========================================

/**
 * æ‰“å¼€ä½ ç”»æˆ‘çŒœApp
 */
function openDrawAndGuess() {
  // é‡ç½®æ‰€æœ‰UIåˆ°åˆå§‹çŠ¶æ€
  document.getElementById('draw-guess-interactive-area').style.display = 'none';
  document.getElementById('draw-guess-welcome-text').style.display = 'block';
  document.getElementById('draw-guess-studio').style.display = 'none';
  document.getElementById('draw-guess-bottom-bar').style.display = 'none';
  document.getElementById('start-draw-guess-game-btn').textContent = 'å¼€å§‹æ¸¸æˆ';
  document.getElementById('draw-guess-dialogue-box').textContent = '';
  document.getElementById('draw-guess-input').value = '';
  document.getElementById('draw-guess-action-bar').style.display = 'none';

  // é‡ç½®æ‰€æœ‰æ¸¸æˆçŠ¶æ€
  drawGuessState.isActive = false;
  drawGuessState.partnerId = null;
  drawGuessState.history = [];
  drawGuessState.isAiResponding = false;
  drawGuessState.messageManager = { isOpen: false, mode: null, selectedTimestamps: new Set() };
  
  showScreen('draw-guess-screen');
}

// æŒ‚è½½åˆ°å…¨å±€å¯¹è±¡ï¼Œä½¿HTMLçš„onclickå¯ä»¥è°ƒç”¨
window.openDrawAndGuess = openDrawAndGuess;

/**
 * ç»˜å›¾æ¿å¯¹è±¡
 */
const drawingBoard = {
  canvas: null,
  ctx: null,
  isDrawing: false,
  lastX: 0,
  lastY: 0,
  history: [],
  tool: 'pen',
  color: '#000000',
  brushSize: 5,
  penType: 'pen',

  init(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.canvas.width = this.canvas.offsetWidth;
    this.canvas.height = this.canvas.offsetHeight;
    this.history = [];
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.saveState();
    this.addEventListeners();
  },

  addEventListeners() {
    this.handleDown = this.handleDown.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleUp = this.handleUp.bind(this);

    this.canvas.addEventListener('mousedown', this.handleDown);
    this.canvas.addEventListener('mousemove', this.handleMove);
    this.canvas.addEventListener('mouseup', this.handleUp);
    this.canvas.addEventListener('mouseleave', this.handleUp);

    this.canvas.addEventListener('touchstart', this.handleDown, { passive: false });
    this.canvas.addEventListener('touchmove', this.handleMove, { passive: false });
    this.canvas.addEventListener('touchend', this.handleUp);
  },

  getCoords(e) {
    const rect = this.canvas.getBoundingClientRect();
    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  },

  handleDown(e) {
    e.preventDefault();
    this.isDrawing = true;
    const { x, y } = this.getCoords(e);
    [this.lastX, this.lastY] = [x, y];
    this.ctx.beginPath();
    this.ctx.moveTo(x, y);
  },

  handleMove(e) {
    if (!this.isDrawing) return;
    e.preventDefault();
    const { x, y } = this.getCoords(e);
    this.drawLine(this.lastX, this.lastY, x, y);
    [this.lastX, this.lastY] = [x, y];
  },

  handleUp() {
    if (!this.isDrawing) return;
    this.isDrawing = false;
    this.ctx.closePath();
    this.saveState();
  },

  drawLine(x1, y1, x2, y2) {
    this.ctx.beginPath();

    if (this.tool === 'eraser') {
      this.ctx.globalCompositeOperation = 'destination-out';
      this.ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      this.ctx.globalCompositeOperation = 'source-over';
      this.ctx.strokeStyle = this.color;
    }

    this.ctx.lineWidth = this.brushSize;
    this.ctx.lineCap = 'round';
    this.ctx.lineJoin = 'round';
    
    switch(this.penType) {
      case 'pencil':
        this.ctx.globalAlpha = 0.4;
        this.ctx.lineWidth = this.brushSize * 0.5;
        break;
      case 'watercolor':
        this.ctx.globalAlpha = 0.2;
        break;
      case 'brush':
        this.ctx.globalAlpha = 0.8;
        this.ctx.lineWidth = Math.random() * (this.brushSize - 2) + 2;
        break;
      case 'calligraphy':
        this.ctx.globalAlpha = 1;
        const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        this.ctx.lineWidth = Math.max(this.brushSize - distance / 2, 1);
        break;
      case 'pen':
      default:
        this.ctx.globalAlpha = 1;
        break;
    }

    this.ctx.moveTo(x1, y1);
    this.ctx.lineTo(x2, y2);
    this.ctx.stroke();
    this.ctx.globalAlpha = 1.0;
  },

  saveState() {
    if (this.history.length >= 20) {
      this.history.shift();
    }
    this.history.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
  },

  undo() {
    if (this.history.length > 1) {
      this.history.pop();
      this.ctx.putImageData(this.history[this.history.length - 1], 0, 0);
    } else {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.history = [];
      this.saveState();
    }
  },
  
  setTool(tool) {
    this.tool = tool;
    document.getElementById('pen-settings').style.display = tool === 'pen' ? 'block' : 'none';
  },

  setColor(color) {
    this.color = color;
  },

  setSize(size) {
    this.brushSize = size;
  },

  setPenType(type) {
    this.penType = type;
  },

  clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.history = [];
    this.saveState();
  }
};

/**
 * é€‰æ‹©è§’è‰²å¹¶å¼€å§‹æ¸¸æˆ
 */
async function setupDrawAndGuessSession(characterId) {
  if (!characterId) return;

  drawGuessState.isActive = true;
  drawGuessState.partnerId = characterId;
  drawGuessState.history = [];

  const chat = state.chats[characterId];
  if (!chat) return;

  const userAvatar = chat.settings.myAvatar || defaultAvatar;
  const userNickname = chat.settings.myNickname || 'æˆ‘';
  const charAvatar = chat.settings.aiAvatar || defaultAvatar;
  const charNickname = chat.name;

  document.getElementById('draw-guess-user-avatar').src = userAvatar;
  document.getElementById('draw-guess-user-name').textContent = userNickname;
  document.getElementById('draw-guess-char-avatar').src = charAvatar;
  document.getElementById('draw-guess-char-name').textContent = charNickname;
  
  document.getElementById('draw-guess-interactive-area').style.display = 'flex';
  document.getElementById('draw-guess-welcome-text').style.display = 'none';
  document.getElementById('draw-guess-bottom-bar').style.display = 'block';

  showScreen('draw-guess-screen');

  await triggerDrawAndGuessAiResponse(true);
  document.getElementById('draw-guess-action-bar').style.display = 'flex';
}

/**
 * å‘é€æ¶ˆæ¯
 */
function sendDrawGuessMessage() {
  const input = document.getElementById('draw-guess-input');
  const content = input.value.trim();
  if (!content || !drawGuessState.partnerId) return;

  const chat = state.chats[drawGuessState.partnerId];
  if (!chat) return;

  const userMessage = {
    sender: chat.settings.myNickname || 'æˆ‘',
    content: content,
    timestamp: Date.now()
  };

  drawGuessState.history.push(userMessage);
  appendDrawGuessMessage(userMessage);

  input.value = '';
  handleDrawGuessInput();
}

/**
 * æ·»åŠ æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
 */
function appendDrawGuessMessage(msg) {
  const dialogueBox = document.getElementById('draw-guess-dialogue-box');
  dialogueBox.removeAttribute('data-placeholder');
  
  const p = document.createElement('p');
  p.textContent = `${msg.sender}: ${msg.content}`;
  p.style.margin = '4px 0';
  p.style.color = 'var(--text-primary)';
  p.dataset.timestamp = msg.timestamp;
  dialogueBox.appendChild(p);
  dialogueBox.scrollTop = dialogueBox.scrollHeight;
  return p;
}

/**
 * å¤„ç†è¾“å…¥æ¡†å˜åŒ–
 */
function handleDrawGuessInput() {
  const input = document.getElementById('draw-guess-input');
  const actionBar = document.getElementById('draw-guess-action-bar');
  if (input.value.trim()) {
    actionBar.style.display = 'flex';
  } else {
    actionBar.style.display = 'none';
  }
}

/**
 * é‡è¯´åŠŸèƒ½
 */
async function handleDrawGuessResay() {
  const chat = state.chats[drawGuessState.partnerId];
  if (!chat) return;
  
  const userNickname = chat.settings.myNickname || 'æˆ‘';
  const lastAiMsgIndex = drawGuessState.history.findLastIndex(msg => msg.sender !== userNickname);
  
  if (lastAiMsgIndex === -1) {
    alert("è¿˜æ²¡æœ‰AIçš„å›å¤å¯ä¾›é‡è¯´ã€‚");
    return;
  }
  
  let firstAiMsgIndex = lastAiMsgIndex;
  while(firstAiMsgIndex > 0 && drawGuessState.history[firstAiMsgIndex - 1].sender !== userNickname) {
    firstAiMsgIndex--;
  }
  
  drawGuessState.history.splice(firstAiMsgIndex);
  
  const dialogueBox = document.getElementById('draw-guess-dialogue-box');
  dialogueBox.innerHTML = '';
  drawGuessState.history.forEach(appendDrawGuessMessage);
}

/**
 * AIç»˜ç”»åŠ¨ç”»
 */
async function playAiDrawingAnimation(paths) {
  const ctx = drawingBoard.ctx;
  if (!ctx) return;

  drawingBoard.canvas.classList.remove('active');
  drawingBoard.canvas.style.pointerEvents = 'none';

  for (const path of paths) {
    const points = path.points;
    if (!points || points.length < 2) continue;
    
    ctx.strokeStyle = path.color || '#000000';
    ctx.lineWidth = path.size || 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);

    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i][0], points[i][1]);
      ctx.stroke();
      await new Promise(resolve => setTimeout(resolve, 50)); 
    }
    
    drawingBoard.saveState();
    await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
  }

  drawingBoard.canvas.classList.add('active');
  drawingBoard.canvas.style.pointerEvents = 'auto';
}

/**
 * AIå†³å®šè¦ç”»ä»€ä¹ˆ
 */
async function decideAiDrawing(retryCount = 0) {
  if (retryCount > 2) {
    throw new Error("AIè¿ç»­å¤šæ¬¡æœªèƒ½ç”Ÿæˆæœ‰æ•ˆçš„ç»˜ç”»æ•°æ®ï¼Œè¯·æ£€æŸ¥Promptæˆ–APIæ¨¡å‹ã€‚");
  }

  const chat = state.chats[drawGuessState.partnerId];
  const { proxyUrl, apiKey, model } = state.apiConfig;
  
  const mainChatHistory = chat.history.slice(-5).map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || 'æˆ‘') : chat.name}: ${String(msg.content)}`).join('\\n');
  const drawGuessHistory = drawGuessState.history.map(msg => `${msg.sender}: ${msg.content}`).join('\\n');

  const systemPrompt = `# ä½ çš„ä»»åŠ¡
ä½ æ­£åœ¨å’Œç”¨æˆ·ç©"ä½ ç”»æˆ‘çŒœ"æ¸¸æˆï¼Œç°åœ¨è½®åˆ°ä½ ç”»ç”»äº†ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼š
1. æ ¹æ®ä½ çš„äººè®¾ã€ä½ ä»¬çš„å¯¹è¯å†å²ï¼Œæƒ³ä¸€ä¸ªã€ç®€å•ã€å¯ä»¥ç”¨å‡ ç¬”ç”»å‡ºæ¥ã€‘çš„ç‰©ä½“æˆ–æ¦‚å¿µã€‚
2. å°†è¿™ä¸ªç‰©ä½“çš„ç»˜ç”»è¿‡ç¨‹ï¼Œæè¿°æˆä¸€ä¸ªç”±åæ ‡å’Œé¢œè‰²ç»„æˆçš„JSONæ•°æ®ã€‚

# æ ¸å¿ƒè§„åˆ™
1. **ä¸»é¢˜ç®€å•**: å¿…é¡»é€‰æ‹©éå¸¸ç®€å•çš„ã€èƒ½ç”¨å‡ ç¬”çº¿æ¡å°±å‹¾å‹’å‡ºè½®å»“çš„ç‰©ä½“ã€‚ä¾‹å¦‚ï¼šè‹¹æœã€å¤ªé˜³ã€çˆ±å¿ƒã€é±¼ã€çŒ«çš„ç®€ç¬”ç”»è½®å»“ã€æˆ¿å­ã€‚
2. **ç»˜ç”»ç®€æ´**: æ•´ä¸ªç»˜ç”»è¿‡ç¨‹çš„ã€æ€»ç¬”ç”»æ•°ï¼ˆpathsæ•°ç»„çš„é•¿åº¦ï¼‰ä¸èƒ½è¶…è¿‡15ç¬”ã€‘ã€‚
3. **æ ¼å¼é“å¾‹**: ä½ çš„å›å¤ã€å¿…é¡»ä¸”åªèƒ½ã€‘æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ã€‚æ ¼å¼å¦‚ä¸‹:
{
  "topic": "ä½ ç”»çš„è¿™ä¸ªä¸œè¥¿çš„ä¸­æ–‡åï¼Œä¾‹å¦‚ï¼šä¸€åªçŒ«",
  "paths": [
    { "color": "#000000", "size": 3, "points": [[x1, y1], [x2, y2], [x3, y3]] },
    { "color": "#ff3b30", "size": 5, "points": [[x4, y4], [x5, y5]] }
  ]
}

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
- **ä½ çš„è§’è‰²è®¾å®š**: ${chat.settings.aiPersona}
- **ä½ ä»¬åœ¨ä¸»èŠå¤©é‡Œçš„å¯¹è¯**: ${mainChatHistory || 'æ— '}
- **ä½ ä»¬åœ¨è¿™ä¸ªæ¸¸æˆé‡Œçš„å¯¹è¯**: ${drawGuessHistory || 'æ— '}

ç°åœ¨ï¼Œè¯·æ„æ€ä¸€ä¸ªç®€å•çš„ç‰©ä½“ï¼Œå¹¶ç”Ÿæˆå®ƒçš„ç»˜ç”»è·¯å¾„JSONã€‚`;

  let messagesForApi;
  if (retryCount > 0) {
    messagesForApi = [{ role: 'user', content: `ä½ ä¸Šæ¬¡çš„å›å¤æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä¸¥æ ¼éµå®ˆ"æ ¼å¼é“å¾‹"ï¼Œåªè¿”å›ä¸€ä¸ªçº¯ç²¹çš„JSONå¯¹è±¡ï¼Œä¸è¦æ·»åŠ ä»»ä½•é¢å¤–çš„æ–‡å­—ã€‚ç°åœ¨è¯·é‡æ–°ç”Ÿæˆã€‚` }];
  } else {
    messagesForApi = [{ role: 'user', content: "è½®åˆ°ä½ ç”»äº†ï¼Œè¯·å†³å®šè¦ç”»ä»€ä¹ˆå¹¶ç»™å‡ºç»˜ç”»æ•°æ®ã€‚" }];
  }

  let isGemini = proxyUrl.includes('generativelanguage');
  let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
  
  const response = isGemini 
    ? await fetch(geminiConfig.url, geminiConfig.data) 
    : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
        body: JSON.stringify({ model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi], temperature: 1.0, response_format: { "type": "json_object" } })
      });
      
  if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
  const data = await response.json();
  const aiResponseContent = getGeminiResponseText(data);
  
  try {
    const parsedJson = robustJsonParse(aiResponseContent);
    if (!parsedJson || !parsedJson.topic || !Array.isArray(parsedJson.paths)) {
      throw new Error('è§£æå‡ºçš„JSONç¼ºå°‘å¿…è¦çš„topicæˆ–pathså­—æ®µã€‚');
    }
    return parsedJson;
  } catch (e) {
    console.error(`AIç»˜ç”»æ•°æ®è§£æå¤±è´¥ (ç¬¬ ${retryCount + 1} æ¬¡å°è¯•):`, e);
    console.error("AIåŸå§‹è¿”å›å†…å®¹:", aiResponseContent);
    return decideAiDrawing(retryCount + 1);
  }
}

/**
 * è½®åˆ°AIç”»ç”»
 */
async function handleAiTurnToDraw() {
  if (drawGuessState.isAiResponding) return;

  await showCustomAlert("è¯·ç¨å€™...", "å¯¹æ–¹æ­£åœ¨æ€è€ƒè¦ç”»ä»€ä¹ˆ...");

  try {
    document.getElementById('draw-guess-welcome-text').style.display = 'none';
    document.getElementById('draw-guess-studio').style.display = 'flex';
    document.getElementById('drawing-canvas').classList.add('active');

    drawingBoard.ctx.clearRect(0, 0, drawingBoard.canvas.width, drawingBoard.canvas.height);
    drawingBoard.history = [];
    drawingBoard.saveState();
    
    const drawingData = await decideAiDrawing();
    if (!drawingData || !drawingData.paths) throw new Error("AIæœªèƒ½å†³å®šè¦ç”»ä»€ä¹ˆæˆ–è¿”å›äº†æ— æ•ˆçš„ç»˜ç”»æ•°æ®ã€‚");

    await playAiDrawingAnimation(drawingData.paths);

    await showCustomAlert("ä»–ç”»å®Œå•¦ï¼", "å¿«åœ¨ä¸Šé¢çš„å¯¹è¯æ¡†é‡ŒçŒœçŒœçœ‹ä»–ç”»çš„æ˜¯ä»€ä¹ˆå§ï¼");
    
    const hiddenMessageForAi = {
      role: 'system',
      content: `[ç³»ç»Ÿæç¤ºï¼šä½ åˆšåˆšç”»å®Œäº†ä¸€å¹…å…³äº"${drawingData.topic}"çš„ç”»ã€‚ç°åœ¨è½®åˆ°ç”¨æˆ·çŒœæµ‹äº†ï¼Œè¯·æ ¹æ®TAçš„çŒœæµ‹ç»™å‡ºå›åº”ã€‚]`,
      timestamp: Date.now(),
      isHidden: true
    };
    const chat = state.chats[drawGuessState.partnerId];
    chat.history.push(hiddenMessageForAi);
    await db.chats.put(chat);

  } catch (error) {
    console.error("AIç»˜ç”»æµç¨‹å‡ºé”™:", error);
    await showCustomAlert("å‡ºé”™äº†", `AIåœ¨ç»˜ç”»æ—¶é‡åˆ°äº†é—®é¢˜: ${error.message}`);
    document.getElementById('draw-guess-studio').style.display = 'flex';
    document.getElementById('draw-guess-welcome-text').style.display = 'none';
  }
}

/**
 * AIå‡ºé¢˜åŠŸèƒ½
 */
async function handleGetTopicFromAi() {
  if (!drawGuessState.partnerId) return;
  
  const chat = state.chats[drawGuessState.partnerId];
  const { proxyUrl, apiKey, model } = state.apiConfig;
  const userNickname = chat.settings.myNickname || 'æˆ‘';
  
  // è·å–ä¸Šä¸‹æ–‡ä¿¡æ¯
  const aiPersona = chat.settings.aiPersona || 'ä¸€ä¸ªå‹å¥½çš„å¯¹è¯ä¼™ä¼´';
  const myPersona = chat.settings.myPersona || 'ç”¨æˆ·';
  
  const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId => 
    state.worldBooks.find(wb => wb.id === bookId)
  ).filter(Boolean).map(book => 
    `## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`
  ).join('\n');
  
  const longTermMemory = chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n')
    : '';
  
  const shortTermMemory = chat.history.slice(-10).map(msg => 
    `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content)}`
  ).join('\n');
  
  let systemPrompt;
  if (drawGuessState.mode === 'online') {
    systemPrompt = `ä½ ç°åœ¨æ‰®æ¼”: ${chat.name}
ä½ çš„äººè®¾: ${aiPersona}

ç”¨æˆ·å: ${userNickname}
ç”¨æˆ·äººè®¾: ${myPersona}

ä½ æ­£åœ¨é€šè¿‡ã€çº¿ä¸ŠèŠå¤©ã€‘å’Œ${userNickname}ç©"ä½ ç”»æˆ‘çŒœ"æ¸¸æˆã€‚ç”¨æˆ·è®©ä½ å‡ºä¸€ä¸ªç»˜ç”»é¢˜ç›®ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡
ä¸–ç•Œè§‚: ${worldBookContext || 'ï¼ˆæš‚æ— ï¼‰'}
é•¿æœŸè®°å¿†: ${longTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}
æœ€è¿‘å¯¹è¯: ${shortTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}

# è¦æ±‚
1. ç»™ç”¨æˆ·å‡ºä¸€ä¸ªç®€å•çš„ç»˜ç”»é¢˜ç›®ï¼ˆå¯ä»¥ç”¨ç®€ç¬”ç”»ç”»å‡ºæ¥çš„ç‰©ä½“æˆ–æ¦‚å¿µï¼‰
2. ç”¨è‡ªç„¶çš„çº¿ä¸ŠèŠå¤©æ–¹å¼é‚€è¯·TAç”»
3. å¯ä»¥åˆ†æˆå¤šæ¡æ¶ˆæ¯ï¼Œæ¯æ¡ä¸è¶…è¿‡30å­—
4. ä¸è¦æœ‰ä»»ä½•çº¿ä¸‹åŠ¨ä½œæå†™

è¯·ç›´æ¥å›å¤ä½ æƒ³è¯´çš„å†…å®¹ï¼Œå¦‚æœæœ‰å¤šæ¡æ¶ˆæ¯ç”¨æ¢è¡Œç¬¦åˆ†éš”ã€‚æ ¼å¼ä¾‹å¦‚ï¼š
"è¯¶ï¼"
"æˆ‘æƒ³åˆ°ä¸€ä¸ªç®€å•çš„~"
"ä½ æ¥ç”»ä¸€ä¸ªè‹¹æœå§ï¼"`;
  } else {
    systemPrompt = `ä½ æ­£åœ¨å’Œ${userNickname}ç©"ä½ ç”»æˆ‘çŒœ"æ¸¸æˆã€‚è¯·ç»™ç”¨æˆ·å‡ºä¸€ä¸ªç®€å•çš„ç»˜ç”»é¢˜ç›®ï¼ˆä¸€ä¸ªå¯ä»¥ç”¨ç®€ç¬”ç”»ç”»å‡ºæ¥çš„ç‰©ä½“æˆ–æ¦‚å¿µï¼‰ï¼Œå¹¶ç”¨ä¸€å¥è¯å‘TAå‘å‡ºé‚€è¯·ã€‚

ä½ çš„äººè®¾: ${aiPersona}
ç”¨æˆ·äººè®¾: ${myPersona}

ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡:
ä¸–ç•Œè§‚: ${worldBookContext || 'ï¼ˆæš‚æ— ï¼‰'}
é•¿æœŸè®°å¿†: ${longTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}
æœ€è¿‘å¯¹è¯: ${shortTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}

è¯·ç›´æ¥å›å¤ï¼Œæ ¼å¼ä¾‹å¦‚ï¼š"æ¥ï¼Œç”»ä¸€ä¸ªè‹¹æœå§ï¼"`;
  }
  
  const messagesForApi = [{ role: 'user', content: "è¯·ç»™æˆ‘å‡ºä¸ªé¢˜å§" }];
  
  let isGemini = proxyUrl.includes('generativelanguage');
  let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
  
  try {
    const response = isGemini 
      ? await fetch(geminiConfig.url, geminiConfig.data) 
      : await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
          body: JSON.stringify({ model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi] })
        });
        
    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
    const data = await response.json();
    const aiTopic = getGeminiResponseText(data);
    
    // å¤„ç†å›å¤ï¼ˆçº¿ä¸Šæ¨¡å¼æ”¯æŒå¤šæ¡æ¶ˆæ¯ï¼‰
    if (drawGuessState.mode === 'online') {
      const messages = aiTopic.split('\n').filter(msg => msg.trim());
      for (const msgContent of messages) {
        const aiMessage = {
          sender: chat.name,
          content: msgContent.trim(),
          timestamp: Date.now()
        };
        drawGuessState.history.push(aiMessage);
        appendDrawGuessMessage(aiMessage);
        if (messages.length > 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
    } else {
      const aiMessage = {
        sender: chat.name,
        content: aiTopic,
        timestamp: Date.now()
      };
      drawGuessState.history.push(aiMessage);
      appendDrawGuessMessage(aiMessage);
    }
    
  } catch (error) {
    console.error("AIå‡ºé¢˜å¤±è´¥:", error);
    await showCustomAlert("å‡ºé¢˜å¤±è´¥", `æ— æ³•è·å–é¢˜ç›®: ${error.message}`);
  }
}

/**
 * è§¦å‘AIå“åº”
 */
async function triggerDrawAndGuessAiResponse(isInitial = false, imageBase64 = null) {
  if (drawGuessState.isAiResponding || !drawGuessState.isActive || !drawGuessState.partnerId) return;

  drawGuessState.isAiResponding = true;
  
  const dialogueBox = document.getElementById('draw-guess-dialogue-box');
  if (dialogueBox.childElementCount === 0) {
    dialogueBox.setAttribute('data-placeholder', 'å¯¹æ–¹æ­£åœ¨æ€è€ƒ...');
  }

  try {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) throw new Error('APIæœªé…ç½®');

    const chat = state.chats[drawGuessState.partnerId];
    const userNickname = chat.settings.myNickname || 'æˆ‘';
    
    // æ„å»ºæ›´å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
    
    // 1. åŒæ–¹äººè®¾
    const aiPersona = chat.settings.aiPersona || 'ä¸€ä¸ªå‹å¥½çš„å¯¹è¯ä¼™ä¼´';
    const myPersona = chat.settings.myPersona || 'ç”¨æˆ·';
    
    // 2. ä¸–ç•Œä¹¦
    const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId => 
      state.worldBooks.find(wb => wb.id === bookId)
    ).filter(Boolean).map(book => 
      `## ä¸–ç•Œä¹¦ã€Š${book.name}ã€‹è®¾å®š:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`
    ).join('\n');
    
    // 3. é•¿æœŸè®°å¿†
    const longTermMemory = chat.longTermMemory && chat.longTermMemory.length > 0 
      ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n')
      : '';
    
    // 4. çŸ­æœŸè®°å¿†ï¼ˆä¸»èŠå¤©æœ€è¿‘çš„å¯¹è¯ï¼‰
    const shortTermMemory = chat.history.slice(-15).map(msg => 
      `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content)}`
    ).join('\n');
    
    // 5. æŒ‚è½½çš„èŠå¤©è®°å½•
    let linkedChatsContext = '';
    if (chat.settings.linkedChatIds && chat.settings.linkedChatIds.length > 0) {
      const linkedMemories = [];
      for (const linkedId of chat.settings.linkedChatIds) {
        const linkedChat = state.chats[linkedId];
        if (linkedChat && linkedChat.history.length > 0) {
          const recentMessages = linkedChat.history.slice(-5).map(msg => 
            `${msg.role === 'user' ? userNickname : linkedChat.name}: ${String(msg.content)}`
          ).join('\n');
          linkedMemories.push(`\n### å…³è”èŠå¤©è®°å½•ï¼ˆæ¥è‡ª ${linkedChat.name}ï¼‰:\n${recentMessages}`);
        }
      }
      linkedChatsContext = linkedMemories.join('\n');
    }
    
    // 6. æ¸¸æˆå†…å¯¹è¯å†å²
    const drawGuessHistory = drawGuessState.history.map(msg => `${msg.sender}: ${msg.content}`).join('\n');
    
    const canvasContentDescription = imageBase64 ? "(ç”¨æˆ·åˆšåˆšç”»å®Œäº†ä¸€å¹…ç”»ï¼Œå›¾ç‰‡å†…å®¹å¦‚ä¸‹ï¼Œè¯·ä½ çŒœæµ‹ã€‚)" : "(å½“å‰ç”»æ¿ä¸ºç©º)";

    let systemPrompt;
    
    if (drawGuessState.mode === 'online') {
      // çº¿ä¸Šæ¨¡å¼ï¼šæ— çº¿ä¸‹æå†™ï¼Œæ”¯æŒå¤šæ¡æ¶ˆæ¯
      let finalInstruction;
      if (isInitial) {
        finalInstruction = 'è¿™æ˜¯ä½ ä»¬ç¬¬ä¸€æ¬¡åœ¨çº¿ä¸Šæ‰“å¼€è¿™ä¸ªæ¸¸æˆã€‚è¯·ä½ ä¸»åŠ¨è¯´å‡ å¥è¯ï¼Œæ¯”å¦‚æ‰“ä¸ªæ‹›å‘¼ã€è¡¨è¾¾å¯¹æ¸¸æˆçš„æœŸå¾…ã€æˆ–è€…æè®®æ¸¸æˆè§„åˆ™ã€‚';
      } else if (imageBase64) {
        finalInstruction = 'ç”¨æˆ·åˆšåˆšåœ¨çº¿ä¸Šå‘æ¥äº†ä¸€å¹…ç”»ã€‚è¯·ä½ æ ¹æ®å›¾ç‰‡å†…å®¹ã€ä½ çš„äººè®¾å’Œå¯¹è¯å†å²ï¼Œå¼€å§‹ä½ çš„çŒœæµ‹ã€‚ä½ å¯ä»¥å…ˆæè¿°ä½ çœ‹åˆ°äº†ä»€ä¹ˆï¼Œç„¶åæå‡ºå¯èƒ½çš„ç­”æ¡ˆã€‚';
      } else {
        finalInstruction = 'è¯·æ ¹æ®å¯¹è¯å†å²è‡ªç„¶å›åº”ã€‚';
      }
      
      systemPrompt = `# ä½ çš„èº«ä»½
ä½ ç°åœ¨æ‰®æ¼”: ${chat.name}
ä½ çš„äººè®¾: ${aiPersona}

# ç”¨æˆ·çš„èº«ä»½
ç”¨æˆ·å: ${userNickname}
ç”¨æˆ·äººè®¾: ${myPersona}

# å½“å‰æƒ…å†µ
ä½ æ­£åœ¨é€šè¿‡ã€çº¿ä¸ŠèŠå¤©ã€‘å’Œ${userNickname}ç©"ä½ ç”»æˆ‘çŒœ"æ¸¸æˆã€‚è¿™æ˜¯ä¸€ä¸ªçº¿ä¸Šäº’åŠ¨ï¼Œä½ ä»¬ä¸åœ¨åŒä¸€ä¸ªåœ°ç‚¹ã€‚
ç”»æ¿å†…å®¹: ${canvasContentDescription}

# ã€å¯¹è¯èŠ‚å¥é“å¾‹ï¼ˆè‡³å…³é‡è¦ï¼ï¼‰ã€‘
ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ¨¡æ‹ŸçœŸäººåœ¨çº¿èŠå¤©çš„æ‰“å­—ä¹ æƒ¯ã€‚**ç»å¯¹ä¸è¦ä¸€æ¬¡æ€§å‘é€ä¸€å¤§æ®µæ–‡å­—ï¼** ä½ åº”è¯¥å°†ä½ æƒ³è¯´çš„è¯ï¼Œæ‹†åˆ†æˆã€å¤šæ¡ã€ç®€çŸ­çš„ã€‘æ¶ˆæ¯æ¥å‘é€ï¼Œæ¯æ¡æ¶ˆæ¯æœ€å¥½ä¸è¦è¶…è¿‡30ä¸ªå­—ã€‚è¿™ä¼šè®©å¯¹è¯çœ‹èµ·æ¥æ›´è‡ªç„¶ã€æ›´çœŸå®ã€‚

ä¸¾ä¾‹ï¼š
- âŒ é”™è¯¯ï¼š"å“‡ï¼ä½ ç”»çš„è¿™ä¸ªçœŸæœ‰æ„æ€ï¼Œè®©æˆ‘æƒ³æƒ³...è¿™ä¸ªåœ†åœ†çš„å½¢çŠ¶ï¼Œè¿˜æœ‰ä¸Šé¢çš„å°ç‚¹ï¼Œä¼šä¸ä¼šæ˜¯ä¸€ä¸ªè‹¹æœï¼Ÿä¸å¯¹ï¼Œæ„Ÿè§‰æ›´åƒæ˜¯ä¸€ä¸ªå¤ªé˜³å‘¢ï¼"
- âœ… æ­£ç¡®ï¼š
  æ¶ˆæ¯1: "å“‡ï¼ä½ ç”»çš„è¿™ä¸ªçœŸæœ‰æ„æ€"
  æ¶ˆæ¯2: "è®©æˆ‘æƒ³æƒ³..."
  æ¶ˆæ¯3: "è¿™ä¸ªåœ†åœ†çš„å½¢çŠ¶"
  æ¶ˆæ¯4: "è¿˜æœ‰ä¸Šé¢çš„å°ç‚¹"
  æ¶ˆæ¯5: "ä¼šä¸ä¼šæ˜¯ä¸€ä¸ªè‹¹æœï¼Ÿ"
  æ¶ˆæ¯6: "ä¸å¯¹ï¼Œæ„Ÿè§‰æ›´åƒæ˜¯ä¸€ä¸ªå¤ªé˜³å‘¢ï¼"

# æ ¸å¿ƒè§„åˆ™
1. **ã€çº¿ä¸Šåœºæ™¯ã€‘**: ä½ ä»¬åœ¨çº¿ä¸ŠèŠå¤©ï¼Œä¸åœ¨åŒä¸€ä¸ªåœ°ç‚¹ã€‚ã€ç¦æ­¢ã€‘å‡ºç°ä»»ä½•çº¿ä¸‹è§é¢çš„æå†™ï¼Œå¦‚"èµ°è¿‡æ¥"ã€"æ‹¿èµ·ç¬”"ã€"çœ‹å‘ä½ "ç­‰åŠ¨ä½œæè¿°ã€‚
2. **ã€çº¯æ–‡å­—äº¤æµã€‘**: ä½ åªèƒ½é€šè¿‡æ–‡å­—è¡¨è¾¾ï¼Œå¯ä»¥ä½¿ç”¨è¯­æ°”è¯ã€è¡¨æƒ…ç¬¦å·ï¼Œä½†ä¸èƒ½æè¿°è‚¢ä½“åŠ¨ä½œæˆ–è¡¨æƒ…ã€‚
3. **ã€å¤šæ¡æ¶ˆæ¯ã€‘**: ä½ çš„å›å¤åº”è¯¥è‡ªç„¶åœ°æ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯ï¼Œå°±åƒçœŸäººåœ¨çº¿èŠå¤©æ—¶çš„èŠ‚å¥ã€‚

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡

## ä¸–ç•Œè§‚è®¾å®š
${worldBookContext || 'ï¼ˆæš‚æ— ï¼‰'}

## é•¿æœŸè®°å¿†ï¼ˆä½ ä»¬ä¹‹é—´çš„é‡è¦è®°å¿†ï¼‰
${longTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}
${linkedChatsContext}

## çŸ­æœŸè®°å¿†ï¼ˆä½ ä»¬æœ€è¿‘åœ¨ä¸»èŠå¤©çš„å¯¹è¯ï¼‰
${shortTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}

## æ¸¸æˆå†…å¯¹è¯ï¼ˆæœ¬æ¬¡æ¸¸æˆä¸­çš„å¯¹è¯ï¼‰
${drawGuessHistory || 'ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰'}

# ä½ çš„ä»»åŠ¡
${finalInstruction}

è¯·ç›´æ¥å›å¤ä½ æƒ³è¯´çš„å†…å®¹ï¼Œå°†ä½ çš„è¯è‡ªç„¶åœ°åˆ†æˆå¤šæ¡æ¶ˆæ¯ã€‚æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç”¨æ¢è¡Œç¬¦ï¼ˆ\nï¼‰åˆ†éš”ã€‚ä¸è¦åŠ ä»»ä½•JSONæ ¼å¼æˆ–å‰ç¼€åç¼€ã€‚`;
    } else {
      // çº¿ä¸‹æ¨¡å¼ï¼šä¿ç•™åŸæœ‰çš„æç¤ºè¯ï¼ˆæœ‰çº¿ä¸‹æå†™ï¼‰
      let finalInstruction;
      if (isInitial) {
        finalInstruction = 'è¿™æ˜¯ä½ ä»¬ç¬¬ä¸€æ¬¡æ‰“å¼€è¿™ä¸ªæ¸¸æˆã€‚è¯·ä½ ä¸»åŠ¨è¯´å‡ å¥è¯ï¼Œæ¯”å¦‚æ‰“ä¸ªæ‹›å‘¼ã€è¡¨è¾¾å¯¹æ¸¸æˆçš„æœŸå¾…ã€æˆ–è€…åˆ¶å®šæ¸¸æˆè§„åˆ™ï¼Œæ¥å¼€å¯è¿™åœºæ¸¸æˆã€‚';
      } else if (imageBase64) {
        finalInstruction = 'ç”¨æˆ·åˆšåˆšç”»å®Œäº†ä¸€å¹…ç”»ï¼Œå›¾ç‰‡å†…å®¹å·²æä¾›ã€‚è¯·ä½ æ ¹æ®å›¾ç‰‡å†…å®¹ã€ä½ çš„äººè®¾å’Œå¯¹è¯å†å²ï¼Œå¼€å§‹ä½ çš„çŒœæµ‹ã€‚ä½ çš„çŒœæµ‹è¿‡ç¨‹åº”è¯¥åƒçœŸäººä¸€æ ·ï¼Œå¯ä»¥å…ˆæè¿°ä½ çœ‹åˆ°äº†ä»€ä¹ˆï¼Œç„¶åæå‡ºå¯èƒ½çš„ç­”æ¡ˆï¼Œå¯ä»¥æ˜¯å¯¹çš„ä¹Ÿå¯ä»¥æ˜¯é”™çš„ã€‚';
      } else {
        finalInstruction = 'è¯·æ ¹æ®å¯¹è¯å†å²è‡ªç„¶å›åº”ã€‚';
      }
      
      systemPrompt = `# ä½ çš„èº«ä»½
ä½ ç°åœ¨æ‰®æ¼”: ${chat.name}
ä½ çš„äººè®¾: ${aiPersona}

# ç”¨æˆ·çš„èº«ä»½
ç”¨æˆ·å: ${userNickname}
ç”¨æˆ·äººè®¾: ${myPersona}

# å½“å‰æƒ…å†µ
ä½ æ­£åœ¨å’Œ${userNickname}ç©"ä½ ç”»æˆ‘çŒœ"æ¸¸æˆã€‚
ç”»æ¿å†…å®¹: ${canvasContentDescription}

# ä¾›ä½ å‚è€ƒçš„ä¸Šä¸‹æ–‡

## ä¸–ç•Œè§‚è®¾å®š
${worldBookContext || 'ï¼ˆæš‚æ— ï¼‰'}

## é•¿æœŸè®°å¿†ï¼ˆä½ ä»¬ä¹‹é—´çš„é‡è¦è®°å¿†ï¼‰
${longTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}
${linkedChatsContext}

## çŸ­æœŸè®°å¿†ï¼ˆä½ ä»¬æœ€è¿‘åœ¨ä¸»èŠå¤©çš„å¯¹è¯ï¼‰
${shortTermMemory || 'ï¼ˆæš‚æ— ï¼‰'}

## æ¸¸æˆå†…å¯¹è¯ï¼ˆæœ¬æ¬¡æ¸¸æˆä¸­çš„å¯¹è¯ï¼‰
${drawGuessHistory || 'ï¼ˆæ¸¸æˆåˆšå¼€å§‹ï¼‰'}

# ä½ çš„ä»»åŠ¡
${finalInstruction}

è¯·ç›´æ¥å›å¤ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€æˆ–åç¼€ã€‚`;
    }

  let messagesForApi = imageBase64 
    ? [{ role: 'user', content: [{ type: 'text', text: 'ä½ çœ‹æˆ‘ç”»äº†ä»€ä¹ˆï¼Ÿ' }, { type: 'image_url', image_url: { url: imageBase64 } }] }]
    : [{ role: 'user', content: drawGuessState.history.length > 0 ? drawGuessState.history[drawGuessState.history.length - 1].content : 'å¼€å§‹æ¸¸æˆå§' }];

  let isGemini = proxyUrl.includes('generativelanguage');
  let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
    
    const response = isGemini 
      ? await fetch(geminiConfig.url, geminiConfig.data) 
      : await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
          body: JSON.stringify({ model, messages: [{role: 'system', content: systemPrompt}, ...messagesForApi] })
        });
        
    if (!response.ok) throw new Error(`API é”™è¯¯: ${response.statusText}`);
    const data = await response.json();
    const aiReply = getGeminiResponseText(data);

    // å¤„ç†AIå›å¤
    if (drawGuessState.mode === 'online') {
      // çº¿ä¸Šæ¨¡å¼ï¼šæ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯
      const messages = aiReply.split('\n').filter(msg => msg.trim());
      
      for (const msgContent of messages) {
        const aiMessage = {
          sender: chat.name,
          content: msgContent.trim(),
          timestamp: Date.now()
        };
        drawGuessState.history.push(aiMessage);
        appendDrawGuessMessage(aiMessage);
        
        // æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œæ¨¡æ‹Ÿæ‰“å­—æ•ˆæœ
        if (messages.length > 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
    } else {
      // çº¿ä¸‹æ¨¡å¼ï¼šä¿æŒåŸæœ‰é€»è¾‘ï¼ˆå•æ¡æ¶ˆæ¯ï¼‰
      const aiMessage = {
        sender: chat.name,
        content: aiReply,
        timestamp: Date.now()
      };
      drawGuessState.history.push(aiMessage);
      appendDrawGuessMessage(aiMessage);
    }

  } catch (error) {
    console.error("AIå“åº”å¤±è´¥:", error);
    await showCustomAlert("AIå“åº”å¤±è´¥", `æ— æ³•è·å–å›å¤: ${error.message}`);
  } finally {
    drawGuessState.isAiResponding = false;
    dialogueBox.removeAttribute('data-placeholder');
  }
}

/**
 * æäº¤ç”»ä½œè®©AIçŒœ
 */
async function submitDrawingToAi() {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = drawingBoard.canvas.width;
  tempCanvas.height = drawingBoard.canvas.height;
  tempCtx.fillStyle = '#FFFFFF';
  tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  if (drawingBoard.canvas.toDataURL() === tempCanvas.toDataURL()) {
    alert("ç”»æ¿ä¸Šè¿˜æ²¡æœ‰å†…å®¹å“¦ï¼Œå¿«æ¥ç”»ç‚¹ä»€ä¹ˆå§ï¼");
    return;
  }
  
  const chat = state.chats[drawGuessState.partnerId];
  if (chat) {
    await showCustomAlert("æäº¤æˆåŠŸ", `å·²ç»æŠŠä½ çš„ç”»ä½œæäº¤ç»™"${chat.name}"äº†ï¼\\nTAæ­£åœ¨åŠªåŠ›çŒœæµ‹ä¸­...`);
  }
  
  const drawingBase64 = drawingBoard.canvas.toDataURL('image/png');
  await triggerDrawAndGuessAiResponse(false, drawingBase64);

  drawingBoard.ctx.clearRect(0, 0, drawingBoard.canvas.width, drawingBoard.canvas.height);
  drawingBoard.history = [];
  drawingBoard.saveState();
  document.getElementById('start-draw-guess-game-btn').textContent = 'æäº¤ç”»ä½œ';
}

/**
 * æ‰“å¼€æ¶ˆæ¯ç®¡ç†å¼¹çª—
 */
function openDrawGuessMessageManager(mode) {
  const modal = document.getElementById('draw-guess-message-manager-modal');
  const titleEl = document.getElementById('draw-guess-manager-title');
  const confirmBtn = document.getElementById('draw-guess-manager-confirm-btn');
  const listEl = document.getElementById('draw-guess-manager-list');
  listEl.innerHTML = '';

  titleEl.textContent = mode === 'edit' ? 'é€‰æ‹©è¦ç¼–è¾‘çš„æ¶ˆæ¯' : 'é€‰æ‹©è¦åˆ é™¤çš„æ¶ˆæ¯';
  confirmBtn.textContent = mode === 'edit' ? 'å¼€å§‹ç¼–è¾‘' : 'ç¡®è®¤åˆ é™¤';
  confirmBtn.classList.toggle('btn-danger', mode === 'delete');

  drawGuessState.history.forEach(msg => {
    const item = document.createElement('div');
    item.className = 'contact-picker-item';
    item.dataset.timestamp = msg.timestamp;
    item.innerHTML = `
      <div class="checkbox"></div>
      <div class="info" style="display: block;">
        <p style="margin:0; font-weight:500;">${msg.sender}:</p>
        <p style="margin:0; color: #8a8a8a;">${msg.content.substring(0, 30)}...</p>
      </div>
    `;
    listEl.appendChild(item);
  });
  
  drawGuessState.messageManager.mode = mode;
  drawGuessState.messageManager.selectedTimestamps.clear();
  modal.classList.add('visible');
}

/**
 * å¤„ç†æ¶ˆæ¯ç®¡ç†ç¡®è®¤
 */
async function handleMessageManagerConfirm() {
  const { mode, selectedTimestamps } = drawGuessState.messageManager;
  if (selectedTimestamps.size === 0) {
    alert("è¯·è‡³å°‘é€‰æ‹©ä¸€æ¡æ¶ˆæ¯ã€‚");
    return;
  }

  if (mode === 'delete') {
    drawGuessState.history = drawGuessState.history.filter(m => !selectedTimestamps.has(m.timestamp));
    const dialogueBox = document.getElementById('draw-guess-dialogue-box');
    dialogueBox.innerHTML = '';
    drawGuessState.history.forEach(appendDrawGuessMessage);
  } else if (mode === 'edit') {
    if (selectedTimestamps.size > 1) {
      alert("ç¼–è¾‘æ¨¡å¼ä¸‹åªèƒ½é€‰æ‹©ä¸€æ¡æ¶ˆæ¯ã€‚");
      return;
    }
    const timestampToEdit = [...selectedTimestamps][0];
    const msgIndex = drawGuessState.history.findIndex(m => m.timestamp === timestampToEdit);
    if (msgIndex > -1) {
      const currentContent = drawGuessState.history[msgIndex].content;
      const newContent = await showCustomPrompt('ç¼–è¾‘æ¶ˆæ¯', '', currentContent, 'textarea');
      if (newContent !== null) {
        drawGuessState.history[msgIndex].content = newContent.trim();
        const dialogueBox = document.getElementById('draw-guess-dialogue-box');
        dialogueBox.innerHTML = '';
        drawGuessState.history.forEach(appendDrawGuessMessage);
      }
    }
  }

  document.getElementById('draw-guess-message-manager-modal').classList.remove('visible');
  drawGuessState.messageManager.selectedTimestamps.clear();
}

/**
 * åˆå§‹åŒ–"ä½ ç”»æˆ‘çŒœ"äº‹ä»¶ç›‘å¬å™¨
 */
function initDrawAndGuessListeners() {
  // è®¾ç½®æŒ‰é’®
  const settingsBtn = document.getElementById('draw-guess-settings-btn');
  if (settingsBtn) {
    settingsBtn.addEventListener('click', () => {
      // æ‰“å¼€è®¾ç½®å¼¹çª—
      const modal = document.getElementById('draw-guess-settings-modal');
      const onlineRadio = document.getElementById('draw-guess-mode-online');
      const offlineRadio = document.getElementById('draw-guess-mode-offline');
      
      // è®¾ç½®å½“å‰é€‰ä¸­çš„æ¨¡å¼
      if (drawGuessState.mode === 'online') {
        onlineRadio.checked = true;
      } else {
        offlineRadio.checked = true;
      }
      
      modal.classList.add('visible');
    });
  }

  // è®¾ç½®å¼¹çª— - ä¿å­˜æŒ‰é’®
  const settingsSaveBtn = document.getElementById('draw-guess-settings-save-btn');
  if (settingsSaveBtn) {
    settingsSaveBtn.addEventListener('click', () => {
      const onlineRadio = document.getElementById('draw-guess-mode-online');
      drawGuessState.mode = onlineRadio.checked ? 'online' : 'offline';
      
      document.getElementById('draw-guess-settings-modal').classList.remove('visible');
      console.log('æ¸¸æˆæ¨¡å¼å·²åˆ‡æ¢ä¸º:', drawGuessState.mode);
    });
  }

  // è®¾ç½®å¼¹çª— - å–æ¶ˆæŒ‰é’®
  const settingsCancelBtn = document.getElementById('draw-guess-settings-cancel-btn');
  if (settingsCancelBtn) {
    settingsCancelBtn.addEventListener('click', () => {
      document.getElementById('draw-guess-settings-modal').classList.remove('visible');
    });
  }

  // é€‰æ‹©è§’è‰²æŒ‰é’®
  const selectCharBtn = document.getElementById('draw-guess-select-char-btn');
  if (selectCharBtn) {
    selectCharBtn.addEventListener('click', async () => {
      const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
      if (characters.length === 0) {
        alert("è¿˜æ²¡æœ‰å¯ä»¥ä¸€èµ·ç©çš„è§’è‰²å“¦~");
        return;
      }
      
      const options = characters.map(char => ({ text: char.name, value: char.id }));
      const selectedId = await showChoiceModal('é€‰æ‹©æ¸¸æˆä¼™ä¼´', options);
      if (selectedId) {
        await setupDrawAndGuessSession(selectedId);
      }
    });
  }

  // å¼€å§‹æ¸¸æˆ/æäº¤ç”»ä½œæŒ‰é’®
  const startBtn = document.getElementById('start-draw-guess-game-btn');
  if (startBtn) {
    startBtn.addEventListener('click', async () => {
      if (!drawGuessState.isActive) return;
      
      const btnText = startBtn.textContent;
      if (btnText === 'å¼€å§‹æ¸¸æˆ') {
        document.getElementById('draw-guess-studio').style.display = 'flex';
        document.getElementById('draw-guess-welcome-text').style.display = 'none';
        drawingBoard.init('drawing-canvas');
        document.getElementById('drawing-canvas').classList.add('active');
        startBtn.textContent = 'æäº¤ç”»ä½œ';
      } else if (btnText === 'æäº¤ç”»ä½œ') {
        await submitDrawingToAi();
      }
    });
  }

  // å‘é€æ¶ˆæ¯æŒ‰é’®
  const sendBtn = document.getElementById('draw-guess-send-btn');
  if (sendBtn) {
    sendBtn.addEventListener('click', sendDrawGuessMessage);
  }

  // è¾“å…¥æ¡†å›è½¦å‘é€
  const input = document.getElementById('draw-guess-input');
  if (input) {
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendDrawGuessMessage();
    });
    input.addEventListener('input', handleDrawGuessInput);
  }

  // AIå‡ºé¢˜æŒ‰é’®
  const getTopicBtn = document.getElementById('draw-guess-get-topic-btn');
  if (getTopicBtn) {
    getTopicBtn.addEventListener('click', handleGetTopicFromAi);
  }

  // è½®åˆ°AIç”»ç”»æŒ‰é’®
  const aiTurnBtn = document.getElementById('draw-guess-ai-turn-btn');
  if (aiTurnBtn) {
    aiTurnBtn.addEventListener('click', handleAiTurnToDraw);
  }

  // é¢œè‰²é€‰æ‹©
  document.querySelectorAll('.color-dot').forEach(dot => {
    dot.addEventListener('click', () => {
      document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
      dot.classList.add('active');
      const color = dot.dataset.color;
      drawingBoard.setColor(color);
      document.getElementById('custom-color-input').value = color;
    });
  });

  // è‡ªå®šä¹‰é¢œè‰²é€‰æ‹©å™¨
  const customColorInput = document.getElementById('custom-color-input');
  if (customColorInput) {
    customColorInput.addEventListener('change', (e) => {
      const color = e.target.value;
      drawingBoard.setColor(color);
      document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
    });
  }

  // å·¥å…·æŒ‰é’®
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const tool = btn.dataset.tool;
      if (tool === 'undo') {
        drawingBoard.undo();
      } else if (tool === 'clear') {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»æ¿å—ï¼Ÿ')) {
          drawingBoard.clearCanvas();
        }
      } else {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        drawingBoard.setTool(tool);
      }
    });
  });

  // ç”»ç¬”å¤§å°
  const sizeSlider = document.getElementById('brush-size-slider');
  const sizeInput = document.getElementById('brush-size-input');
  if (sizeSlider && sizeInput) {
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      sizeInput.value = size;
      drawingBoard.setSize(size);
    });
    sizeInput.addEventListener('change', (e) => {
      const size = parseInt(e.target.value);
      sizeSlider.value = size;
      drawingBoard.setSize(size);
    });
  }

  // ç”»ç¬”ç±»å‹
  const penTypeSelect = document.getElementById('pen-type-select');
  if (penTypeSelect) {
    penTypeSelect.addEventListener('change', (e) => {
      drawingBoard.setPenType(e.target.value);
    });
  }

  // æ“ä½œæ æŒ‰é’®
  const actionBar = document.getElementById('draw-guess-action-bar');
  if (actionBar) {
    actionBar.addEventListener('click', async (e) => {
      const btn = e.target.closest('.action-bar-btn');
      if (!btn) return;
      
      const action = btn.dataset.action;
      if (action === 'reply') {
        await triggerDrawAndGuessAiResponse();
      } else if (action === 'delete') {
        openDrawGuessMessageManager('delete');
      } else if (action === 'edit') {
        openDrawGuessMessageManager('edit');
      } else if (action === 'resay') {
        await handleDrawGuessResay();
      }
    });
  }

  // æ¶ˆæ¯ç®¡ç†å¼¹çª—
  const managerCancelBtn = document.getElementById('draw-guess-manager-cancel-btn');
  const managerConfirmBtn = document.getElementById('draw-guess-manager-confirm-btn');
  const managerSelectAll = document.getElementById('draw-guess-manager-select-all');
  
  if (managerCancelBtn) {
    managerCancelBtn.addEventListener('click', () => {
      document.getElementById('draw-guess-message-manager-modal').classList.remove('visible');
      drawGuessState.messageManager.selectedTimestamps.clear();
    });
  }
  
  if (managerConfirmBtn) {
    managerConfirmBtn.addEventListener('click', handleMessageManagerConfirm);
  }
  
  if (managerSelectAll) {
    managerSelectAll.addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      document.querySelectorAll('#draw-guess-manager-list .contact-picker-item').forEach(item => {
        item.classList.toggle('selected', isChecked);
        const timestamp = parseFloat(item.dataset.timestamp);
        if (isChecked) {
          drawGuessState.messageManager.selectedTimestamps.add(timestamp);
        } else {
          drawGuessState.messageManager.selectedTimestamps.delete(timestamp);
        }
      });
    });
  }

  // æ¶ˆæ¯åˆ—è¡¨ç‚¹å‡»é€‰æ‹©
  const managerList = document.getElementById('draw-guess-manager-list');
  if (managerList) {
    managerList.addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (item) {
        const timestamp = parseFloat(item.dataset.timestamp);
        if (drawGuessState.messageManager.mode === 'edit') {
          document.querySelectorAll('#draw-guess-manager-list .contact-picker-item.selected').forEach(el => el.classList.remove('selected'));
          drawGuessState.messageManager.selectedTimestamps.clear();
        }
        item.classList.toggle('selected');
        if (drawGuessState.messageManager.selectedTimestamps.has(timestamp)) {
          drawGuessState.messageManager.selectedTimestamps.delete(timestamp);
        } else {
          drawGuessState.messageManager.selectedTimestamps.add(timestamp);
        }
      }
    });
  }
}

// åˆå§‹åŒ–ä½ ç”»æˆ‘çŒœåŠŸèƒ½
initDrawAndGuessListeners();

// â–²â–²â–² ä½ ç”»æˆ‘çŒœåŠŸèƒ½ç»“æŸ â–²â–²â–²
   
// 2. ç»‘å®šç¡®è®¤å’Œå–æ¶ˆæŒ‰é’®äº‹ä»¶ (è¯·å°†æ­¤æ®µä»£ç æ”¾åœ¨ init() å‡½æ•°ä¸­ï¼Œæˆ–è€…è„šæœ¬åº•éƒ¨çš„äº‹ä»¶ç›‘å¬åŒºåŸŸ)
document.addEventListener('DOMContentLoaded', () => {
    // ... å…¶ä»–åˆå§‹åŒ–ä»£ç  ...

    // ç»‘å®šäº²å±å¡å¼¹çª—æŒ‰é’®
    const cancelBtn = document.getElementById('cancel-kinship-creation-btn');
    const confirmBtn = document.getElementById('confirm-kinship-creation-btn');
    const modal = document.getElementById('kinship-creation-modal');

    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
            modal.classList.remove('visible');
        });
    }

    if (confirmBtn) {
        confirmBtn.addEventListener('click', async () => {
            if (!selectedKinshipCharId) {
                return alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç»‘å®šå¯¹è±¡ï¼");
            }

            const limitInput = document.getElementById('kinship-limit-input');
            const limit = parseFloat(limitInput.value);

            if (isNaN(limit) || limit <= 0) {
                return alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é¢åº¦ï¼");
            }

            // è°ƒç”¨åŸæœ‰çš„å‘é€é€»è¾‘
            await sendKinshipRequest(selectedKinshipCharId, limit);
            
            // å…³é—­å¼¹çª—
            modal.classList.remove('visible');
            
            // å¦‚æœå½“å‰ä¸åœ¨è¯¥èŠå¤©ï¼Œæç¤ºè·³è½¬
            if (state.activeChatId !== selectedKinshipCharId) {
               // sendKinshipRequest å†…éƒ¨å·²ç»å¤„ç†äº†è·³è½¬æˆ–è¿½åŠ æ¶ˆæ¯
            }
        });
    }
});
const kinshipCancelBtn = document.getElementById('cancel-kinship-creation-btn');
    if (kinshipCancelBtn) {
        // å…ˆç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§ç›‘å¬å™¨ï¼Œé˜²æ­¢é‡å¤
        const newCancelBtn = kinshipCancelBtn.cloneNode(true);
        kinshipCancelBtn.parentNode.replaceChild(newCancelBtn, kinshipCancelBtn);
        
        newCancelBtn.addEventListener('click', () => {
            document.getElementById('kinship-creation-modal').classList.remove('visible');
        });
    }

    // ç»‘å®šç¡®è®¤èµ é€/ç”³è¯·æŒ‰é’®
    const kinshipConfirmBtn = document.getElementById('confirm-kinship-creation-btn');
    if (kinshipConfirmBtn) {
        const newConfirmBtn = kinshipConfirmBtn.cloneNode(true);
        kinshipConfirmBtn.parentNode.replaceChild(newConfirmBtn, kinshipConfirmBtn);

        newConfirmBtn.addEventListener('click', async () => {
            if (!selectedKinshipCharId) {
                return alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¯¹è±¡ï¼");
            }

            const limitInput = document.getElementById('kinship-limit-input');
            const limit = parseFloat(limitInput.value);

            if (isNaN(limit) || limit <= 0) {
                return alert("è¯·è¾“å…¥æœ‰æ•ˆçš„é¢åº¦ï¼ˆå¿…é¡»å¤§äº0ï¼‰ï¼");
            }

            // --- æ–°å¢ï¼šè·å–é€‰æ‹©çš„ç±»å‹ ---
            const typeRadio = document.querySelector('input[name="kinship-type"]:checked');
            const type = typeRadio ? typeRadio.value : 'grant'; // é»˜è®¤ä¸ºèµ é€

            // è°ƒç”¨å‘é€é€»è¾‘ï¼Œä¼ å…¥ type
            await sendKinshipRequest(selectedKinshipCharId, limit, type);
            
            document.getElementById('kinship-creation-modal').classList.remove('visible');
            
            const actionText = type === 'grant' ? "èµ é€" : "ç”³è¯·";
            await showCustomAlert(`${actionText}æˆåŠŸ`, `äº²å±å¡${actionText}å·²å‘é€ç»™å¯¹æ–¹ã€‚`);
        });
    }
document.getElementById('char-wallet-content').addEventListener('click', async (e) => {
    if (e.target.classList.contains('unbind-kinship-btn')) {
        e.stopPropagation();
        const chatId = e.target.dataset.chatId;
        
        // 1. å…ˆè·å–é’±åŒ…æ•°æ®ï¼Œåˆ¤æ–­æ˜¯è°ç»™è°å¼€çš„å¡
        const wallet = await db.userWallet.get('main');
        const card = wallet?.kinshipCards?.find(c => c.chatId === chatId);
        
        if (!card) {
            // å¡ä¸å­˜åœ¨ï¼ˆå¯èƒ½æ•°æ®é”™ä¹±ï¼‰ï¼Œç»™ä¸ªé»˜è®¤æç¤º
            alert("æœªæ‰¾åˆ°è¯¥äº²å±å¡è®°å½•");
            return;
        }

        // 2. æ ¹æ®ç±»å‹å†³å®šæ–‡æ¡ˆ
        // å¦‚æœæ²¡æœ‰ type å­—æ®µï¼ˆæ—§æ•°æ®ï¼‰ï¼Œé»˜è®¤è®¤ä¸ºæ˜¯ 'out' (æˆ‘é€TA)
        const isMyGift = (card.type === 'out' || !card.type); 
        
        let title = "";
        let message = "";
        let confirmText = "";

        if (isMyGift) {
            title = "æ”¶å›äº²å±å¡";
            message = "ç¡®å®šè¦åœæ­¢ä¸º TA ä¹°å•å—ï¼Ÿ\næ”¶å›åï¼Œå¯¹æ–¹å°†æ— æ³•å†ä½¿ç”¨æ‚¨çš„é¢åº¦æ¶ˆè´¹ã€‚";
            confirmText = "ç¡®è®¤æ”¶å›";
        } else {
            title = "é€€è¿˜äº²å±å¡";
            message = "ç¡®å®šè¦è§£ç»‘è¿™å¼ äº²å±å¡å—ï¼Ÿ\nè§£ç»‘åï¼Œæ‚¨å°†æ— æ³•å†ä½¿ç”¨ TA çš„é¢åº¦æ¶ˆè´¹ã€‚";
            confirmText = "ç¡®è®¤é€€è¿˜";
        }
        
        const confirmed = await showCustomConfirm(
            title, 
            message, 
            { confirmButtonClass: 'btn-danger', confirmText: confirmText }
        );

        if (confirmed) {
            try {
                if (wallet && wallet.kinshipCards) {
                    // è¿‡æ»¤æ‰å½“å‰è§’è‰²çš„å¡
                    wallet.kinshipCards = wallet.kinshipCards.filter(c => c.chatId !== chatId);
                    await db.userWallet.put(wallet);
                    
                    await showCustomAlert("æˆåŠŸ", "äº²å±å¡å·²è§£ç»‘ã€‚");
                    
                    // åˆ·æ–°ç•Œé¢
                    renderCharWallet();
                    
                    // 3. å‘é€ç³»ç»Ÿæ¶ˆæ¯é€šçŸ¥AI (æ ¹æ®æ–¹å‘ä¸åŒï¼Œé€šçŸ¥å†…å®¹ä¹Ÿä¸åŒ)
                    const chat = state.chats[chatId];
                    if(chat) {
                        let sysContent = "";
                        if (isMyGift) {
                            sysContent = '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å·²æ”¶å›äº†ç»™ä½ çš„äº²å±å¡é¢åº¦ï¼Œä½ æ— æ³•å†ä½¿ç”¨ä»£ä»˜åŠŸèƒ½äº†ã€‚]';
                        } else {
                            sysContent = '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ä¸»åŠ¨é€€è¿˜/è§£ç»‘äº†ä½ èµ é€çš„äº²å±å¡ï¼Œä¸å†ä½¿ç”¨ä½ çš„é’±äº†ã€‚]';
                        }

                        chat.history.push({
                           role: 'system',
                           content: sysContent,
                           timestamp: Date.now(),
                           isHidden: true
                        });
                        await db.chats.put(chat);
                    }
                }
            } catch (error) {
                console.error(error);
                alert("è§£ç»‘å¤±è´¥");
            }
        }
    }
});
const alipayScreen = document.getElementById('alipay-screen');
if (alipayScreen) {
    alipayScreen.addEventListener('click', async (e) => {
        // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯ä¸æ˜¯è§£ç»‘æŒ‰é’®
        if (e.target.classList.contains('alipay-unbind-btn')) {
            e.stopPropagation(); 
            
            const chatId = e.target.dataset.chatId;
            const chat = state.chats[chatId];
            const charName = chat ? chat.name : 'è¯¥è§’è‰²';

            // 1. è·å–é’±åŒ…æ•°æ®åˆ¤æ–­æ–¹å‘
            const wallet = await db.userWallet.get('main');
            const card = wallet?.kinshipCards?.find(c => c.chatId === chatId);
            
            if (!card) return;

            // 2. åŠ¨æ€ç”Ÿæˆæ–‡æ¡ˆ
            const isMyGift = (card.type === 'out' || !card.type);
            
            let title = "";
            let message = "";
            let confirmText = "";

            if (isMyGift) {
                title = "ç»ˆæ­¢èµ äºˆ";
                message = `ç¡®å®šè¦åœæ­¢èµ äºˆâ€œ${charName}â€äº²å±å¡å—ï¼Ÿ\nè§£ç»‘åï¼Œå¯¹æ–¹å°†æ— æ³•å†ä½¿ç”¨è¯¥é¢åº¦ã€‚`;
                confirmText = "ç¡®è®¤æ”¶å›";
            } else {
                title = "è§£ç»‘äº²å±å¡";
                message = `ç¡®å®šè¦è§£ç»‘â€œ${charName}â€èµ é€çš„äº²å±å¡å—ï¼Ÿ\nè§£ç»‘åï¼Œæ‚¨å°†å¤±å»è¯¥æ¶ˆè´¹é¢åº¦ã€‚`;
                confirmText = "ç¡®è®¤è§£ç»‘";
            }

            const confirmed = await showCustomConfirm(
                title, 
                message, 
                { confirmButtonClass: 'btn-danger', confirmText: confirmText }
            );

            if (confirmed) {
                try {
                    if (wallet && wallet.kinshipCards) {
                        // ä»æ•°ç»„ä¸­ç§»é™¤è¯¥å¡ç‰‡
                        wallet.kinshipCards = wallet.kinshipCards.filter(c => c.chatId !== chatId);
                        await db.userWallet.put(wallet);
                        
                        await showCustomAlert("æˆåŠŸ", "å·²æˆåŠŸè§£ç»‘äº²å±å¡ã€‚");
                        
                        // åˆ·æ–°æ”¯ä»˜å®ç•Œé¢
                        openAlipayScreen();

                        // 3. é€šçŸ¥ AI
                        if (chat) {
                            let sysContent = "";
                            if (isMyGift) {
                                sysContent = '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å·²åœ¨æ”¯ä»˜å®ç«¯å•æ–¹é¢æ”¶å›äº†ç»™ä½ çš„äº²å±å¡æˆæƒã€‚]';
                            } else {
                                sysContent = '[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·å·²åœ¨æ”¯ä»˜å®ç«¯ä¸»åŠ¨é€€è¿˜/è§£ç»‘äº†ä½ èµ é€çš„äº²å±å¡ã€‚]';
                            }

                            chat.history.push({
                               role: 'system',
                               content: sysContent,
                               timestamp: Date.now(),
                               isHidden: true
                            });
                            await db.chats.put(chat);
                        }
                    }
                } catch (error) {
                    console.error(error);
                    alert("è§£ç»‘æ“ä½œå¤±è´¥");
                }
            }
        }
    });
}
document.getElementById('export-appearance-btn').addEventListener('click', exportAppearanceSettings);
// --- To-Do List Events ---
    const todoBtn = document.getElementById('open-todo-list-btn');
    if(todoBtn) todoBtn.addEventListener('click', openTodoList);
    
    document.getElementById('todo-list-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
    
    document.getElementById('todo-prev-day-btn').addEventListener('click', () => changeTodoDate(-1));

    document.getElementById('todo-next-day-btn').addEventListener('click', () => changeTodoDate(1));
    
    document.getElementById('add-todo-btn').addEventListener('click', () => openTodoEditor(null));
    
    document.getElementById('cancel-todo-editor-btn').addEventListener('click', () => {
        document.getElementById('todo-editor-modal').classList.remove('visible');
    });
    
    document.getElementById('save-todo-btn').addEventListener('click', saveTodo);
    const todoDateDisplay = document.getElementById('todo-current-date-display');
    if (todoDateDisplay) {
        // 1. åŠ¨æ€åˆ›å»ºä¸€ä¸ªéšè—çš„ input[type="date"]
        const datePicker = document.createElement('input');
        datePicker.type = 'date';
        // éšè—å®ƒï¼Œä½†ä¿æŒå¯äº¤äº’æ€§
        datePicker.style.cssText = 'position:absolute; visibility:hidden; width:0; height:0; top:0; left:0;';
        todoDateDisplay.parentNode.appendChild(datePicker); // æ’å…¥åˆ°å¯¼èˆªæ é‡Œ

        // 2. ç‚¹å‡»æ–‡å­— -> è§¦å‘é€‰æ‹©å™¨
        todoDateDisplay.addEventListener('click', () => {
            // å°†å½“å‰æ˜¾ç¤ºçš„æ—¥æœŸåŒæ­¥ç»™é€‰æ‹©å™¨
            datePicker.value = getTodoDateString(currentTodoDate);
            
            // å°è¯•å¼¹å‡ºåŸç”Ÿæ—¥æœŸé¢æ¿
            try {
                datePicker.showPicker(); // ç°ä»£æµè§ˆå™¨ (Chrome 99+, Safari 15+)
            } catch(e) {
                datePicker.click(); // æ—§ç‰ˆå…¼å®¹
            }
        });

        // 3. ç›‘å¬æ—¥æœŸæ”¹å˜
        datePicker.addEventListener('change', (e) => {
            if (e.target.value) {
                // è§£æ YYYY-MM-DD (é¿å…ç›´æ¥ new Date() å¸¦æ¥çš„æ—¶åŒºåå·®é—®é¢˜)
                const [y, m, d] = e.target.value.split('-').map(Number);
                // æ„é€ æœ¬åœ°æ—¶é—´å¯¹è±¡
                currentTodoDate = new Date(y, m - 1, d);
                
                // åˆ·æ–°ç•Œé¢
                updateTodoDateDisplay();
                renderTodoList();
            }
        });
    }
    // ç±»å‹é€‰æ‹©å™¨ç‚¹å‡»äº‹ä»¶
    const typeOptions = document.querySelectorAll('.todo-type-option');
    typeOptions.forEach(opt => {
        opt.addEventListener('click', () => {
            typeOptions.forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
        });
    });
// --- åœ¨ init() å‡½æ•°å†…éƒ¨çš„äº‹ä»¶ç»‘å®šåŒºåŸŸæ·»åŠ  ---

    // 1. é•¿æœŸè®°å¿†åˆ—è¡¨æ»šåŠ¨ç›‘å¬
    const memoryListContainer = document.getElementById('memory-list-container');
    if (memoryListContainer) {
        memoryListContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = memoryListContainer;
            // è·ç¦»åº•éƒ¨ 50px æ—¶è§¦å‘åŠ è½½
            if (scrollHeight - scrollTop <= clientHeight + 50) {
                loadMoreMemories();
            }
        });
    }

    // 2. å¾…åŠäº‹é¡¹åˆ—è¡¨æ»šåŠ¨ç›‘å¬
    const todoListContainer = document.getElementById('todo-list-container');
    if (todoListContainer) {
        todoListContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = todoListContainer;
            if (scrollHeight - scrollTop <= clientHeight + 50) {
                loadMoreTodos();
            }
        });
    }
// ç»‘å®šé‚®ç®±åº•éƒ¨æŒ‰é’®äº‹ä»¶
const deleteSelectedBtn = document.getElementById('mail-delete-selected-btn');
if (deleteSelectedBtn) {
    deleteSelectedBtn.addEventListener('click', executeBatchDeleteEmails);
}

const selectAllBtn = document.getElementById('mail-select-all-btn');
if (selectAllBtn) {
    selectAllBtn.addEventListener('click', handleSelectAllEmails);
}
    document.getElementById('manage-rules-btn').addEventListener('click', toggleRuleManagementMode);
    document.getElementById('import-rules-btn').addEventListener('click', () => {
        document.getElementById('import-rules-input').click();
    });
    document.getElementById('import-rules-input').addEventListener('change', handleRulesImport);

    // 2. åº•éƒ¨æ“ä½œæ æŒ‰é’®
    document.getElementById('select-all-rules-checkbox').addEventListener('change', handleSelectAllRules);
    document.getElementById('export-selected-rules-btn').addEventListener('click', exportSelectedRules);
    document.getElementById('delete-selected-rules-btn').addEventListener('click', deleteSelectedRules);
// ... åœ¨ init() å‡½æ•°å†… ...
const redditSearchBtn = document.getElementById('char-reddit-search-btn');
if (redditSearchBtn) {
    redditSearchBtn.addEventListener('click', () => {
        const query = document.getElementById('char-reddit-search-input').value.trim();
        handleRedditSearch(query);
    });
}

// ç»‘å®šå›è½¦æœç´¢
const redditInput = document.getElementById('char-reddit-search-input');
if (redditInput) {
    redditInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
             const query = e.target.value.trim();
             handleRedditSearch(query);
        }
    });
}
const regenRedditBtn = document.getElementById('regenerate-char-reddit-btn');
if (regenRedditBtn) {
    regenRedditBtn.addEventListener('click', handleGenerateSimulatedReddit);
}
document.getElementById('nai-preset-select').addEventListener('change', handleNaiPresetChange);
    document.getElementById('save-nai-preset-btn').addEventListener('click', () => handleSaveNaiPreset(false));
    document.getElementById('update-nai-preset-btn').addEventListener('click', () => handleSaveNaiPreset(true));
    document.getElementById('delete-nai-preset-btn').addEventListener('click', handleDeleteNaiPreset);
    document.getElementById('bind-nai-preset-btn').addEventListener('click', openNaiBindingModal);
    
    document.getElementById('save-nai-binding-btn').addEventListener('click', saveNaiBinding);
    document.getElementById('cancel-nai-binding-btn').addEventListener('click', () => {
        document.getElementById('nai-binding-modal').classList.remove('visible');
    });
document.getElementById('manage-quick-reply-categories-btn').addEventListener('click', openQuickReplyCategoryManager);
    
    // 2. ç»‘å®šåˆ†ç±»ç®¡ç†å™¨å†…çš„æŒ‰é’®
    document.getElementById('add-new-quick-reply-category-btn').addEventListener('click', addNewQuickReplyCategory);
    document.getElementById('close-quick-reply-category-manager-btn').addEventListener('click', () => {
        document.getElementById('quick-reply-category-manager-modal').classList.remove('visible');
        renderQuickReplyList(true); // å…³é—­æ—¶åˆ·æ–°ä¸»åˆ—è¡¨çš„Tabs
    });
// --- Sticker Batch Move (è¡¨æƒ…åŒ…æ‰¹é‡ç§»åŠ¨) ---
const stickerMoveBtn = document.getElementById('move-selected-stickers-btn');
if (stickerMoveBtn) {
    stickerMoveBtn.addEventListener('click', executeBatchMoveStickers);
}

// --- Quick Reply Management (å¿«æ·å›å¤ç®¡ç†) ---
const batchQuickReplyBtn = document.getElementById('batch-quick-reply-btn');
if (batchQuickReplyBtn) {
    batchQuickReplyBtn.addEventListener('click', toggleQuickReplyManagementMode);
}

const selectAllQuickRepliesCb = document.getElementById('select-all-quick-replies-checkbox');
if (selectAllQuickRepliesCb) {
    selectAllQuickRepliesCb.addEventListener('change', handleSelectAllQuickReplies);
}

const moveQuickRepliesBtn = document.getElementById('move-selected-quick-replies-btn');
if (moveQuickRepliesBtn) {
    moveQuickRepliesBtn.addEventListener('click', executeBatchMoveQuickReplies);
}

const deleteQuickRepliesBtn = document.getElementById('delete-selected-quick-replies-btn');
if (deleteQuickRepliesBtn) {
    deleteQuickRepliesBtn.addEventListener('click', executeBatchDeleteQuickReplies);
}


   
    initLockScreen();
    checkForUpdates();
    updateLockedFeatureUI();
    initSystemNotification();
    initializeBackgroundKeepAlive();
    bindBackgroundKeepAliveEvents();
    loadBackgroundKeepAliveSettings();
    showScreen('home-screen');
  }

  // ==========================================
  // ========== ç™»å½•ç•Œé¢æ¸²æŸ“å‡½æ•° ==========
  // ==========================================
  function renderLoginOverlay() {
    // é˜²æ­¢é‡å¤ç”Ÿæˆ
    if (document.getElementById('login-overlay')) return;

    const overlay = document.createElement('div');
    overlay.id = 'login-overlay';
    // æç®€æš—é»‘é£æ ¼æ ·å¼
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: #0a0a0a; z-index: 99999; 
        display: flex; flex-direction: column; 
        justify-content: center; align-items: center; 
        color: #ffffff; font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

    overlay.innerHTML = `
        <style>
            /* å†…éƒ¨æ ·å¼ï¼Œåªä½œç”¨äºç™»å½•ç•Œé¢ */
            .ephone-input-group {
                position: relative;
                margin-bottom: 30px;
                width: 100%;
            }
            .ephone-input {
                width: 100%;
                padding: 10px 0;
                font-size: 16px;
                color: #fff;
                background: transparent;
                border: none;
                border-bottom: 1px solid #333;
                outline: none;
                border-radius: 0; /* ç§»é™¤iOSåœ†è§’ */
                transition: border-color 0.3s ease;
                font-family: inherit;
            }
            .ephone-input:focus {
                border-bottom-color: #fff;
            }
            .ephone-input::placeholder {
                color: #444;
                font-size: 14px;
                letter-spacing: 1px;
                text-transform: uppercase;
            }
            .ephone-btn {
                width: 100%;
                padding: 16px;
                background: #fff;
                color: #000;
                border: none;
                font-size: 14px;
                font-weight: 600;
                letter-spacing: 2px;
                text-transform: uppercase;
                cursor: pointer;
                transition: all 0.3s ease;
                margin-top: 20px;
            }
            .ephone-btn:hover {
                background: #e0e0e0;
                transform: translateY(-1px);
            }
            .ephone-btn:active {
                transform: translateY(0);
            }
            .ephone-btn:disabled {
                background: #333;
                color: #666;
                cursor: not-allowed;
                transform: none;
            }
            .fade-in {
                animation: fadeIn 0.8s ease-out forwards;
                opacity: 0;
            }
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
        </style>

        <div style="width: 100%; max-width: 340px; padding: 40px; box-sizing: border-box;">
            <!-- å¤´éƒ¨åŒºåŸŸ -->
            <div class="fade-in" style="margin-bottom: 60px; text-align: left;">
                <div style="font-size: 12px; color: #666; letter-spacing: 3px; text-transform: uppercase; margin-bottom: 12px;">System Access</div>
                <h1 style="font-size: 36px; font-weight: 200; margin: 0; letter-spacing: -1px; color: #fff;">EPhone</h1>
            </div>

            <!-- è¾“å…¥åŒºåŸŸ -->
            <div class="fade-in" style="animation-delay: 0.1s;">
                <div class="ephone-input-group">
                    <input type="text" id="ephone-account" class="ephone-input" placeholder="Account ID" autocomplete="off">
                </div>
                
                <div class="ephone-input-group">
                    <input type="password" id="ephone-password" class="ephone-input" placeholder="Password">
                </div>

                <!-- æŒ‰é’® -->
                <button id="ephone-login-btn" class="ephone-btn">
                    Connect
                </button>

                <!-- æ¶ˆæ¯æç¤º -->
                <p id="login-msg" style="margin-top: 25px; font-size: 12px; min-height: 20px; color: #666; text-align: left; transition: color 0.3s;"></p>
            </div>
        </div>

        <!-- åº•éƒ¨è£…é¥° -->
        <div class="fade-in" style="position: absolute; bottom: 40px; font-size: 10px; color: #333; letter-spacing: 1px; animation-delay: 0.3s;">
            SECURE CONNECTION â€¢ V2.0
        </div>
    `;

    document.body.prepend(overlay);

    // ç»‘å®šäº‹ä»¶
    document.getElementById('ephone-login-btn').onclick = tryLogin;
    document.getElementById('ephone-password').onkeypress = function(e) {
        if (e.key === 'Enter') tryLogin();
    };
  }

  // ==========================================
  // ========== éªŒè¯ä¸å¯åŠ¨å‡½æ•° ==========
  // ==========================================
  async function tryLogin() {
    const accountEl = document.getElementById('ephone-account');
    const passwordEl = document.getElementById('ephone-password');
    const msgEl = document.getElementById('login-msg');
    const btn = document.getElementById('ephone-login-btn');

    // å®‰å…¨æ£€æŸ¥
    if (!accountEl || !passwordEl) {
        console.error("æ‰¾ä¸åˆ°ç™»å½•è¾“å…¥æ¡†ï¼Œè¯·åˆ·æ–°é¡µé¢");
        return;
    }

    const account = accountEl.value.trim();
    const password = passwordEl.value.trim();

    if (!account || !password) {
        msgEl.style.color = "#ff453a";
        msgEl.textContent = "è¯·è¾“å…¥è´¦å·å’Œå¯†ç ";
        return;
    }

    // æ˜¾ç¤ºéªŒè¯ä¸­çŠ¶æ€
    btn.disabled = true;
    btn.textContent = "éªŒè¯ä¸­...";
    msgEl.style.color = "#ffd60a";
    msgEl.textContent = "æ­£åœ¨éªŒè¯ï¼Œè¯·ç¨å€™...";

    // è°ƒç”¨APIéªŒè¯
    const result = await ephoneVerify(account, password);

    if (result.success) {
        msgEl.style.color = "#32d74b";
        msgEl.textContent = "éªŒè¯æˆåŠŸï¼Œæ­£åœ¨è¿›å…¥...";

        try {
            // ä¿å­˜ç™»å½•çŠ¶æ€
            localStorage.setItem('ephone_auth', 'true');
            localStorage.setItem('ephone_account', account);

            // åˆå§‹åŒ–æ•°æ®åº“
            initDatabase(account);
            
            // ç§»é™¤é®ç½©
            const overlay = document.getElementById('login-overlay');
            if (overlay) {
                overlay.style.transition = 'opacity 0.5s ease';
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 500);
            }
            
            // å¯åŠ¨ App
            init(); 
            
        } catch (e) {
            console.error(e);
            msgEl.style.color = "#ff453a";
            msgEl.textContent = "åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é‡è¯•";
            btn.disabled = false;
            btn.textContent = "éªŒ è¯";
        }
    } else {
        msgEl.style.color = "#ff453a";
        msgEl.textContent = result.message || "éªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥è´¦å·å¯†ç ";
        btn.style.background = "#ff453a";
        setTimeout(() => {
            btn.style.background = "#007aff";
            btn.disabled = false;
            btn.textContent = "éªŒ è¯";
        }, 1000);
    }
  }

  // ==========================================
  // ========== è‡ªåŠ¨ç™»å½•åˆ¤æ–­ (ä¸»å…¥å£) ==========
  // ==========================================
  
  // æ£€æŸ¥æœ¬åœ°æ˜¯å¦å·²ç™»å½•
  const isAuthenticated = localStorage.getItem('ephone_auth');
  const savedAccount = localStorage.getItem('ephone_account');

  if (isAuthenticated === 'true' && savedAccount) {
    console.log(`[Auto Login] æ£€æµ‹åˆ°å·²ç™»å½•è´¦å·: ${savedAccount}`);
    try {
        // å·²ç™»å½•ï¼šç›´æ¥åˆå§‹åŒ–æ•°æ®åº“å¹¶å¯åŠ¨ï¼Œä¸æ˜¾ç¤ºç™»å½•æ¡†
        initDatabase(savedAccount);
        init(); 
    } catch (e) {
        console.error("è‡ªåŠ¨ç™»å½•å‡ºé”™ï¼Œé‡ç½®çŠ¶æ€:", e);
        localStorage.removeItem('ephone_auth');
        localStorage.removeItem('ephone_account');
        renderLoginOverlay();
    }
  } else {
    // æœªç™»å½•ï¼šæ˜¾ç¤ºç™»å½•æ¡†
    renderLoginOverlay();
  }
  
  // ==========================================
  // ========== é€€å‡ºç™»å½•æŒ‰é’®äº‹ä»¶ç»‘å®š ==========
  // ==========================================
  // æ”¾åœ¨ä¸€ä¸ªå®šæ—¶å™¨é‡Œï¼Œç¡®ä¿ logout-btn å·²ç»åŠ è½½å‡ºæ¥
  setTimeout(() => {
    const logoutBtn = document.getElementById('logout-btn');
    if (logoutBtn) {
        // ç§»é™¤æ—§çš„ç›‘å¬å™¨é˜²æ­¢é‡å¤
        const newBtn = logoutBtn.cloneNode(true);
        logoutBtn.parentNode.replaceChild(newBtn, logoutBtn);
        
        newBtn.addEventListener('click', async () => {
            // ä½¿ç”¨åŸç”Ÿçš„ confirm
            if (confirm("ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ")) {
                localStorage.removeItem('ephone_auth');
                localStorage.removeItem('ephone_account');
                window.location.reload();
            }
        });
    }
  }, 1000);

});
        
        

  // æ–°å¢ï¼šå¤„ç†ç”¨æˆ·æ‹è‡ªå·±çš„åŠŸèƒ½
  async function handleUserPatSelf(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');

    const myNickname = getDisplayNameInGroup(chat, state.qzoneSettings.nickname);

    // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ‹è‡ªå·±çš„åç¼€
    const suffix = await showCustomPrompt(
      `ä½ æ‹äº†æ‹è‡ªå·±`,
      "è¾“å…¥æ‹ä¸€æ‹åç¼€",
      "",
      "text"
    );

    if (suffix === null) return;

    // åˆ›å»ºå¯è§çš„æ‹ä¸€æ‹æ¶ˆæ¯
    const visibleMessageContent = `${myNickname} æ‹äº†æ‹è‡ªå·± ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // åˆ›å»ºéšè—çš„ç³»ç»Ÿæç¤ºï¼Œè®©AIçŸ¥é“ç”¨æˆ·æ‹äº†è‡ªå·±
    const hiddenMessageContent = `[ç³»ç»Ÿæç¤ºï¼šç”¨æˆ·ï¼ˆ${myNickname}ï¼‰åˆšåˆšæ‹äº†æ‹è‡ªå·±${suffix.trim()}ã€‚ä½ å¯ä»¥å¯¹æ­¤ä½œå‡ºå›åº”æˆ–è¯„è®ºã€‚]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }

  // ========================================
  // è§†é¢‘é€šè¯ä¼˜åŒ–åŠŸèƒ½
  // ========================================

  // æ‘„åƒå¤´ç›¸å…³å˜é‡
  let cameraStream = null;
  let captureInterval = null;
  let lastCapturedImage = null;

  // æå–å¯¹è¯å†…å®¹ï¼ˆåªä¿ç•™å¼•å·å†…çš„æ–‡æœ¬ï¼‰
  function extractDialogueOnly(text) {
    if (!text) return '';
    
    // æ”¯æŒçš„å¼•å·ç±»å‹ï¼šä¸­æ–‡å¼•å·ã€è‹±æ–‡å¼•å·
    const quotePatterns = [
      /"([^"]*)"/g,        // è‹±æ–‡åŒå¼•å·
      /'([^']*)'/g,        // è‹±æ–‡å•å¼•å·
      /ã€Œ([^ã€]*)ã€/g,     // ä¸­æ–‡ç›´è§’å¼•å·
      /ã€([^ã€]*)ã€/g,     // ä¸­æ–‡ç›´è§’åŒå¼•å·
      /"([^"]*)"/g,        // ä¸­æ–‡åŒå¼•å·
      /'([^']*)'/g         // ä¸­æ–‡å•å¼•å·
    ];
    
    let dialogues = [];
    
    // æå–æ‰€æœ‰å¼•å·å†…çš„å†…å®¹
    quotePatterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        if (match[1] && match[1].trim()) {
          dialogues.push(match[1].trim());
        }
      }
    });
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯¹è¯ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
    if (dialogues.length === 0) {
      return '';
    }
    
    // ç”¨ç©ºæ ¼è¿æ¥å¤šä¸ªå¯¹è¯ç‰‡æ®µ
    return dialogues.join(' ');
  }

  // è·å–å¤„ç†åçš„TTSæ–‡æœ¬
  window.getProcessedTTSText = function(originalText, chatId) {
    if (!originalText) return '';
    
    // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†"ä»…è¯»å–å¯¹è¯"åŠŸèƒ½
    if (typeof state !== 'undefined' && state.chats && state.chats[chatId]) {
      const chat = state.chats[chatId];
      if (chat.videoOptimization && chat.videoOptimization.ttsDialogueOnly) {
        const dialogueText = extractDialogueOnly(originalText);
        // å¦‚æœæå–åˆ°äº†å¯¹è¯å†…å®¹å°±è¿”å›ï¼Œå¦åˆ™è¿”å›åŸæ–‡ï¼ˆé¿å…å®Œå…¨é™éŸ³ï¼‰
        return dialogueText || originalText;
      }
    }
    
    return originalText;
  };

  // åˆå§‹åŒ–è§†é¢‘é€šè¯ä¼˜åŒ–äº‹ä»¶ç›‘å¬
  function initVideoOptimization() {
    // è§†é¢‘é€šè¯ä¼˜åŒ–å¼€å…³
    const enableSwitch = document.getElementById('enable-video-optimization-switch');
    const configContainer = document.getElementById('video-optimization-config-container');
    
    if (enableSwitch) {
      enableSwitch.addEventListener('change', function() {
        if (this.checked) {
          configContainer.style.display = 'block';
        } else {
          configContainer.style.display = 'none';
        }
      });
    }

    // å¯¹æ–¹è§†é¢‘å›¾ç‰‡ - æœ¬åœ°ä¸Šä¼ 
    const remoteVideoInput = document.getElementById('remote-video-input');
    if (remoteVideoInput) {
      remoteVideoInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const imgUrl = event.target.result;
            document.getElementById('remote-video-preview').src = imgUrl;
            document.getElementById('remote-video-preview').style.display = 'block';
            document.getElementById('remote-video-placeholder').style.display = 'none';
          };
          reader.readAsDataURL(file);
        }
      });
    }

    // å¯¹æ–¹è§†é¢‘å›¾ç‰‡ - URLä¸Šä¼ 
    const remoteVideoUrlBtn = document.getElementById('remote-video-url-btn');
    const remoteVideoUrlInput = document.getElementById('remote-video-url-input');
    if (remoteVideoUrlBtn && remoteVideoUrlInput) {
      remoteVideoUrlBtn.addEventListener('click', function() {
        const url = remoteVideoUrlInput.value.trim();
        if (url) {
          document.getElementById('remote-video-preview').src = url;
          document.getElementById('remote-video-preview').style.display = 'block';
          document.getElementById('remote-video-placeholder').style.display = 'none';
        }
      });
      
      remoteVideoUrlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          remoteVideoUrlBtn.click();
        }
      });
    }

    // æˆ‘æ–¹è§†é¢‘å›¾ç‰‡ - æœ¬åœ°ä¸Šä¼ 
    const localVideoInput = document.getElementById('local-video-input');
    if (localVideoInput) {
      localVideoInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const imgUrl = event.target.result;
            document.getElementById('local-video-preview').src = imgUrl;
            document.getElementById('local-video-preview').style.display = 'block';
            document.getElementById('local-video-placeholder').style.display = 'none';
          };
          reader.readAsDataURL(file);
        }
      });
    }

    // æˆ‘æ–¹è§†é¢‘å›¾ç‰‡ - URLä¸Šä¼ 
    const localVideoUrlBtn = document.getElementById('local-video-url-btn');
    const localVideoUrlInput = document.getElementById('local-video-url-input');
    if (localVideoUrlBtn && localVideoUrlInput) {
      localVideoUrlBtn.addEventListener('click', function() {
        const url = localVideoUrlInput.value.trim();
        if (url) {
          document.getElementById('local-video-preview').src = url;
          document.getElementById('local-video-preview').style.display = 'block';
          document.getElementById('local-video-placeholder').style.display = 'none';
        }
      });
      
      localVideoUrlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          localVideoUrlBtn.click();
        }
      });
    }

    // å¯¹æ–¹è§†é¢‘å›¾ç‰‡ - é‡ç½®æŒ‰é’®
    const remoteVideoResetBtn = document.getElementById('remote-video-reset-btn');
    if (remoteVideoResetBtn) {
      remoteVideoResetBtn.addEventListener('click', function() {
        document.getElementById('remote-video-preview').src = '';
        document.getElementById('remote-video-preview').style.display = 'none';
        document.getElementById('remote-video-placeholder').style.display = 'flex';
        document.getElementById('remote-video-url-input').value = '';
        const remoteVideoInput = document.getElementById('remote-video-input');
        if (remoteVideoInput) remoteVideoInput.value = '';
      });
    }

    // æˆ‘æ–¹è§†é¢‘å›¾ç‰‡ - é‡ç½®æŒ‰é’®
    const localVideoResetBtn = document.getElementById('local-video-reset-btn');
    if (localVideoResetBtn) {
      localVideoResetBtn.addEventListener('click', function() {
        document.getElementById('local-video-preview').src = '';
        document.getElementById('local-video-preview').style.display = 'none';
        document.getElementById('local-video-placeholder').style.display = 'flex';
        document.getElementById('local-video-url-input').value = '';
        const localVideoInput = document.getElementById('local-video-input');
        if (localVideoInput) localVideoInput.value = '';
      });
    }

    // çœŸå®æ‘„åƒå¤´å¼€å…³
    const enableRealCameraSwitch = document.getElementById('enable-real-camera-switch');
    const cameraIntervalSetting = document.getElementById('camera-interval-setting');
    if (enableRealCameraSwitch) {
      enableRealCameraSwitch.addEventListener('change', function() {
        if (this.checked) {
          cameraIntervalSetting.style.display = 'block';
        } else {
          cameraIntervalSetting.style.display = 'none';
          stopCamera();
        }
      });
    }

    // ç‚¹å‡»å°å±äº’æ¢ä½ç½®
    const localVideoSmall = document.getElementById('local-video-small');
    if (localVideoSmall) {
      localVideoSmall.addEventListener('click', swapVideoPosition);
    }
  }

  // äº’æ¢è§†é¢‘ä½ç½®
  function swapVideoPosition() {
    const remoteImg = document.getElementById('remote-video-img');
    const localImg = document.getElementById('local-video-img');
    
    const tempSrc = remoteImg.src;
    remoteImg.src = localImg.src;
    localImg.src = tempSrc;
  }

  // åŠ è½½è§†é¢‘é€šè¯ä¼˜åŒ–è®¾ç½®
  window.loadVideoOptimizationSettings = function(chat) {
    if (!chat) return;

    const settings = chat.videoOptimization || {};
    
    const enableSwitch = document.getElementById('enable-video-optimization-switch');
    const configContainer = document.getElementById('video-optimization-config-container');
    if (enableSwitch) {
      enableSwitch.checked = settings.enabled || false;
      configContainer.style.display = settings.enabled ? 'block' : 'none';
    }

    if (settings.remoteVideoUrl) {
      document.getElementById('remote-video-preview').src = settings.remoteVideoUrl;
      document.getElementById('remote-video-preview').style.display = 'block';
      document.getElementById('remote-video-placeholder').style.display = 'none';
      document.getElementById('remote-video-url-input').value = settings.remoteVideoUrl;
    } else {
      document.getElementById('remote-video-preview').style.display = 'none';
      document.getElementById('remote-video-placeholder').style.display = 'flex';
      document.getElementById('remote-video-url-input').value = '';
    }

    if (settings.localVideoUrl) {
      document.getElementById('local-video-preview').src = settings.localVideoUrl;
      document.getElementById('local-video-preview').style.display = 'block';
      document.getElementById('local-video-placeholder').style.display = 'none';
      document.getElementById('local-video-url-input').value = settings.localVideoUrl;
    } else {
      document.getElementById('local-video-preview').style.display = 'none';
      document.getElementById('local-video-placeholder').style.display = 'flex';
      document.getElementById('local-video-url-input').value = '';
    }
    
    // åŠ è½½çœŸå®æ‘„åƒå¤´è®¾ç½®
    const enableRealCameraSwitch = document.getElementById('enable-real-camera-switch');
    const cameraIntervalSetting = document.getElementById('camera-interval-setting');
    const cameraIntervalInput = document.getElementById('camera-capture-interval');
    
    if (enableRealCameraSwitch) {
      enableRealCameraSwitch.checked = settings.enableRealCamera || false;
      cameraIntervalSetting.style.display = settings.enableRealCamera ? 'block' : 'none';
    }
    
    if (cameraIntervalInput) {
      cameraIntervalInput.value = settings.cameraInterval || 5;
    }
    
    // åŠ è½½ä»…è¯»å–å¯¹è¯è®¾ç½®
    const ttsDialogueOnlySwitch = document.getElementById('tts-dialogue-only-switch');
    if (ttsDialogueOnlySwitch) {
      ttsDialogueOnlySwitch.checked = settings.ttsDialogueOnly || false;
    }
  };

  // ä¿å­˜è§†é¢‘é€šè¯ä¼˜åŒ–è®¾ç½®
  window.saveVideoOptimizationSettings = function(chat) {
    if (!chat) return;

    const enableSwitch = document.getElementById('enable-video-optimization-switch');
    const remoteVideoPreview = document.getElementById('remote-video-preview');
    const localVideoPreview = document.getElementById('local-video-preview');
    const enableRealCameraSwitch = document.getElementById('enable-real-camera-switch');
    const cameraIntervalInput = document.getElementById('camera-capture-interval');
    const ttsDialogueOnlySwitch = document.getElementById('tts-dialogue-only-switch');

    chat.videoOptimization = {
      enabled: enableSwitch ? enableSwitch.checked : false,
      remoteVideoUrl: remoteVideoPreview.style.display === 'block' ? remoteVideoPreview.src : '',
      localVideoUrl: localVideoPreview.style.display === 'block' ? localVideoPreview.src : '',
      enableRealCamera: enableRealCameraSwitch ? enableRealCameraSwitch.checked : false,
      cameraInterval: cameraIntervalInput ? parseInt(cameraIntervalInput.value) || 5 : 5,
      ttsDialogueOnly: ttsDialogueOnlySwitch ? ttsDialogueOnlySwitch.checked : false
    };
    
    // ä¸éœ€è¦åœ¨è¿™é‡Œputåˆ°æ•°æ®åº“ï¼Œå› ä¸ºè°ƒç”¨æ–¹ä¼šç»Ÿä¸€ä¿å­˜
  };

  // åº”ç”¨è§†é¢‘é€šè¯ä¼˜åŒ–åˆ°è§†é¢‘ç•Œé¢
  window.applyVideoOptimizationToCall = async function(chat) {
    const videoDisplayArea = document.getElementById('video-display-area');
    const avatarArea = document.querySelector('.video-call-avatar-area');
    
    if (!chat || !chat.videoOptimization || !chat.videoOptimization.enabled) {
      videoDisplayArea.style.display = 'none';
      if (avatarArea) avatarArea.style.display = 'flex';
      stopCamera();
      return;
    }

    const settings = chat.videoOptimization;
    if (settings.remoteVideoUrl || settings.localVideoUrl || settings.enableRealCamera) {
      videoDisplayArea.style.display = 'block';
      if (avatarArea) avatarArea.style.display = 'none';
      
      if (settings.remoteVideoUrl) {
        document.getElementById('remote-video-img').src = settings.remoteVideoUrl;
      }
      
      // å¤„ç†æˆ‘æ–¹ç”»é¢ï¼šçœŸå®æ‘„åƒå¤´æˆ–é™æ€å›¾ç‰‡
      const localImg = document.getElementById('local-video-img');
      const localVideo = document.getElementById('local-camera-video');
      
      if (settings.enableRealCamera) {
        // ä½¿ç”¨çœŸå®æ‘„åƒå¤´
        localImg.style.display = 'none';
        localVideo.style.display = 'block';
        
        const success = await startCamera();
        if (success) {
          // å¯åŠ¨å®šæ—¶æˆªå›¾
          const interval = settings.cameraInterval || 5;
          startCameraCapture(interval);
        }
      } else if (settings.localVideoUrl) {
        // ä½¿ç”¨é™æ€å›¾ç‰‡
        localVideo.style.display = 'none';
        localImg.style.display = 'block';
        localImg.src = settings.localVideoUrl;
        stopCamera();
      }
    } else {
      videoDisplayArea.style.display = 'none';
      if (avatarArea) avatarArea.style.display = 'flex';
      stopCamera();
    }
  };

  // å¯åŠ¨æ‘„åƒå¤´
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user'
        },
        audio: false 
      });
      
      cameraStream = stream;
      const videoElement = document.getElementById('local-camera-video');
      if (videoElement) {
        videoElement.srcObject = stream;
      }
      
      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      updateCameraStatus(true, 'æ‘„åƒå¤´å·²å¯åŠ¨');
      
      return true;
    } catch (error) {
      console.error('æ— æ³•è®¿é—®æ‘„åƒå¤´:', error);
      updateCameraStatus(false, 'æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + error.message);
      return false;
    }
  }

  // åœæ­¢æ‘„åƒå¤´
  function stopCamera() {
    if (cameraStream) {
      cameraStream.getTracks().forEach(track => track.stop());
      cameraStream = null;
    }
    
    if (captureInterval) {
      clearInterval(captureInterval);
      captureInterval = null;
    }
    
    const videoElement = document.getElementById('local-camera-video');
    if (videoElement) {
      videoElement.srcObject = null;
    }
    
    updateCameraStatus(false, 'æ‘„åƒå¤´å·²åœæ­¢');
  }

  // æ›´æ–°æ‘„åƒå¤´çŠ¶æ€æ˜¾ç¤º
  function updateCameraStatus(isActive, message) {
    const statusDiv = document.getElementById('camera-status');
    const statusIcon = document.getElementById('camera-status-icon');
    const statusText = document.getElementById('camera-status-text');
    
    if (statusDiv && statusIcon && statusText) {
      statusDiv.style.display = 'block';
      statusIcon.style.background = isActive ? '#4cd964' : '#ccc';
      statusText.textContent = message;
    }
  }

  // æˆªå–æ‘„åƒå¤´ç”»é¢
  function captureCameraFrame() {
    const videoElement = document.getElementById('local-camera-video');
    if (!videoElement || !cameraStream) return null;
    
    const canvas = document.createElement('canvas');
    canvas.width = videoElement.videoWidth;
    canvas.height = videoElement.videoHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(videoElement, 0, 0);
    
    // è½¬æ¢ä¸ºbase64
    const imageData = canvas.toDataURL('image/jpeg', 0.8);
    lastCapturedImage = imageData;
    
    return imageData;
  }

  // å¯åŠ¨å®šæ—¶æˆªå›¾
  function startCameraCapture(intervalSeconds) {
    if (captureInterval) {
      clearInterval(captureInterval);
    }
    
    // ç«‹å³æˆªå–ä¸€æ¬¡
    captureCameraFrame();
    
    // å®šæ—¶æˆªå–
    captureInterval = setInterval(() => {
      captureCameraFrame();
      console.log('å·²æˆªå–æ‘„åƒå¤´ç”»é¢');
    }, intervalSeconds * 1000);
  }

  // è·å–æœ€æ–°æˆªå›¾
  window.getLastCameraCapture = function() {
    return lastCapturedImage;
  };

  // åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
  document.addEventListener('DOMContentLoaded', function() {
    initVideoOptimization();
  });

  // å¦‚æœDOMContentLoadedå·²ç»è§¦å‘ï¼Œç«‹å³åˆå§‹åŒ–
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(initVideoOptimization, 1);
  }
